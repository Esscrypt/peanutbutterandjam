import {
  getBanderoutFromGamma,
  IETFVRFProver,
  IETFVRFVerifier,
} from '@pbnj/bandersnatch-vrf'
import { bytesToHex, logger } from '@pbnj/core'
import { encodeUnsignedHeader } from '@pbnj/serialization'
import type {
  IConfigService,
  Safe,
  SafroleTicket,
  UnsignedBlockHeader,
} from '@pbnj/types'
import { safeError, safeResult } from '@pbnj/types'

/**
 * Generate ticket-based seal signature according to Gray Paper Eq. 147-148
 *
 * Gray Paper Eq. 147-148:
 * i_st_id = banderout{H_sealsig}
 * H_sealsig ∈ bssignature{H_authorbskey}{Xticket ∥ entropy'_3 ∥ i_st_entryindex}{encodeunsignedheader{H}}
 * isticketed = 1
 *
 * Implementation steps:
 * 1. Build VRF context: Xticket ∥ entropy'_3 ∥ i_st_entryindex
 * 2. Generate IETF VRF signature with ticket context
 * 3. Validate: ticket.id = banderout{H_sealsig}
 * 4. Return VRF output hash for entropy generation
 */
export function generateTicketBasedSealSignature(
  authorPrivateKey: Uint8Array,
  entropy3: Uint8Array,
  unsignedHeader: UnsignedBlockHeader,
  ticket: SafroleTicket,
  slot: bigint,
  config: IConfigService,
): Safe<Uint8Array> {
    // Gray Paper Eq. 161: Xticket = "$jam_ticket_seal"
    const XTICKET_SEAL = new TextEncoder().encode('jam_ticket_seal')

    // Gray Paper Eq. 148: Build VRF context
    // context = Xticket ∥ entropy'_3 ∥ i_st_entryindex
    // Cticketentries = 2, so entryIndex can only be 0 or 1 (1 byte sufficient)
    const entryIndexBytes = new Uint8Array(1)
    entryIndexBytes[0] = Number(ticket.entryIndex)

    const context = new Uint8Array(
      XTICKET_SEAL.length + entropy3.length + entryIndexBytes.length,
    )
    let offset = 0
    context.set(XTICKET_SEAL, offset)
    offset += XTICKET_SEAL.length
    context.set(entropy3, offset)
    offset += entropy3.length
    context.set(entryIndexBytes, offset)

    // Encode unsigned header for VRF message
    const [encodeError, encodedUnsignedHeader] = encodeUnsignedHeader(
      unsignedHeader,
      config,
    )
    if (encodeError) {
      return safeError(encodeError)
    }

    // Generate IETF VRF signature using ticket context
    // Gray Paper Eq. 148: bssignature{H_authorbskey}{Xticket ∥ entropy'_3 ∥ i_st_entryindex}{encodeunsignedheader{H}}
    const vrfResult = IETFVRFProver.prove(
      authorPrivateKey,
      encodedUnsignedHeader, // message
      context, // Xticket ∥ entropy'_3 ∥ i_st_entryindex
    )

    // Gray Paper Eq. 147: Validate ticket ID matches VRF output
    // i_st_id = banderout{H_sealsig}
    const vrfOutput = getBanderoutFromGamma(vrfResult.gamma)
    const expectedTicketId = bytesToHex(vrfOutput)

    if (ticket.id !== expectedTicketId) {
      return safeError(
        new Error(
          `Ticket ID mismatch: expected ${expectedTicketId}, got ${ticket.id}`,
        ),
      )
    }

    logger.debug('Generated ticket-based seal signature', {
      slot,
      authorIndex: unsignedHeader.authorIndex,
      ticketId: ticket.id,
      entryIndex: ticket.entryIndex.toString(),
      entropy3Length: entropy3.length,
      signatureLength: vrfResult.proof.length,
      vrfOutputLength: vrfOutput.length,
      sealingType: 'ticket-based', // Gray Paper: isticketed = 1
    })

    // Return the VRF output hash (banderout result) for entropy generation
    return safeResult(vrfOutput)

}

/**
 * Verify ticket-based seal signature according to Gray Paper Eq. 147-148
 *
 * Gray Paper Eq. 147-148:
 * i_st_id = banderout{H_sealsig}
 * H_sealsig ∈ bssignature{H_authorbskey}{Xticket ∥ entropy'_3 ∥ i_st_entryindex}{encodeunsignedheader{H}}
 * isticketed = 1
 *
 * This verifies that:
 * 1. The signature was generated by someone with the correct secret key
 * 2. The signature corresponds to the correct context and message
 * 3. The ticket ID matches the VRF output (banderout{H_sealsig})
 *
 * @param validatorPublicKey Validator's Bandersnatch public key (32 bytes)
 * @param signature IETF VRF signature to verify (96 bytes)
 * @param entropy3 Third-oldest epoch entropy (32 bytes)
 * @param unsignedHeader Block header without seal signature
 * @param ticket Safrole ticket for this slot
 * @returns True if signature is valid, false otherwise
 */
export function verifyTicketBasedSealSignature(
  validatorPublicKey: Uint8Array,
  signature: Uint8Array,
  entropy3: Uint8Array,
  unsignedHeader: UnsignedBlockHeader,
  ticket: SafroleTicket,
  config: IConfigService,
): Safe<boolean> {
  // Validate inputs
  if (validatorPublicKey.length !== 32) {
    return safeError(new Error('Validator public key must be 32 bytes'))
  }

  if (signature.length !== 96) {
    return safeError(new Error('IETF VRF signature must be 96 bytes'))
  }

  if (entropy3.length !== 32) {
    return safeError(new Error('entropy_3 must be 32 bytes'))
  }

  // Gray Paper Eq. 161: Xticket = "$jam_ticket_seal"
  const XTICKET_SEAL = new TextEncoder().encode('jam_ticket_seal')

  // Gray Paper Eq. 148: Build VRF context
  // context = Xticket ∥ entropy'_3 ∥ i_st_entryindex
  // Cticketentries = 2, so entryIndex can only be 0 or 1 (1 byte sufficient)
  const entryIndexBytes = new Uint8Array(1)
  entryIndexBytes[0] = Number(ticket.entryIndex)

  const context = new Uint8Array(
    XTICKET_SEAL.length + entropy3.length + entryIndexBytes.length,
  )
  let offset = 0
  context.set(XTICKET_SEAL, offset)
  offset += XTICKET_SEAL.length
  context.set(entropy3, offset)
  offset += entropy3.length
  context.set(entryIndexBytes, offset)

  // Encode unsigned header for VRF message
  const [encodeError, encodedUnsignedHeader] = encodeUnsignedHeader(
    unsignedHeader,
    config,
  )
  if (encodeError) {
    return safeError(encodeError)
  }

  // Verify IETF VRF signature using IETFVRFVerifier
  // Gray Paper Eq. 148: bssignature{k}{c}{m} where:
  // k = validatorPublicKey, c = context, m = encodedUnsignedHeader
  // NOTE: IETFVRFVerifier.verify parameter order is (publicKey, input, proof, auxData)
  // where input = message and auxData = context per IETF VRF specification
  const isValid = IETFVRFVerifier.verify(
    validatorPublicKey,
    context, // Xticket ∥ entropy'_3 ∥ i_st_entryindex (message) - goes to _input parameter
    signature,
    encodedUnsignedHeader, // encodeunsignedheader{H} (context) - goes to _auxData parameter
  )

  if (!isValid) {
    logger.debug('Ticket-based seal signature verification failed', {
      ticketId: ticket.id,
      entryIndex: ticket.entryIndex.toString(),
      entropy3Length: entropy3.length,
      signatureLength: signature.length,
    })
    return safeResult(false)
  }

  // Gray Paper Eq. 147: Validate ticket ID matches VRF output
  // i_st_id = banderout{H_sealsig}
  const vrfOutput = getBanderoutFromGamma(signature.slice(0, 32)) // First 32 bytes are gamma
  const expectedTicketId = bytesToHex(vrfOutput)

  if (ticket.id !== expectedTicketId) {
    logger.debug('Ticket ID mismatch in seal signature verification', {
      expectedTicketId,
      actualTicketId: ticket.id,
      entryIndex: ticket.entryIndex.toString(),
    })
    return safeResult(false)
  }

  logger.debug('Ticket-based seal signature verification successful', {
    ticketId: ticket.id,
    entryIndex: ticket.entryIndex.toString(),
    entropy3Length: entropy3.length,
    signatureLength: signature.length,
    vrfOutputLength: vrfOutput.length,
    sealingType: 'ticket-based', // Gray Paper: isticketed = 1
  })

  return safeResult(true)
}
