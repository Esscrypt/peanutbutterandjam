import { blake2bHash, bytesToHex, hexToBytes } from '@pbnj/core'

export interface ValidatorKeys {
  seed: string
  ed25519_secret_seed: string
  ed25519_public: string
  bandersnatch_secret_seed: string
  bandersnatch_public: string
  dnsAltName: string
}

/**
 * Generate deterministic seed from validator index according to JAM specification
 * The seed is generated by encoding the index as unsigned 32-bit little-endian integer
 * and repeating that sequence of bits 8 times
 */
function generateSeedFromIndex(index: number): string {
  const seedBytes = new Uint8Array(32)

  // Encode index as 32-bit little-endian integer repeated 8 times
  for (let i = 0; i < 32; i += 4) {
    seedBytes[i] = index & 0xff
    seedBytes[i + 1] = (index >> 8) & 0xff
    seedBytes[i + 2] = (index >> 16) & 0xff
    seedBytes[i + 3] = (index >> 24) & 0xff
  }

  return bytesToHex(seedBytes)
}

/**
 * Generate Ed25519 key pair from seed
 */
function generateEd25519FromSeed(seed: string): {
  secretSeed: string
  public: string
} {
  const seedBytes = hexToBytes(seed as `0x${string}`)

  // Use blake2b to derive Ed25519 secret seed
  const ed25519SecretSeed = blake2bHash(seedBytes)

  // Derive public key from secret seed
  const publicKey = blake2bHash(hexToBytes(ed25519SecretSeed as `0x${string}`))

  return {
    secretSeed: ed25519SecretSeed,
    public: publicKey,
  }
}

/**
 * Generate Bandersnatch key pair from seed
 */
function generateBandersnatchFromSeed(seed: string): {
  secretSeed: string
  public: string
} {
  const seedBytes = hexToBytes(seed as `0x${string}`)

  // Use blake2b with different salt for Bandersnatch
  const bandersnatchSecretSeed = blake2bHash(
    Buffer.concat([seedBytes, Buffer.from('bandersnatch', 'utf8')]),
  )

  // Derive public key from secret seed
  const publicKey = blake2bHash(
    hexToBytes(bandersnatchSecretSeed as `0x${string}`),
  )

  return {
    secretSeed: bandersnatchSecretSeed,
    public: publicKey,
  }
}

/**
 * Generate DNS alternative name from seed
 * Uses base32-like encoding as specified in JAM documentation
 */
function generateDnsAltName(seed: string): string {
  const chars = 'abcdefghijklmnopqrstuvwxyz234567'
  let result = ''

  // Remove 0x prefix and ensure we have enough characters
  const cleanSeed = seed.replace('0x', '')

  // Generate exactly 52 characters
  for (let i = 0; i < 52; i++) {
    // Use different parts of the seed to ensure we get 52 characters
    const byteIndex = i % (cleanSeed.length / 2)
    const byte = Number.parseInt(cleanSeed.substr(byteIndex * 2, 2), 16)
    result += chars[byte % chars.length]
  }

  return result
}

export function generateValidatorKeys(index: number): ValidatorKeys {
  // Generate deterministic seed from index
  const seed = generateSeedFromIndex(index)

  // Generate Ed25519 keys from seed
  const ed25519Keys = generateEd25519FromSeed(seed)

  // Generate Bandersnatch keys from seed
  const bandersnatchKeys = generateBandersnatchFromSeed(seed)

  // Generate DNS alternative name
  const dnsAltName = generateDnsAltName(seed)

  return {
    seed,
    ed25519_secret_seed: ed25519Keys.secretSeed,
    ed25519_public: ed25519Keys.public,
    bandersnatch_secret_seed: bandersnatchKeys.secretSeed,
    bandersnatch_public: bandersnatchKeys.public,
    dnsAltName,
  }
}
