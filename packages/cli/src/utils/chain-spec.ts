import { createStateKey, createStateTrie } from '@pbnjam/codec'
import { bytesToHex, type Hex, logger, z, zeroHash } from '@pbnjam/core'
import type {
  Account,
  GenesisState,
  IConfigService,
  Safe,
  ServiceAccount,
  Validator,
} from '@pbnjam/types'
import { safeError, safeResult } from '@pbnjam/types'
import { generateBootnodes } from './key-generation.js'

/**
 * Helper function to convert Uint8Array to hex without 0x prefix
 */
function Uint8ArrayToHexNoPrefix(bytes: Uint8Array): string {
  return Array.from(bytes)
    .map((b) => b.toString(16).padStart(2, '0'))
    .join('')
}

/**
 * Input configuration schema for chain spec generation
 */
const ChainSpecConfigSchema = z.object({
  id: z.string().min(1, 'Chain ID is required'),
  name: z.string().optional(),
  genesis_validators: z
    .array(
      z.object({
        peer_id: z.string().min(1, 'Peer ID is required'),
        bandersnatch: z
          .string()
          .regex(
            /^[a-fA-F0-9]{64}$/,
            'Bandersnatch key must be a 64-character hex string',
          ),
        net_addr: z.string().min(1, 'Network address is required'),
        validator_index: z.number().int().min(0).optional().default(0),
        stake: z
          .string()
          .regex(/^\d+$/, 'Stake must be a numeric string')
          .optional()
          .default('1000000000000000000'),
      }),
    )
    .min(1, 'At least one genesis validator is required'),
  accounts: z
    .array(
      z.object({
        address: z
          .string()
          .regex(/^0x[a-fA-F0-9]{40}$/, 'Address must be a valid hex address'),
        balance: z.string().regex(/^\d+$/, 'Balance must be a numeric string'),
        nonce: z.number().int().min(0).optional().default(0),
        isValidator: z.boolean().optional().default(false),
        validatorKey: z.string().optional(),
        stake: z
          .string()
          .regex(/^\d+$/, 'Stake must be a numeric string')
          .optional(),
      }),
    )
    .optional(),
})

export type ChainSpecConfig = z.infer<typeof ChainSpecConfigSchema>

/**
 * Chain specification structure matching JIP-4 format (polkajam compatible)
 * Reference: https://github.com/polkadot-fellows/JIPs/blob/main/JIP-4.md
 *
 * Note: This is a partial chainspec - it only includes genesis_state and bootnodes.
 * genesis_header and protocol_parameters should be generated by polkajam or another tool.
 */
export interface ChainSpec {
  /** Chain identifier */
  id: string
  /** Bootstrap nodes - optional list of nodes accepting connections in format "name@ip:port" */
  bootnodes?: readonly string[]
  /** Genesis state structure - flat key-value mapping (JIP-4 format: 62-char hex keys without 0x prefix) */
  genesis_state: Record<string, string>
  /** Genesis header - hex string containing JAM-serialized genesis block header (optional, should be generated separately) */
  genesis_header?: Hex
  /** Protocol parameters - hex string containing JAM-serialized protocol parameters (optional, should be generated separately) */
  protocol_parameters?: Hex
}

export function generateChainSpec(
  inputConfig: ChainSpecConfig,
  configService: IConfigService,
): Safe<ChainSpec> {
  logger.info('Generating chain spec', {
    id: inputConfig.id,
    validatorsCount: inputConfig.genesis_validators.length,
  })

  // Validate input config
  const validatedConfig = ChainSpecConfigSchema.parse(inputConfig)

  // Generate validators and accounts using proper JIP-5 functions
  const validators: Validator[] = []
  const accounts: Record<string, Account> = {}

  for (const validator of validatedConfig.genesis_validators) {
    try {
      const validatorIndex = validator.validator_index || 0

      // Generate deterministic address from validator index
      const addressUint8Array = new Uint8Array(20)
      for (let i = 0; i < 20; i++) {
        addressUint8Array[i] = (validatorIndex + i) % 256
      }
      const address = `0x${Uint8ArrayToHexNoPrefix(addressUint8Array)}`

      // Create validator entry
      const validatorEntry = {
        address,
        publicKey: `0x${validator.bandersnatch}`,
        stake: validator.stake,
        isActive: true,
        altname: `validator-${validatorIndex}`,
      }

      validators.push(validatorEntry as unknown as Validator)

      // Add validator account to accounts
      accounts[address] = {
        address: address as `0x${string}`,
        balance: BigInt(validator.stake),
        nonce: 0n,
        isValidator: true,
        validatorKey: `0x${validator.bandersnatch}`,
        stake: BigInt(validator.stake),
      }

      logger.debug('Generated validator', {
        index: validatorIndex,
        address: validatorEntry.address,
        altname: validatorEntry.altname,
      })
    } catch (error) {
      logger.error('Failed to generate validator', {
        validator,
        error: error instanceof Error ? error.message : String(error),
      })
      throw error
    }
  }

  // Create genesis state with proper types according to Gray Paper specification
  const genesisState: GenesisState = {
    accounts: {
      accounts: new Map(
        Object.entries(accounts).map(([address, account]) => [
          BigInt(address),
          {
            ...account,
            nonce: 0n,
            isValidator: false,
            storage: new Map(),
            preimages: new Map(),
            requests: new Map(),
            gratis: 0n,
            codehash: zeroHash,
            minaccgas: 1000n,
            minmemogas: 100n,
            octets: 0n,
            items: 0n,
            created: 0n,
            lastacc: 0n,
            parent: 0n,
            minbalance: 0n,
            rawCshKeyvals: {},
          },
        ]),
      ),
    },
    authpool: [],
    recent: {
      history: [
        {
          headerHash: zeroHash,
          accoutLogSuperPeak: zeroHash,
          stateRoot: zeroHash,
          reportedPackageHashes: new Map(),
        },
      ],
      accoutBelt: {
        peaks: [],
        totalCount: 0n,
      },
    },
    lastAccumulationOutput: [],
    entropy: {
      accumulator: zeroHash,
      entropy1: zeroHash,
      entropy2: zeroHash,
      entropy3: zeroHash,
    },
    safrole: {
      pendingSet: [],
      epochRoot: zeroHash,
      sealTickets: [],
      ticketAccumulator: [],
    },
    reports: {
      coreReports: new Array(341).fill(null),
    },
    disputes: {
      goodSet: new Set(),
      badSet: new Set(),
      wonkySet: new Set(),
      offenders: new Set(),
    },
    stagingset: [],
    activeset: [],
    previousset: [],
    thetime: 0n,
    authqueue: [],
    privileges: {
      manager: 0n,
      delegator: 0n,
      registrar: 0n,
      assigners: [],
      alwaysaccers: new Map(),
    },
    activity: {
      validatorStatsAccumulator: [],
      validatorStatsPrevious: [],
      coreStats: [],
      serviceStats: new Map(),
    },
    ready: {
      epochSlots: new Array(341).fill(null),
    },
    accumulated: {
      packages: [],
    },
  }

  // Generate service accounts for each validator (Chapter 255) according to Gray Paper
  for (let i = 0; i < validators.length; i++) {
    const validator = validators[i]
    const serviceAccount: ServiceAccount = {
      balance: validator.stake,
      gratis: 0n,
      codehash: zeroHash,
      minaccgas: 1000n,
      minmemogas: 100n,
      octets: 0n,
      items: 0n,
      created: 0n,
      lastacc: 0n,
      parent: 0n,
      rawCshKeyvals: {},
    }

    // Create service account key (Chapter 255 with service ID) according to Gray Paper
    const serviceKey = createStateKey(255, BigInt(i))
    const serviceKeyHex = bytesToHex(serviceKey)
    genesisState.accounts.accounts.set(BigInt(serviceKeyHex), serviceAccount)
  }

  // Generate genesis state trie according to Gray Paper specification
  // This includes chapters 1-16 and 255 (service accounts)
  const [genesisError, genesisStateTrie] = createStateTrie(
    genesisState,
    configService,
    configService.jamVersion,
  )

  if (genesisError) {
    return safeError(genesisError)
  }

  // Convert keys to match Polkajam format (remove 0x prefix for keys, keep 0x for values)
  const convertedStateTrie: Record<string, string> = {}
  for (const [key, value] of Object.entries(genesisStateTrie)) {
    // JIP-4 format: keys are 62-character hex strings (31 bytes, no 0x prefix)
    const keyWithoutPrefix = key.startsWith('0x') ? key.slice(2) : key
    // Values are hex strings (with or without 0x prefix - polkajam uses without)
    const valueWithoutPrefix = value.startsWith('0x')
      ? value.slice(2)
      : (value as Hex)
    convertedStateTrie[keyWithoutPrefix] = valueWithoutPrefix
  }

  // Generate bootnodes from genesis_validators (like polkajam does)
  const [bootnodesError, bootnodes] = generateBootnodes(
    validatedConfig.genesis_validators,
  )
  if (bootnodesError) {
    logger.warn(
      'Failed to generate bootnodes, continuing without them:',
      bootnodesError.message,
    )
  }

  // Create chain spec matching JIP-4 format (polkajam compatible)
  const chainSpec: ChainSpec = {
    id: validatedConfig.id,
    ...(bootnodes && bootnodes.length > 0 && { bootnodes }),
    genesis_state: convertedStateTrie,
    // Note: genesis_header and protocol_parameters are not generated here
    // They should be generated by polkajam or another tool that creates the actual genesis block
    // This function only generates the genesis_state from the config
  }

  logger.info('Chain spec generated successfully', {
    accountsCount: Object.keys(accounts).length,
    validatorsCount: validators.length,
    stateTrieEntries: Object.keys(convertedStateTrie).length,
    bootnodesCount: bootnodes?.length || 0,
  })

  return safeResult(chainSpec)
}
