// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck
/* eslint-disable */

// This file is generated by AssemblyScript compiler.
// We just change it a bit to export `instantiate` function
// instead of loading WASM directly.

// Error tracking for WASM abort/panic messages
let lastWasmError: {
  message: string | null;
  fileName: string | null;
  lineNumber: number;
  columnNumber: number;
  timestamp: number;
} | null = null;

export function getLastWasmError() {
  return lastWasmError;
}

export function clearLastWasmError() {
  lastWasmError = null;
}

export async function instantiate(module, imports = {}) {
  const adaptedImports = {
    env: Object.assign(Object.create(globalThis), imports.env || {}, {
      abort(message, fileName, lineNumber, columnNumber) {
        // ~lib/builtins/abort(~lib/string/String | null?, ~lib/string/String | null?, u32?, u32?) => void
        message = __liftString(message >>> 0);
        fileName = __liftString(fileName >>> 0);
        lineNumber = lineNumber >>> 0;
        columnNumber = columnNumber >>> 0;
        
        // Store error information for later retrieval
        lastWasmError = {
          message: message || null,
          fileName: fileName || null,
          lineNumber: lineNumber,
          columnNumber: columnNumber,
          timestamp: Date.now(),
        };
        
        // Create detailed error message
        const errorMessage = message 
          ? `${message} in ${fileName || '<unknown>'}:${lineNumber}:${columnNumber}`
          : `WASM abort at ${fileName || '<unknown>'}:${lineNumber}:${columnNumber}`;
        
        const error = new Error(errorMessage);
        // Add additional properties for easier debugging
        (error as any).wasmError = lastWasmError;
        (error as any).wasmFileName = fileName;
        (error as any).wasmLineNumber = lineNumber;
        (error as any).wasmColumnNumber = columnNumber;
        
        (() => {
          // @external.js
          throw error;
        })();
      },
      'console.log'(message) {
        console.log(__liftString(message >>> 0));
      },
      'console.debug'(message) {
        console.debug(__liftString(message >>> 0));
      },
      'console.info'(message) {
        console.info(__liftString(message >>> 0));
      },
      'console.warn'(message) {
        console.warn(__liftString(message >>> 0));
      },
      'console.error'(message) {
        console.error(__liftString(message >>> 0));
      },
      trace(message) {
        // AssemblyScript trace function - logs debug messages
        console.debug('[WASM trace]', __liftString(message >>> 0));
      },
    }),
  };
  const result = await WebAssembly.instantiate(module, adaptedImports);
  const instance = result instanceof WebAssembly.Instance ? result : result.instance;
  const exports = instance.exports;  const memory = exports.memory || imports.env?.memory;
  const adaptedExports = Object.setPrototypeOf({
    RAMType: (values => (
      // assembly/index/RAMType
      values[values.PVMRAM = exports["RAMType.PVMRAM"].valueOf()] = "PVMRAM",
      values[values.SimpleRAM = exports["RAMType.SimpleRAM"].valueOf()] = "SimpleRAM",
      values[values.MockRAM = exports["RAMType.MockRAM"].valueOf()] = "MockRAM",
      values
    ))({}),
    roundTripSingleImplications(data, numCores, numValidators, authQueueSize) {
      // assembly/index/roundTripSingleImplications(~lib/typedarray/Uint8Array, i32, i32, i32) => ~lib/typedarray/Uint8Array
      data = __lowerTypedArray(Uint8Array, 11, 0, data) || __notnull();
      return __liftTypedArray(Uint8Array, exports.roundTripSingleImplications(data, numCores, numValidators, authQueueSize) >>> 0);
    },
    roundTripImplications(data, numCores, numValidators, authQueueSize) {
      // assembly/index/roundTripImplications(~lib/typedarray/Uint8Array, i32, i32, i32) => ~lib/typedarray/Uint8Array
      data = __lowerTypedArray(Uint8Array, 11, 0, data) || __notnull();
      return __liftTypedArray(Uint8Array, exports.roundTripImplications(data, numCores, numValidators, authQueueSize) >>> 0);
    },
    roundTripServiceAccount(data) {
      // assembly/index/roundTripServiceAccount(~lib/typedarray/Uint8Array) => ~lib/typedarray/Uint8Array
      data = __lowerTypedArray(Uint8Array, 11, 0, data) || __notnull();
      return __liftTypedArray(Uint8Array, exports.roundTripServiceAccount(data) >>> 0);
    },
    roundTripPartialState(data, numCores, numValidators, authQueueSize) {
      // assembly/index/roundTripPartialState(~lib/typedarray/Uint8Array, i32, i32, i32) => ~lib/typedarray/Uint8Array
      data = __lowerTypedArray(Uint8Array, 11, 0, data) || __notnull();
      return __liftTypedArray(Uint8Array, exports.roundTripPartialState(data, numCores, numValidators, authQueueSize) >>> 0);
    },
    roundTripAccumulateInputs(data) {
      // assembly/index/roundTripAccumulateInputs(~lib/typedarray/Uint8Array) => ~lib/typedarray/Uint8Array
      data = __lowerTypedArray(Uint8Array, 11, 0, data) || __notnull();
      return __liftTypedArray(Uint8Array, exports.roundTripAccumulateInputs(data) >>> 0);
    },
    roundTripSingleAccumulateInput(data) {
      // assembly/index/roundTripSingleAccumulateInput(~lib/typedarray/Uint8Array) => ~lib/typedarray/Uint8Array
      data = __lowerTypedArray(Uint8Array, 11, 0, data) || __notnull();
      return __liftTypedArray(Uint8Array, exports.roundTripSingleAccumulateInput(data) >>> 0);
    },
    getAccumulationContext(numCores, numValidators, authQueueSize) {
      // assembly/index/getAccumulationContext(i32, i32, i32) => ~lib/typedarray/Uint8Array
      return __liftTypedArray(Uint8Array, exports.getAccumulationContext(numCores, numValidators, authQueueSize) >>> 0);
    },
    resetGeneric(program, registers, gas) {
      // assembly/index/resetGeneric(~lib/typedarray/Uint8Array, ~lib/typedarray/Uint8Array, u32) => void
      program = __retain(__lowerTypedArray(Uint8Array, 11, 0, program) || __notnull());
      registers = __lowerTypedArray(Uint8Array, 11, 0, registers) || __notnull();
      try {
        exports.resetGeneric(program, registers, gas);
      } finally {
        __release(program);
      }
    },
    resetGenericWithMemory(programPtr, registersPtr, pageMapPtr, chunksPtr, gas) {
      // assembly/index/resetGenericWithMemory(~lib/typedarray/Uint8Array, ~lib/typedarray/Uint8Array, ~lib/typedarray/Uint8Array, ~lib/typedarray/Uint8Array, u32) => void
      programPtr = __retain(__lowerTypedArray(Uint8Array, 11, 0, programPtr) || __notnull());
      registersPtr = __retain(__lowerTypedArray(Uint8Array, 11, 0, registersPtr) || __notnull());
      pageMapPtr = __retain(__lowerTypedArray(Uint8Array, 11, 0, pageMapPtr) || __notnull());
      chunksPtr = __lowerTypedArray(Uint8Array, 11, 0, chunksPtr) || __notnull();
      try {
        exports.resetGenericWithMemory(programPtr, registersPtr, pageMapPtr, chunksPtr, gas);
      } finally {
        __release(programPtr);
        __release(registersPtr);
        __release(pageMapPtr);
      }
    },
    nextStep() {
      // assembly/index/nextStep() => bool
      return exports.nextStep() != 0;
    },
    nSteps(steps) {
      // assembly/index/nSteps(i32) => bool
      return exports.nSteps(steps) != 0;
    },
    runBlob(program) {
      // assembly/index/runBlob(~lib/typedarray/Uint8Array) => void
      program = __lowerTypedArray(Uint8Array, 15, 0, program) || __notnull();
      exports.runBlob(program);
    },
    prepareBlob(program) {
      // assembly/index/prepareBlob(~lib/typedarray/Uint8Array) => void
      program = __lowerTypedArray(Uint8Array, 15, 0, program) || __notnull();
      exports.prepareBlob(program);
    },
    accumulateInvocation(gasLimit, program, args, context, numCores, numValidators, authQueueSize, entropyAccumulator, encodedWorkItems, configNumCores, configPreimageExpungePeriod, configEpochDuration, configMaxBlockGas, configTicketsPerValidator, configSlotDuration, configRotationPeriod, configNumValidators) {
      // assembly/index/accumulateInvocation(u32, ~lib/typedarray/Uint8Array, ~lib/typedarray/Uint8Array, ~lib/typedarray/Uint8Array, i32, i32, i32, ~lib/typedarray/Uint8Array, ~lib/typedarray/Uint8Array, i32?, u32?, u32?, u64?, u16?, u16?, u16?, u16?) => assembly/pvm/AccumulateInvocationResult
      program = __retain(__lowerTypedArray(Uint8Array, 15, 0, program) || __notnull());
      args = __retain(__lowerTypedArray(Uint8Array, 15, 0, args) || __notnull());
      context = __retain(__lowerTypedArray(Uint8Array, 15, 0, context) || __notnull());
      entropyAccumulator = __retain(__lowerTypedArray(Uint8Array, 15, 0, entropyAccumulator) || __notnull());
      encodedWorkItems = __lowerTypedArray(Uint8Array, 15, 0, encodedWorkItems) || __notnull();
      configMaxBlockGas = configMaxBlockGas || 0n;
      try {
        exports.__setArgumentsLength(arguments.length);
        return __liftInternref(exports.accumulateInvocation(gasLimit, program, args, context, numCores, numValidators, authQueueSize, entropyAccumulator, encodedWorkItems, configNumCores, configPreimageExpungePeriod, configEpochDuration, configMaxBlockGas, configTicketsPerValidator, configSlotDuration, configRotationPeriod, configNumValidators) >>> 0);
      } finally {
        __release(program);
        __release(args);
        __release(context);
        __release(entropyAccumulator);
      }
    },
    setupAccumulateInvocation(gasLimit, program, args, context, numCores, numValidators, authQueueSize, entropyAccumulator, encodedWorkItems, configNumCores, configPreimageExpungePeriod, configEpochDuration, configMaxBlockGas, configMaxRefineGas, configMaxTicketsPerExtrinsic, configTicketsPerValidator, configSlotDuration, configRotationPeriod, configNumValidators, configNumEcPiecesPerSegment, configContestDuration, configMaxLookupAnchorage, configEcPieceSize, jamVersionMajor, jamVersionMinor, jamVersionPatch) {
      // assembly/index/setupAccumulateInvocation(u32, ~lib/typedarray/Uint8Array, ~lib/typedarray/Uint8Array, ~lib/typedarray/Uint8Array, i32, i32, i32, ~lib/typedarray/Uint8Array, ~lib/typedarray/Uint8Array, i32?, u32?, u32?, u64?, u64?, u16?, u16?, u16?, u16?, u16?, u32?, u32?, u32?, u32?, u8?, u8?, u8?) => void
      program = __retain(__lowerTypedArray(Uint8Array, 15, 0, program) || __notnull());
      args = __retain(__lowerTypedArray(Uint8Array, 15, 0, args) || __notnull());
      context = __retain(__lowerTypedArray(Uint8Array, 15, 0, context) || __notnull());
      entropyAccumulator = __retain(__lowerTypedArray(Uint8Array, 15, 0, entropyAccumulator) || __notnull());
      encodedWorkItems = __lowerTypedArray(Uint8Array, 15, 0, encodedWorkItems) || __notnull();
      configMaxBlockGas = configMaxBlockGas || 0n;
      configMaxRefineGas = configMaxRefineGas || 0n;
      jamVersionMajor = jamVersionMajor ?? 0;
      jamVersionMinor = jamVersionMinor ?? 7;
      jamVersionPatch = jamVersionPatch ?? 2;
      try {
        exports.__setArgumentsLength(arguments.length);
        exports.setupAccumulateInvocation(gasLimit, program, args, context, numCores, numValidators, authQueueSize, entropyAccumulator, encodedWorkItems, configNumCores, configPreimageExpungePeriod, configEpochDuration, configMaxBlockGas, configMaxRefineGas, configMaxTicketsPerExtrinsic, configTicketsPerValidator, configSlotDuration, configRotationPeriod, configNumValidators, configNumEcPiecesPerSegment, configContestDuration, configMaxLookupAnchorage, configEcPieceSize, jamVersionMajor, jamVersionMinor, jamVersionPatch);
      } finally {
        __release(program);
        __release(args);
        __release(context);
        __release(entropyAccumulator);
      }
    },
    setAccumulateInputs(inputs) {
      // assembly/index/setAccumulateInputs(~lib/array/Array<assembly/codec/AccumulateInput> | null) => void
      inputs = __lowerArray((pointer, value) => { __setU32(pointer, __lowerInternref(value) || __notnull()); }, 51, 2, inputs);
      exports.setAccumulateInputs(inputs);
    },
    setupRefineInvocation(gasLimit, program, args, workPackage, authorizerTrace, importSegments, exportSegmentOffset, serviceAccount, lookupAnchorTimeslot) {
      // assembly/index/setupRefineInvocation(u32, ~lib/typedarray/Uint8Array, ~lib/typedarray/Uint8Array, assembly/codec/WorkPackage | null, ~lib/typedarray/Uint8Array | null, ~lib/array/Array<~lib/array/Array<~lib/typedarray/Uint8Array>> | null, u32, assembly/codec/CompleteServiceAccount | null, u64) => void
      program = __retain(__lowerTypedArray(Uint8Array, 15, 0, program) || __notnull());
      args = __retain(__lowerTypedArray(Uint8Array, 15, 0, args) || __notnull());
      workPackage = workPackage ? __lowerInternref(workPackage) || __notnull() : null;
      authorizerTrace = authorizerTrace ? __retain(__lowerTypedArray(Uint8Array, 15, 0, authorizerTrace) || __notnull()) : null;
      importSegments = importSegments ? __retain(__lowerArray((pointer, value) => { __setU32(pointer, __retain(__lowerArray((pointer, value) => { __setU32(pointer, __retain(__lowerTypedArray(Uint8Array, 15, 0, value) || __notnull())); }, 11, 0, value) || __notnull())); }, 14, 2, value) || __notnull()) : null;
      serviceAccount = serviceAccount ? __lowerInternref(serviceAccount) || __notnull() : null;
      lookupAnchorTimeslot = lookupAnchorTimeslot || 0n;
      try {
        exports.__setArgumentsLength(arguments.length);
        exports.setupRefineInvocation(gasLimit, program, args, workPackage, authorizerTrace, importSegments, exportSegmentOffset, serviceAccount, lookupAnchorTimeslot);
      } finally {
        __release(program);
        __release(args);
        if (authorizerTrace) __release(authorizerTrace);
        if (importSegments) __release(importSegments);
      }
    },
    setupIsAuthorizedInvocation(gasLimit, program, args, workPackage) {
      // assembly/index/setupIsAuthorizedInvocation(u32, ~lib/typedarray/Uint8Array, ~lib/typedarray/Uint8Array, assembly/codec/WorkPackage | null) => void
      program = __retain(__lowerTypedArray(Uint8Array, 15, 0, program) || __notnull());
      args = __retain(__lowerTypedArray(Uint8Array, 15, 0, args) || __notnull());
      workPackage = workPackage ? __lowerInternref(workPackage) || __notnull() : null;
      try {
        exports.__setArgumentsLength(arguments.length);
        exports.setupIsAuthorizedInvocation(gasLimit, program, args, workPackage);
      } finally {
        __release(program);
        __release(args);
      }
    },
    isAuthorizedInvocation(gasLimit, program, args, workPackage) {
      // assembly/index/isAuthorizedInvocation(u32, ~lib/typedarray/Uint8Array, ~lib/typedarray/Uint8Array, assembly/codec/WorkPackage | null) => assembly/types/RunProgramResult
      program = __retain(__lowerTypedArray(Uint8Array, 15, 0, program) || __notnull());
      args = __retain(__lowerTypedArray(Uint8Array, 15, 0, args) || __notnull());
      workPackage = workPackage ? __lowerInternref(workPackage) || __notnull() : null;
      try {
        exports.__setArgumentsLength(arguments.length);
        return __liftInternref(exports.isAuthorizedInvocation(gasLimit, program, args, workPackage) >>> 0);
      } finally {
        __release(program);
        __release(args);
      }
    },
    runProgram() {
      // assembly/index/runProgram() => assembly/types/RunProgramResult
      return __liftInternref(exports.runProgram() >>> 0);
    },
    getProgramCounter() {
      // assembly/index/getProgramCounter() => u32
      return exports.getProgramCounter() >>> 0;
    },
    getGasLeft() {
      // assembly/index/getGasLeft() => u32
      return exports.getGasLeft() >>> 0;
    },
    setGasLeft(gas) {
      // assembly/index/setGasLeft(i64) => void
      gas = gas || 0n;
      exports.setGasLeft(gas);
    },
    getExitArg() {
      // assembly/index/getExitArg() => u32
      return exports.getExitArg() >>> 0;
    },
    getResultCode() {
      // assembly/index/getResultCode() => u32
      return exports.getResultCode() >>> 0;
    },
    getResult() {
      // assembly/index/getResult() => ~lib/typedarray/Uint8Array
      return __liftTypedArray(Uint8Array, exports.getResult() >>> 0);
    },
    // JIP-6 trace support: memory operation tracking
    getLastLoadAddress() {
      // assembly/index/getLastLoadAddress() => u32
      return exports.getLastLoadAddress() >>> 0;
    },
    getLastLoadValue() {
      // assembly/index/getLastLoadValue() => u64
      return exports.getLastLoadValue();
    },
    getLastStoreAddress() {
      // assembly/index/getLastStoreAddress() => u32
      return exports.getLastStoreAddress() >>> 0;
    },
    getLastStoreValue() {
      // assembly/index/getLastStoreValue() => u64
      return exports.getLastStoreValue();
    },
    clearLastMemoryOp() {
      // assembly/index/clearLastMemoryOp() => void
      exports.clearLastMemoryOp();
    },
    getCode() {
      // assembly/index/getCode() => ~lib/typedarray/Uint8Array
      return __liftTypedArray(Uint8Array, exports.getCode() >>> 0);
    },
    getBitmask() {
      // assembly/index/getBitmask() => ~lib/typedarray/Uint8Array
      return __liftTypedArray(Uint8Array, exports.getBitmask() >>> 0);
    },
    getRegisters() {
      // assembly/index/getRegisters() => ~lib/typedarray/Uint8Array
      return __liftTypedArray(Uint8Array, exports.getRegisters() >>> 0);
    },
    setRegisters(registers) {
      // assembly/index/setRegisters(~lib/array/Array<u8>) => void
      registers = __lowerArray(__setU8, 5, 0, registers) || __notnull();
      exports.setRegisters(registers);
    },
    getRegister(index) {
      // assembly/index/getRegister(u8) => u64
      return BigInt.asUintN(64, exports.getRegister(index));
    },
    setRegister(index, value) {
      // assembly/index/setRegister(u8, u64) => void
      value = value || 0n;
      exports.setRegister(index, value);
    },
    setMemory(address, data) {
      // assembly/index/setMemory(u32, ~lib/typedarray/Uint8Array) => void
      data = __lowerTypedArray(Uint8Array, 15, 0, data) || __notnull();
      exports.setMemory(address, data);
    },
    getPageDump(pageIndex) {
      // assembly/index/getPageDump(i32) => ~lib/typedarray/Uint8Array
      const pointer = exports.getPageDump(pageIndex) >>> 0;
      if (!pointer) return null;
      return __liftTypedArray(Uint8Array, pointer);
    },
    getAccumulationContext(numCores, numValidators, authQueueSize) {
      // assembly/index/getAccumulationContext(i32, i32, i32) => ~lib/typedarray/Uint8Array
      return __liftTypedArray(Uint8Array, exports.getAccumulationContext(numCores, numValidators, authQueueSize) >>> 0);
    },
    initializeProgram(program, args) {
      // assembly/index/initializeProgram(~lib/typedarray/Uint8Array, ~lib/typedarray/Uint8Array) => void
      program = __retain(__lowerTypedArray(Uint8Array, 15, 0, program) || __notnull());
      args = __lowerTypedArray(Uint8Array, 15, 0, args) || __notnull();
      try {
        exports.initializeProgram(program, args);
      } finally {
        __release(program);
      }
    },
    alignToPage(size) {
      // assembly/alignment-helpers/alignToPage(u32) => u32
      return exports.alignToPage(size) >>> 0;
    },
    alignToZone(size) {
      // assembly/alignment-helpers/alignToZone(u32) => u32
      return exports.alignToZone(size) >>> 0;
    },
    decodeNatural(data) {
      // assembly/codec/decodeNatural(~lib/typedarray/Uint8Array) => assembly/codec/DecodingResult<u64> | null
      data = __lowerTypedArray(Uint8Array, 15, 0, data) || __notnull();
      return __liftInternref(exports.decodeNatural(data) >>> 0);
    },
    decodeBlob(programBlob) {
      // assembly/codec/decodeBlob(~lib/typedarray/Uint8Array) => assembly/codec/DecodedBlob | null
      programBlob = __lowerTypedArray(Uint8Array, 15, 0, programBlob) || __notnull();
      return __liftInternref(exports.decodeBlob(programBlob) >>> 0);
    },
    decodeServiceCodeFromPreimage(preimageBlob) {
      // assembly/codec/decodeServiceCodeFromPreimage(~lib/typedarray/Uint8Array) => assembly/codec/DecodingResult<assembly/codec/ServiceCodeResult> | null
      preimageBlob = __lowerTypedArray(Uint8Array, 15, 0, preimageBlob) || __notnull();
      return __liftInternref(exports.decodeServiceCodeFromPreimage(preimageBlob) >>> 0);
    },
    decodeProgram(programBlob) {
      // assembly/codec/decodeProgram(~lib/typedarray/Uint8Array) => assembly/codec/DecodedProgram | null
      programBlob = __lowerTypedArray(Uint8Array, 15, 0, programBlob) || __notnull();
      return __liftInternref(exports.decodeProgram(programBlob) >>> 0);
    },
    decodeProgramFromPreimage(preimageBlob) {
      // assembly/codec/decodeProgramFromPreimage(~lib/typedarray/Uint8Array) => assembly/codec/DecodedProgram | null
      preimageBlob = __lowerTypedArray(Uint8Array, 15, 0, preimageBlob) || __notnull();
      return __liftInternref(exports.decodeProgramFromPreimage(preimageBlob) >>> 0);
    },
    encodeServiceAccount(account, major, minor, patch) {
      // assembly/codec/encodeServiceAccount(assembly/codec/ServiceAccountData, i32?, i32?, i32?) => ~lib/typedarray/Uint8Array
      account = __lowerInternref(account) || __notnull();
      exports.__setArgumentsLength(arguments.length);
      return __liftTypedArray(Uint8Array, exports.encodeServiceAccount(account, major, minor, patch) >>> 0);
    },
    decodeServiceAccount(data, major, minor, patch) {
      // assembly/codec/decodeServiceAccount(~lib/typedarray/Uint8Array, i32?, i32?, i32?) => assembly/codec/DecodingResult<assembly/codec/ServiceAccountData> | null
      data = __lowerTypedArray(Uint8Array, 15, 0, data) || __notnull();
      exports.__setArgumentsLength(arguments.length);
      return __liftInternref(exports.decodeServiceAccount(data, major, minor, patch) >>> 0);
    },
    encodeFixedLength(value, length) {
      // assembly/codec/encodeFixedLength(u64, i32) => ~lib/typedarray/Uint8Array
      value = value || 0n;
      return __liftTypedArray(Uint8Array, exports.encodeFixedLength(value, length) >>> 0);
    },
    encodeNatural(value) {
      // assembly/codec/encodeNatural(u64) => ~lib/typedarray/Uint8Array
      value = value || 0n;
      return __liftTypedArray(Uint8Array, exports.encodeNatural(value) >>> 0);
    },
    encodeRefineContext(context) {
      // assembly/codec/encodeRefineContext(assembly/codec/RefineContext) => ~lib/typedarray/Uint8Array
      context = __lowerInternref(context) || __notnull();
      return __liftTypedArray(Uint8Array, exports.encodeRefineContext(context) >>> 0);
    },
    encodeImportReference(importRef) {
      // assembly/codec/encodeImportReference(assembly/codec/ImportSegment) => ~lib/typedarray/Uint8Array
      importRef = __lowerInternref(importRef) || __notnull();
      return __liftTypedArray(Uint8Array, exports.encodeImportReference(importRef) >>> 0);
    },
    encodeExtrinsicReference(extrinsicRef) {
      // assembly/codec/encodeExtrinsicReference(assembly/codec/ExtrinsicReference) => ~lib/typedarray/Uint8Array
      extrinsicRef = __lowerInternref(extrinsicRef) || __notnull();
      return __liftTypedArray(Uint8Array, exports.encodeExtrinsicReference(extrinsicRef) >>> 0);
    },
    encodeVariableSequence(sequence) {
      // assembly/codec/encodeVariableSequence(~lib/array/Array<~lib/typedarray/Uint8Array>) => ~lib/typedarray/Uint8Array
      sequence = __lowerArray((pointer, value) => { __setU32(pointer, __lowerTypedArray(Uint8Array, 15, 0, value) || __notnull()); }, 41, 2, sequence) || __notnull();
      return __liftTypedArray(Uint8Array, exports.encodeVariableSequence(sequence) >>> 0);
    },
    encodeWorkItem(workItem) {
      // assembly/codec/encodeWorkItem(assembly/codec/WorkItem) => ~lib/typedarray/Uint8Array
      workItem = __lowerInternref(workItem) || __notnull();
      return __liftTypedArray(Uint8Array, exports.encodeWorkItem(workItem) >>> 0);
    },
    encodeWorkItemSummary(workItem) {
      // assembly/codec/encodeWorkItemSummary(assembly/codec/WorkItem) => ~lib/typedarray/Uint8Array
      workItem = __lowerInternref(workItem) || __notnull();
      return __liftTypedArray(Uint8Array, exports.encodeWorkItemSummary(workItem) >>> 0);
    },
    decodeImportReference(data) {
      // assembly/codec/decodeImportReference(~lib/typedarray/Uint8Array) => assembly/codec/DecodingResult<assembly/codec/ImportSegment> | null
      data = __lowerTypedArray(Uint8Array, 15, 0, data) || __notnull();
      return __liftInternref(exports.decodeImportReference(data) >>> 0);
    },
    decodeExtrinsicReference(data) {
      // assembly/codec/decodeExtrinsicReference(~lib/typedarray/Uint8Array) => assembly/codec/DecodingResult<assembly/codec/ExtrinsicReference> | null
      data = __lowerTypedArray(Uint8Array, 15, 0, data) || __notnull();
      return __liftInternref(exports.decodeExtrinsicReference(data) >>> 0);
    },
    decodeWorkItem(data) {
      // assembly/codec/decodeWorkItem(~lib/typedarray/Uint8Array) => assembly/codec/DecodingResult<assembly/codec/WorkItem> | null
      data = __lowerTypedArray(Uint8Array, 15, 0, data) || __notnull();
      return __liftInternref(exports.decodeWorkItem(data) >>> 0);
    },
    encodeWorkPackage(workPackage) {
      // assembly/codec/encodeWorkPackage(assembly/codec/WorkPackage) => ~lib/typedarray/Uint8Array
      workPackage = __lowerInternref(workPackage) || __notnull();
      return __liftTypedArray(Uint8Array, exports.encodeWorkPackage(workPackage) >>> 0);
    },
    decodeAccumulateArgs(args) {
      // assembly/codec/decodeAccumulateArgs(~lib/typedarray/Uint8Array) => assembly/codec/DecodingResult<assembly/codec/DecodedAccumulateArgs> | null
      args = __lowerTypedArray(Uint8Array, 15, 0, args) || __notnull();
      return __liftInternref(exports.decodeAccumulateArgs(args) >>> 0);
    },
    decodeFixedLength(data, length) {
      // assembly/codec/decodeFixedLength(~lib/typedarray/Uint8Array, i32) => assembly/codec/DecodingResult<u64> | null
      data = __lowerTypedArray(Uint8Array, 15, 0, data) || __notnull();
      return __liftInternref(exports.decodeFixedLength(data, length) >>> 0);
    },
    decodeVariableLength(data) {
      // assembly/codec/decodeVariableLength(~lib/typedarray/Uint8Array) => assembly/codec/DecodingResult<~lib/typedarray/Uint8Array> | null
      data = __lowerTypedArray(Uint8Array, 15, 0, data) || __notnull();
      return __liftInternref(exports.decodeVariableLength(data) >>> 0);
    },
    decodeVariableSequence(data, elementDecoder) {
      // assembly/codec/decodeVariableSequence<u32>(~lib/typedarray/Uint8Array, (~lib/typedarray/Uint8Array) => assembly/codec/DecodingResult<u32> | null) => assembly/codec/DecodingResult<~lib/array/Array<u32>> | null
      data = __retain(__lowerTypedArray(Uint8Array, 15, 0, data) || __notnull());
      elementDecoder = __lowerInternref(elementDecoder) || __notnull();
      try {
        return __liftInternref(exports.decodeVariableSequence(data, elementDecoder) >>> 0);
      } finally {
        __release(data);
      }
    },
    decodeVariableSequence(data, elementDecoder) {
      // assembly/codec/decodeVariableSequence<assembly/codec/DeferredTransfer>(~lib/typedarray/Uint8Array, (~lib/typedarray/Uint8Array) => assembly/codec/DecodingResult<assembly/codec/DeferredTransfer> | null) => assembly/codec/DecodingResult<~lib/array/Array<assembly/codec/DeferredTransfer>> | null
      data = __retain(__lowerTypedArray(Uint8Array, 15, 0, data) || __notnull());
      elementDecoder = __lowerInternref(elementDecoder) || __notnull();
      try {
        return __liftInternref(exports.decodeVariableSequence(data, elementDecoder) >>> 0);
      } finally {
        __release(data);
      }
    },
    decodeVariableSequence(data, elementDecoder) {
      // assembly/codec/decodeVariableSequence<assembly/codec/ProvisionEntry>(~lib/typedarray/Uint8Array, (~lib/typedarray/Uint8Array) => assembly/codec/DecodingResult<assembly/codec/ProvisionEntry> | null) => assembly/codec/DecodingResult<~lib/array/Array<assembly/codec/ProvisionEntry>> | null
      data = __retain(__lowerTypedArray(Uint8Array, 15, 0, data) || __notnull());
      elementDecoder = __lowerInternref(elementDecoder) || __notnull();
      try {
        return __liftInternref(exports.decodeVariableSequence(data, elementDecoder) >>> 0);
      } finally {
        __release(data);
      }
    },
    decodeVariableSequence(data, elementDecoder) {
      // assembly/codec/decodeVariableSequence<assembly/codec/AccumulateInput>(~lib/typedarray/Uint8Array, (~lib/typedarray/Uint8Array) => assembly/codec/DecodingResult<assembly/codec/AccumulateInput> | null) => assembly/codec/DecodingResult<~lib/array/Array<assembly/codec/AccumulateInput>> | null
      data = __retain(__lowerTypedArray(Uint8Array, 15, 0, data) || __notnull());
      elementDecoder = __lowerInternref(elementDecoder) || __notnull();
      try {
        return __liftInternref(exports.decodeVariableSequence(data, elementDecoder) >>> 0);
      } finally {
        __release(data);
      }
    },
    decodeCompleteServiceAccount(data) {
      // assembly/codec/decodeCompleteServiceAccount(~lib/typedarray/Uint8Array) => assembly/codec/DecodingResult<assembly/codec/CompleteServiceAccount> | null
      data = __lowerTypedArray(Uint8Array, 15, 0, data) || __notnull();
      return __liftInternref(exports.decodeCompleteServiceAccount(data) >>> 0);
    },
    decodePartialState(data, numCores, numValidators, authQueueSize) {
      // assembly/codec/decodePartialState(~lib/typedarray/Uint8Array, i32, i32, i32) => assembly/codec/DecodingResult<assembly/codec/PartialState> | null
      data = __lowerTypedArray(Uint8Array, 15, 0, data) || __notnull();
      return __liftInternref(exports.decodePartialState(data, numCores, numValidators, authQueueSize) >>> 0);
    },
    decodeDeferredTransfer(data) {
      // assembly/codec/decodeDeferredTransfer(~lib/typedarray/Uint8Array) => assembly/codec/DecodingResult<assembly/codec/DeferredTransfer> | null
      data = __lowerTypedArray(Uint8Array, 15, 0, data) || __notnull();
      return __liftInternref(exports.decodeDeferredTransfer(data) >>> 0);
    },
    decodeImplications(data, numCores, numValidators, authQueueSize) {
      // assembly/codec/decodeImplications(~lib/typedarray/Uint8Array, i32, i32, i32) => assembly/codec/DecodingResult<assembly/codec/Implications> | null
      data = __lowerTypedArray(Uint8Array, 15, 0, data) || __notnull();
      return __liftInternref(exports.decodeImplications(data, numCores, numValidators, authQueueSize) >>> 0);
    },
    decodeImplicationsPair(data, numCores, numValidators, authQueueSize) {
      // assembly/codec/decodeImplicationsPair(~lib/typedarray/Uint8Array, i32, i32, i32) => assembly/codec/DecodingResult<assembly/codec/ImplicationsPair> | null
      data = __lowerTypedArray(Uint8Array, 15, 0, data) || __notnull();
      return __liftInternref(exports.decodeImplicationsPair(data, numCores, numValidators, authQueueSize) >>> 0);
    },
    encodeOptional(value, encoder) {
      // assembly/codec/encodeOptional(~lib/typedarray/Uint8Array | null, (~lib/typedarray/Uint8Array) => ~lib/typedarray/Uint8Array) => ~lib/typedarray/Uint8Array
      value = __retain(__lowerTypedArray(Uint8Array, 15, 0, value));
      encoder = __lowerInternref(encoder) || __notnull();
      try {
        return __liftTypedArray(Uint8Array, exports.encodeOptional(value, encoder) >>> 0);
      } finally {
        __release(value);
      }
    },
    encodeDeferredTransfer(transfer) {
      // assembly/codec/encodeDeferredTransfer(assembly/codec/DeferredTransfer) => ~lib/typedarray/Uint8Array
      transfer = __lowerInternref(transfer) || __notnull();
      return __liftTypedArray(Uint8Array, exports.encodeDeferredTransfer(transfer) >>> 0);
    },
    encodeWorkResult(resultType, result) {
      // assembly/codec/encodeWorkResult(u8, ~lib/typedarray/Uint8Array) => ~lib/typedarray/Uint8Array
      result = __lowerTypedArray(Uint8Array, 15, 0, result) || __notnull();
      return __liftTypedArray(Uint8Array, exports.encodeWorkResult(resultType, result) >>> 0);
    },
    encodeOperandTuple(ot) {
      // assembly/codec/encodeOperandTuple(assembly/codec/OperandTuple) => ~lib/typedarray/Uint8Array
      ot = __lowerInternref(ot) || __notnull();
      return __liftTypedArray(Uint8Array, exports.encodeOperandTuple(ot) >>> 0);
    },
    encodeAccumulateInput(input) {
      // assembly/codec/encodeAccumulateInput(assembly/codec/AccumulateInput) => ~lib/typedarray/Uint8Array
      input = __lowerInternref(input) || __notnull();
      return __liftTypedArray(Uint8Array, exports.encodeAccumulateInput(input) >>> 0);
    },
    decodeWorkResult(data) {
      // assembly/codec/decodeWorkResult(~lib/typedarray/Uint8Array) => assembly/codec/DecodingResult<assembly/codec/OperandTuple> | null
      data = __lowerTypedArray(Uint8Array, 15, 0, data) || __notnull();
      return __liftInternref(exports.decodeWorkResult(data) >>> 0);
    },
    decodeOperandTuple(data) {
      // assembly/codec/decodeOperandTuple(~lib/typedarray/Uint8Array) => assembly/codec/DecodingResult<assembly/codec/OperandTuple> | null
      data = __lowerTypedArray(Uint8Array, 15, 0, data) || __notnull();
      return __liftInternref(exports.decodeOperandTuple(data) >>> 0);
    },
    decodeAccumulateInput(data) {
      // assembly/codec/decodeAccumulateInput(~lib/typedarray/Uint8Array) => assembly/codec/DecodingResult<assembly/codec/AccumulateInput> | null
      data = __lowerTypedArray(Uint8Array, 15, 0, data) || __notnull();
      return __liftInternref(exports.decodeAccumulateInput(data) >>> 0);
    },
    encodeVariableSequenceGeneric(sequence, elementEncoder) {
      // assembly/codec/encodeVariableSequenceGeneric<u32>(~lib/array/Array<u32>, (u32) => ~lib/typedarray/Uint8Array) => ~lib/typedarray/Uint8Array
      sequence = __retain(__lowerArray(__setU32, 14, 2, sequence) || __notnull());
      elementEncoder = __lowerInternref(elementEncoder) || __notnull();
      try {
        return __liftTypedArray(Uint8Array, exports.encodeVariableSequenceGeneric(sequence, elementEncoder) >>> 0);
      } finally {
        __release(sequence);
      }
    },
    encodeVariableSequenceGeneric(sequence, elementEncoder) {
      // assembly/codec/encodeVariableSequenceGeneric<assembly/codec/DeferredTransfer>(~lib/array/Array<assembly/codec/DeferredTransfer>, (assembly/codec/DeferredTransfer) => ~lib/typedarray/Uint8Array) => ~lib/typedarray/Uint8Array
      sequence = __retain(__lowerArray((pointer, value) => { __setU32(pointer, __lowerInternref(value) || __notnull()); }, 46, 2, sequence) || __notnull());
      elementEncoder = __lowerInternref(elementEncoder) || __notnull();
      try {
        return __liftTypedArray(Uint8Array, exports.encodeVariableSequenceGeneric(sequence, elementEncoder) >>> 0);
      } finally {
        __release(sequence);
      }
    },
    encodeVariableSequenceGeneric(sequence, elementEncoder) {
      // assembly/codec/encodeVariableSequenceGeneric<assembly/codec/ProvisionEntry>(~lib/array/Array<assembly/codec/ProvisionEntry>, (assembly/codec/ProvisionEntry) => ~lib/typedarray/Uint8Array) => ~lib/typedarray/Uint8Array
      sequence = __retain(__lowerArray((pointer, value) => { __setU32(pointer, __lowerInternref(value) || __notnull()); }, 48, 2, sequence) || __notnull());
      elementEncoder = __lowerInternref(elementEncoder) || __notnull();
      try {
        return __liftTypedArray(Uint8Array, exports.encodeVariableSequenceGeneric(sequence, elementEncoder) >>> 0);
      } finally {
        __release(sequence);
      }
    },
    encodeVariableSequenceGeneric(sequence, elementEncoder) {
      // assembly/codec/encodeVariableSequenceGeneric<assembly/codec/AccumulateInput>(~lib/array/Array<assembly/codec/AccumulateInput>, (assembly/codec/AccumulateInput) => ~lib/typedarray/Uint8Array) => ~lib/typedarray/Uint8Array
      sequence = __retain(__lowerArray((pointer, value) => { __setU32(pointer, __lowerInternref(value) || __notnull()); }, 51, 2, sequence) || __notnull());
      elementEncoder = __lowerInternref(elementEncoder) || __notnull();
      try {
        return __liftTypedArray(Uint8Array, exports.encodeVariableSequenceGeneric(sequence, elementEncoder) >>> 0);
      } finally {
        __release(sequence);
      }
    },
    encodeCompleteServiceAccount(account) {
      // assembly/codec/encodeCompleteServiceAccount(assembly/codec/CompleteServiceAccount) => ~lib/typedarray/Uint8Array
      account = __lowerInternref(account) || __notnull();
      return __liftTypedArray(Uint8Array, exports.encodeCompleteServiceAccount(account) >>> 0);
    },
    encodePartialState(state, numCores, numValidators, authQueueSize) {
      // assembly/codec/encodePartialState(assembly/codec/PartialState, i32, i32, i32) => ~lib/typedarray/Uint8Array
      state = __lowerInternref(state) || __notnull();
      return __liftTypedArray(Uint8Array, exports.encodePartialState(state, numCores, numValidators, authQueueSize) >>> 0);
    },
    encodeImplications(implications, numCores, numValidators, authQueueSize) {
      // assembly/codec/encodeImplications(assembly/codec/Implications, i32, i32, i32) => ~lib/typedarray/Uint8Array
      implications = __lowerInternref(implications) || __notnull();
      return __liftTypedArray(Uint8Array, exports.encodeImplications(implications, numCores, numValidators, authQueueSize) >>> 0);
    },
    encodeImplicationsPair(pair, numCores, numValidators, authQueueSize) {
      // assembly/codec/encodeImplicationsPair(assembly/codec/ImplicationsPair, i32, i32, i32) => ~lib/typedarray/Uint8Array
      pair = __lowerInternref(pair) || __notnull();
      return __liftTypedArray(Uint8Array, exports.encodeImplicationsPair(pair, numCores, numValidators, authQueueSize) >>> 0);
    },
    DEFAULT_GAS_LIMIT: {
      // assembly/config/DEFAULT_GAS_LIMIT: u32
      valueOf() { return this.value; },
      get value() {
        return exports.DEFAULT_GAS_LIMIT.value >>> 0;
      }
    },
    MIN_GAS_COST: {
      // assembly/config/MIN_GAS_COST: u32
      valueOf() { return this.value; },
      get value() {
        return exports.MIN_GAS_COST.value >>> 0;
      }
    },
    MAX_GAS_COST: {
      // assembly/config/MAX_GAS_COST: u32
      valueOf() { return this.value; },
      get value() {
        return exports.MAX_GAS_COST.value >>> 0;
      }
    },
    RESERVED_MEMORY_END: {
      // assembly/config/RESERVED_MEMORY_END: u32
      valueOf() { return this.value; },
      get value() {
        return exports.RESERVED_MEMORY_END.value >>> 0;
      }
    },
    MAX_MEMORY_ADDRESS: {
      // assembly/config/MAX_MEMORY_ADDRESS: u32
      valueOf() { return this.value; },
      get value() {
        return exports.MAX_MEMORY_ADDRESS.value >>> 0;
      }
    },
    INITIAL_ZONE_SIZE: {
      // assembly/config/INITIAL_ZONE_SIZE: u32
      valueOf() { return this.value; },
      get value() {
        return exports.INITIAL_ZONE_SIZE.value >>> 0;
      }
    },
    PAGE_SIZE: {
      // assembly/config/PAGE_SIZE: u32
      valueOf() { return this.value; },
      get value() {
        return exports.PAGE_SIZE.value >>> 0;
      }
    },
    DYNAMIC_ADDRESS_ALIGNMENT: {
      // assembly/config/DYNAMIC_ADDRESS_ALIGNMENT: u32
      valueOf() { return this.value; },
      get value() {
        return exports.DYNAMIC_ADDRESS_ALIGNMENT.value >>> 0;
      }
    },
    ZONE_SIZE: {
      // assembly/config/ZONE_SIZE: u32
      valueOf() { return this.value; },
      get value() {
        return exports.ZONE_SIZE.value >>> 0;
      }
    },
    INIT_INPUT_SIZE: {
      // assembly/config/INIT_INPUT_SIZE: u32
      valueOf() { return this.value; },
      get value() {
        return exports.INIT_INPUT_SIZE.value >>> 0;
      }
    },
    HALT_ADDRESS: {
      // assembly/config/HALT_ADDRESS: u32
      valueOf() { return this.value; },
      get value() {
        return exports.HALT_ADDRESS.value >>> 0;
      }
    },
    STACK_SEGMENT_END: {
      // assembly/config/STACK_SEGMENT_END: u32
      valueOf() { return this.value; },
      get value() {
        return exports.STACK_SEGMENT_END.value >>> 0;
      }
    },
    ARGS_SEGMENT_START: {
      // assembly/config/ARGS_SEGMENT_START: u32
      valueOf() { return this.value; },
      get value() {
        return exports.ARGS_SEGMENT_START.value >>> 0;
      }
    },
    PACKAGE_AUTH_GAS: {
      // assembly/config/PACKAGE_AUTH_GAS: u32
      valueOf() { return this.value; },
      get value() {
        return exports.PACKAGE_AUTH_GAS.value >>> 0;
      }
    },
    MAX_AUTH_CODE_SIZE: {
      // assembly/config/MAX_AUTH_CODE_SIZE: u32
      valueOf() { return this.value; },
      get value() {
        return exports.MAX_AUTH_CODE_SIZE.value >>> 0;
      }
    },
    PACKAGE_REF_GAS: {
      // assembly/config/PACKAGE_REF_GAS: u64
      valueOf() { return this.value; },
      get value() {
        return BigInt.asUintN(64, exports.PACKAGE_REF_GAS.value);
      }
    },
    MAX_SERVICE_CODE_SIZE: {
      // assembly/config/MAX_SERVICE_CODE_SIZE: u32
      valueOf() { return this.value; },
      get value() {
        return exports.MAX_SERVICE_CODE_SIZE.value >>> 0;
      }
    },
    SEGMENT_SIZE: {
      // assembly/config/SEGMENT_SIZE: u32
      valueOf() { return this.value; },
      get value() {
        return exports.SEGMENT_SIZE.value >>> 0;
      }
    },
    MAX_PACKAGE_EXPORTS: {
      // assembly/config/MAX_PACKAGE_EXPORTS: u32
      valueOf() { return this.value; },
      get value() {
        return exports.MAX_PACKAGE_EXPORTS.value >>> 0;
      }
    },
    MIN_PUBLIC_INDEX: {
      // assembly/config/MIN_PUBLIC_INDEX: u32
      valueOf() { return this.value; },
      get value() {
        return exports.MIN_PUBLIC_INDEX.value >>> 0;
      }
    },
    isTerminationInstruction(opcode) {
      // assembly/config/isTerminationInstruction(u8) => bool
      return exports.isTerminationInstruction(opcode) != 0;
    },
    REGISTER_INIT_STACK_SEGMENT_END() {
      // assembly/config/REGISTER_INIT_STACK_SEGMENT_END() => u32
      return exports.REGISTER_INIT_STACK_SEGMENT_END() >>> 0;
    },
    REGISTER_INIT_ARGS_SEGMENT_START() {
      // assembly/config/REGISTER_INIT_ARGS_SEGMENT_START() => u32
      return exports.REGISTER_INIT_ARGS_SEGMENT_START() >>> 0;
    },
    MemoryAccessType: (values => (
      // assembly/types/MemoryAccessType
      values[values.NONE = exports["MemoryAccessType.NONE"].valueOf()] = "NONE",
      values[values.READ = exports["MemoryAccessType.READ"].valueOf()] = "READ",
      values[values.WRITE = exports["MemoryAccessType.WRITE"].valueOf()] = "WRITE",
      values
    ))({}),
    bytesToHex(bytes) {
      // assembly/types/bytesToHex(~lib/typedarray/Uint8Array) => ~lib/string/String
      bytes = __lowerTypedArray(Uint8Array, 15, 0, bytes) || __notnull();
      return __liftString(exports.bytesToHex(bytes) >>> 0);
    },
    blake2b256(data) {
      // assembly/crypto/blake2b256(~lib/typedarray/Uint8Array) => ~lib/typedarray/Uint8Array
      data = __lowerTypedArray(Uint8Array, 15, 0, data) || __notnull();
      return __liftTypedArray(Uint8Array, exports.blake2b256(data) >>> 0);
    },
    testCreateStorageKey(serviceId, storageKey) {
      // assembly/test-exports/testCreateStorageKey(u32, ~lib/typedarray/Uint8Array) => ~lib/typedarray/Uint8Array
      storageKey = __lowerTypedArray(Uint8Array, 15, 0, storageKey) || __notnull();
      return __liftTypedArray(Uint8Array, exports.testCreateStorageKey(serviceId, storageKey) >>> 0);
    },
    testCreatePreimageKey(serviceId, preimageHash) {
      // assembly/test-exports/testCreatePreimageKey(u32, ~lib/typedarray/Uint8Array) => ~lib/typedarray/Uint8Array
      preimageHash = __lowerTypedArray(Uint8Array, 15, 0, preimageHash) || __notnull();
      return __liftTypedArray(Uint8Array, exports.testCreatePreimageKey(serviceId, preimageHash) >>> 0);
    },
    testCreateRequestKey(serviceId, requestHash, length) {
      // assembly/test-exports/testCreateRequestKey(u32, ~lib/typedarray/Uint8Array, u64) => ~lib/typedarray/Uint8Array
      requestHash = __lowerTypedArray(Uint8Array, 15, 0, requestHash) || __notnull();
      return __liftTypedArray(Uint8Array, exports.testCreateRequestKey(serviceId, requestHash, length) >>> 0);
    },
    testBlake2b256(data) {
      // assembly/test-exports/testBlake2b256(~lib/typedarray/Uint8Array) => ~lib/typedarray/Uint8Array
      data = __lowerTypedArray(Uint8Array, 15, 0, data) || __notnull();
      return __liftTypedArray(Uint8Array, exports.testBlake2b256(data) >>> 0);
    },
    testEncodeFixedLength(value, length) {
      // assembly/test-exports/testEncodeFixedLength(u64, i32) => ~lib/typedarray/Uint8Array
      return __liftTypedArray(Uint8Array, exports.testEncodeFixedLength(value, length) >>> 0);
    },
    testCalculateMinBalance(items, octets, gratis) {
      // assembly/test-exports/testCalculateMinBalance(u64, u64, u64) => u64
      return exports.testCalculateMinBalance(items, octets, gratis);
    },
    testSolicitLogic(encodedAccount, serviceId, requestHash, preimageLength, timeslot) {
      // assembly/test-exports/testSolicitLogic(...) => HostFunctionTestResult
      encodedAccount = __lowerTypedArray(Uint8Array, 15, 0, encodedAccount) || __notnull();
      requestHash = __lowerTypedArray(Uint8Array, 15, 0, requestHash) || __notnull();
      const resultPtr = exports.testSolicitLogic(encodedAccount, serviceId, requestHash, preimageLength, timeslot);
      return __liftHostFunctionTestResult(resultPtr >>> 0);
    },
    testForgetLogic(encodedAccount, serviceId, requestHash, preimageLength, timeslot, expungePeriod) {
      // assembly/test-exports/testForgetLogic(...) => HostFunctionTestResult
      encodedAccount = __lowerTypedArray(Uint8Array, 15, 0, encodedAccount) || __notnull();
      requestHash = __lowerTypedArray(Uint8Array, 15, 0, requestHash) || __notnull();
      const resultPtr = exports.testForgetLogic(encodedAccount, serviceId, requestHash, preimageLength, timeslot, expungePeriod);
      return __liftHostFunctionTestResult(resultPtr >>> 0);
    },
    testQueryLogic(encodedAccount, serviceId, requestHash, preimageLength) {
      // assembly/test-exports/testQueryLogic(...) => HostFunctionTestResult
      encodedAccount = __lowerTypedArray(Uint8Array, 15, 0, encodedAccount) || __notnull();
      requestHash = __lowerTypedArray(Uint8Array, 15, 0, requestHash) || __notnull();
      const resultPtr = exports.testQueryLogic(encodedAccount, serviceId, requestHash, preimageLength);
      return __liftHostFunctionTestResult(resultPtr >>> 0);
    },
    testWriteLogic(encodedAccount, serviceId, key, value) {
      // assembly/test-exports/testWriteLogic(...) => HostFunctionTestResult
      encodedAccount = __lowerTypedArray(Uint8Array, 15, 0, encodedAccount) || __notnull();
      key = __lowerTypedArray(Uint8Array, 15, 0, key) || __notnull();
      value = __lowerTypedArray(Uint8Array, 15, 0, value) || __notnull();
      const resultPtr = exports.testWriteLogic(encodedAccount, serviceId, key, value);
      return __liftHostFunctionTestResult(resultPtr >>> 0);
    },
    testReadLogic(encodedAccount, serviceId, key, fromOffset, length) {
      // assembly/test-exports/testReadLogic(...) => HostFunctionTestResult
      encodedAccount = __lowerTypedArray(Uint8Array, 15, 0, encodedAccount) || __notnull();
      key = __lowerTypedArray(Uint8Array, 15, 0, key) || __notnull();
      const resultPtr = exports.testReadLogic(encodedAccount, serviceId, key, fromOffset, length);
      return __liftHostFunctionTestResult(resultPtr >>> 0);
    },
    testEncodeRequestTimeslots(timeslots) {
      // assembly/test-exports/testEncodeRequestTimeslots(u32[]) => ~lib/typedarray/Uint8Array
      const loweredTimeslots = __lowerArray((ptr, v) => new Uint32Array(memory.buffer)[ptr >>> 2] = v, 17, 2, timeslots) || __notnull();
      return __liftTypedArray(Uint8Array, exports.testEncodeRequestTimeslots(loweredTimeslots) >>> 0);
    },
    testDecodeRequestTimeslots(data) {
      // assembly/test-exports/testDecodeRequestTimeslots(~lib/typedarray/Uint8Array) => u32[] | null
      data = __lowerTypedArray(Uint8Array, 15, 0, data) || __notnull();
      const resultPtr = exports.testDecodeRequestTimeslots(data);
      if (resultPtr === 0) return null;
      return __liftArray(ptr => new Uint32Array(memory.buffer)[ptr >>> 2], 2, resultPtr >>> 0);
    },
    testSbrkLogic(currentHeapPointer, requestedSize) {
      // assembly/test-exports/testSbrkLogic(u32, u64) => SBRKTestResult
      const resultPtr = exports.testSbrkLogic(currentHeapPointer, requestedSize);
      return __liftSBRKTestResult(resultPtr >>> 0);
    },
    testAlignToPage(address) {
      // assembly/test-exports/testAlignToPage(u32) => u32
      return exports.testAlignToPage(address);
    },
    testGetMemoryConfig() {
      // assembly/test-exports/testGetMemoryConfig() => ~lib/typedarray/Uint8Array
      return __liftTypedArray(Uint8Array, exports.testGetMemoryConfig() >>> 0);
    },
    testGetSystemConstants(
      numCores, preimageExpungePeriod, epochDuration, maxBlockGas, maxRefineGas,
      maxTicketsPerExtrinsic, ticketsPerValidator, slotDuration, rotationPeriod,
      numValidators, numEcPiecesPerSegment, contestDuration, maxLookupAnchorage, ecPieceSize
    ) {
      // assembly/test-exports/testGetSystemConstants(...) => ~lib/typedarray/Uint8Array
      return __liftTypedArray(Uint8Array, exports.testGetSystemConstants(
        numCores, preimageExpungePeriod, epochDuration, maxBlockGas, maxRefineGas,
        maxTicketsPerExtrinsic, ticketsPerValidator, slotDuration, rotationPeriod,
        numValidators, numEcPiecesPerSegment, contestDuration, maxLookupAnchorage, ecPieceSize
      ) >>> 0);
    },
    Status: (values => (
      // assembly/wasm-wrapper/Status
      values[values.OK = exports["Status.OK"].valueOf()] = "OK",
      values[values.HALT = exports["Status.HALT"].valueOf()] = "HALT",
      values[values.PANIC = exports["Status.PANIC"].valueOf()] = "PANIC",
      values[values.FAULT = exports["Status.FAULT"].valueOf()] = "FAULT",
      values[values.HOST = exports["Status.HOST"].valueOf()] = "HOST",
      values[values.OOG = exports["Status.OOG"].valueOf()] = "OOG",
      values
    ))({}),
    createPvmShell() {
      // assembly/wasm-wrapper/createPvmShell() => assembly/wasm-wrapper/WasmPvmShellInterface
      return __liftRecord9(exports.createPvmShell() >>> 0);
    },
    roundTripSingleImplications(data, numCores, numValidators, authQueueSize) {
      // assembly/test-exports/roundTripSingleImplications(~lib/typedarray/Uint8Array, i32, i32, i32) => ~lib/typedarray/Uint8Array
      data = __lowerTypedArray(Uint8Array, 15, 0, data) || __notnull();
      return __liftTypedArray(Uint8Array, exports.roundTripSingleImplications(data, numCores, numValidators, authQueueSize) >>> 0);
    },
    roundTripImplications(data, numCores, numValidators, authQueueSize) {
      // assembly/test-exports/roundTripImplications(~lib/typedarray/Uint8Array, i32, i32, i32) => ~lib/typedarray/Uint8Array
      data = __lowerTypedArray(Uint8Array, 15, 0, data) || __notnull();
      return __liftTypedArray(Uint8Array, exports.roundTripImplications(data, numCores, numValidators, authQueueSize) >>> 0);
    },
    roundTripServiceAccount(data) {
      // assembly/test-exports/roundTripServiceAccount(~lib/typedarray/Uint8Array) => ~lib/typedarray/Uint8Array
      data = __lowerTypedArray(Uint8Array, 15, 0, data) || __notnull();
      return __liftTypedArray(Uint8Array, exports.roundTripServiceAccount(data) >>> 0);
    },
    roundTripPartialState(data, numCores, numValidators, authQueueSize) {
      // assembly/test-exports/roundTripPartialState(~lib/typedarray/Uint8Array, i32, i32, i32) => ~lib/typedarray/Uint8Array
      data = __lowerTypedArray(Uint8Array, 15, 0, data) || __notnull();
      return __liftTypedArray(Uint8Array, exports.roundTripPartialState(data, numCores, numValidators, authQueueSize) >>> 0);
    },
    getDecodedProgramFields(preimageBlob) {
      // assembly/test-exports/getDecodedProgramFields(~lib/typedarray/Uint8Array) => assembly/test-exports/DecodedProgramFields | null
      preimageBlob = __lowerTypedArray(Uint8Array, 15, 0, preimageBlob) || __notnull();
      return __liftInternref(exports.getDecodedProgramFields(preimageBlob) >>> 0);
    },
    roundTripAccumulateInputs(data) {
      // assembly/test-exports/roundTripAccumulateInputs(~lib/typedarray/Uint8Array) => ~lib/typedarray/Uint8Array
      data = __lowerTypedArray(Uint8Array, 15, 0, data) || __notnull();
      return __liftTypedArray(Uint8Array, exports.roundTripAccumulateInputs(data) >>> 0);
    },
    roundTripSingleAccumulateInput(data) {
      // assembly/test-exports/roundTripSingleAccumulateInput(~lib/typedarray/Uint8Array) => ~lib/typedarray/Uint8Array
      data = __lowerTypedArray(Uint8Array, 15, 0, data) || __notnull();
      return __liftTypedArray(Uint8Array, exports.roundTripSingleAccumulateInput(data) >>> 0);
    },
  }, exports);
  function __liftRecord5(pointer) {
    // assembly/wasm-wrapper/WasmPvmShellInterface
    // Hint: Opt-out from lifting as a record by providing an empty constructor
    if (!pointer) return null;
    return {
    };
  }
  function __liftHostFunctionTestResult(pointer) {
    // assembly/test-exports/HostFunctionTestResult
    // Structure: resultCode: i64, encodedAccount: Uint8Array, returnValue: u64
    if (!pointer) return null;
    return {
      resultCode: __dataview.getBigInt64(pointer + 0, true),
      encodedAccount: __liftTypedArray(Uint8Array, __getU32(pointer + 8)),
      returnValue: __dataview.getBigUint64(pointer + 16, true),
    };
  }
  function __liftSBRKTestResult(pointer) {
    // assembly/test-exports/SBRKTestResult
    // Structure: resultValue: u64, newHeapPointer: u32, pagesAllocated: u32, startPageIndex: u32
    if (!pointer) return null;
    return {
      resultValue: __dataview.getBigUint64(pointer + 0, true),
      newHeapPointer: __dataview.getUint32(pointer + 8, true),
      pagesAllocated: __dataview.getUint32(pointer + 12, true),
      startPageIndex: __dataview.getUint32(pointer + 16, true),
    };
  }
  function __liftArray(liftElement, align, pointer) {
    if (!pointer) return null;
    const
      length = __dataview.getUint32(pointer + 12, true),
      values = new Array(length),
      buffer = __getU32(pointer + 4);
    for (let i = 0; i < length; ++i) values[i] = liftElement(buffer + (i << align >>> 0));
    return values;
  }
  function __liftString(pointer) {
    if (!pointer) return null;
    const
      end = pointer + new Uint32Array(memory.buffer)[pointer - 4 >>> 2] >>> 1,
      memoryU16 = new Uint16Array(memory.buffer);
    let
      start = pointer >>> 1,
      string = "";
    while (end - start > 1024) string += String.fromCharCode(...memoryU16.subarray(start, start += 1024));
    return string + String.fromCharCode(...memoryU16.subarray(start, end));
  }
  function __lowerString(value) {
    if (value == null) return 0;
    const
      length = value.length,
      pointer = exports.__new(length << 1, 2) >>> 0,
      memoryU16 = new Uint16Array(memory.buffer);
    for (let i = 0; i < length; ++i) memoryU16[(pointer >>> 1) + i] = value.charCodeAt(i);
    return pointer;
  }
  function __lowerArray(lowerElement, id, align, values) {
    if (values == null) return 0;
    const
      length = values.length,
      buffer = exports.__pin(exports.__new(length << align, 1)) >>> 0,
      header = exports.__pin(exports.__new(16, id)) >>> 0;
    __setU32(header + 0, buffer);
    __dataview.setUint32(header + 4, buffer, true);
    __dataview.setUint32(header + 8, length << align, true);
    __dataview.setUint32(header + 12, length, true);
    for (let i = 0; i < length; ++i) lowerElement(buffer + (i << align >>> 0), values[i]);
    exports.__unpin(buffer);
    exports.__unpin(header);
    return header;
  }
  function __liftTypedArray(constructor, pointer) {
    if (!pointer) return null;
    return new constructor(
      memory.buffer,
      __getU32(pointer + 4),
      __dataview.getUint32(pointer + 8, true) / constructor.BYTES_PER_ELEMENT
    ).slice();
  }
  function __lowerTypedArray(constructor, id, align, values) {
    if (values == null) return 0;
    const
      length = values.length,
      buffer = exports.__pin(exports.__new(length << align, 1)) >>> 0,
      header = exports.__new(12, id) >>> 0;
    __setU32(header + 0, buffer);
    __dataview.setUint32(header + 4, buffer, true);
    __dataview.setUint32(header + 8, length << align, true);
    new constructor(memory.buffer, buffer, length).set(values);
    exports.__unpin(buffer);
    return header;
  }
  class Internref extends Number {}
  const registry = new FinalizationRegistry(__release);
  function __liftInternref(pointer) {
    if (!pointer) return null;
    const sentinel = new Internref(__retain(pointer));
    registry.register(sentinel, pointer);
    return sentinel;
  }
  function __lowerInternref(value) {
    if (value == null) return 0;
    if (value instanceof Internref) return value.valueOf();
    throw TypeError("internref expected");
  }
  const refcounts = new Map();
  function __retain(pointer) {
    if (pointer) {
      const refcount = refcounts.get(pointer);
      if (refcount) refcounts.set(pointer, refcount + 1);
      else refcounts.set(exports.__pin(pointer), 1);
    }
    return pointer;
  }
  function __release(pointer) {
    if (pointer) {
      const refcount = refcounts.get(pointer);
      if (refcount === 1) exports.__unpin(pointer), refcounts.delete(pointer);
      else if (refcount) refcounts.set(pointer, refcount - 1);
      else throw Error(`invalid refcount '${refcount}' for reference '${pointer}'`);
    }
  }
  function __notnull() {
    throw TypeError("value must not be null");
  }
  let __dataview = new DataView(memory.buffer);
  function __setU8(pointer, value) {
    try {
      __dataview.setUint8(pointer, value, true);
    } catch {
      __dataview = new DataView(memory.buffer);
      __dataview.setUint8(pointer, value, true);
    }
  }
  function __setU32(pointer, value) {
    try {
      __dataview.setUint32(pointer, value, true);
    } catch {
      __dataview = new DataView(memory.buffer);
      __dataview.setUint32(pointer, value, true);
    }
  }
  function __getU32(pointer) {
    try {
      return __dataview.getUint32(pointer, true);
    } catch {
      __dataview = new DataView(memory.buffer);
      return __dataview.getUint32(pointer, true);
    }
  }
  return adaptedExports;
}
