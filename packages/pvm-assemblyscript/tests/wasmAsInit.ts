// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck
/* eslint-disable */

// This file is generated by AssemblyScript compiler.
// We just change it a bit to export `instantiate` function
// instead of loading WASM directly.

// Error tracking for WASM abort/panic messages
let lastWasmError: {
  message: string | null;
  fileName: string | null;
  lineNumber: number;
  columnNumber: number;
  timestamp: number;
} | null = null;

export function getLastWasmError() {
  return lastWasmError;
}

export function clearLastWasmError() {
  lastWasmError = null;
}

export async function instantiate(module, imports = {}) {
  const adaptedImports = {
    env: Object.assign(Object.create(globalThis), imports.env || {}, {
      abort(message, fileName, lineNumber, columnNumber) {
        // ~lib/builtins/abort(~lib/string/String | null?, ~lib/string/String | null?, u32?, u32?) => void
        message = __liftString(message >>> 0);
        fileName = __liftString(fileName >>> 0);
        lineNumber = lineNumber >>> 0;
        columnNumber = columnNumber >>> 0;
        
        // Store error information for later retrieval
        lastWasmError = {
          message: message || null,
          fileName: fileName || null,
          lineNumber: lineNumber,
          columnNumber: columnNumber,
          timestamp: Date.now(),
        };
        
        // Create detailed error message
        const errorMessage = message 
          ? `${message} in ${fileName || '<unknown>'}:${lineNumber}:${columnNumber}`
          : `WASM abort at ${fileName || '<unknown>'}:${lineNumber}:${columnNumber}`;
        
        const error = new Error(errorMessage);
        // Add additional properties for easier debugging
        (error as any).wasmError = lastWasmError;
        (error as any).wasmFileName = fileName;
        (error as any).wasmLineNumber = lineNumber;
        (error as any).wasmColumnNumber = columnNumber;
        
        (() => {
          // @external.js
          throw error;
        })();
      },
      'console.log'(message) {
        console.log(__liftString(message >>> 0));
      },
      'console.debug'(message) {
        console.debug(__liftString(message >>> 0));
      },
      'console.info'(message) {
        console.info(__liftString(message >>> 0));
      },
      'console.warn'(message) {
        console.warn(__liftString(message >>> 0));
      },
      'console.error'(message) {
        console.error(__liftString(message >>> 0));
      },
    }),
  };
  const result = await WebAssembly.instantiate(module, adaptedImports);
  const instance = result instanceof WebAssembly.Instance ? result : result.instance;
  const exports = instance.exports;  const memory = exports.memory || imports.env?.memory;
  const adaptedExports = Object.setPrototypeOf({
    RAMType: (values => (
      // assembly/index/RAMType
      values[values.PVMRAM = exports["RAMType.PVMRAM"].valueOf()] = "PVMRAM",
      values[values.SimpleRAM = exports["RAMType.SimpleRAM"].valueOf()] = "SimpleRAM",
      values[values.MockRAM = exports["RAMType.MockRAM"].valueOf()] = "MockRAM",
      values
    ))({}),
    roundTripSingleImplications(data, numCores, numValidators, authQueueSize) {
      // assembly/index/roundTripSingleImplications(~lib/typedarray/Uint8Array, i32, i32, i32) => ~lib/typedarray/Uint8Array
      data = __lowerTypedArray(Uint8Array, 11, 0, data) || __notnull();
      return __liftTypedArray(Uint8Array, exports.roundTripSingleImplications(data, numCores, numValidators, authQueueSize) >>> 0);
    },
    roundTripImplications(data, numCores, numValidators, authQueueSize) {
      // assembly/index/roundTripImplications(~lib/typedarray/Uint8Array, i32, i32, i32) => ~lib/typedarray/Uint8Array
      data = __lowerTypedArray(Uint8Array, 11, 0, data) || __notnull();
      return __liftTypedArray(Uint8Array, exports.roundTripImplications(data, numCores, numValidators, authQueueSize) >>> 0);
    },
    roundTripServiceAccount(data) {
      // assembly/index/roundTripServiceAccount(~lib/typedarray/Uint8Array) => ~lib/typedarray/Uint8Array
      data = __lowerTypedArray(Uint8Array, 11, 0, data) || __notnull();
      return __liftTypedArray(Uint8Array, exports.roundTripServiceAccount(data) >>> 0);
    },
    roundTripPartialState(data, numCores, numValidators, authQueueSize) {
      // assembly/index/roundTripPartialState(~lib/typedarray/Uint8Array, i32, i32, i32) => ~lib/typedarray/Uint8Array
      data = __lowerTypedArray(Uint8Array, 11, 0, data) || __notnull();
      return __liftTypedArray(Uint8Array, exports.roundTripPartialState(data, numCores, numValidators, authQueueSize) >>> 0);
    },
    resetGeneric(program, registers, gas) {
      // assembly/index/resetGeneric(~lib/typedarray/Uint8Array, ~lib/typedarray/Uint8Array, u32) => void
      program = __retain(__lowerTypedArray(Uint8Array, 11, 0, program) || __notnull());
      registers = __lowerTypedArray(Uint8Array, 11, 0, registers) || __notnull();
      try {
        exports.resetGeneric(program, registers, gas);
      } finally {
        __release(program);
      }
    },
    resetGenericWithMemory(programPtr, registersPtr, pageMapPtr, chunksPtr, gas) {
      // assembly/index/resetGenericWithMemory(~lib/typedarray/Uint8Array, ~lib/typedarray/Uint8Array, ~lib/typedarray/Uint8Array, ~lib/typedarray/Uint8Array, u32) => void
      programPtr = __retain(__lowerTypedArray(Uint8Array, 11, 0, programPtr) || __notnull());
      registersPtr = __retain(__lowerTypedArray(Uint8Array, 11, 0, registersPtr) || __notnull());
      pageMapPtr = __retain(__lowerTypedArray(Uint8Array, 11, 0, pageMapPtr) || __notnull());
      chunksPtr = __lowerTypedArray(Uint8Array, 11, 0, chunksPtr) || __notnull();
      try {
        exports.resetGenericWithMemory(programPtr, registersPtr, pageMapPtr, chunksPtr, gas);
      } finally {
        __release(programPtr);
        __release(registersPtr);
        __release(pageMapPtr);
      }
    },
    nextStep() {
      // assembly/index/nextStep() => bool
      return exports.nextStep() != 0;
    },
    nSteps(steps) {
      // assembly/index/nSteps(i32) => bool
      return exports.nSteps(steps) != 0;
    },
    runBlob(program) {
      // assembly/index/runBlob(~lib/typedarray/Uint8Array) => void
      program = __lowerTypedArray(Uint8Array, 11, 0, program) || __notnull();
      exports.runBlob(program);
    },
    prepareBlob(program) {
      // assembly/index/prepareBlob(~lib/typedarray/Uint8Array) => void
      program = __lowerTypedArray(Uint8Array, 11, 0, program) || __notnull();
      exports.prepareBlob(program);
    },
    runProgram() {
      // assembly/index/runProgram() => assembly/types/RunProgramResult
      return __liftInternref(exports.runProgram() >>> 0);
    },
    getProgramCounter() {
      // assembly/index/getProgramCounter() => u32
      return exports.getProgramCounter() >>> 0;
    },
    getGasLeft() {
      // assembly/index/getGasLeft() => u32
      return exports.getGasLeft() >>> 0;
    },
    setGasLeft(gas) {
      // assembly/index/setGasLeft(i64) => void
      gas = gas || 0n;
      exports.setGasLeft(gas);
    },
    getExitArg() {
      // assembly/index/getExitArg() => u32
      return exports.getExitArg() >>> 0;
    },
    getResultCode() {
      // assembly/index/getResultCode() => u32
      return exports.getResultCode() >>> 0;
    },
    getRegisters() {
      // assembly/index/getRegisters() => ~lib/typedarray/Uint8Array
      return __liftTypedArray(Uint8Array, exports.getRegisters() >>> 0);
    },
    setRegisters(registers) {
      // assembly/index/setRegisters(~lib/array/Array<u8>) => void
      registers = __lowerArray(__setU8, 193, 0, registers) || __notnull();
      exports.setRegisters(registers);
    },
    getRegister(index) {
      // assembly/index/getRegister(u8) => u64
      return BigInt.asUintN(64, exports.getRegister(index));
    },
    setRegister(index, value) {
      // assembly/index/setRegister(u8, u64) => void
      value = value || 0n;
      exports.setRegister(index, value);
    },
    getPageDump(pageIndex) {
      // assembly/index/getPageDump(i32) => ~lib/typedarray/Uint8Array
      return __liftTypedArray(Uint8Array, exports.getPageDump(pageIndex) >>> 0);
    },
    setMemory(address, data) {
      // assembly/index/setMemory(u32, ~lib/typedarray/Uint8Array) => void
      data = __lowerTypedArray(Uint8Array, 11, 0, data) || __notnull();
      exports.setMemory(address, data);
    },
    initializeProgram(program, args) {
      // assembly/index/initializeProgram(~lib/typedarray/Uint8Array, ~lib/typedarray/Uint8Array) => void
      program = __retain(__lowerTypedArray(Uint8Array, 11, 0, program) || __notnull());
      args = __lowerTypedArray(Uint8Array, 11, 0, args) || __notnull();
      try {
        exports.initializeProgram(program, args);
      } finally {
        __release(program);
      }
    },
    accumulateInvocation(gasLimit, program, args, context, numCores, numValidators, authQueueSize) {
      // assembly/index/accumulateInvocation(u32, ~lib/typedarray/Uint8Array, ~lib/typedarray/Uint8Array, ~lib/typedarray/Uint8Array, i32, i32, i32) => assembly/pvm/AccumulateInvocationResult
      // Clear any previous error before calling
      clearLastWasmError();
      
      program = __retain(__lowerTypedArray(Uint8Array, 11, 0, program) || __notnull());
      args = __lowerTypedArray(Uint8Array, 11, 0, args) || __notnull();
      context = __retain(__lowerTypedArray(Uint8Array, 11, 0, context) || __notnull());
      try {
        const resultPtr = exports.accumulateInvocation(gasLimit, program, args, context, numCores, numValidators, authQueueSize);
        // Lift the AccumulateInvocationResult from WASM memory
        return __liftInternref(resultPtr >>> 0);
      } catch (error) {
        // If error was thrown, check if we have WASM error details
        const wasmError = getLastWasmError();
        if (wasmError) {
          // Enhance the error with WASM details
          (error as any).wasmErrorDetails = wasmError;
        }
        throw error;
      } finally {
        __release(program);
        __release(context);
      }
    },
    setupAccumulateInvocation(gasLimit, program, args, context, numCores, numValidators, authQueueSize, entropyAccumulator, encodedWorkItems, configNumCores, configPreimageExpungePeriod, configEpochDuration, configMaxBlockGas, configMaxRefineGas, configMaxTicketsPerExtrinsic, configTicketsPerValidator, configSlotDuration, configRotationPeriod, configNumValidators, configNumEcPiecesPerSegment, configContestDuration, configMaxLookupAnchorage, configEcPieceSize) {
      // assembly/index/setupAccumulateInvocation(u32, ~lib/typedarray/Uint8Array, ~lib/typedarray/Uint8Array, ~lib/typedarray/Uint8Array, i32, i32, i32, ~lib/typedarray/Uint8Array, ~lib/typedarray/Uint8Array, i32?, u32?, u32?, u64?, u64?, u16?, u16?, u16?, u16?, u16?, u32?, u32?, u32?, u32?) => void
      program = __retain(__lowerTypedArray(Uint8Array, 11, 0, program) || __notnull());
      args = __retain(__lowerTypedArray(Uint8Array, 11, 0, args) || __notnull());
      context = __retain(__lowerTypedArray(Uint8Array, 11, 0, context) || __notnull());
      entropyAccumulator = __lowerTypedArray(Uint8Array, 11, 0, entropyAccumulator) || __notnull();
      encodedWorkItems = __lowerTypedArray(Uint8Array, 11, 0, encodedWorkItems) || __notnull();
      configMaxBlockGas = configMaxBlockGas || 0n;
      configMaxRefineGas = configMaxRefineGas || 0n;
      try {
        exports.__setArgumentsLength(arguments.length);
        exports.setupAccumulateInvocation(gasLimit, program, args, context, numCores, numValidators, authQueueSize, entropyAccumulator, encodedWorkItems, configNumCores, configPreimageExpungePeriod, configEpochDuration, configMaxBlockGas, configMaxRefineGas, configMaxTicketsPerExtrinsic, configTicketsPerValidator, configSlotDuration, configRotationPeriod, configNumValidators, configNumEcPiecesPerSegment, configContestDuration, configMaxLookupAnchorage, configEcPieceSize);
      } finally {
        __release(program);
        __release(args);
        __release(context);
      }
    },
    alignToPage(size) {
      // assembly/alignment-helpers/alignToPage(u32) => u32
      return exports.alignToPage(size) >>> 0;
    },
    alignToZone(size) {
      // assembly/alignment-helpers/alignToZone(u32) => u32
      return exports.alignToZone(size) >>> 0;
    },
    decodeNatural(data) {
      // assembly/codec/decodeNatural(~lib/typedarray/Uint8Array) => assembly/codec/DecodingResult<u64> | null
      data = __lowerTypedArray(Uint8Array, 11, 0, data) || __notnull();
      return __liftInternref(exports.decodeNatural(data) >>> 0);
    },
    decodeBlob(programBlob) {
      // assembly/codec/decodeBlob(~lib/typedarray/Uint8Array) => assembly/codec/DecodedBlob | null
      programBlob = __lowerTypedArray(Uint8Array, 11, 0, programBlob) || __notnull();
      return __liftInternref(exports.decodeBlob(programBlob) >>> 0);
    },
    decodeServiceCodeFromPreimage(preimageBlob) {
      // assembly/codec/decodeServiceCodeFromPreimage(~lib/typedarray/Uint8Array) => assembly/codec/DecodingResult<assembly/codec/ServiceCodeResult> | null
      preimageBlob = __lowerTypedArray(Uint8Array, 11, 0, preimageBlob) || __notnull();
      return __liftInternref(exports.decodeServiceCodeFromPreimage(preimageBlob) >>> 0);
    },
    decodeProgram(programBlob) {
      // assembly/codec/decodeProgram(~lib/typedarray/Uint8Array) => assembly/codec/DecodedProgram | null
      programBlob = __lowerTypedArray(Uint8Array, 11, 0, programBlob) || __notnull();
      return __liftInternref(exports.decodeProgram(programBlob) >>> 0);
    },
    decodeProgramFromPreimage(preimageBlob) {
      // assembly/codec/decodeProgramFromPreimage(~lib/typedarray/Uint8Array) => assembly/codec/DecodedProgram | null
      preimageBlob = __lowerTypedArray(Uint8Array, 11, 0, preimageBlob) || __notnull();
      return __liftInternref(exports.decodeProgramFromPreimage(preimageBlob) >>> 0);
    },
    getCode() {
      // assembly/index/getCode() => ~lib/typedarray/Uint8Array
      return __liftTypedArray(Uint8Array, exports.getCode() >>> 0);
    },
    getBitmask() {
      // assembly/index/getBitmask() => ~lib/typedarray/Uint8Array
      return __liftTypedArray(Uint8Array, exports.getBitmask() >>> 0);
    },
    encodeServiceAccount(account) {
      // assembly/codec/encodeServiceAccount(assembly/codec/ServiceAccountData) => ~lib/typedarray/Uint8Array
      account = __lowerInternref(account) || __notnull();
      return __liftTypedArray(Uint8Array, exports.encodeServiceAccount(account) >>> 0);
    },
    hexToBytes(hex) {
      // assembly/codec/hexToBytes(~lib/string/String) => ~lib/typedarray/Uint8Array
      hex = __lowerString(hex) || __notnull();
      return __liftTypedArray(Uint8Array, exports.hexToBytes(hex) >>> 0);
    },
    encodeFixedLength(value, length) {
      // assembly/codec/encodeFixedLength(u64, i32) => ~lib/typedarray/Uint8Array
      value = value || 0n;
      return __liftTypedArray(Uint8Array, exports.encodeFixedLength(value, length) >>> 0);
    },
    encodeNatural(value) {
      // assembly/codec/encodeNatural(u64) => ~lib/typedarray/Uint8Array
      value = value || 0n;
      return __liftTypedArray(Uint8Array, exports.encodeNatural(value) >>> 0);
    },
    encodeRefineContext(context) {
      // assembly/codec/encodeRefineContext(assembly/codec/RefineContext) => ~lib/typedarray/Uint8Array
      context = __lowerInternref(context) || __notnull();
      return __liftTypedArray(Uint8Array, exports.encodeRefineContext(context) >>> 0);
    },
    encodeImportReference(importRef) {
      // assembly/codec/encodeImportReference(assembly/codec/ImportSegment) => ~lib/typedarray/Uint8Array
      importRef = __lowerInternref(importRef) || __notnull();
      return __liftTypedArray(Uint8Array, exports.encodeImportReference(importRef) >>> 0);
    },
    encodeExtrinsicReference(extrinsicRef) {
      // assembly/codec/encodeExtrinsicReference(assembly/codec/ExtrinsicReference) => ~lib/typedarray/Uint8Array
      extrinsicRef = __lowerInternref(extrinsicRef) || __notnull();
      return __liftTypedArray(Uint8Array, exports.encodeExtrinsicReference(extrinsicRef) >>> 0);
    },
    encodeVariableSequence(sequence) {
      // assembly/codec/encodeVariableSequence(~lib/array/Array<~lib/typedarray/Uint8Array>) => ~lib/typedarray/Uint8Array
      sequence = __lowerArray((pointer, value) => { __setU32(pointer, __lowerTypedArray(Uint8Array, 11, 0, value) || __notnull()); }, 195, 2, sequence) || __notnull();
      return __liftTypedArray(Uint8Array, exports.encodeVariableSequence(sequence) >>> 0);
    },
    encodeWorkItem(workItem) {
      // assembly/codec/encodeWorkItem(assembly/codec/WorkItem) => ~lib/typedarray/Uint8Array
      workItem = __lowerInternref(workItem) || __notnull();
      return __liftTypedArray(Uint8Array, exports.encodeWorkItem(workItem) >>> 0);
    },
    encodeWorkItemSummary(workItem) {
      // assembly/codec/encodeWorkItemSummary(assembly/codec/WorkItem) => ~lib/typedarray/Uint8Array
      workItem = __lowerInternref(workItem) || __notnull();
      return __liftTypedArray(Uint8Array, exports.encodeWorkItemSummary(workItem) >>> 0);
    },
    encodeWorkPackage(workPackage) {
      // assembly/codec/encodeWorkPackage(assembly/codec/WorkPackage) => ~lib/typedarray/Uint8Array
      workPackage = __lowerInternref(workPackage) || __notnull();
      return __liftTypedArray(Uint8Array, exports.encodeWorkPackage(workPackage) >>> 0);
    },
    DEFAULT_GAS_LIMIT: {
      // assembly/config/DEFAULT_GAS_LIMIT: u32
      valueOf() { return this.value; },
      get value() {
        return exports.DEFAULT_GAS_LIMIT.value >>> 0;
      }
    },
    MIN_GAS_COST: {
      // assembly/config/MIN_GAS_COST: u32
      valueOf() { return this.value; },
      get value() {
        return exports.MIN_GAS_COST.value >>> 0;
      }
    },
    MAX_GAS_COST: {
      // assembly/config/MAX_GAS_COST: u32
      valueOf() { return this.value; },
      get value() {
        return exports.MAX_GAS_COST.value >>> 0;
      }
    },
    RESERVED_MEMORY_END: {
      // assembly/config/RESERVED_MEMORY_END: u32
      valueOf() { return this.value; },
      get value() {
        return exports.RESERVED_MEMORY_END.value >>> 0;
      }
    },
    MAX_MEMORY_ADDRESS: {
      // assembly/config/MAX_MEMORY_ADDRESS: u32
      valueOf() { return this.value; },
      get value() {
        return exports.MAX_MEMORY_ADDRESS.value >>> 0;
      }
    },
    INITIAL_ZONE_SIZE: {
      // assembly/config/INITIAL_ZONE_SIZE: u32
      valueOf() { return this.value; },
      get value() {
        return exports.INITIAL_ZONE_SIZE.value >>> 0;
      }
    },
    PAGE_SIZE: {
      // assembly/config/PAGE_SIZE: u32
      valueOf() { return this.value; },
      get value() {
        return exports.PAGE_SIZE.value >>> 0;
      }
    },
    DYNAMIC_ADDRESS_ALIGNMENT: {
      // assembly/config/DYNAMIC_ADDRESS_ALIGNMENT: u32
      valueOf() { return this.value; },
      get value() {
        return exports.DYNAMIC_ADDRESS_ALIGNMENT.value >>> 0;
      }
    },
    ZONE_SIZE: {
      // assembly/config/ZONE_SIZE: u32
      valueOf() { return this.value; },
      get value() {
        return exports.ZONE_SIZE.value >>> 0;
      }
    },
    INIT_INPUT_SIZE: {
      // assembly/config/INIT_INPUT_SIZE: u32
      valueOf() { return this.value; },
      get value() {
        return exports.INIT_INPUT_SIZE.value >>> 0;
      }
    },
    HALT_ADDRESS: {
      // assembly/config/HALT_ADDRESS: u32
      valueOf() { return this.value; },
      get value() {
        return exports.HALT_ADDRESS.value >>> 0;
      }
    },
    STACK_SEGMENT_END: {
      // assembly/config/STACK_SEGMENT_END: u32
      valueOf() { return this.value; },
      get value() {
        return exports.STACK_SEGMENT_END.value >>> 0;
      }
    },
    ARGS_SEGMENT_START: {
      // assembly/config/ARGS_SEGMENT_START: u32
      valueOf() { return this.value; },
      get value() {
        return exports.ARGS_SEGMENT_START.value >>> 0;
      }
    },
    PACKAGE_AUTH_GAS: {
      // assembly/config/PACKAGE_AUTH_GAS: u32
      valueOf() { return this.value; },
      get value() {
        return exports.PACKAGE_AUTH_GAS.value >>> 0;
      }
    },
    MAX_AUTH_CODE_SIZE: {
      // assembly/config/MAX_AUTH_CODE_SIZE: u32
      valueOf() { return this.value; },
      get value() {
        return exports.MAX_AUTH_CODE_SIZE.value >>> 0;
      }
    },
    PACKAGE_REF_GAS: {
      // assembly/config/PACKAGE_REF_GAS: u64
      valueOf() { return this.value; },
      get value() {
        return BigInt.asUintN(64, exports.PACKAGE_REF_GAS.value);
      }
    },
    MAX_SERVICE_CODE_SIZE: {
      // assembly/config/MAX_SERVICE_CODE_SIZE: u32
      valueOf() { return this.value; },
      get value() {
        return exports.MAX_SERVICE_CODE_SIZE.value >>> 0;
      }
    },
    SEGMENT_SIZE: {
      // assembly/config/SEGMENT_SIZE: u32
      valueOf() { return this.value; },
      get value() {
        return exports.SEGMENT_SIZE.value >>> 0;
      }
    },
    MAX_PACKAGE_EXPORTS: {
      // assembly/config/MAX_PACKAGE_EXPORTS: u32
      valueOf() { return this.value; },
      get value() {
        return exports.MAX_PACKAGE_EXPORTS.value >>> 0;
      }
    },
    MIN_PUBLIC_INDEX: {
      // assembly/config/MIN_PUBLIC_INDEX: u32
      valueOf() { return this.value; },
      get value() {
        return exports.MIN_PUBLIC_INDEX.value >>> 0;
      }
    },
    isTerminationInstruction(opcode) {
      // assembly/config/isTerminationInstruction(u8) => bool
      return exports.isTerminationInstruction(opcode) != 0;
    },
    REGISTER_INIT_STACK_SEGMENT_END() {
      // assembly/config/REGISTER_INIT_STACK_SEGMENT_END() => u32
      return exports.REGISTER_INIT_STACK_SEGMENT_END() >>> 0;
    },
    REGISTER_INIT_ARGS_SEGMENT_START() {
      // assembly/config/REGISTER_INIT_ARGS_SEGMENT_START() => u32
      return exports.REGISTER_INIT_ARGS_SEGMENT_START() >>> 0;
    },
    MemoryAccessType: (values => (
      // assembly/types/MemoryAccessType
      values[values.NONE = exports["MemoryAccessType.NONE"].valueOf()] = "NONE",
      values[values.READ = exports["MemoryAccessType.READ"].valueOf()] = "READ",
      values[values.WRITE = exports["MemoryAccessType.WRITE"].valueOf()] = "WRITE",
      values
    ))({}),
    bytesToHex(bytes) {
      // assembly/types/bytesToHex(~lib/typedarray/Uint8Array) => ~lib/string/String
      bytes = __lowerTypedArray(Uint8Array, 11, 0, bytes) || __notnull();
      return __liftString(exports.bytesToHex(bytes) >>> 0);
    },
    Status: (values => (
      // assembly/wasm-wrapper/Status
      values[values.OK = exports["Status.OK"].valueOf()] = "OK",
      values[values.HALT = exports["Status.HALT"].valueOf()] = "HALT",
      values[values.PANIC = exports["Status.PANIC"].valueOf()] = "PANIC",
      values[values.FAULT = exports["Status.FAULT"].valueOf()] = "FAULT",
      values[values.HOST = exports["Status.HOST"].valueOf()] = "HOST",
      values[values.OOG = exports["Status.OOG"].valueOf()] = "OOG",
      values
    ))({}),
    createPvmShell() {
      // assembly/wasm-wrapper/createPvmShell() => assembly/wasm-wrapper/WasmPvmShellInterface
      return __liftRecord5(exports.createPvmShell() >>> 0);
    },
    // Error tracking helpers
    getLastWasmError() {
      return getLastWasmError();
    },
    clearLastWasmError() {
      clearLastWasmError();
    },
    getDecodedProgramFields(preimageBlob) {
      // assembly/index/getDecodedProgramFields(~lib/typedarray/Uint8Array) => assembly/test-exports/DecodedProgramFields | null
      preimageBlob = __lowerTypedArray(Uint8Array, 11, 0, preimageBlob) || __notnull();
      const result = exports.getDecodedProgramFields(preimageBlob);
      if (!result) return null;
      // result is an internref pointer to DecodedProgramFields class in WASM memory
      // We need to read the fields from memory using the pointer
      const memory = exports.memory || imports.env?.memory;
      const view = new DataView(memory.buffer);
      // Read class fields from WASM memory (each field is 4 bytes for pointers, u32 values)
      // Class layout: metadata (ptr), roDataLength (u32), rwDataLength (u32), heapZeroPaddingSize (u32), 
      //               stackSize (u32), roData (ptr), rwData (ptr), codeSize (u32), code (ptr)
      const metadataPtr = view.getUint32(result + 0, true);
      const roDataLength = view.getUint32(result + 4, true);
      const rwDataLength = view.getUint32(result + 8, true);
      const heapZeroPaddingSize = view.getUint32(result + 12, true);
      const stackSize = view.getUint32(result + 16, true);
      const roDataPtr = view.getUint32(result + 20, true);
      const rwDataPtr = view.getUint32(result + 24, true);
      const codeSize = view.getUint32(result + 28, true);
      const codePtr = view.getUint32(result + 32, true);
      
      return {
        metadata: metadataPtr ? __liftTypedArray(Uint8Array, metadataPtr >>> 0) : new Uint8Array(0),
        roDataLength: roDataLength >>> 0,
        rwDataLength: rwDataLength >>> 0,
        heapZeroPaddingSize: heapZeroPaddingSize >>> 0,
        stackSize: stackSize >>> 0,
        roData: roDataPtr ? __liftTypedArray(Uint8Array, roDataPtr >>> 0) : new Uint8Array(0),
        rwData: rwDataPtr ? __liftTypedArray(Uint8Array, rwDataPtr >>> 0) : new Uint8Array(0),
        codeSize: codeSize >>> 0,
        code: codePtr ? __liftTypedArray(Uint8Array, codePtr >>> 0) : new Uint8Array(0),
      };
    },
  }, exports);
  function __liftRecord5(pointer) {
    // assembly/wasm-wrapper/WasmPvmShellInterface
    // Hint: Opt-out from lifting as a record by providing an empty constructor
    if (!pointer) return null;
    return {
    };
  }
  function __liftString(pointer) {
    if (!pointer) return null;
    const
      end = pointer + new Uint32Array(memory.buffer)[pointer - 4 >>> 2] >>> 1,
      memoryU16 = new Uint16Array(memory.buffer);
    let
      start = pointer >>> 1,
      string = "";
    while (end - start > 1024) string += String.fromCharCode(...memoryU16.subarray(start, start += 1024));
    return string + String.fromCharCode(...memoryU16.subarray(start, end));
  }
  function __lowerString(value) {
    if (value == null) return 0;
    const
      length = value.length,
      pointer = exports.__new(length << 1, 2) >>> 0,
      memoryU16 = new Uint16Array(memory.buffer);
    for (let i = 0; i < length; ++i) memoryU16[(pointer >>> 1) + i] = value.charCodeAt(i);
    return pointer;
  }
  function __lowerArray(lowerElement, id, align, values) {
    if (values == null) return 0;
    const
      length = values.length,
      buffer = exports.__pin(exports.__new(length << align, 1)) >>> 0,
      header = exports.__pin(exports.__new(16, id)) >>> 0;
    __setU32(header + 0, buffer);
    __dataview.setUint32(header + 4, buffer, true);
    __dataview.setUint32(header + 8, length << align, true);
    __dataview.setUint32(header + 12, length, true);
    for (let i = 0; i < length; ++i) lowerElement(buffer + (i << align >>> 0), values[i]);
    exports.__unpin(buffer);
    exports.__unpin(header);
    return header;
  }
  function __liftTypedArray(constructor, pointer) {
    if (!pointer) return null;
    return new constructor(
      memory.buffer,
      __getU32(pointer + 4),
      __dataview.getUint32(pointer + 8, true) / constructor.BYTES_PER_ELEMENT
    ).slice();
  }
  function __lowerTypedArray(constructor, id, align, values) {
    if (values == null) return 0;
    const
      length = values.length,
      buffer = exports.__pin(exports.__new(length << align, 1)) >>> 0,
      header = exports.__new(12, id) >>> 0;
    __setU32(header + 0, buffer);
    __dataview.setUint32(header + 4, buffer, true);
    __dataview.setUint32(header + 8, length << align, true);
    new constructor(memory.buffer, buffer, length).set(values);
    exports.__unpin(buffer);
    return header;
  }
  class Internref extends Number {}
  const registry = new FinalizationRegistry(__release);
  function __liftInternref(pointer) {
    if (!pointer) return null;
    const sentinel = new Internref(__retain(pointer));
    registry.register(sentinel, pointer);
    return sentinel;
  }
  function __lowerInternref(value) {
    if (value == null) return 0;
    if (value instanceof Internref) return value.valueOf();
    throw TypeError("internref expected");
  }
  const refcounts = new Map();
  function __retain(pointer) {
    if (pointer) {
      const refcount = refcounts.get(pointer);
      if (refcount) refcounts.set(pointer, refcount + 1);
      else refcounts.set(exports.__pin(pointer), 1);
    }
    return pointer;
  }
  function __release(pointer) {
    if (pointer) {
      const refcount = refcounts.get(pointer);
      if (refcount === 1) exports.__unpin(pointer), refcounts.delete(pointer);
      else if (refcount) refcounts.set(pointer, refcount - 1);
      else throw Error(`invalid refcount '${refcount}' for reference '${pointer}'`);
    }
  }
  function __notnull() {
    throw TypeError("value must not be null");
  }
  let __dataview = new DataView(memory.buffer);
  function __setU8(pointer, value) {
    try {
      __dataview.setUint8(pointer, value, true);
    } catch {
      __dataview = new DataView(memory.buffer);
      __dataview.setUint8(pointer, value, true);
    }
  }
  function __setU32(pointer, value) {
    try {
      __dataview.setUint32(pointer, value, true);
    } catch {
      __dataview = new DataView(memory.buffer);
      __dataview.setUint32(pointer, value, true);
    }
  }
  function __getU32(pointer) {
    try {
      return __dataview.getUint32(pointer, true);
    } catch {
      __dataview = new DataView(memory.buffer);
      return __dataview.getUint32(pointer, true);
    }
  }
  return adaptedExports;
}
