/**
 * Rust Reed-Solomon Erasure Coding Wrapper
 *
 * TypeScript wrapper around the native Rust reed-solomon-simd implementation
 * Provides JAM-compatible erasure coding with configurable shard sizes
 */

import { logger } from '@pbnj/core'
import type {
  EncodedData,
  ErasureCoder,
  ErasureCodingValidationResult,
} from '@pbnj/types'

// Import the native Rust module (will be generated by napi)
let nativeModule: any
try {
  // Try platform-specific filename first
  const platform = process.platform
  const arch = process.arch
  nativeModule = require(
    `../rust-reed-solomon/jam-reed-solomon.${platform}-${arch}.node`,
  )
} catch (_error) {
  try {
    // Fallback to generic filename
    nativeModule = require('../rust-reed-solomon/jam-reed-solomon.node')
  } catch (fallbackError) {
    logger.warn(
      'Native Rust module not available, falling back to error mode',
      { error: fallbackError },
    )
  }
}

interface RustEncodedResult {
  shards: Buffer[]
  k: number
  n: number
  originalLength: number
  indices: number[]
}

interface RustValidationResult {
  isValid: boolean
  errors: string[]
  warnings: string[]
}

export class RustReedSolomonCoder implements ErasureCoder {
  private nativeInstance: any
  private readonly k: number
  private readonly n: number

  constructor(k = 2, n = 6) {
    this.k = k
    this.n = n

    if (!nativeModule) {
      throw new Error(
        'Native Rust Reed-Solomon module not available. Please build with: bun run build:native',
      )
    }

    try {
      this.nativeInstance = new nativeModule.RustReedSolomon(k, n)
      logger.debug('Rust Reed-Solomon Coder initialized', {
        k: this.k,
        n: this.n,
        parityShards: this.n - this.k,
      })
    } catch (error) {
      logger.error('Failed to initialize Rust Reed-Solomon coder', { error })
      throw new Error(`Failed to initialize Rust Reed-Solomon: ${error}`)
    }
  }

  private calculateShardSize(dataLength: number, k: number): number {
    if (dataLength === 0) {
      return 2 // Minimum shard size for empty data
    }

    const calculatedSize = Math.ceil(dataLength / k)
    const alignedSize = Math.max(2, calculatedSize)

    // Ensure even number (JAM uses 2-byte words, reed-solomon-simd requires even)
    return alignedSize % 2 === 0 ? alignedSize : alignedSize + 1
  }

  /**
   * Encode data using Rust Reed-Solomon implementation with configurable shard size
   */
  encode(
    data: Uint8Array,
    k?: number,
    n?: number,
    shardSize?: number,
  ): EncodedData {
    const actualK = k ?? this.k
    const actualN = n ?? this.n

    if (actualK <= 0 || actualN <= actualK) {
      throw new Error(`Invalid parameters: k=${actualK}, n=${actualN}`)
    }

    // If using different parameters, create new instance
    const instance =
      actualK !== this.k || actualN !== this.n
        ? new nativeModule.RustReedSolomon(actualK, actualN)
        : this.nativeInstance

    logger.debug('Encoding with Rust Reed-Solomon', {
      inputSize: data.length,
      k: actualK,
      n: actualN,
      requestedShardSize: shardSize,
    })

    // Determine shard size if not provided
    const actualShardSize =
      shardSize || this.calculateShardSize(data.length, actualK)

    try {
      const dataBuffer = Buffer.from(data)
      const result: RustEncodedResult = instance.encode(
        dataBuffer,
        actualShardSize,
      )

      // Convert Buffer[] to Uint8Array[]
      const shards = result.shards.map((buffer) => new Uint8Array(buffer))

      logger.debug('Rust encoding complete', {
        totalShards: shards.length,
        shardSizes: shards.map((s) => s.length),
        originalLength: result.originalLength,
      })

      return {
        shards,
        k: result.k,
        n: result.n,
        originalLength: result.originalLength,
        indices: result.indices,
      }
    } catch (error) {
      logger.error('Rust encoding failed', { error })
      throw new Error(`Rust encoding failed: ${error}`)
    }
  }

  /**
   * Decode data using Rust Reed-Solomon implementation
   */
  decode(encodedData: EncodedData, k?: number): Uint8Array {
    const { shards, k: encodedK, originalLength } = encodedData
    const actualK = k ?? encodedK

    // Ensure originalLength is defined
    if (originalLength === undefined) {
      throw new Error('originalLength is required for decoding')
    }

    // If using different parameters, create new instance
    const instance =
      actualK !== this.k || encodedData.n !== this.n
        ? new nativeModule.RustReedSolomon(actualK, encodedData.n)
        : this.nativeInstance

    logger.debug('Decoding with Rust Reed-Solomon', {
      totalShards: shards.length,
      k: actualK,
      originalLength,
    })

    try {
      // Convert Uint8Array[] to Buffer[]
      const shardBuffers = shards.map((shard) => Buffer.from(shard))

      const result: Buffer = instance.decode(shardBuffers, originalLength)

      return new Uint8Array(result)
    } catch (error) {
      logger.error('Rust decoding failed', { error })
      throw new Error(`Rust decoding failed: ${error}`)
    }
  }

  /**
   * Validate erasure coding configuration
   */
  validate(encodedData: EncodedData): ErasureCodingValidationResult {
    const { k, n } = encodedData

    try {
      const result: RustValidationResult = this.nativeInstance.validate(k, n)

      return {
        isValid: result.isValid,
        errors: result.errors,
        warnings: result.warnings,
      }
    } catch (error) {
      return {
        isValid: false,
        errors: [`Validation failed: ${error}`],
        warnings: [],
      }
    }
  }

  /**
   * Recover data from corrupted shards using Rust Reed-Solomon
   */
  recover(encodedData: EncodedData, corruptedIndices: number[]): Uint8Array {
    const { shards, k, n, originalLength } = encodedData

    // If using different parameters, create new instance
    const instance =
      k !== this.k || n !== this.n
        ? new nativeModule.RustReedSolomon(k, n)
        : this.nativeInstance

    logger.debug('Recovering with Rust Reed-Solomon', {
      totalShards: shards.length,
      k,
      n,
      originalLength,
      corruptedIndices,
    })

    try {
      // Convert Uint8Array[] to Buffer[]
      const shardBuffers = shards.map((shard) => Buffer.from(shard))

      const result: Buffer = instance.recover(
        shardBuffers,
        corruptedIndices,
        originalLength,
      )

      logger.debug('Rust recovery complete', {
        recoveredSize: result.length,
      })

      return new Uint8Array(result)
    } catch (error) {
      logger.error('Rust recovery failed', { error })
      throw new Error(`Rust recovery failed: ${error}`)
    }
  }

  /**
   * Get coder parameters
   */
  getParameters(): { k: number; n: number; parityShards: number } {
    try {
      return {
        k: this.nativeInstance.get_k(),
        n: this.nativeInstance.get_n(),
        parityShards: this.nativeInstance.get_parity_shards(),
      }
    } catch (_error) {
      return {
        k: this.k,
        n: this.n,
        parityShards: this.n - this.k,
      }
    }
  }

  /**
   * Create JAM-compatible tiny configuration encoder with 2-byte shards
   */
  static createJAMTinyEncoder(): RustReedSolomonCoder {
    return new RustReedSolomonCoder(2, 6)
  }

  /**
   * Create JAM-compatible full configuration encoder
   */
  static createJAMFullEncoder(): RustReedSolomonCoder {
    return new RustReedSolomonCoder(342, 1023)
  }

  /**
   * Encode with specific shard size for JAM compatibility
   */
  encodeWithShardSize(data: Uint8Array, shardSize: number): EncodedData {
    return this.encode(data, undefined, undefined, shardSize)
  }
}

/**
 * Factory function to create a Rust Reed-Solomon coder
 */
export function createRustReedSolomonCoder(k = 2, n = 6): RustReedSolomonCoder {
  return new RustReedSolomonCoder(k, n)
}

/**
 * Test function to verify Rust implementation against JAM test vectors
 */
export function testRustAgainstJAM(
  inputData: Uint8Array,
  expectedShards: Uint8Array[],
  shardSize?: number,
): {
  success: boolean
  rustShards: Uint8Array[]
  systematicMatches: number
  parityMatches: number
  shardSizeMatch: boolean
} {
  try {
    const coder = new RustReedSolomonCoder(2, 6)
    const encoded = shardSize
      ? coder.encodeWithShardSize(inputData, shardSize)
      : coder.encode(inputData)

    // Test round-trip
    const decoded = coder.decode(encoded)
    const roundTripSuccess =
      decoded.length === inputData.length &&
      decoded.every((byte, i) => byte === inputData[i])

    if (!roundTripSuccess) {
      return {
        success: false,
        rustShards: encoded.shards,
        systematicMatches: 0,
        parityMatches: 0,
        shardSizeMatch: false,
      }
    }

    // Check shard size compatibility
    const shardSizeMatch =
      encoded.shards.length > 0 && expectedShards.length > 0
        ? encoded.shards[0].length === expectedShards[0].length
        : true

    // Compare systematic shards (first k=2 shards)
    const systematicMatches = encoded.shards
      .slice(0, 2)
      .reduce((count, shard, i) => {
        if (i < expectedShards.length) {
          const matches =
            shard.length === expectedShards[i].length &&
            shard.every((byte, j) => byte === expectedShards[i][j])
          return count + (matches ? 1 : 0)
        }
        return count
      }, 0)

    // Compare parity shards
    const parityMatches = encoded.shards.slice(2).reduce((count, shard, i) => {
      const shardIndex = i + 2
      if (shardIndex < expectedShards.length) {
        const matches =
          shard.length === expectedShards[shardIndex].length &&
          shard.every((byte, j) => byte === expectedShards[shardIndex][j])
        return count + (matches ? 1 : 0)
      }
      return count
    }, 0)

    return {
      success: true,
      rustShards: encoded.shards,
      systematicMatches,
      parityMatches,
      shardSizeMatch,
    }
  } catch (error) {
    logger.error('Rust test failed', { error })
    return {
      success: false,
      rustShards: [],
      systematicMatches: 0,
      parityMatches: 0,
      shardSizeMatch: false,
    }
  }
}

/**
 * Check if native Rust module is available
 */
export function isRustModuleAvailable(): boolean {
  return nativeModule !== undefined
}

/**
 * Get expected shard size from JAM test vector data
 * Analyzes the actual test vector to determine what shard size it expects
 */
export function getJAMTestVectorShardSize(testVector: any): number {
  if (!testVector || !testVector.shards || !Array.isArray(testVector.shards)) {
    throw new Error('Invalid test vector format')
  }

  // Get the length of the first shard (all shards should be the same size)
  const firstShardHex = testVector.shards[0]
  if (!firstShardHex || typeof firstShardHex !== 'string') {
    throw new Error('Invalid shard format in test vector')
  }

  // Remove '0x' prefix and calculate byte length
  const hexWithoutPrefix = firstShardHex.startsWith('0x')
    ? firstShardHex.slice(2)
    : firstShardHex
  const shardSizeBytes = hexWithoutPrefix.length / 2

  return Math.floor(shardSizeBytes)
}
