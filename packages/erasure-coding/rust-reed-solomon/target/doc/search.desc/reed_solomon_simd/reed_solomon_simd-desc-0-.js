searchState.loadedDescShard(
  'reed_solomon_simd',
  0,
  'Reed-Solomon erasure coding based on Leopard-RS, featuring:\nResult of decoding. Contains the restored original shards.\nGiven shard has different size than given or inferred …\nDecoder was given two original shards with same index.\nDecoder was given two recovery shards with same index.\nResult of encoding. Contains the generated recovery shards.\nRepresents all possible errors that can occur in this …\nDecoder was given original shard with invalid index, i.e. …\nDecoder was given recovery shard with invalid index, i.e. …\nGiven or inferred shard size is invalid: Size must be …\nDecoder was given too few shards.\nIterator over generated recovery shards.\nReed-Solomon decoder using <code>DefaultEngine</code> and <code>DefaultRate</code>.\nReed-Solomon encoder using <code>DefaultEngine</code> and <code>DefaultRate</code>.\nIterator over restored original shards and their indexes.\nEncoder was given less than <code>original_count</code> original shards.\nEncoder was given more than <code>original_count</code> original shards.\nGiven <code>original_count</code> / <code>recovery_count</code> combination is not …\nAdds one original shard to the encoder.\nAdds one original shard to the decoder.\nAdds one recovery shard to the decoder.\nAlgorithm documentation.\nDecodes in one go using <code>ReedSolomonDecoder</code>, returning …\nDecodes the added shards returning <code>DecoderResult</code> which …\nEncodes in one go using <code>ReedSolomonEncoder</code>, returning …\nEncodes the added original shards returning <code>EncoderResult</code> …\nLow-level building blocks for Reed-Solomon …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates new encoder with given configuration and allocates …\nCreates new decoder with given configuration and allocates …\nAdvanced encoding/decoding using chosen <code>Engine</code> and <code>Rate</code>.\nReturns recovery shard with given <code>index</code> or <code>None</code> if …\nReturns iterator over all recovery shards ordered by their …\nResets encoder to given configuration.\nResets decoder to given configuration.\nReturns restored original shard with given <code>index</code> or <code>None</code> …\nReturns iterator over all restored original shards and …\nReturns <code>true</code> if given <code>original_count</code> / <code>recovery_count</code> …\nReturns <code>true</code> if given <code>original_count</code> / <code>recovery_count</code> …\nSize of the given shard.\nGiven duplicate index.\nGiven duplicate index.\nGiven invalid index.\nGiven invalid index.\nConfigured number of original shards.\nConfigured number of original shards.\nConfigured number of original shards.\nConfigured number of original shards.\nGiven number of original shards.\nNumber of original shards given to decoder.\nNumber of original shards given to encoder.\nConfigured number of recovery shards.\nGiven number of recovery shards.\nNumber of recovery shards given to decoder.\nGiven or inferred shard size.\nGiven or inferred shard size.\nTODO\n<code>Engine</code> that at runtime selects the best Engine.\nTrait for compute-intensive low-level algorithms needed …\nSize of Galois field element <code>GfElement</code> in bits.\n<code>GF_ORDER - 1</code>\nGalois field order, i.e. number of elements.\nGalois field polynomial.\nGalois field element.\nSimple reference implementation of <code>Engine</code>.\nOptimized <code>Engine</code> using Arm Neon instructions.\nOptimized <code>Engine</code> without SIMD.\nMutable reference to a shard array.\nReturns mutable references to shards at <code>pos</code> and <code>pos + dist</code>.\nReturns mutable references to shards at <code>pos</code>, <code>pos + dist</code>, …\nEvaluate polynomial.\nIn-place decimation-in-time FFT (fast Fourier transform).\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIn-place decimation-in-time IFFT (inverse fast Fourier …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if this contains no shards.\nReturns number of shards.\n<code>x[] *= log_m</code>\nCreates new <code>DefaultEngine</code> by chosing and initializing the …\nCreates new <code>ShardsRefMut</code> that references given <code>data</code>.\nCreates new <code>Naive</code>, initializing all tables needed for …\nCreates new <code>NoSimd</code>, initializing all tables needed for …\nCreates new <code>Neon</code>, initializing all tables needed for …\nSplits this <code>ShardsRefMut</code> into two so that first includes …\nLookup-tables used by <code>Engine</code>:s.\nA collection of utility functions and helpers to …\nFills the given shard-range with <code>0u8</code>:s.\nLazily initialized exponentiation and logarithm tables.\nUsed by <code>Naive</code> engine for multiplications and by all <code>Engine</code>…\nStruct holding the <code>Exp</code> and <code>Log</code> lookup tables.\nLazily initialized logarithmic Walsh transform table.\nUsed by <code>Naive</code> engine for multiplications and by all <code>Engine</code>…\nUsed by all <code>Engine</code>:s in <code>Engine::eval_poly</code>.\nLazily initialized multiplication table for SIMD engines.\nLazily initialized multiplication table for the <code>NoSimd</code> …\nUsed by <code>Avx2</code> and <code>Ssse3</code> engines for multiplications.\nUsed by <code>NoSimd</code> engine for multiplications.\nElements of the Mul128 table\nLazily initialized skew table used in FFT and IFFT …\nUsed by all <code>Engine</code>:s for FFT and IFFT.\nExponentiation table.\nReturns the argument unchanged.\nReturns the argument unchanged.\nUpper half of <code>GfElements</code>\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLower half of <code>GfElements</code>\nLogarithm table.\nCalculates <code>x * log_m</code> using <code>Exp</code> and <code>Log</code> tables.\nEvaluate Polynomial using Fast Walsh-Hadamard Transform …\n<code>x[] ^= y[]</code>\n<code>data[x .. x + count] ^= data[y .. y + count]</code>\nWorking space for <code>RateDecoder</code>.\nReed-Solomon encoder/decoder generator using high or low …\nReed-Solomon decoder using high or low rate as appropriate.\nReed-Solomon encoder using high or low rate as appropriate.\nWorking space for <code>RateEncoder</code>.\nReed-Solomon encoder/decoder generator using only high …\nReed-Solomon decoder using only high rate.\nReed-Solomon encoder using only high rate.\nReed-Solomon encoder/decoder generator using only low rate.\nReed-Solomon decoder using only low rate.\nReed-Solomon encoder using only low rate.\nReed-Solomon encoder/decoder generator using specific rate.\nRate of this encoder.\nRate of this decoder.\nReed-Solomon decoder using specific rate.\nDecoder of this rate.\nReed-Solomon encoder using specific rate.\nEncoder of this rate.\nLike <code>ReedSolomonEncoder::add_original_shard</code>.\nLike <code>ReedSolomonDecoder::add_original_shard</code>.\nLike <code>ReedSolomonDecoder::add_recovery_shard</code>.\nLike <code>ReedSolomonDecoder::decode</code>.\nCreates new decoder. This is same as <code>RateDecoder::new</code>.\nLike <code>ReedSolomonEncoder::encode</code>.\nCreates new encoder. This is same as <code>RateEncoder::new</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes this encoder returning its <code>Engine</code> and <code>EncoderWork</code> …\nConsumes this decoder returning its <code>Engine</code> and <code>DecoderWork</code> …\nLike <code>ReedSolomonEncoder::new</code> with <code>Engine</code> to use and …\nLike <code>ReedSolomonDecoder::new</code> with <code>Engine</code> to use and …\nCreates new <code>DecoderWork</code> which initially has no working …\nCreates new <code>EncoderWork</code> which initially has no working …\nLike <code>ReedSolomonEncoder::reset</code>.\nLike <code>ReedSolomonDecoder::reset</code>.\nReturns <code>true</code> if given <code>original_count</code> / <code>recovery_count</code> …\nReturns <code>true</code> if given <code>original_count</code> / <code>recovery_count</code> …\nReturns <code>true</code> if given <code>original_count</code> / <code>recovery_count</code> …\nReturns <code>Ok(())</code> if given <code>original_count</code> / <code>recovery_count</code> …\nReturns <code>Ok(())</code> if given <code>original_count</code> / <code>recovery_count</code> …\nReturns <code>Ok(())</code> if given <code>original_count</code> / <code>recovery_count</code> …',
)
