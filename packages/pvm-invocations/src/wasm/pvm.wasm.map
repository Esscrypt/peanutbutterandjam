{"version":3,"sources":["~lib/rt/common.ts","~lib/rt/tlsf.ts","~lib/shared/typeinfo.ts","~lib/rt/itcms.ts","assembly/config.ts","assembly/crypto.ts","~lib/shared/runtime.ts","~lib/util/number.ts","~lib/util/math.ts","~lib/util/string.ts","~lib/rt.ts","~lib/util/error.ts","~lib/util/sort.ts","~lib/array.ts","assembly/types.ts","assembly/host-functions/accumulate/base.ts","assembly/host-functions/general/write.ts","assembly/host-functions/accumulate/solicit.ts","assembly/pbnj-types-compat.ts","assembly/wasm-wrapper.ts","assembly/test-exports.ts","assembly/index.ts","assembly/simple-ram.ts","~lib/arraybuffer.ts","~lib/typedarray.ts","~lib/util/hash.ts","~lib/map.ts","assembly/mock-ram.ts","~lib/staticarray.ts","assembly/ram.ts","assembly/host-functions/general/registry.ts","assembly/host-functions/general/base.ts","assembly/host-functions/general/gas.ts","assembly/host-functions/general/fetch.ts","assembly/host-functions/general/historical-lookup.ts","assembly/host-functions/general/lookup.ts","assembly/host-functions/general/read.ts","assembly/host-functions/general/info.ts","assembly/host-functions/general/export.ts","assembly/host-functions/general/machine.ts","assembly/host-functions/general/peek.ts","assembly/host-functions/general/poke.ts","assembly/host-functions/general/pages.ts","assembly/host-functions/general/invoke.ts","assembly/host-functions/general/expunge.ts","assembly/host-functions/general/log.ts","assembly/instructions/registry.ts","assembly/instructions/base.ts","assembly/instructions/control-flow.ts","assembly/instructions/system.ts","assembly/instructions/memory.ts","assembly/instructions/memory-indirect.ts","assembly/instructions/arithmetic.ts","assembly/instructions/bitwise.ts","assembly/instructions/comparison.ts","assembly/instructions/conditional.ts","assembly/instructions/shifts.ts","assembly/instructions/shifts-alt.ts","assembly/instructions/shifts-64.ts","assembly/instructions/shifts-alt-64.ts","assembly/instructions/rotations.ts","assembly/instructions/branching.ts","assembly/instructions/arithmetic-32.ts","assembly/instructions/shifts-32-register.ts","assembly/instructions/arithmetic-64.ts","assembly/instructions/shifts-64-register.ts","assembly/instructions/bitwise-register.ts","assembly/instructions/multiplication-upper.ts","assembly/instructions/comparison-register.ts","assembly/instructions/conditional-register.ts","assembly/instructions/rotation-register.ts","assembly/instructions/advanced-bitwise.ts","assembly/instructions/min-max.ts","assembly/instructions/register.ts","assembly/pvm.ts","assembly/host-functions/accumulate/registry.ts","assembly/host-functions/accumulate/assign.ts","assembly/host-functions/accumulate/bless.ts","assembly/host-functions/accumulate/checkpoint.ts","assembly/host-functions/accumulate/designate.ts","assembly/host-functions/accumulate/eject.ts","assembly/host-functions/accumulate/forget.ts","assembly/host-functions/accumulate/new.ts","assembly/host-functions/accumulate/provide.ts","assembly/host-functions/accumulate/query.ts","assembly/host-functions/accumulate/transfer.ts","assembly/host-functions/accumulate/upgrade.ts","assembly/host-functions/accumulate/yield.ts","assembly/codec.ts","~lib/builtins.ts","~lib/number.ts","~lib/string.ts","assembly/alignment-helpers.ts","~lib/math.ts","~lib/util/bytes.ts","~lib/dataview.ts","~lib/polyfills.ts","~lib/console.ts","~lib/function.ts"],"names":[],"mappings":"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IsB,CAC0D,EAAxB,CAAhC,CAAvB,EACsB,GAAtB,GACa,EAAkB,EAA/B,GACA,EAAU,E,CAAV,GAEF,EAAU,E,CAAV,E,MAGF,E,KAAe,E,oBACf,E,KAAmB,EAAnB,G,EACA,E,KAAe,E,oBACf,E,KAAuB,EAAvB,G,EACA,E,KAAqB,E,OAAA,GAArB,G,UAhEgB,E,OAAA,G,OACyD,E,KAAA,E,OAAA,G,QAArC,E,EAA6D,EAAhC,CAAvD,CAAR,EAEY,EAAZ,G,EAIc,E,GAAd,E,EAAA,GAES,EAAyB,EAA0B,EADxC,E,EAGlB,E,KAAA,E,OAAA,G,GAAF,G,EAEsC,E,KAAlB,G,IAAqD,KACzE,EADoB,EAA0C,E,EAAW,GAAnB,CAAuC,EAAvC,CAAlC,CAApB,EACmB,GAAnB,GACa,EAAe,EAA5B,I,8EoBuQF,E,OAAA,G,wLAAkC,E,KAAhB,E,yHE5XN,E,qDFuLZ,E,8EE1KY,E,qDF2KZ,E,8EEzJY,E,qDF0JZ,E,8EE7GY,E,qDF8GZ,E,8EElCY,G,qDFmCZ,E,8EEsBY,G,qDFrBZ,E,8EG5LY,E,qDH+LZ,E,8EI7KY,E,qDJgLZ,E,8EIlJY,E,qDJmJZ,E,8EI9GY,E,qDJ+GZ,E,8EIhFY,E,qDJiFZ,E,8EIlDY,E,qDJmDZ,E,8EIZY,E,qDJaZ,E,8EIWY,E,qDJVZ,E,8EIwCY,E,qDJvCZ,E,8EImEY,E,qDJlEZ,E,8EI8FY,E,qDJ7FZ,E,8EI0IY,E,qDJzIZ,E,8EIwKY,E,qDJvKZ,E,8EIwMY,E,qDJvMZ,E,8EI0OY,E,qDJzOZ,E,8EI2QY,E,qDJ1QZ,E,8EI6SY,E,qDJ5SZ,E,8EI+UY,E,qDJ9UZ,E,8EIiXY,G,qDJhXZ,E,8EIgaY,G,qDJ/ZZ,E,8EI+cY,G,qDJ9cZ,E,8EI4fY,G,qDJ3fZ,E,8EK9MY,G,qDLiNZ,E,8EK9JY,G,qDL+JZ,E,8EK9GY,G,qDL+GZ,E,8EK9DY,G,qDL+DZ,E,8EKZY,G,qDLaZ,E,8EKoCY,G,qDLnCZ,E,8EKyFY,G,qDLxFZ,E,8EKyIY,G,qDLxIZ,E,8EK+LY,G,qDL9LZ,E,8EK6OY,G,qDL5OZ,E,8EKmSY,G,qDLlSZ,E,8EMjOY,G,qDNoOZ,E,8EMlMY,G,qDNmMZ,E,8EMhKY,G,qDNiKZ,E,8EM9HY,G,qDN+HZ,E,8EO7PY,G,qDPgQZ,E,8EO7OY,G,qDP8OZ,E,8EO3NY,G,qDP4NZ,E,8EQ7PY,G,qDRgQZ,E,8EQlOY,G,qDRmOZ,E,8EQrMY,G,qDRsMZ,E,8EQxKY,G,qDRyKZ,E,8ESxQY,G,qDT2QZ,E,8ESjPY,G,qDTkPZ,E,8EUnQY,G,qDVsQZ,E,8EU1OY,G,qDV2OZ,E,8EU/MY,G,qDVgNZ,E,8EUhLY,G,qDViLZ,E,8EW9QY,G,qDXiRZ,E,8EWvPY,G,qDXwPZ,E,8EW9NY,G,qDX+NZ,E,8EY7QY,G,qDZgRZ,E,8EYnPY,G,qDZoPZ,E,8EYxNY,G,qDZyNZ,E,8EY7LY,G,qDZ8LZ,E,8EazRY,G,qDb4RZ,E,8EapQY,G,qDbqQZ,E,8Ea7OY,G,qDb8OZ,E,8Ec7RY,G,qDdgSZ,E,8EcxPY,G,qDdyPZ,E,8Ec/MY,G,qDdgNZ,E,8EctKY,G,qDduKZ,E,8EexQY,G,qDf2QZ,E,8EepOY,G,qDfqOZ,E,8Ee7LY,G,qDf8LZ,E,8EetJY,G,qDfuJZ,E,8Ee9GY,G,qDf+GZ,E,8EetEY,G,qDfuEZ,E,8Ee9BY,G,qDf+BZ,E,8EeUY,G,qDfTZ,E,8EekDY,G,qDfjDZ,E,8Ee0FY,G,qDfzFZ,E,8EewIY,G,qDfrIZ,E,8EemLY,G,qDflLZ,E,8Ee8NY,G,qDf7NZ,E,8EewQY,G,qDfvQZ,E,8EemTY,G,qDflTZ,E,8Ee8VY,G,qDf7VZ,E,8EgBxTY,G,qDhB2TZ,E,8EgB3RY,G,qDhB4RZ,E,8EgBlQY,G,qDhBmQZ,E,8EgBzOY,G,qDhB0OZ,E,8EgBpMY,G,qDhBqMZ,E,8EgBjJY,G,qDhBkJZ,E,8EgBxHY,G,qDhByHZ,E,8EiB7TY,G,qDjBgUZ,E,8EiBzSY,G,qDjB0SZ,E,8EiBnRY,G,qDjBoRZ,E,8EkB1UY,G,qDlB6UZ,E,8EkB3TY,G,qDlB4TZ,E,8EkB1SY,G,qDlB2SZ,E,8EkBzRY,G,qDlB0RZ,E,8EkBrQY,G,qDlBsQZ,E,8EkBrNY,G,qDlBsNZ,E,8EkBlMY,G,qDlBmMZ,E,8EmB3UY,G,qDnB8UZ,E,8EmBvTY,G,qDnBwTZ,E,8EmBjSY,G,qDnBkSZ,E,8EoBxVY,G,qDpB2VZ,E,8EoBvTY,G,qDpBwTZ,E,8EoB3RY,G,wDpB4RZ,E,8EqBzVY,G,wDrB4VZ,E,8EqB5QY,G,wDrB6QZ,E,8EqBxNY,G,wDrByNZ,E,8EsBlWY,G,wDtBqWZ,E,8EsB5UY,G,wDtB6UZ,E,8EuBtWY,G,wDvByWZ,E,8EuB5UY,G,wDvB6UZ,E,8EwBrWY,G,wDxBwWZ,E,8EwB1TY,G,wDxB2TZ,E,8EwBlRY,G,wDxBmRZ,E,8EwBrOY,G,wDxBsOZ,E,8EyBhXY,G,wDzBmXZ,E,8EyBjWY,G,wDzBkWZ,E,8EyBhVY,G,wDzBiVZ,E,8E0BhXY,G,wD1BmXZ,E,8E0B7VY,G,wD1B8VZ,E,8E0B5UY,G,wD1B6UZ,E,8E0BvTY,G,wD1BwTZ,E,8E2BhWY,G,wD3BmWZ,E,8E2B5UY,G,wD3B6UZ,E,8E2BtRY,G,wD3BuRZ,E,8E2B1PY,G,wD3B2PZ,E,8E2B9NY,G,wD3B+NZ,E,8E2B/LY,G,wD3BgMZ,E,8E2BhKY,G,wD3BiKZ,E,8E2BjIY,G,wD3BkIZ,E,8E2BlGY,G,wD3BmGZ,E,8E2BvEY,G,wD3BwEZ,E,8E2B7CY,G,wD3B8CZ,E,EACA,E,0E2B1BY,G,wD3B0BZ,E,mI/BvSA,E,KAAkB,EAAlB,G,EACA,E,KAAY,G,qE4D3EZ,E,mJCGgB,E,+CAEH,E,YAGU,G,4BDRvB,E,EACA,E,+C5DwEmD,G,iG8DrEnC,E,+CAEH,E,4BFLb,E,EACA,E,+C5DuEmD,G,iG+DpFnC,E,+CAEH,E,4BHWb,E,EACA,E,mJILgB,E,+CAEH,E,YAGO,G,4BJApB,E,EACA,E,+C5DqEmD,G,iGiErEnC,E,+CAEH,E,4BLFb,E,EACA,E,+C5DoEmD,G,iGkE9DnC,E,+CAEH,E,4BNRb,E,EACA,E,+C5DmEmD,G,iGmEhEnC,E,+CAEH,E,4BPLb,E,EACA,E,+C5DkEmD,G,iGoEpEnC,E,+CAEH,E,4BRAb,E,EACA,E,+C5DiEmD,G,iGqErEnC,E,+CAEH,E,4BTEb,E,EACA,E,+C5DgEmD,G,iGEzDnC,E,+CAEH,E,4B0DTb,E,EACA,E,+C5D+DmD,G,iGsEjEnC,E,+CAEH,E,4BVAb,E,EACA,E,+C5D8DmD,G,iGuEzEnC,E,+CAEH,E,4BXSb,E,EACA,E,+C5D6DmD,G,iGwE5EnC,E,+DZehB,E,wKD+G6C,E,oBAC/B,E,YACwB,E,oBACU,E,oBACF,E,oBAER,E,oBACG,E,oBACa,E,oBACvB,E,YACqB,E,oBACpB,E,YAGZ,G,YACa,I,YACR,G,YACF,M,YACC,M,YACU,E,YACH,E,YACP,E,YACE,E,YACD,G,YACQ,E,YACN,G,YACG,I,YACP,G,aAGH,E,aACA,E,aACA,E,MAUpB,E,uGhDvI6C,EAAhB,G,iCACJ,E,UAGoB,EAAhB,G,iCACA,E,YACF,E,YACD,E,kCoBuI1B,E,KAAA,E,sC4BJ4B,E,6HhD1IiB,EAAhB,G,iCACJ,E,UAGoB,GAAhB,G,iCACA,E,YACF,E,YACD,E,kCiDzC1B,E,KAAA,E,sCDkL0B,E,KAAe,E,uDAtH1B,E,YACK,E,wDAGJ,E,oBACC,G,+BACe,EAAf,E,+BACkB,EAAf,E,iCACF,E,YACI,E,YACN,E,KAUhB,E,KAAqB,E,2BACV,E,2BACW,EAAtB,G,EACA,E,KAAkB,EAAlB,G,oIvDpBmB,E,YACN,E,KAGS,G,OACD,EAAI,EAAJ,C,WACL,ESGoC,EAAhB,CAA3B,CTHY,ESGrB,GTJ6B,E,GAAA,E,MAIT,E,CAAA,EAAY,EAAN,G,6GOtCmB,EAAhB,G,iCACJ,E,UAGoB,GAAhB,G,iCACA,E,YACF,E,YACD,E,kCIvC1B,E,KAAA,E,gDXwEW,E,0FuDokCX,E,OAAA,G,OAAwB,EAAxB,G,EAGA,E,OAAA,G,OAA4B,EAA5B,G,EAGgB,EAAI,EAAJ,C,IACd,E,OAAA,G,SAAA,G,OAAyB,E9C7kCyB,EAAhB,CAA3B,C8C6kCuB,E9C7kChC,G8C4kCwB,E,GAAA,E,MAKxB,E,OAAA,G,SAAA,G,KAAA,U,4C7CxiBA,E,OAAA,G,OAAA,G,EAGA,E,OAAA,G,OAAA,G,EAGA,E,KAAoB,EAApB,G,EACA,E,KAAwB,EAAxB,G,EACA,E,KAAsB,EAAtB,G,EACA,E,KAAwB,EAAxB,G,EACA,E,KAA0B,EAA1B,G,EACA,E,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","sourceRoot":"./pvm","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n//  Memory manager block layout (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// \n//                            MM info                              -4\n// >ptr\n//                               ...                              \n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n//  Garbage collector object layout (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// \n//                      Memory manager block                       -20\n// \n//                             GC info                             -16\n// \n//                             GC info                             -12\n// \n//                             RT id                               -8\n// \n//                             RT size                             -4\n// >ptr\n//                               ...                              \n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","import { AL_BITS, AL_SIZE, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"./common\";\nimport { oninit, onalloc, onresize, onmove, onfree } from \"./rtrace\";\nimport { E_ALLOCATION_TOO_LARGE } from \"../util/error\";\n\n// === The TLSF (Two-Level Segregate Fit) memory allocator ===\n// see: http://www.gii.upv.es/tlsf/\n\n// - `ffs(x)` is equivalent to `ctz(x)` with x != 0\n// - `fls(x)` is equivalent to `sizeof(x) * 8 - clz(x) - 1`\n\n//  Block size interpretation (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// \n//  |                    FL                        SB = SL + AL    usize\n// \n// FL: first level, SL: second level, AL: alignment, SB: small block\n\n// @ts-ignore: decorator\n@inline const SL_BITS: u32 = 4;\n// @ts-ignore: decorator\n@inline const SL_SIZE: u32 = 1 << SL_BITS;\n\n// @ts-ignore: decorator\n@inline const SB_BITS: u32 = SL_BITS + AL_BITS;\n// @ts-ignore: decorator\n@inline const SB_SIZE: u32 = 1 << SB_BITS;\n\n// @ts-ignore: decorator\n@inline const FL_BITS: u32 = 31 - SB_BITS;\n\n// [00]: < 256B (SB)  [12]: < 1M\n// [01]: < 512B       [13]: < 2M\n// [02]: < 1K         [14]: < 4M\n// [03]: < 2K         [15]: < 8M\n// [04]: < 4K         [16]: < 16M\n// [05]: < 8K         [17]: < 32M\n// [06]: < 16K        [18]: < 64M\n// [07]: < 32K        [19]: < 128M\n// [08]: < 64K        [20]: < 256M\n// [09]: < 128K       [21]: < 512M\n// [10]: < 256K       [22]: <= 1G - OVERHEAD\n// [11]: < 512K\n// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead\n\n// Tags stored in otherwise unused alignment bits\n\n// @ts-ignore: decorator\n@inline const FREE: usize = 1 << 0;\n// @ts-ignore: decorator\n@inline const LEFTFREE: usize = 1 << 1;\n// @ts-ignore: decorator\n@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK\n\n//  Block layout (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n//             \n//                           size                             LF  info   overhead\n// >ptr           \n//                         if free:  prev                          usize\n//    \n//                         if free: next                          \n//    \n//                              ...                                   >= 0\n//    \n//                         if free: back                          \n//  >= MIN SIZE\n// F: FREE, L: LEFTFREE\n@unmanaged export class Block extends BLOCK {\n\n  /** Previous free block, if any. Only valid if free, otherwise part of payload. */\n  prev: Block | null;\n  /** Next free block, if any. Only valid if free, otherwise part of payload. */\n  next: Block | null;\n\n  // If the block is free, there is a 'back'reference at its end pointing at its start.\n}\n\n// Block constants. A block must have a minimum size of three pointers so it can hold `prev`,\n// `next` and `back` if free.\n\n// @ts-ignore: decorator\n@inline const BLOCK_MINSIZE: usize = ((3 * sizeof<usize>() + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD; // prev + next + back\n// @ts-ignore: decorator\n// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts\n\n/** Gets the left block of a block. Only valid if the left block is free. */\n// @ts-ignore: decorator\n@inline function GETFREELEFT(block: Block): Block {\n  return load<Block>(changetype<usize>(block) - sizeof<usize>());\n}\n\n/** Gets the right block of a block by advancing to the right by its size. */\n// @ts-ignore: decorator\n@inline function GETRIGHT(block: Block): Block {\n  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));\n}\n\n//  Root layout (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n//           \n//         0        |           flMap                            S \n//       \n//                            slMap[0] S                             \n//      \n//                            slMap[1]                               \n//   u32 \n//                            slMap[22]                              \n//     usize\n//                             head[0]                             \n//       \n//                               ...                               \n//       \n//                            head[367]                            \n//       \n//                              tail                               \n//    SIZE   \n// S: Small blocks map\n@unmanaged class Root {\n  /** First level bitmap. */\n  flMap: usize;\n}\n\n// Root constants. Where stuff is stored inside of the root structure.\n\n// @ts-ignore: decorator\n@inline const SL_START: usize = sizeof<usize>();\n// @ts-ignore: decorator\n@inline const SL_END: usize = SL_START + (FL_BITS << alignof<u32>());\n// @ts-ignore: decorator\n@inline const HL_START: usize = (SL_END + AL_MASK) & ~AL_MASK;\n// @ts-ignore: decorator\n@inline const HL_END: usize = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();\n// @ts-ignore: decorator\n@inline const ROOT_SIZE: usize = HL_END + sizeof<usize>();\n\n// @ts-ignore: decorator\n@lazy export let ROOT: Root = changetype<Root>(0); // unsafe initializion below\n\n/** Gets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function GETSL(root: Root, fl: usize): u32 {\n  return load<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    SL_START\n  );\n}\n\n/** Sets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function SETSL(root: Root, fl: usize, slMap: u32): void {\n  store<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    slMap,\n    SL_START\n  );\n}\n\n/** Gets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {\n  return load<Block>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    HL_START\n  );\n}\n\n/** Sets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {\n  store<Block | null>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    head,\n    HL_START\n  );\n}\n\n/** Gets the tail block.. */\n// @ts-ignore: decorator\n@inline function GETTAIL(root: Root): Block {\n  return load<Block>(\n    changetype<usize>(root),\n    HL_END\n  );\n}\n\n/** Sets the tail block. */\n// @ts-ignore: decorator\n@inline function SETTAIL(root: Root, tail: Block): void {\n  store<Block>(\n    changetype<usize>(root),\n    tail,\n    HL_END\n  );\n}\n\n/** Inserts a previously used block back into the free list. */\nfunction insertBlock(root: Root, block: Block): void {\n  if (DEBUG) assert(block); // cannot be null\n  let blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n\n  let right = GETRIGHT(block);\n  let rightInfo = right.mmInfo;\n\n  // merge with right block if also free\n  if (rightInfo & FREE) {\n    removeBlock(root, right);\n    block.mmInfo = blockInfo = blockInfo + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK); // keep block tags\n    right = GETRIGHT(block);\n    rightInfo = right.mmInfo;\n    // 'back' is set below\n  }\n\n  // merge with left block if also free\n  if (blockInfo & LEFTFREE) {\n    let left = GETFREELEFT(block);\n    let leftInfo = left.mmInfo;\n    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags\n    removeBlock(root, left);\n    block = left;\n    block.mmInfo = blockInfo = leftInfo + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK); // keep left tags\n    // 'back' is set below\n  }\n\n  right.mmInfo = rightInfo | LEFTFREE;\n  // reference to right is no longer used now, hence rightInfo is not synced\n\n  // we now know the size of the block\n  let size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be a valid size\n  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match\n\n  // set 'back' to itself at the end of block\n  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);\n\n  // mapping_insert\n  let fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // perform insertion\n  let head = GETHEAD(root, fl, sl);\n  block.prev = null;\n  block.next = head;\n  if (head) head.prev = block;\n  SETHEAD(root, fl, sl, block);\n\n  // update first and second level maps\n  root.flMap |= (1 << fl);\n  SETSL(root, fl, GETSL(root, fl) | (1 << sl));\n}\n\n/** Removes a free block from internal lists. */\nfunction removeBlock(root: Root, block: Block): void {\n  let blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n  let size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be valid\n\n  // mapping_insert\n  let fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // link previous and next free block\n  let prev = block.prev;\n  let next = block.next;\n  if (prev) prev.next = next;\n  if (next) next.prev = prev;\n\n  // update head if we are removing it\n  if (block == GETHEAD(root, fl, sl)) {\n    SETHEAD(root, fl, sl, next);\n\n    // clear second level map if head is empty now\n    if (!next) {\n      let slMap = GETSL(root, fl);\n      SETSL(root, fl, slMap &= ~(1 << sl));\n\n      // clear first level map if second level is empty now\n      if (!slMap) root.flMap &= ~(1 << fl);\n    }\n  }\n  // note: does not alter left/back because it is likely that splitting\n  // is performed afterwards, invalidating those changes. so, the caller\n  // must perform those updates.\n}\n\nfunction roundSize(size: usize): usize {\n  const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl\n  const inv: usize = sizeof<usize>() * 8 - 1;\n  const invRound = inv - SL_BITS;\n  return size < halfMaxSize\n    ? size + (1 << (invRound - clz<usize>(size))) - 1\n    : size;\n}\n\n/** Searches for a free block of at least the specified size. */\nfunction searchBlock(root: Root, size: usize): Block | null {\n  // size was already asserted by caller\n\n  // mapping_search\n  let fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const requestSize = roundSize(size);\n    fl = sizeof<usize>() * 8 - 1 - clz<usize>(requestSize);\n    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // search second level\n  let slMap = GETSL(root, fl) & (~0 << sl);\n  let head: Block | null = null;\n  if (!slMap) {\n    // search next larger first level\n    let flMap = root.flMap & (~0 << (fl + 1));\n    if (!flMap) {\n      head = null;\n    } else {\n      fl = ctz<usize>(flMap);\n      slMap = GETSL(root, fl);\n      if (DEBUG) assert(slMap);  // can't be zero if fl points here\n      head = GETHEAD(root, fl, ctz<u32>(slMap));\n    }\n  } else {\n    head = GETHEAD(root, fl, ctz<u32>(slMap));\n  }\n  return head;\n}\n\n/** Prepares the specified block before (re-)use, possibly splitting it. */\nfunction prepareBlock(root: Root, block: Block, size: usize): void {\n  // size was already asserted by caller\n\n  let blockInfo = block.mmInfo;\n  if (DEBUG) assert(!((size + BLOCK_OVERHEAD) & AL_MASK)); // size must be aligned so the new block is\n\n  // split if the block can hold another MINSIZE block incl. overhead\n  let remaining = (blockInfo & ~TAGS_MASK) - size;\n  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {\n    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE\n\n    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);\n    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE\n    insertBlock(root, spare); // also sets 'back'\n\n  // otherwise tag block as no longer FREE and right as no longer LEFTFREE\n  } else {\n    block.mmInfo = blockInfo & ~FREE;\n    GETRIGHT(block).mmInfo &= ~LEFTFREE;\n  }\n}\n\n/** Adds more memory to the pool. */\nfunction addMemory(root: Root, start: usize, endU64: u64): bool {\n  let end = <usize>endU64;\n  if (DEBUG) assert(<u64>start <= endU64); // must be valid\n  start = ((start + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n  end &= ~AL_MASK;\n\n  let tail = GETTAIL(root);\n  let tailInfo: usize = 0;\n  if (tail) { // more memory\n    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);\n\n    // merge with current tail if adjacent\n    const offsetToTail = AL_SIZE;\n    if (start - offsetToTail == changetype<usize>(tail)) {\n      start -= offsetToTail;\n      tailInfo = tail.mmInfo;\n    } else {\n      // We don't do this, but a user might `memory.grow` manually\n      // leading to non-adjacent pages managed by TLSF.\n    }\n\n  } else if (DEBUG) { // first memory\n    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root\n  }\n\n  // check if size is large enough for a free block and the tail block\n  let size = end - start;\n  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {\n    return false;\n  }\n\n  // left size is total minus its own and the zero-length tail's header\n  let leftSize = size - 2 * BLOCK_OVERHEAD;\n  let left = changetype<Block>(start);\n  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);\n  left.prev = null;\n  left.next = null;\n\n  // tail is a zero-length used block\n  tail = changetype<Block>(start + BLOCK_OVERHEAD + leftSize);\n  tail.mmInfo = 0 | LEFTFREE;\n  SETTAIL(root, tail);\n\n  insertBlock(root, left); // also merges with free left before tail / sets 'back'\n\n  return true;\n}\n\n/** Grows memory to fit at least another block of the specified size. */\nfunction growMemory(root: Root, size: usize): void {\n  if (ASC_LOW_MEMORY_LIMIT) {\n    unreachable();\n    return;\n  }\n  // Here, both rounding performed in searchBlock ...\n  if (size >= SB_SIZE) {\n    size = roundSize(size);\n  }\n  // and additional BLOCK_OVERHEAD must be taken into account. If we are going\n  // to merge with the tail block, that's one time, otherwise it's two times.\n  let pagesBefore = memory.size();\n  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));\n  let pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\n  let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n  if (memory.grow(pagesWanted) < 0) {\n    if (memory.grow(pagesNeeded) < 0) unreachable();\n  }\n  let pagesAfter = memory.size();\n  addMemory(root, <usize>pagesBefore << 16, <u64>pagesAfter << 16);\n}\n\n/** Computes the size (excl. header) of a block. */\nfunction computeSize(size: usize): usize {\n  // Size must be large enough and aligned minus preceeding overhead\n  return size <= BLOCK_MINSIZE\n    ? BLOCK_MINSIZE\n    : ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n}\n\n/** Prepares and checks an allocation size. */\nfunction prepareSize(size: usize): usize {\n  if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  return computeSize(size);\n}\n\n/** Initializes the root structure. */\nfunction initialize(): void {\n  if (isDefined(ASC_RTRACE)) oninit(__heap_base);\n  let rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;\n  let pagesBefore = memory.size();\n  let pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);\n  if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\n  let root = changetype<Root>(rootOffset);\n  root.flMap = 0;\n  SETTAIL(root, changetype<Block>(0));\n  for (let fl: usize = 0; fl < FL_BITS; ++fl) {\n    SETSL(root, fl, 0);\n    for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\n      SETHEAD(root, fl, sl, null);\n    }\n  }\n  let memStart = rootOffset + ROOT_SIZE;\n  if (ASC_LOW_MEMORY_LIMIT) {\n    const memEnd = <u64>ASC_LOW_MEMORY_LIMIT & ~AL_MASK;\n    if (memStart <= memEnd) addMemory(root, memStart, memEnd);\n    else unreachable(); // low memory limit already exceeded\n  } else {\n    addMemory(root, memStart, <u64>memory.size() << 16);\n  }\n  ROOT = root;\n}\n\n/** Allocates a block of the specified size. */\nexport function allocateBlock(root: Root, size: usize): Block {\n  let payloadSize = prepareSize(size);\n  let block = searchBlock(root, payloadSize);\n  if (!block) {\n    growMemory(root, payloadSize);\n    block = changetype<Block>(searchBlock(root, payloadSize));\n    if (DEBUG) assert(block); // must be found now\n  }\n  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit\n  removeBlock(root, block);\n  prepareBlock(root, block, payloadSize);\n  if (isDefined(ASC_RTRACE)) onalloc(block);\n  return block;\n}\n\n/** Reallocates a block to the specified size. */\nexport function reallocateBlock(root: Root, block: Block, size: usize): Block {\n  let payloadSize = prepareSize(size);\n  let blockInfo = block.mmInfo;\n  let blockSize = blockInfo & ~TAGS_MASK;\n\n  // possibly split and update runtime size if it still fits\n  if (payloadSize <= blockSize) {\n    prepareBlock(root, block, payloadSize);\n    if (isDefined(ASC_RTRACE)) {\n      if (payloadSize != blockSize) onresize(block, BLOCK_OVERHEAD + blockSize);\n    }\n    return block;\n  }\n\n  // merge with right free block if merger is large enough\n  let right = GETRIGHT(block);\n  let rightInfo = right.mmInfo;\n  if (rightInfo & FREE) {\n    let mergeSize = blockSize + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\n    if (mergeSize >= payloadSize) {\n      removeBlock(root, right);\n      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;\n      prepareBlock(root, block, payloadSize);\n      if (isDefined(ASC_RTRACE)) onresize(block, BLOCK_OVERHEAD + blockSize);\n      return block;\n    }\n  }\n\n  // otherwise move the block\n  return moveBlock(root, block, size);\n}\n\n/** Moves a block to a new one of the specified size. */\nfunction moveBlock(root: Root, block: Block, newSize: usize): Block {\n  let newBlock = allocateBlock(root, newSize);\n  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, block.mmInfo & ~TAGS_MASK);\n  if (changetype<usize>(block) >= __heap_base) {\n    if (isDefined(ASC_RTRACE)) onmove(block, newBlock);\n    freeBlock(root, block);\n  }\n  return newBlock;\n}\n\n/** Frees a block. */\nexport function freeBlock(root: Root, block: Block): void {\n  if (isDefined(ASC_RTRACE)) onfree(block);\n  block.mmInfo = block.mmInfo | FREE;\n  insertBlock(root, block);\n}\n\n/** Checks that a used block is valid to be freed or reallocated. */\nfunction checkUsedBlock(ptr: usize): Block {\n  let block = changetype<Block>(ptr - BLOCK_OVERHEAD);\n  assert(\n    ptr != 0 && !(ptr & AL_MASK) &&  // must exist and be aligned\n    !(block.mmInfo & FREE)           // must be used\n  );\n  return block;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __alloc(size: usize): usize {\n  if (!ROOT) initialize();\n  return changetype<usize>(allocateBlock(ROOT, size)) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __realloc(ptr: usize, size: usize): usize {\n  if (!ROOT) initialize();\n  return (ptr < __heap_base\n    ? changetype<usize>(moveBlock(ROOT, checkUsedBlock(ptr), size))\n    : changetype<usize>(reallocateBlock(ROOT, checkUsedBlock(ptr), size))\n  ) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __free(ptr: usize): void {\n  if (ptr < __heap_base) return;\n  if (!ROOT) initialize();\n  freeBlock(ROOT, checkUsedBlock(ptr));\n}\n","// This file is shared with the compiler and must remain portable\n\n//  Typeinfo interpretation \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n//   __rtti_base\n//                              count                             \n//  \n//                       Typeinfo#flags [id=0]                     id < count\n// \n//                               ...                              \n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type has no outgoing pointers. */\n  POINTERFREE = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","import { BLOCK, BLOCK_OVERHEAD, OBJECT_OVERHEAD, OBJECT_MAXSIZE, TOTAL_OVERHEAD, DEBUG, TRACE, RTRACE, PROFILE } from \"./common\";\nimport { onvisit, oncollect, oninterrupt, onyield } from \"./rtrace\";\nimport { TypeinfoFlags } from \"../shared/typeinfo\";\nimport { E_ALLOCATION_TOO_LARGE, E_ALREADY_PINNED, E_NOT_PINNED } from \"../util/error\";\n\n// === ITCMS: An incremental Tri-Color Mark & Sweep garbage collector ===\n// Adapted from Bach Le's gc, see: https://github.com/bullno1/ugc\n\n//  Colors \n//  Color        Meaning                                         \n// \n//  WHITE*       Unprocessed                                     \n//  BLACK*       Processed                                       \n//  GRAY         Processed with unprocessed children             \n//  TRANSPARENT  Manually pinned (always reachable)              \n// \n// * flipped between cycles\n\n// @ts-ignore: decorator\n@lazy let white = 0;\n// @ts-ignore: decorator\n@inline const gray = 2;\n// @ts-ignore: decorator\n@inline const transparent = 3;\n// @ts-ignore: decorator\n@inline const COLOR_MASK = 3;\n\n/** Size in memory of all objects currently managed by the GC. */\n// @ts-ignore: decorator\n@lazy let total: usize = 0;\n\n/** Currently transitioning from SWEEP to MARK state. */\n// @ts-ignore: decorator\n@inline const STATE_IDLE = 0;\n/** Currently marking reachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_MARK = 1;\n/** Currently sweeping unreachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_SWEEP = 2;\n/** Current collector state. */\n// @ts-ignore: decorator\n@lazy let state = STATE_IDLE;\n\n// @ts-ignore: decorator\n@lazy let fromSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy let toSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy let pinSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy let iter: Object = changetype<Object>(0); // unsafe initializion below\n\nfunction initLazy(space: Object): Object {\n  space.nextWithColor = changetype<usize>(space);\n  space.prev = space;\n  return space;\n}\n\n/** Visit cookie indicating scanning of an object. */\n// @ts-ignore: decorator\n@inline const VISIT_SCAN = 0;\n\n//  Managed object layout (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// \n//                       Memory manager block                     \n// \n//                               next                          C  = nextWithColor\n// \n//                               prev                             \n// \n//                               rtId                             \n// \n//                               rtSize                           \n// >ptr\n//                                ...                             \n// C: color\n\n/** Represents a managed object in memory, consisting of a header followed by the object's data. */\n@unmanaged class Object extends BLOCK {\n  /** Pointer to the next object with color flags stored in the alignment bits. */\n  nextWithColor: usize; // *u32\n  /** Pointer to the previous object. */\n  prev: Object; // *u32\n  /** Runtime id. */\n  rtId: u32;\n  /** Runtime size. */\n  rtSize: u32;\n\n  /** Gets the pointer to the next object. */\n  get next(): Object {\n    return changetype<Object>(this.nextWithColor & ~COLOR_MASK);\n  }\n\n  /** Sets the pointer to the next object. */\n  set next(obj: Object) {\n    this.nextWithColor = changetype<usize>(obj) | (this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Gets this object's color. */\n  get color(): i32 {\n    return i32(this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Sets this object's color. */\n  set color(color: i32) {\n    this.nextWithColor = (this.nextWithColor & ~COLOR_MASK) | color;\n  }\n\n  /** Gets the size of this object in memory. */\n  get size(): usize {\n    return BLOCK_OVERHEAD + (this.mmInfo & ~3);\n  }\n\n  /** Tests if this object is pointerfree. */\n  get isPointerfree(): bool {\n    let rtId = this.rtId;\n    // 0: Object, 1: ArrayBuffer, 2: String\n    return rtId <= idof<string>() || (__typeinfo(rtId) & TypeinfoFlags.POINTERFREE) != 0;\n  }\n\n  /** Unlinks this object from its list. */\n  unlink(): void {\n    let next = this.next;\n    if (next == null) {\n      if (DEBUG) assert(this.prev == null && changetype<usize>(this) < __heap_base);\n      return; // static data not yet linked\n    }\n    let prev = this.prev;\n    if (DEBUG) assert(prev);\n    next.prev = prev;\n    prev.next = next;\n  }\n\n  /** Links this object to the specified list, with the given color. */\n  linkTo(list: Object, withColor: i32): void {\n    let prev = list.prev;\n    this.nextWithColor = changetype<usize>(list) | withColor;\n    this.prev = prev;\n    prev.next = this;\n    list.prev = this;\n  }\n\n  /** Marks this object as gray, that is reachable with unscanned children. */\n  makeGray(): void {\n    if (this == iter) iter = assert(this.prev);\n    this.unlink();\n    this.linkTo(toSpace, this.isPointerfree ? i32(!white) : gray);\n  }\n}\n\n/** Visits all objects considered to be program roots. */\nfunction visitRoots(cookie: u32): void {\n  __visit_globals(cookie);\n  let pn = pinSpace;\n  let iter = pn.next;\n  while (iter != pn) {\n    if (DEBUG) assert(iter.color == transparent);\n    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, cookie);\n    iter = iter.next;\n  }\n}\n\n/** Visits all objects on the stack. */\nfunction visitStack(cookie: u32): void {\n  let ptr = __stack_pointer;\n  while (ptr < __heap_base) {\n    __visit(load<usize>(ptr), cookie);\n    ptr += sizeof<usize>();\n  }\n}\n\n/** Performs a single step according to the current state. */\nfunction step(): usize {\n  // Magic constants responsible for pause times. Obtained experimentally\n  // using the compiler compiling itself. 2048 budget pro run by default.\n  const MARKCOST = isDefined(ASC_GC_MARKCOST) ? ASC_GC_MARKCOST : 1;\n  const SWEEPCOST = isDefined(ASC_GC_SWEEPCOST) ? ASC_GC_SWEEPCOST : 10;\n  let obj: Object;\n  switch (state) {\n    case STATE_IDLE: {\n      state = STATE_MARK;\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      iter = toSpace;\n      return visitCount * MARKCOST;\n    }\n    case STATE_MARK: {\n      let black = i32(!white);\n      obj = iter.next;\n      while (obj != toSpace) {\n        iter = obj;\n        if (obj.color != black) { // skip already-blacks (pointerfree)\n          obj.color = black;\n          visitCount = 0;\n          __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          return visitCount * MARKCOST;\n        }\n        obj = obj.next;\n      }\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      obj = iter.next;\n      if (obj == toSpace) {\n        visitStack(VISIT_SCAN);\n        obj = iter.next;\n        while (obj != toSpace) {\n          if (obj.color != black) {\n            obj.color = black;\n            __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          }\n          obj = obj.next;\n        }\n        let from = fromSpace;\n        fromSpace = toSpace;\n        toSpace = from;\n        white = black;\n        iter = from.next;\n        state = STATE_SWEEP;\n      }\n      return visitCount * MARKCOST;\n    }\n    case STATE_SWEEP: {\n      obj = iter;\n      if (obj != toSpace) {\n        iter = obj.next;\n        if (DEBUG) assert(obj.color == i32(!white)); // old white\n        free(obj);\n        return SWEEPCOST;\n      }\n      toSpace.nextWithColor = changetype<usize>(toSpace);\n      toSpace.prev = toSpace;\n      state = STATE_IDLE;\n      break;\n    }\n  }\n  return 0;\n}\n\n/** Frees an object. */\nfunction free(obj: Object): void {\n  if (changetype<usize>(obj) < __heap_base) {\n    obj.nextWithColor = 0; // may become linked again\n    obj.prev = changetype<Object>(0);\n  } else {\n    total -= obj.size;\n    if (isDefined(__finalize)) {\n      __finalize(changetype<usize>(obj) + TOTAL_OVERHEAD);\n    }\n    __free(changetype<usize>(obj) + BLOCK_OVERHEAD);\n  }\n}\n\n// Garbage collector interface\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __new(size: usize, id: i32): usize {\n  if (size >= OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  if (total >= threshold) interrupt();\n  let obj = changetype<Object>(__alloc(OBJECT_OVERHEAD + size) - BLOCK_OVERHEAD);\n  obj.rtId = id;\n  obj.rtSize = <u32>size;\n  obj.linkTo(fromSpace, white); // inits next/prev\n  total += obj.size;\n  let ptr = changetype<usize>(obj) + TOTAL_OVERHEAD;\n  // may be visited before being fully initialized, so must fill\n  memory.fill(ptr, 0, size);\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __renew(oldPtr: usize, size: usize): usize {\n  let oldObj = changetype<Object>(oldPtr - TOTAL_OVERHEAD);\n  // Update object size if its block is large enough\n  if (size <= (oldObj.mmInfo & ~3) - OBJECT_OVERHEAD) {\n    oldObj.rtSize = <u32>size;\n    return oldPtr;\n  }\n  // If not the same object anymore, we have to move it move it due to the\n  // shadow stack potentially still referencing the old object\n  let newPtr = __new(size, oldObj.rtId);\n  memory.copy(newPtr, oldPtr, min(size, oldObj.rtSize));\n  return newPtr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\n  // Write barrier is unnecessary if non-incremental\n  if (!childPtr) return;\n  if (DEBUG) assert(parentPtr);\n  let child = changetype<Object>(childPtr - TOTAL_OVERHEAD);\n  if (child.color == white) {\n    let parent = changetype<Object>(parentPtr - TOTAL_OVERHEAD);\n    let parentColor = parent.color;\n    if (parentColor == i32(!white)) {\n      // Maintain the invariant that no black object may point to a white object.\n      if (expectMultiple) {\n        // Move the barrier \"backward\". Suitable for containers receiving multiple stores.\n        // Avoids a barrier for subsequent objects stored into the same container.\n        parent.makeGray();\n      } else {\n        // Move the barrier \"forward\". Suitable for objects receiving isolated stores.\n        child.makeGray();\n      }\n    } else if (parentColor == transparent && state == STATE_MARK) {\n      // Pinned objects are considered 'black' during the mark phase.\n      child.makeGray();\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@lazy let visitCount = 0;\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __visit(ptr: usize, cookie: i32): void {\n  if (!ptr) return;\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (RTRACE) if (!onvisit(obj)) return;\n  if (obj.color == white) {\n    obj.makeGray();\n    ++visitCount;\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __pin(ptr: usize): usize {\n  if (ptr) {\n    let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n    if (obj.color == transparent) {\n      throw new Error(E_ALREADY_PINNED);\n    }\n    obj.unlink(); // from fromSpace\n    obj.linkTo(pinSpace, transparent);\n  }\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __unpin(ptr: usize): void {\n  if (!ptr) return;\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (obj.color != transparent) {\n    throw new Error(E_NOT_PINNED);\n  }\n  if (state == STATE_MARK) {\n    // We may be right at the point after marking roots for the second time and\n    // entering the sweep phase, in which case the object would be missed if it\n    // is not only pinned but also a root. Make sure it isn't missed.\n    obj.makeGray();\n  } else {\n    obj.unlink();\n    obj.linkTo(fromSpace, white);\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n  if (TRACE) trace(\"GC (full) at\", 1, total);\n  if (state > STATE_IDLE) {\n    // finish current cycle\n    while (state != STATE_IDLE) step();\n  }\n  // perform a full cycle\n  step();\n  while (state != STATE_IDLE) step();\n  threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n  if (TRACE) trace(\"GC (full) done at cur/max\", 2, total, memory.size() << 16);\n  if (RTRACE || PROFILE) oncollect(total);\n}\n\n// Garbage collector automation\n\n/** How often to interrupt. The default of 1024 means \"interrupt each 1024 bytes allocated\". */\n// @ts-ignore: decorator\n@inline const GRANULARITY: usize = isDefined(ASC_GC_GRANULARITY) ? ASC_GC_GRANULARITY : 1024;\n/** How long to interrupt. The default of 200% means \"run at double the speed of allocations\". */\n// @ts-ignore: decorator\n@inline const STEPFACTOR: usize = isDefined(ASC_GC_SWEEPFACTOR) ? ASC_GC_SWEEPFACTOR : 200;\n/** How long to idle. The default of 200% means \"wait for memory to double before kicking in again\". */\n// @ts-ignore: decorator\n@inline const IDLEFACTOR: usize = isDefined(ASC_GC_IDLEFACTOR) ? ASC_GC_IDLEFACTOR : 200;\n\n/** Threshold of memory used by objects to exceed before interrupting again. */\n// @ts-ignore: decorator\n@lazy let threshold: usize = ((<usize>memory.size() << 16) - __heap_base) >> 1;\n\n/** Performs a reasonable amount of incremental GC steps. */\nfunction interrupt(): void {\n  if (PROFILE) oninterrupt(total);\n  if (TRACE) trace(\"GC (auto) at\", 1, total);\n  let budget: isize = GRANULARITY * STEPFACTOR / 100;\n  do {\n    budget -= step();\n    if (state == STATE_IDLE) {\n      if (TRACE) trace(\" GC (auto) done at cur/max\", 2, total, memory.size() << 16);\n      threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n      if (PROFILE) onyield(total);\n      return;\n    }\n  } while (budget > 0);\n  if (TRACE) trace(\" GC (auto) ongoing at\", 1, total);\n  threshold = total + GRANULARITY * usize(total - threshold < GRANULARITY);\n  if (PROFILE) onyield(total);\n}\n","/**\n * PVM Configuration Constants (AssemblyScript)\n *\n * Centralized configuration for the PVM runtime, following Gray Paper specifications\n * Based on Appendix A instruction tables from the Gray Paper\n */\n\n// ============================================================================\n// Gas Configuration\n// ============================================================================\nexport const DEFAULT_GAS_LIMIT: u32 = u32(4_294_967_296) // 2^32\nexport const MIN_GAS_COST: u32 = 1\nexport const MAX_GAS_COST: u32 = 1_000_000\n\n// ============================================================================\n// Memory Configuration\n// ============================================================================\nexport const RESERVED_MEMORY_END: u32 = 65_536 // 64KB (2^16)\nexport const MAX_MEMORY_ADDRESS: u32 = 2_147_483_647 // 2^31 - 1\nexport const INITIAL_ZONE_SIZE: u32 = 65_536 // 64KB (2^16) - Gray Paper Cpvminitzonesize\nexport const PAGE_SIZE: u32 = 4096 // 4KB (2^12) - Gray Paper Cpvmpagesize\nexport const DYNAMIC_ADDRESS_ALIGNMENT: u32 = 2 // Gray Paper Cpvmdynaddralign\n\n// ============================================================================\n// Program Initialization Configuration\n// ============================================================================\nexport const ZONE_SIZE: u32 = 65_536 // 64KB (2^16) - Gray Paper Cpvminitzonesize\nexport const INIT_INPUT_SIZE: u32 = 16_777_216 // 16MB (2^24) - Gray Paper Cpvminitinputsize\n\n// ============================================================================\n// Register Initialization Constants (Gray Paper equation 803-811)\n// Reference: https://graypaper.fluffylabs.dev/#/579bd12/2c7c012cb101\n// ============================================================================\n\n// r0: HALT address - jumping to this address causes the PVM to halt\n// Gray Paper: 2^32 - 2^16 = 0xffff0000\nexport const HALT_ADDRESS: u32 = 4294901760 // 2 ** 32 - 2 ** 16 = 0xffff0000\n\n// r1: Stack segment end address (exclusive)\n// Gray Paper: 2^32 - 2*Cpvminitzonesize - Cpvminitinputsize\n// This is the end address of the stack region (STACK_SEGMENT)\nexport const STACK_SEGMENT_END: u32 = 4_278_059_008 // 0xFEFE0000\n\n// r7: Arguments segment start address\n// Gray Paper: 2^32 - Cpvminitzonesize - Cpvminitinputsize\n// This is the start address of the arguments/output region (ARGS_SEGMENT)\nexport const ARGS_SEGMENT_START: u32 = 4_278_124_544 // 0xfeff0000\n\n// ============================================================================\n// Result Codes (Gray Paper)\n// ============================================================================\nexport const RESULT_CODE_HALT: u8 = 0 // The invocation completed and halted normally\nexport const RESULT_CODE_PANIC: u8 = 1 // The invocation completed with a panic\nexport const RESULT_CODE_FAULT: i32 = 2 // The invocation completed with a page fault\nexport const RESULT_CODE_HOST: u8 = 3 // The invocation completed with a host-call fault\nexport const RESULT_CODE_OOG: u8 = 4 // The invocation completed by running out of gas\n\n// ============================================================================\n// Opcodes (Gray Paper Appendix A)\n// ============================================================================\n\n// Instructions without Arguments\nexport const OPCODE_TRAP: u8 = 0 // Panic\nexport const OPCODE_FALLTHROUGH: u8 = 1 // No operation\n\n// Instructions with Arguments of One Immediate\nexport const OPCODE_ECALLI: u8 = 10 // Host call with immediate value\n\n// Instructions with Arguments of One Register and One Extended Width Immediate\nexport const OPCODE_LOAD_IMM_64: u8 = 20 // Load 64-bit immediate into register\n\n// Instructions with Arguments of Two Immediates\nexport const OPCODE_STORE_IMM_U8: u8 = 30 // Store 8-bit immediate to memory\nexport const OPCODE_STORE_IMM_U16: u8 = 31 // Store 16-bit immediate to memory\nexport const OPCODE_STORE_IMM_U32: u8 = 32 // Store 32-bit immediate to memory\nexport const OPCODE_STORE_IMM_U64: u8 = 33 // Store 64-bit immediate to memory\n\n// Instructions with Arguments of One Offset\nexport const OPCODE_JUMP: u8 = 40 // Unconditional jump\n\n// Instructions with Arguments of One Register & One Immediate\nexport const OPCODE_JUMP_IND: u8 = 50 // Indirect jump\nexport const OPCODE_LOAD_IMM: u8 = 51 // Load immediate into register\nexport const OPCODE_LOAD_U8: u8 = 52 // Load unsigned 8-bit from memory\nexport const OPCODE_LOAD_I8: u8 = 53 // Load signed 8-bit from memory\nexport const OPCODE_LOAD_U16: u8 = 54 // Load unsigned 16-bit from memory\nexport const OPCODE_LOAD_I16: u8 = 55 // Load signed 16-bit from memory\nexport const OPCODE_LOAD_U32: u8 = 56 // Load unsigned 32-bit from memory\nexport const OPCODE_LOAD_I32: u8 = 57 // Load signed 32-bit from memory\nexport const OPCODE_LOAD_U64: u8 = 58 // Load unsigned 64-bit from memory\nexport const OPCODE_STORE_U8: u8 = 59 // Store 8-bit to memory\nexport const OPCODE_STORE_U16: u8 = 60 // Store 16-bit to memory\nexport const OPCODE_STORE_U32: u8 = 61 // Store 32-bit to memory\nexport const OPCODE_STORE_U64: u8 = 62 // Store 64-bit to memory\n\n// Instructions with Arguments of One Register & Two Immediates\nexport const OPCODE_STORE_IMM_IND_U8: u8 = 70 // Store immediate to indexed memory (8-bit)\nexport const OPCODE_STORE_IMM_IND_U16: u8 = 71 // Store immediate to indexed memory (16-bit)\nexport const OPCODE_STORE_IMM_IND_U32: u8 = 72 // Store immediate to indexed memory (32-bit)\nexport const OPCODE_STORE_IMM_IND_U64: u8 = 73 // Store immediate to indexed memory (64-bit)\n\n// Instructions with Arguments of One Register, One Immediate and One Offset\nexport const OPCODE_LOAD_IMM_JUMP: u8 = 80 // Load immediate and jump\nexport const OPCODE_BRANCH_EQ_IMM: u8 = 81 // Branch if equal to immediate\nexport const OPCODE_BRANCH_NE_IMM: u8 = 82 // Branch if not equal to immediate\nexport const OPCODE_BRANCH_LT_U_IMM: u8 = 83 // Branch if less than immediate (unsigned)\nexport const OPCODE_BRANCH_LE_U_IMM: u8 = 84 // Branch if less than or equal to immediate (unsigned)\nexport const OPCODE_BRANCH_GE_U_IMM: u8 = 85 // Branch if greater than or equal to immediate (unsigned)\nexport const OPCODE_BRANCH_GT_U_IMM: u8 = 86 // Branch if greater than immediate (unsigned)\nexport const OPCODE_BRANCH_LT_S_IMM: u8 = 87 // Branch if less than immediate (signed)\nexport const OPCODE_BRANCH_LE_S_IMM: u8 = 88 // Branch if less than or equal to immediate (signed)\nexport const OPCODE_BRANCH_GE_S_IMM: u8 = 89 // Branch if greater than or equal to immediate (signed)\nexport const OPCODE_BRANCH_GT_S_IMM: u8 = 90 // Branch if greater than immediate (signed)\n\n// Instructions with Arguments of Two Registers\nexport const OPCODE_MOVE_REG: u8 = 100 // Move register to register\nexport const OPCODE_SBRK: u8 = 101 // Allocate memory\nexport const OPCODE_COUNT_SET_BITS_64: u8 = 102 // Count set bits in 64-bit register\nexport const OPCODE_COUNT_SET_BITS_32: u8 = 103 // Count set bits in 32-bit register\nexport const OPCODE_LEADING_ZERO_BITS_64: u8 = 104 // Count leading zero bits in 64-bit register\nexport const OPCODE_LEADING_ZERO_BITS_32: u8 = 105 // Count leading zero bits in 32-bit register\nexport const OPCODE_TRAILING_ZERO_BITS_64: u8 = 106 // Count trailing zero bits in 64-bit register\nexport const OPCODE_TRAILING_ZERO_BITS_32: u8 = 107 // Count trailing zero bits in 32-bit register\nexport const OPCODE_SIGN_EXTEND_8: u8 = 108 // Sign extend 8-bit value\nexport const OPCODE_SIGN_EXTEND_16: u8 = 109 // Sign extend 16-bit value\nexport const OPCODE_ZERO_EXTEND_16: u8 = 110 // Zero extend 16-bit value\nexport const OPCODE_REVERSE_BYTES: u8 = 111 // Reverse byte order\n\n// Instructions with Arguments of Two Registers & One Immediate\nexport const OPCODE_STORE_IND_U8: u8 = 120 // Store to indexed memory (8-bit)\nexport const OPCODE_STORE_IND_U16: u8 = 121 // Store to indexed memory (16-bit)\nexport const OPCODE_STORE_IND_U32: u8 = 122 // Store to indexed memory (32-bit)\nexport const OPCODE_STORE_IND_U64: u8 = 123 // Store to indexed memory (64-bit)\nexport const OPCODE_LOAD_IND_U8: u8 = 124 // Load from indexed memory (8-bit)\nexport const OPCODE_LOAD_IND_I8: u8 = 125 // Load from indexed memory (8-bit signed)\nexport const OPCODE_LOAD_IND_U16: u8 = 126 // Load from indexed memory (16-bit)\nexport const OPCODE_LOAD_IND_I16: u8 = 127 // Load from indexed memory (16-bit signed)\nexport const OPCODE_LOAD_IND_U32: u8 = 128 // Load from indexed memory (32-bit)\nexport const OPCODE_LOAD_IND_I32: u8 = 129 // Load from indexed memory (32-bit signed)\nexport const OPCODE_LOAD_IND_U64: u8 = 130 // Load from indexed memory (64-bit)\nexport const OPCODE_ADD_IMM_32: u8 = 131 // Add immediate to 32-bit register\nexport const OPCODE_AND_IMM: u8 = 132 // Bitwise AND with immediate\nexport const OPCODE_XOR_IMM: u8 = 133 // Bitwise XOR with immediate\nexport const OPCODE_OR_IMM: u8 = 134 // Bitwise OR with immediate\nexport const OPCODE_MUL_IMM_32: u8 =  135 // Multiply 32-bit register by immediate\nexport const OPCODE_SET_LT_U_IMM: u8 = 136 // Set if less than immediate (unsigned)\nexport const OPCODE_SET_LT_S_IMM: u8 = 137 // Set if less than immediate (signed)\nexport const OPCODE_SHLO_L_IMM_32: u8 = 138 // Shift left by immediate (32-bit)\nexport const OPCODE_SHLO_R_IMM_32: u8 = 139 // Shift right logical by immediate (32-bit)\nexport const OPCODE_SHAR_R_IMM_32: u8 = 140 // Shift right arithmetic by immediate (32-bit)\nexport const OPCODE_NEG_ADD_IMM_32: u8 = 141 // Negate and add immediate (32-bit)\nexport const OPCODE_SET_GT_U_IMM: u8 = 142 // Set if greater than immediate (unsigned)\nexport const OPCODE_SET_GT_S_IMM: u8 = 143 // Set if greater than immediate (signed)\nexport const OPCODE_SHLO_L_IMM_ALT_32: u8 = 144 // Alternative shift left by immediate (32-bit)\nexport const OPCODE_SHLO_R_IMM_ALT_32: u8 = 145 // Alternative shift right logical by immediate (32-bit)\nexport const OPCODE_SHAR_R_IMM_ALT_32: u8 = 146 // Alternative shift right arithmetic by immediate (32-bit)\nexport const OPCODE_CMOV_IZ_IMM: u8 = 147 // Conditional move if zero with immediate\nexport const OPCODE_CMOV_NZ_IMM: u8 = 148 // Conditional move if not zero with immediate\nexport const OPCODE_ADD_IMM_64: u8 = 149 // Add immediate to 64-bit register\nexport const OPCODE_MUL_IMM_64: u8 = 150 // Multiply 64-bit register by immediate\nexport const OPCODE_SHLO_L_IMM_64: u8 = 151 // Shift left by immediate (64-bit)\nexport const OPCODE_SHLO_R_IMM_64: u8 = 152 // Shift right logical by immediate (64-bit)\nexport const OPCODE_SHAR_R_IMM_64: u8 = 153 // Shift right arithmetic by immediate (64-bit)\nexport const OPCODE_NEG_ADD_IMM_64: u8 = 154 // Negate and add immediate (64-bit)\nexport const OPCODE_SHLO_L_IMM_ALT_64: u8 = 155 // Alternative shift left by immediate (64-bit)\nexport const OPCODE_SHLO_R_IMM_ALT_64: u8 = 156 // Alternative shift right logical by immediate (64-bit)\nexport const OPCODE_SHAR_R_IMM_ALT_64: u8 = 157 // Alternative shift right arithmetic by immediate (64-bit)\nexport const OPCODE_ROT_R_64_IMM: u8 = 158 // Rotate right by immediate (64-bit)\nexport const OPCODE_ROT_R_64_IMM_ALT: u8 = 159 // Alternative rotate right by immediate (64-bit)\nexport const OPCODE_ROT_R_32_IMM: u8 = 160 // Rotate right by immediate (32-bit)\nexport const OPCODE_ROT_R_32_IMM_ALT: u8 = 161 // Alternative rotate right by immediate (32-bit)\n\n// Instructions with Arguments of Two Registers & One Offset\nexport const OPCODE_BRANCH_EQ: u8 = 170 // Branch if equal\nexport const OPCODE_BRANCH_NE: u8 = 171 // Branch if not equal\nexport const OPCODE_BRANCH_LT_U: u8 = 172 // Branch if less than (unsigned)\nexport const OPCODE_BRANCH_LT_S: u8 = 173 // Branch if less than (signed)\nexport const OPCODE_BRANCH_GE_U: u8 = 174 // Branch if greater than or equal (unsigned)\nexport const OPCODE_BRANCH_GE_S: u8 = 175 // Branch if greater than or equal (signed)\n\n// Instructions with Arguments of Two Registers and Two Immediates\nexport const OPCODE_LOAD_IMM_JUMP_IND: u8 = 180 // Load immediate and indirect jump\n\n// Instructions with Arguments of Three Registers\nexport const OPCODE_ADD_32: u8 = 190 // Add 32-bit registers\nexport const OPCODE_SUB_32: u8 = 191 // Subtract 32-bit registers\nexport const OPCODE_MUL_32: u8 = 192 // Multiply 32-bit registers\nexport const OPCODE_DIV_U_32: u8 = 193 // Divide 32-bit registers (unsigned)\nexport const OPCODE_DIV_S_32: u8 = 194 // Divide 32-bit registers (signed)\nexport const OPCODE_REM_U_32: u8 = 195 // Remainder 32-bit registers (unsigned)\nexport const OPCODE_REM_S_32: u8 = 196 // Remainder 32-bit registers (signed)\nexport const OPCODE_SHLO_L_32: u8 = 197 // Shift left (32-bit)\nexport const OPCODE_SHLO_R_32: u8 = 198 // Shift right logical (32-bit)\nexport const OPCODE_SHAR_R_32: u8 = 199 // Shift right arithmetic (32-bit)\nexport const OPCODE_ADD_64: u8 = 200 // Add 64-bit registers\nexport const OPCODE_SUB_64: u8 = 201 // Subtract 64-bit registers\nexport const OPCODE_MUL_64: u8 = 202 // Multiply 64-bit registers\nexport const OPCODE_DIV_U_64: u8 = 203 // Divide 64-bit registers (unsigned)\nexport const OPCODE_DIV_S_64: u8 = 204 // Divide 64-bit registers (signed)\nexport const OPCODE_REM_U_64: u8 = 205 // Remainder 64-bit registers (unsigned)\nexport const OPCODE_REM_S_64: u8 = 206 // Remainder 64-bit registers (signed)\nexport const OPCODE_SHLO_L_64: u8 = 207 // Shift left (64-bit)\nexport const OPCODE_SHLO_R_64: u8 = 208 // Shift right logical (64-bit)\nexport const OPCODE_SHAR_R_64: u8 = 209 // Shift right arithmetic (64-bit)\nexport const OPCODE_AND: u8 = 210 // Bitwise AND\nexport const OPCODE_XOR: u8 = 211 // Bitwise XOR\nexport const OPCODE_OR: u8 = 212 // Bitwise OR\nexport const OPCODE_MUL_UPPER_S_S: u8 = 213 // Multiply upper bits (signed  signed)\nexport const OPCODE_MUL_UPPER_U_U: u8 = 214 // Multiply upper bits (unsigned  unsigned)\nexport const OPCODE_MUL_UPPER_S_U: u8 = 215 // Multiply upper bits (signed  unsigned)\nexport const OPCODE_SET_LT_U: u8 = 216 // Set if less than (unsigned)\nexport const OPCODE_SET_LT_S: u8 = 217 // Set if less than (signed)\nexport const OPCODE_CMOV_IZ: u8 = 218 // Conditional move if zero\nexport const OPCODE_CMOV_NZ: u8 = 219 // Conditional move if not zero\nexport const OPCODE_ROT_L_64: u8 = 220 // Rotate left (64-bit)\nexport const OPCODE_ROT_L_32: u8 = 221 // Rotate left (32-bit)\nexport const OPCODE_ROT_R_64: u8 = 222 // Rotate right (64-bit)\nexport const OPCODE_ROT_R_32: u8 = 223 // Rotate right (32-bit)\nexport const OPCODE_AND_INV: u8 = 224 // Bitwise AND with inverse\nexport const OPCODE_OR_INV: u8 = 225 // Bitwise OR with inverse\nexport const OPCODE_XNOR: u8 = 226 // Bitwise XNOR\nexport const OPCODE_MAX: u8 = 227 // Maximum (signed)\nexport const OPCODE_MAX_U: u8 = 228 // Maximum (unsigned)\nexport const OPCODE_MIN: u8 = 229 // Minimum (signed)\nexport const OPCODE_MIN_U: u8 = 230 // Minimum (unsigned)\n\n// ============================================================================\n// Gray Paper Constants\n// ============================================================================\nexport const PACKAGE_AUTH_GAS: u32 = 50_000_000 // Cpackageauthgas = 50,000,000\nexport const MAX_AUTH_CODE_SIZE: u32 = 64_000 // Cmaxauthcodesize = 64,000\n\nexport const PACKAGE_REF_GAS: u64 = 5_000_000_000 // Cpackagerefgas = 5,000,000,000\nexport const MAX_SERVICE_CODE_SIZE: u32 = 4_000_000 // Cmaxservicecodesize = 4,000,000\nexport const SEGMENT_SIZE: u32 = 4_104 // Csegmentsize = 4104\nexport const MAX_PACKAGE_EXPORTS: u32 = 3_072 // Cmaxpackageexports = 3,072\n\nexport const MIN_PUBLIC_INDEX: u32 = 65536 // Cminpublicindex = 2^16\n\n// ============================================================================\n// General Function Identifiers (Gray Paper Appendix B.7)\n// ============================================================================\nexport const FUNC_GAS: u8 = 0\nexport const FUNC_FETCH: u8 = 1\nexport const FUNC_LOOKUP: u8 = 2\nexport const FUNC_READ: u8 = 3\nexport const FUNC_WRITE: u8 = 4\nexport const FUNC_INFO: u8 = 5\nexport const FUNC_HISTORICAL_LOOKUP: u8 = 6\nexport const FUNC_EXPORT: u8 = 7\nexport const FUNC_MACHINE: u8 = 8\nexport const FUNC_PEEK: u8 = 9\nexport const FUNC_POKE: u8 = 10\nexport const FUNC_PAGES: u8 = 11\nexport const FUNC_INVOKE: u8 = 12\nexport const FUNC_EXPUNGE: u8 = 13\nexport const FUNC_LOG: u8 = 100\n\n// ============================================================================\n// Accumulate Function Identifiers (Gray Paper Appendix B.7)\n// ============================================================================\nexport const FUNC_BLESS: u8 = 14\nexport const FUNC_ASSIGN: u8 = 15\nexport const FUNC_DESIGNATE: u8 = 16\nexport const FUNC_CHECKPOINT: u8 = 17\nexport const FUNC_NEW: u8 = 18\nexport const FUNC_UPGRADE: u8 = 19\nexport const FUNC_TRANSFER: u8 = 20\nexport const FUNC_EJECT: u8 = 21\nexport const FUNC_QUERY: u8 = 22\nexport const FUNC_SOLICIT: u8 = 23\nexport const FUNC_FORGET: u8 = 24\nexport const FUNC_YIELD: u8 = 25\nexport const FUNC_PROVIDE: u8 = 26\n\n// ============================================================================\n// Accumulate Error Codes (Gray Paper section 31.2)\n// ============================================================================\nexport const ERROR_NONE: i64 = -1 // The return value indicating an item does not exist (2^64 - 1)\nexport const ERROR_WHAT: i64 = -2 // Name unknown\nexport const ERROR_OOB: i64 = -3 // Memory index not accessible\nexport const ERROR_WHO: i64 = -4 // Index unknown\nexport const ERROR_FULL: i64 = -5 // Storage full or resource already allocated\nexport const ERROR_CORE: i64 = -6 // Core index unknown\nexport const ERROR_CASH: i64 = -7 // Insufficient funds\nexport const ERROR_LOW: i64 = -8 // Gas limit too low\nexport const ERROR_HUH: i64 = -9 // Already solicited, cannot be forgotten or operation invalid\nexport const ERROR_OK: i64 = 0 // General success\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/**\n * Check if an opcode is a basic block termination instruction\n *\n * @param opcode - The opcode to check\n * @returns true if the opcode is a termination instruction\n */\nexport function isTerminationInstruction(opcode: u8): boolean {\n  // Trap and fallthrough\n  if (opcode === OPCODE_TRAP || opcode === OPCODE_FALLTHROUGH) return true\n  \n  // Jumps\n  if (opcode === OPCODE_JUMP || opcode === OPCODE_JUMP_IND) return true\n  \n  // Load-and-Jumps\n  if (opcode === OPCODE_LOAD_IMM_JUMP || opcode === OPCODE_LOAD_IMM_JUMP_IND) return true\n  \n  // Branches (register-based)\n  if (opcode >= OPCODE_BRANCH_EQ && opcode <= OPCODE_BRANCH_GE_S) return true // 170-175\n  \n  // Branches (immediate-based)\n  if (opcode >= OPCODE_BRANCH_EQ_IMM && opcode <= OPCODE_BRANCH_GT_S_IMM) return true // 81-90\n  \n  return false\n}\n\n// ============================================================================\n// Config Objects (for compatibility with TypeScript code)\n// ============================================================================\n// Note: AssemblyScript requires explicit type annotations for exported objects\n// All config values are accessed via class static properties to avoid WASM export issues\n\nexport function REGISTER_INIT_STACK_SEGMENT_END(): u32 { return STACK_SEGMENT_END }\nexport function REGISTER_INIT_ARGS_SEGMENT_START(): u32 { return ARGS_SEGMENT_START }\n\n// Compatibility shims - use classes with static readonly properties\n// This provides proper typing in AssemblyScript while maintaining object-like access\nexport class INIT_CONFIG {\n  static readonly ZONE_SIZE: u32 = ZONE_SIZE\n  static readonly INIT_INPUT_SIZE: u32 = INIT_INPUT_SIZE\n}\n\nexport class MEMORY_CONFIG {\n  static readonly PAGE_SIZE: u32 = PAGE_SIZE\n  static readonly RESERVED_MEMORY_END: u32 = RESERVED_MEMORY_END\n  static readonly MAX_MEMORY_ADDRESS: u32 = MAX_MEMORY_ADDRESS\n}\n\nexport class REGISTER_INIT {\n  static readonly HALT_ADDRESS: u32 = HALT_ADDRESS\n  static readonly STACK_SEGMENT_END: u32 = STACK_SEGMENT_END\n  static readonly ARGS_SEGMENT_START: u32 = ARGS_SEGMENT_START\n}\n\nexport class RESULT_CODES {\n  static readonly HALT: u8 = RESULT_CODE_HALT\n  static readonly PANIC: u8 = RESULT_CODE_PANIC\n  static readonly FAULT: i32 = RESULT_CODE_FAULT\n  static readonly HOST: u8 = RESULT_CODE_HOST\n  static readonly OOG: u8 = RESULT_CODE_OOG\n}\n\nexport class GENERAL_FUNCTIONS {\n  static readonly GAS: u8 = FUNC_GAS\n  static readonly FETCH: u8 = FUNC_FETCH\n  static readonly LOOKUP: u8 = FUNC_LOOKUP\n  static readonly READ: u8 = FUNC_READ\n  static readonly WRITE: u8 = FUNC_WRITE\n  static readonly INFO: u8 = FUNC_INFO\n  static readonly HISTORICAL_LOOKUP: u8 = FUNC_HISTORICAL_LOOKUP\n  static readonly EXPORT: u8 = FUNC_EXPORT\n  static readonly MACHINE: u8 = FUNC_MACHINE\n  static readonly PEEK: u8 = FUNC_PEEK\n  static readonly POKE: u8 = FUNC_POKE\n  static readonly PAGES: u8 = FUNC_PAGES\n  static readonly INVOKE: u8 = FUNC_INVOKE\n  static readonly EXPUNGE: u8 = FUNC_EXPUNGE\n  static readonly LOG: u8 = FUNC_LOG\n}\n\nexport class ACCUMULATE_FUNCTIONS {\n  static readonly BLESS: u8 = FUNC_BLESS\n  static readonly ASSIGN: u8 = FUNC_ASSIGN\n  static readonly DESIGNATE: u8 = FUNC_DESIGNATE\n  static readonly CHECKPOINT: u8 = FUNC_CHECKPOINT\n  static readonly NEW: u8 = FUNC_NEW\n  static readonly UPGRADE: u8 = FUNC_UPGRADE\n  static readonly TRANSFER: u8 = FUNC_TRANSFER\n  static readonly EJECT: u8 = FUNC_EJECT\n  static readonly QUERY: u8 = FUNC_QUERY\n  static readonly SOLICIT: u8 = FUNC_SOLICIT\n  static readonly FORGET: u8 = FUNC_FORGET\n  static readonly YIELD: u8 = FUNC_YIELD\n  static readonly PROVIDE: u8 = FUNC_PROVIDE\n}\n\nexport class ACCUMULATE_ERROR_CODES {\n  static readonly NONE: i64 = ERROR_NONE\n  static readonly WHAT: i64 = ERROR_WHAT\n  static readonly OOB: i64 = ERROR_OOB\n  static readonly WHO: i64 = ERROR_WHO\n  static readonly FULL: i64 = ERROR_FULL\n  static readonly CORE: i64 = ERROR_CORE\n  static readonly CASH: i64 = ERROR_CASH\n  static readonly LOW: i64 = ERROR_LOW\n  static readonly HUH: i64 = ERROR_HUH\n  static readonly OK: i64 = ERROR_OK\n}\n\nexport class REFINE_CONFIG {\n  // Empty class for compatibility\n}\n","/**\n * Blake2b-256 hash implementation for AssemblyScript\n * \n * This is a minimal implementation of Blake2b with 256-bit output (32 bytes)\n * for use in the PVM host functions.\n * \n * Based on RFC 7693: https://tools.ietf.org/html/rfc7693\n */\n\n// Blake2b-256 initialization vector\nconst IV: u64[] = [\n  0x6a09e667f3bcc908,\n  0xbb67ae8584caa73b,\n  0x3c6ef372fe94f82b,\n  0xa54ff53a5f1d36f1,\n  0x510e527fade682d1,\n  0x9b05688c2b3e6c1f,\n  0x1f83d9abfb41bd6b,\n  0x5be0cd19137e2179\n]\n\n// Blake2b sigma permutations\nconst SIGMA: u8[][] = [\n  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n  [14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3],\n  [11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4],\n  [7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8],\n  [9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13],\n  [2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9],\n  [12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11],\n  [13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10],\n  [6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5],\n  [10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0]\n]\n\n// Rotation constants for G function\nconst R1: u32 = 32\nconst R2: u32 = 24\nconst R3: u32 = 16\nconst R4: u32 = 63\n\n// G mixing function\nfunction G(v: u64[], a: i32, b: i32, c: i32, d: i32, x: u64, y: u64): void {\n  v[a] = v[a] + v[b] + x\n  v[d] = rotr64(v[d] ^ v[a], R1)\n  v[c] = v[c] + v[d]\n  v[b] = rotr64(v[b] ^ v[c], R2)\n  v[a] = v[a] + v[b] + y\n  v[d] = rotr64(v[d] ^ v[a], R3)\n  v[c] = v[c] + v[d]\n  v[b] = rotr64(v[b] ^ v[c], R4)\n}\n\n// 64-bit rotate right\nfunction rotr64(x: u64, n: u32): u64 {\n  return (x >> n) | (x << (64 - n))\n}\n\n// Compress function\nfunction compress(h: u64[], chunk: Uint8Array, t: u64, last: bool): void {\n  // Initialize working vector\n  const v: u64[] = new Array<u64>(16)\n  for (let i = 0; i < 8; i++) {\n    v[i] = h[i]\n    v[i + 8] = IV[i]\n  }\n  \n  // XOR counter and flags\n  v[12] ^= t  // Low 64 bits of offset\n  v[13] ^= 0  // High 64 bits of offset (always 0 for small inputs)\n  if (last) {\n    v[14] ^= 0xffffffffffffffff\n  }\n  \n  // Parse message block into 16 u64 words (little-endian)\n  const m: u64[] = new Array<u64>(16)\n  for (let i = 0; i < 16; i++) {\n    const offset = i * 8\n    if (offset + 8 <= chunk.length) {\n      m[i] = \n        u64(chunk[offset]) |\n        (u64(chunk[offset + 1]) << 8) |\n        (u64(chunk[offset + 2]) << 16) |\n        (u64(chunk[offset + 3]) << 24) |\n        (u64(chunk[offset + 4]) << 32) |\n        (u64(chunk[offset + 5]) << 40) |\n        (u64(chunk[offset + 6]) << 48) |\n        (u64(chunk[offset + 7]) << 56)\n    } else {\n      m[i] = 0\n    }\n  }\n  \n  // 12 rounds\n  for (let round = 0; round < 12; round++) {\n    const s = SIGMA[round % 10]\n    G(v, 0, 4, 8, 12, m[s[0]], m[s[1]])\n    G(v, 1, 5, 9, 13, m[s[2]], m[s[3]])\n    G(v, 2, 6, 10, 14, m[s[4]], m[s[5]])\n    G(v, 3, 7, 11, 15, m[s[6]], m[s[7]])\n    G(v, 0, 5, 10, 15, m[s[8]], m[s[9]])\n    G(v, 1, 6, 11, 12, m[s[10]], m[s[11]])\n    G(v, 2, 7, 8, 13, m[s[12]], m[s[13]])\n    G(v, 3, 4, 9, 14, m[s[14]], m[s[15]])\n  }\n  \n  // Finalize: h = h XOR upper XOR lower\n  for (let i = 0; i < 8; i++) {\n    h[i] ^= v[i] ^ v[i + 8]\n  }\n}\n\n/**\n * Compute Blake2b-256 hash of input data\n * @param data Input bytes to hash\n * @returns 32-byte hash result\n */\nexport function blake2b256(data: Uint8Array): Uint8Array {\n  const outlen: u8 = 32  // 256 bits = 32 bytes\n  const blockSize = 128  // Blake2b block size\n  \n  // Initialize state\n  const h: u64[] = new Array<u64>(8)\n  for (let i = 0; i < 8; i++) {\n    h[i] = IV[i]\n  }\n  \n  // Parameter block: outlen=32, keylen=0, fanout=1, depth=1\n  h[0] ^= u64(outlen) | (u64(0) << 8) | (u64(1) << 16) | (u64(1) << 24)\n  \n  // Process full blocks\n  let offset: i32 = 0\n  while (offset + blockSize < data.length) {\n    const chunk = data.slice(offset, offset + blockSize)\n    compress(h, chunk, u64(offset + blockSize), false)\n    offset += blockSize\n  }\n  \n  // Process final block (padded with zeros)\n  const remaining = data.length - offset\n  const lastChunk = new Uint8Array(blockSize)\n  for (let i = 0; i < remaining; i++) {\n    lastChunk[i] = data[offset + i]\n  }\n  compress(h, lastChunk, u64(data.length), true)\n  \n  // Output hash (little-endian)\n  const result = new Uint8Array(32)\n  for (let i = 0; i < 4; i++) {\n    const val = h[i]\n    result[i * 8 + 0] = u8(val & 0xff)\n    result[i * 8 + 1] = u8((val >> 8) & 0xff)\n    result[i * 8 + 2] = u8((val >> 16) & 0xff)\n    result[i * 8 + 3] = u8((val >> 24) & 0xff)\n    result[i * 8 + 4] = u8((val >> 32) & 0xff)\n    result[i * 8 + 5] = u8((val >> 40) & 0xff)\n    result[i * 8 + 6] = u8((val >> 48) & 0xff)\n    result[i * 8 + 7] = u8((val >> 56) & 0xff)\n  }\n  \n  return result\n}\n\n","// This file is shared with the compiler and must remain portable\n\n/** Runtime types. */\nexport enum Runtime {\n  /** Simple bump allocator without GC. */\n  Stub = 0,\n  /** Stop the world semi-automatic GC. */\n  Minimal = 1,\n  /** incremental GC. */\n  Incremental = 2,\n}\n","/// <reference path=\"../rt/index.d.ts\" />\n\nimport { idof } from \"../builtins\";\nimport { CharCode } from \"./string\";\n\n// @ts-ignore: decorator\n@inline\nexport const MAX_DOUBLE_LENGTH = 28;\n\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<u32>([\n  1,\n  10,\n  100,\n  1000,\n  10000,\n  100000,\n  1000000,\n  10000000,\n  100000000,\n  1000000000\n]);\n\n/*\n  Lookup table for pairwise char codes in range [0-99]\n\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\n*/\n// @ts-ignore: decorator\n@lazy @inline const DIGITS = memory.data<u32>([\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\n]);\n\n// Lookup table for pairwise char codes in range [0x00-0xFF]\n// @ts-ignore: decorator\n@lazy @inline const HEX_DIGITS =\n\"000102030405060708090a0b0c0d0e0f\\\n101112131415161718191a1b1c1d1e1f\\\n202122232425262728292a2b2c2d2e2f\\\n303132333435363738393a3b3c3d3e3f\\\n404142434445464748494a4b4c4d4e4f\\\n505152535455565758595a5b5c5d5e5f\\\n606162636465666768696a6b6c6d6e6f\\\n707172737475767778797a7b7c7d7e7f\\\n808182838485868788898a8b8c8d8e8f\\\n909192939495969798999a9b9c9d9e9f\\\na0a1a2a3a4a5a6a7a8a9aaabacadaeaf\\\nb0b1b2b3b4b5b6b7b8b9babbbcbdbebf\\\nc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\\\nd0d1d2d3d4d5d6d7d8d9dadbdcdddedf\\\ne0e1e2e3e4e5e6e7e8e9eaebecedeeef\\\nf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\";\n\n// @ts-ignore: decorator\n@lazy @inline const ANY_DIGITS = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_POWERS = memory.data<i16>([/* eslint-disable indent */\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\n    907,   933,   960,   986,  1013,  1039,  1066\n/* eslint-enable indent */]);\n\n// 1e-348, 1e-340, ..., 1e340\n// @ts-ignore: decorator\n@lazy @inline const FRC_POWERS = memory.data<u64>([\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function isPowerOf2<T extends number>(value: T): bool {\n  return popcnt<T>(value) == 1;\n}\n\n// Count number of decimals for u32 values\n// In our case input value always non-zero so we can simplify some parts\nexport function decimalCount32(value: u32): u32 {\n  if (value < 100000) {\n    if (value < 100) {\n      return 1 + u32(value >= 10);\n    } else {\n      return 3 + u32(value >= 10000) + u32(value >= 1000);\n    }\n  } else {\n    if (value < 10000000) {\n      return 6 + u32(value >= 1000000);\n    } else {\n      return 8 + u32(value >= 1000000000) + u32(value >= 100000000);\n    }\n  }\n}\n\n// Count number of decimals for u64 values\n// In our case input value always greater than 2^32-1 so we can skip some parts\nexport function decimalCount64High(value: u64): u32 {\n  if (value < 1000000000000000) {\n    if (value < 1000000000000) {\n      return 10 + u32(value >= 100000000000) + u32(value >= 10000000000);\n    } else {\n      return 13 + u32(value >= 100000000000000) + u32(value >= 10000000000000);\n    }\n  } else {\n    if (value < 100000000000000000) {\n      return 16 + u32(value >= 10000000000000000);\n    } else {\n      return 18 + u32(value >= 10000000000000000000) + u32(value >= 1000000000000000000);\n    }\n  }\n}\n\nfunction ulog_base(num: u64, base: i32): u32 {\n  if (isPowerOf2(base)) {\n    return (63 - <u32>clz(num)) / (31 - <u32>clz(base)) + 1;\n  }\n  let b64 = u64(base), b = b64, e: u32 = 1;\n  while (num >= b) {\n    num /= b;\n    b *= b;\n    e <<= 1;\n  }\n  while (num >= 1) {\n    num /= b64;\n    e++;\n  }\n  return e - 1;\n}\n\nfunction utoa32_dec_lut(buffer: usize, num: u32, offset: usize): void {\n  while (num >= 10000) {\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\n    let t = num / 10000;\n    let r = num % 10000;\n    num = t;\n\n    let d1 = r / 100;\n    let d2 = r % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>d2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  if (num >= 100) {\n    let t  = num / 100;\n    let d1 = num % 100;\n    num = t;\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  }\n\n  if (num >= 10) {\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>num << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  } else {\n    offset -= 1;\n    let digit = CharCode._0 + num;\n    store<u16>(buffer + (offset << 1), digit);\n  }\n}\n\nfunction utoa64_dec_lut(buffer: usize, num: u64, offset: usize): void {\n  while (num >= 100000000) {\n    let t = num / 100000000;\n    let r = <usize>(num - t * 100000000);\n    num = t;\n\n    let b = r / 10000;\n    let c = r % 10000;\n\n    let b1 = b / 100;\n    let b2 = b % 100;\n    let c1 = c / 100;\n    let c2 = c % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>c1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>c2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n\n    digits1 = <u64>load<u32>(DIGITS + (<usize>b1 << alignof<u32>()));\n    digits2 = <u64>load<u32>(DIGITS + (<usize>b2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  utoa32_dec_lut(buffer, <u32>num, offset);\n}\n\nfunction utoa_hex_lut(buffer: usize, num: u64, offset: usize): void {\n  const lut = changetype<usize>(HEX_DIGITS);\n  while (offset >= 2) {\n    offset -= 2;\n    store<u32>(\n      buffer + (offset << 1),\n      load<u32>(lut + ((<usize>num & 0xFF) << alignof<u32>()))\n    );\n    num >>= 8;\n  }\n  if (offset & 1) {\n    store<u16>(buffer, load<u16>(lut + (<usize>num << 6)));\n  }\n}\n\nfunction utoa_dec_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let t = num / 10;\n    let r = <u32>(num % 10);\n    num = changetype<T>(t);\n    offset--;\n    store<u16>(buffer + (offset << 1), CharCode._0 + r);\n  } while (num);\n}\n\nfunction utoa_hex_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let d = num & 0x0F | CharCode._0;\n    d += select<T>(<T>0x27, <T>0, d > <T>CharCode._9);\n    offset--;\n    store<u16>(buffer + (offset << 1), d);\n    // @ts-ignore: type\n    num >>= 4;\n  } while (num);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function utoa32_dec_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u32>(buffer, num, offset);\n  } else {\n    utoa32_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa32_hex_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u32>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_dec_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u64>(buffer, num, offset);\n  } else {\n    utoa64_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_hex_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u64>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\nfunction utoa64_any_core(buffer: usize, num: u64, offset: usize, radix: i32): void {\n  const lut = changetype<usize>(ANY_DIGITS);\n  let base = u64(radix);\n  if ((radix & (radix - 1)) == 0) { // for radix which pow of two\n    let shift = u64(ctz(radix) & 7);\n    let mask = base - 1;\n    do {\n      offset--;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num & mask) << 1)));\n      num >>= shift;\n    } while (num);\n  } else {\n    do {\n      offset--;\n      let q = num / base;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num - q * base) << 1)));\n      num = q;\n    } while (num);\n  }\n}\n\nexport function utoa32(value: u32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  let out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out), value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa32(value: i32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  let sign = (value >>> 31) << 1;\n  if (sign) value = -value;\n  let out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out) + sign, value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1;\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out) + sign, value, decimals);\n  } else {\n    let val32 = u32(value);\n    let decimals = ulog_base(val32, radix);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_any_core(changetype<usize>(out) + sign, val32, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\nexport function utoa64(value: u64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  let out: String;\n\n  if (radix == 10) {\n    if (value <= u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out), val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out), value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa64(value: i64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  let sign = u32(value >>> 63) << 1;\n  if (sign) value = -value;\n  let out: String;\n\n  if (radix == 10) {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32);\n      out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out) + sign, val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value);\n      out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out) + sign, value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out) + sign, value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_any_core(changetype<usize>(out) + sign, value, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\n// @ts-ignore: decorator\n@lazy let _K: i32 = 0;\n\n// // @ts-ignore: decorator\n// @lazy\n// let _frc: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _exp: i32 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_minus: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_plus: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_pow: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _exp_pow: i32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction umul64f(u: u64, v: u64): u64 {\n  let u0 = u & 0xFFFFFFFF;\n  let v0 = v & 0xFFFFFFFF;\n\n  let u1 = u >> 32;\n  let v1 = v >> 32;\n\n  let l = u0 * v0;\n  let t = u1 * v0 + (l >> 32);\n  let w = u0 * v1 + (t & 0xFFFFFFFF);\n\n  w += 0x7FFFFFFF; // rounding\n\n  t >>= 32;\n  w >>= 32;\n\n  return u1 * v1 + t + w;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction umul64e(e1: i32, e2: i32): i32 {\n  return e1 + e2 + 64; // where 64 is significand size\n}\n\n// @ts-ignore: decorator\n@inline\nfunction normalizedBoundaries(f: u64, e: i32, isSingle: bool): void {\n  let frc = (f << 1) + 1;\n  let exp = e - 1;\n  let off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  let m = 1 + i32(f == (isSingle ? 0x00800000 : 0x0010000000000000));\n\n  _frc_plus  = frc;\n  _frc_minus = ((f << m) - 1) << e - m - exp;\n  _exp = exp;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\n  let lastp = buffer + ((len - 1) << 1);\n  let digit = load<u16>(lastp);\n  while (\n    rest < wp_w &&\n    delta - rest >= ten_kappa && (\n      rest + ten_kappa < wp_w ||\n      wp_w - rest > rest + ten_kappa - wp_w\n    )\n  ) {\n    --digit;\n    rest += ten_kappa;\n  }\n  store<u16>(lastp, digit);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction getCachedPower(minExp: i32): void {\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\n  let dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\n  let k = <i32>dk;\n  k += i32(k != dk); // conversion with ceil\n\n  let index = (k >> 3) + 1;\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\n  _frc_pow = load<u64>(FRC_POWERS + (<usize>index << alignof<u64>()));\n  _exp_pow = load<i16>(EXP_POWERS + (<usize>index << alignof<i16>()));\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisu2(value: f64, buffer: usize, sign: i32, isSingle: bool): i32 {\n  let frc: u64;\n  let exp: i32;\n\n  // frexp routine\n  if (isSingle) {\n    let uv = reinterpret<u32>(<f32>value);\n    exp = (uv & 0x7F800000) >>> 23;\n    let sid = uv & 0x007FFFFF;\n    frc = (u64(exp != 0) << 23) + sid;\n    exp = (exp || 1) - (0x7F + 23);\n  } else {\n    let uv = reinterpret<u64>(value);\n    exp = i32((uv & 0x7FF0000000000000) >>> 52);\n    let sid = uv & 0x000FFFFFFFFFFFFF;\n    frc = (u64(exp != 0) << 52) + sid;\n    exp = (exp || 1) - (0x3FF + 52);\n  }\n\n  normalizedBoundaries(frc, exp, isSingle);\n  getCachedPower(_exp);\n\n  // normalize\n  let off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  let frc_pow = _frc_pow;\n  let exp_pow = _exp_pow;\n\n  let w_frc = umul64f(frc, frc_pow);\n  let w_exp = umul64e(exp, exp_pow);\n\n  let wp_frc = umul64f(_frc_plus, frc_pow) - 1;\n  let wp_exp = umul64e(_exp, exp_pow);\n\n  let wm_frc = umul64f(_frc_minus, frc_pow) + 1;\n  let delta  = wp_frc - wm_frc;\n\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\n}\n\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\n  let one_exp = -mp_exp;\n  let one_frc = (<u64>1) << one_exp;\n  let mask    = one_frc - 1;\n\n  let wp_w_frc = mp_frc - w_frc;\n\n  let p1 = u32(mp_frc >> one_exp);\n  let p2 = mp_frc & mask;\n\n  let kappa = <i32>decimalCount32(p1);\n  let len = sign;\n\n  while (kappa > 0) {\n    let d: u32;\n    switch (kappa) {\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\n      case  3: { d = p1 /        100; p1 %=        100; break; }\n      case  2: { d = p1 /         10; p1 %=         10; break; }\n      case  1: { d = p1;              p1 =           0; break; }\n      default: { d = 0; break; }\n    }\n\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    --kappa;\n    let tmp = ((<u64>p1) << one_exp) + p2;\n    if (tmp <= delta) {\n      _K += kappa;\n      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(POWERS10 + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);\n      return len;\n    }\n  }\n\n  while (true) {\n    p2    *= 10;\n    delta *= 10;\n\n    let d = p2 >> one_exp;\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    p2 &= mask;\n    --kappa;\n    if (p2 < delta) {\n      _K += kappa;\n      wp_w_frc *= <u64>load<u32>(POWERS10 + (<usize>-kappa << alignof<u32>()));\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\n      return len;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction genExponent(buffer: usize, k: i32): i32 {\n  let sign = k < 0;\n  if (sign) k = -k;\n  let decimals = decimalCount32(k) + 1;\n  utoa32_dec_core(buffer, k, decimals);\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));\n  return decimals;\n}\n\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\n  if (!k) {\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));\n    return length + 2;\n  }\n\n  let kk = length + k;\n  if (length <= kk && kk <= 21) {\n    // 1234e7 -> 12340000000\n    for (let i = length; i < kk; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));\n    return kk + 2;\n  } else if (kk > 0 && kk <= 21) {\n    // 1234e-2 -> 12.34\n    let ptr = buffer + (kk << 1);\n    memory.copy(\n      ptr + 2,\n      ptr,\n      -k << 1\n    );\n    store<u16>(buffer + (kk << 1), CharCode.DOT);\n    return length + 1;\n  } else if (-6 < kk && kk <= 0) {\n    // 1234e-6 -> 0.001234\n    let offset = 2 - kk;\n    memory.copy(\n      buffer + (offset << 1),\n      buffer,\n      length << 1\n    );\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));\n    for (let i = 2; i < offset; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    return length + offset;\n  } else if (length == 1) {\n    // 1e30\n    store<u16>(buffer, CharCode.e, 2);\n    length = genExponent(buffer + 4, kk - 1);\n    return length + 2;\n  } else {\n    let len = length << 1;\n    memory.copy(\n      buffer + 4,\n      buffer + 2,\n      len - 2\n    );\n    store<u16>(buffer,       CharCode.DOT, 2);\n    store<u16>(buffer + len, CharCode.e,   2);\n    length += genExponent(buffer + len + 4, kk - 1);\n    return length + 2;\n  }\n}\n\nfunction dtoa_core(buffer: usize, value: f64, isSingle: bool): i32 {\n  let sign = i32(value < 0);\n  if (sign) {\n    value = -value;\n    store<u16>(buffer, CharCode.MINUS);\n  }\n  // assert(value > 0 && value <= (isSingle ? f32.MAX_VALUE : f64.MAX_VALUE));\n  let len = grisu2(value, buffer, sign, isSingle);\n  len = prettify(buffer + (sign << 1), len - sign, _K);\n  return len + sign;\n}\n\n// @ts-ignore: decorator\n@lazy @inline const dtoa_buf = memory.data(MAX_DOUBLE_LENGTH << 1);\n\nexport function dtoa<T extends number>(value: T): String {\n  const isSingle = isFloat<T>() && sizeof<T>() == 4;\n  return dtoa_impl(value, isSingle);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction dtoa_impl(value: f64, isSingle: bool): String {\n  if (value == 0) return \"0.0\";\n  if (!isFinite(value)) {\n    if (isNaN(value)) return \"NaN\";\n    return select<String>(\"-Infinity\", \"Infinity\", value < 0);\n  }\n  let size = dtoa_core(dtoa_buf, value, isSingle) << 1;\n  let result = changetype<String>(__new(size, idof<String>()));\n  memory.copy(changetype<usize>(result), dtoa_buf, size);\n  return result;\n}\n\nexport function itoa_buffered<T extends number>(buffer: usize, value: T): u32 {\n  let sign: u32 = 0;\n  if (isSigned<T>()) {\n    sign = u32(value < 0);\n    if (sign) {\n      if (sizeof<T>() == 1) {\n        if (value == -0x80) {\n          // -0x80  ->  -128\n          store<u64>(buffer,\n            <u64>CharCode.MINUS |\n            <u64>(CharCode._0 + 1) << 16 |\n            <u64>(CharCode._0 + 2) << 32 |\n            <u64>(CharCode._0 + 8) << 48\n          );\n          return 4;\n        }\n      }\n      if (sizeof<T>() == 2) {\n        if (value == -0x8000) {\n          // -0x8000  ->  -32768\n          store<u64>(buffer,\n            <u64>CharCode.MINUS |\n            <u64>(CharCode._0 + 3) << 16 |\n            <u64>(CharCode._0 + 2) << 32 |\n            <u64>(CharCode._0 + 7) << 48\n          ); // -327\n          store<u32>(buffer + 8,\n            (CharCode._0 + 6) << 0 |\n            (CharCode._0 + 8) << 16\n          ); // 68\n          return 6;\n        }\n      }\n      store<u16>(buffer, CharCode.MINUS);\n      // @ts-ignore\n      value = -value;\n    }\n  }\n  let dest = buffer + (sign << 1);\n  if (ASC_SHRINK_LEVEL <= 1) {\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        if (<u32>value < 10) {\n          store<u16>(dest, value | CharCode._0);\n          return 1 + sign;\n        }\n      } else {\n        if (<u64>value < 10) {\n          store<u16>(dest, value | CharCode._0);\n          return 1 + sign;\n        }\n      }\n    } else {\n      if (value < 10) {\n        store<u16>(buffer, value | CharCode._0);\n        return 1;\n      }\n    }\n  }\n  let decimals: u32 = 0;\n  if (sizeof<T>() <= 4) {\n    let val32 = <u32>value;\n    decimals = decimalCount32(val32);\n    utoa32_dec_core(dest, val32, decimals);\n  } else {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32 = <u32>value;\n      decimals = decimalCount32(val32);\n      utoa32_dec_core(dest, val32, decimals);\n    } else {\n      let val64 = <u64>value;\n      decimals = decimalCount64High(val64);\n      utoa64_dec_core(dest, val64, decimals);\n    }\n  }\n  return sign + decimals;\n}\n\nexport function dtoa_buffered<T extends number>(buffer: usize, value: T): u32 {\n  const isSingle = isFloat<T>() && sizeof<T>() == 4;\n  return dtoa_buffered_impl(buffer, value, isSingle);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction dtoa_buffered_impl(buffer: usize, value: f64, isSingle: bool): u32 {\n  if (value == 0) {\n    store<u16>(buffer, CharCode._0);\n    store<u16>(buffer, CharCode.DOT, 2);\n    store<u16>(buffer, CharCode._0,  4);\n    return 3;\n  }\n  if (!isFinite(value)) {\n    if (isNaN(value)) {\n      store<u16>(buffer, CharCode.N);\n      store<u16>(buffer, CharCode.a, 2);\n      store<u16>(buffer, CharCode.N, 4);\n      return 3;\n    } else {\n      let sign = value < 0;\n      if (sign) {\n        store<u16>(buffer, CharCode.MINUS); // -\n        buffer += 2;\n      }\n      store<u64>(buffer, 0x690066006E0049, 0); // ifnI\n      store<u64>(buffer, 0x7900740069006E, 8); // ytin\n      return 8 + u32(sign);\n    }\n  }\n  return dtoa_core(buffer, value, isSingle);\n}\n","//\n// Lookup data for exp2f\n//\n\n// @ts-ignore: decorator\n@inline const EXP2F_TABLE_BITS = 5;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP2F_DATA_TAB = memory.data<u64>([\n  // exp2f_data_tab[i] = uint(2^(i/N)) - (i << 52-BITS)\n  // used for computing 2^(k/N) for an int |k| < 150 N as\n  // double(tab[k%N] + (k << 52-BITS))\n  0x3FF0000000000000, 0x3FEFD9B0D3158574, 0x3FEFB5586CF9890F, 0x3FEF9301D0125B51,\n  0x3FEF72B83C7D517B, 0x3FEF54873168B9AA, 0x3FEF387A6E756238, 0x3FEF1E9DF51FDEE1,\n  0x3FEF06FE0A31B715, 0x3FEEF1A7373AA9CB, 0x3FEEDEA64C123422, 0x3FEECE086061892D,\n  0x3FEEBFDAD5362A27, 0x3FEEB42B569D4F82, 0x3FEEAB07DD485429, 0x3FEEA47EB03A5585,\n  0x3FEEA09E667F3BCD, 0x3FEE9F75E8EC5F74, 0x3FEEA11473EB0187, 0x3FEEA589994CCE13,\n  0x3FEEACE5422AA0DB, 0x3FEEB737B0CDC5E5, 0x3FEEC49182A3F090, 0x3FEED503B23E255D,\n  0x3FEEE89F995AD3AD, 0x3FEEFF76F2FB5E47, 0x3FEF199BDD85529C, 0x3FEF3720DCEF9069,\n  0x3FEF5818DCFBA487, 0x3FEF7C97337B9B5F, 0x3FEFA4AFA2A490DA, 0x3FEFD0765B6E4540\n]);\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-1/64, 1/64] (before rounding.)\n// Wrong count: 168353 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function exp2f_lut(x: f32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N, // 0x1.8p+52\n    Ox127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  let xd = <f64>x;\n  let ix = reinterpret<u32>(x);\n  let ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x430) {\n    // |x| >= 128 or x is nan.\n    if (ix == 0xFF800000) return 0; // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;  // x == Inf/NaN -> Inf/NaN\n    if (x > 0) return x * Ox127f;   // x >     0    -> HugeVal (Owerflow)\n    if (x <= -150) return 0;        // x <= -150    -> 0 (Underflow)\n  }\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)] and int k.\n  let kd = xd + shift;\n  let ki = reinterpret<u64>(kd);\n  let r  = xd - (kd - shift);\n  let t: u64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  y  = C2 * r + 1;\n  y += (C0 * r + C1) * (r  * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-ln2/64, ln2/64] (before rounding.)\n// Wrong count: 170635 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function expf_lut(x: f32): f32 {\n  const\n    N        = 1 << EXP2F_TABLE_BITS,\n    N_MASK   = N - 1,\n    shift    = reinterpret<f64>(0x4338000000000000),        // 0x1.8p+52\n    InvLn2N  = reinterpret<f64>(0x3FF71547652B82FE) * N,    // 0x1.71547652b82fep+0\n    Ox1p127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394) / N / N / N, // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3) / N / N,     // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6) / N;         // 0x1.62e42ff0c52d6p-1\n\n  let xd = <f64>x;\n  let ix = reinterpret<u32>(x);\n  let ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x42B) {\n    // |x| >= 88 or x is nan.\n    if (ix == 0xFF800000) return 0;                            // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;                             // x == Inf/NaN -> Inf/NaN\n    if (x > reinterpret<f32>(0x42B17217)) return x * Ox1p127f; // x > log(0x1p128)  ~=  88.72 -> HugeVal (Owerflow)\n    if (x < reinterpret<f32>(0xC2CFF1B4)) return 0;            // x < log(0x1p-150) ~= -103.97 -> 0 (Underflow)\n  }\n\n  // x*N/Ln2 = k + r with r in [-1/2, 1/2] and int k.\n  let z = InvLn2N * xd;\n\n  // Round and convert z to int, the result is in [-150*N, 128*N] and\n  // ideally ties-to-even rule is used, otherwise the magnitude of r\n  // can be bigger which gives larger approximation error.\n  let kd = <f64>(z + shift);\n  let ki = reinterpret<u64>(kd);\n  let r  = z - (kd - shift);\n  let s: f64, y: f64, t: u64;\n\n  // exp(x) = 2^(k/N) * 2^(r/N) ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for log2f\n//\n\n// @ts-ignore: decorator\n@inline const LOG2F_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2F_DATA_TAB = memory.data<u64>([\n  0x3FF661EC79F8F3BE, 0xBFDEFEC65B963019, // 0x1.661ec79f8f3bep+0, -0x1.efec65b963019p-2,\n  0x3FF571ED4AAF883D, 0xBFDB0B6832D4FCA4, // 0x1.571ed4aaf883dp+0, -0x1.b0b6832d4fca4p-2,\n  0x3FF49539F0F010B0, 0xBFD7418B0A1FB77B, // 0x1.49539f0f010bp+0 , -0x1.7418b0a1fb77bp-2,\n  0x3FF3C995B0B80385, 0xBFD39DE91A6DCF7B, // 0x1.3c995b0b80385p+0, -0x1.39de91a6dcf7bp-2,\n  0x3FF30D190C8864A5, 0xBFD01D9BF3F2B631, // 0x1.30d190c8864a5p+0, -0x1.01d9bf3f2b631p-2,\n  0x3FF25E227B0B8EA0, 0xBFC97C1D1B3B7AF0, // 0x1.25e227b0b8eap+0 , -0x1.97c1d1b3b7afp-3 ,\n  0x3FF1BB4A4A1A343F, 0xBFC2F9E393AF3C9F, // 0x1.1bb4a4a1a343fp+0, -0x1.2f9e393af3c9fp-3,\n  0x3FF12358F08AE5BA, 0xBFB960CBBF788D5C, // 0x1.12358f08ae5bap+0, -0x1.960cbbf788d5cp-4,\n  0x3FF0953F419900A7, 0xBFAA6F9DB6475FCE, // 0x1.0953f419900a7p+0, -0x1.a6f9db6475fcep-5,\n  0x3FF0000000000000, 0,                  // 0x1p+0,                0x0,\n  0x3FEE608CFD9A47AC, 0x3FB338CA9F24F53D, // 0x1.e608cfd9a47acp-1,  0x1.338ca9f24f53dp-4,\n  0x3FECA4B31F026AA0, 0x3FC476A9543891BA, // 0x1.ca4b31f026aap-1 ,  0x1.476a9543891bap-3,\n  0x3FEB2036576AFCE6, 0x3FCE840B4AC4E4D2, // 0x1.b2036576afce6p-1,  0x1.e840b4ac4e4d2p-3,\n  0x3FE9C2D163A1AA2D, 0x3FD40645F0C6651C, // 0x1.9c2d163a1aa2dp-1,  0x1.40645f0c6651cp-2,\n  0x3FE886E6037841ED, 0x3FD88E9C2C1B9FF8, // 0x1.886e6037841edp-1,  0x1.88e9c2c1b9ff8p-2,\n  0x3FE767DCF5534862, 0x3FDCE0A44EB17BCC  // 0x1.767dcf5534862p-1,  0x1.ce0a44eb17bccp-2\n]);\n\n// ULP error: 0.752 (nearest rounding.)\n// Relative error: 1.9 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function log2f_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOG2F_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    A0 = reinterpret<f64>(0xBFD712B6F70A7E4D), // -0x1.712b6f70a7e4dp-2\n    A1 = reinterpret<f64>(0x3FDECABF496832E0), //  0x1.ecabf496832ep-2\n    A2 = reinterpret<f64>(0xBFE715479FFAE3DE), // -0x1.715479ffae3dep-1\n    A3 = reinterpret<f64>(0x3FF715475F35C8B8); //  0x1.715475f35c8b8p0\n\n  let ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && predict_false(ix == 0x3f800000)) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if (ux * 2 == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log2(inf) == inf.\n    if ((ux >> 31) || ux * 2 >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ux - 0x3F330000;\n  let i    = (tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK;\n  let top  = tmp & 0xFF800000;\n  let iz   = ux - top;\n  let k    = <i32>tmp >> 23;\n\n  let invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  let z    = <f64>reinterpret<f32>(iz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  let r  = z * invc - 1;\n  let y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  let y  = A1 * r + A2;\n  let p  = A3 * r + y0;\n  let r2 = r * r;\n  y += A0 * r2;\n  y  = y * r2 + p;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for logf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/logf.c\n//\n\n// @ts-ignore: decorator\n@inline const LOGF_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOGF_DATA_TAB = memory.data<u64>([\n  0x3FF661EC79F8F3BE, 0xBFD57BF7808CAADE, // 0x1.661ec79f8f3bep+0, -0x1.57bf7808caadep-2,\n  0x3FF571ED4AAF883D, 0xBFD2BEF0A7C06DDB, // 0x1.571ed4aaf883dp+0, -0x1.2bef0a7c06ddbp-2,\n  0x3FF49539F0F010B0, 0xBFD01EAE7F513A67, // 0x1.49539f0f010bp+0 , -0x1.01eae7f513a67p-2,\n  0x3FF3C995B0B80385, 0xBFCB31D8A68224E9, // 0x1.3c995b0b80385p+0, -0x1.b31d8a68224e9p-3,\n  0x3FF30D190C8864A5, 0xBFC6574F0AC07758, // 0x1.30d190c8864a5p+0, -0x1.6574f0ac07758p-3,\n  0x3FF25E227B0B8EA0, 0xBFC1AA2BC79C8100, // 0x1.25e227b0b8eap+0 , -0x1.1aa2bc79c81p-3  ,\n  0x3FF1BB4A4A1A343F, 0xBFBA4E76CE8C0E5E, // 0x1.1bb4a4a1a343fp+0, -0x1.a4e76ce8c0e5ep-4,\n  0x3FF12358F08AE5BA, 0xBFB1973C5A611CCC, // 0x1.12358f08ae5bap+0, -0x1.1973c5a611cccp-4,\n  0x3FF0953F419900A7, 0xBFA252F438E10C1E, // 0x1.0953f419900a7p+0, -0x1.252f438e10c1ep-5,\n  0x3FF0000000000000, 0,                  // 0x1p+0,                0,\n  0x3FEE608CFD9A47AC, 0x3FAAA5AA5DF25984, // 0x1.e608cfd9a47acp-1,  0x1.aa5aa5df25984p-5,\n  0x3FECA4B31F026AA0, 0x3FBC5E53AA362EB4, // 0x1.ca4b31f026aap-1 ,  0x1.c5e53aa362eb4p-4,\n  0x3FEB2036576AFCE6, 0x3FC526E57720DB08, // 0x1.b2036576afce6p-1,  0x1.526e57720db08p-3,\n  0x3FE9C2D163A1AA2D, 0x3FCBC2860D224770, // 0x1.9c2d163a1aa2dp-1,  0x1.bc2860d22477p-3 ,\n  0x3FE886E6037841ED, 0x3FD1058BC8A07EE1, // 0x1.886e6037841edp-1,  0x1.1058bc8a07ee1p-2,\n  0x3FE767DCF5534862, 0x3FD4043057B6EE09  // 0x1.767dcf5534862p-1,  0x1.4043057b6ee09p-2\n]);\n\n// ULP error: 0.818 (nearest rounding.)\n// Relative error: 1.957 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function logf_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOGF_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    Ln2 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1;\n    A0  = reinterpret<f64>(0xBFD00EA348B88334), // -0x1.00ea348b88334p-2\n    A1  = reinterpret<f64>(0x3FD5575B0BE00B6A), //  0x1.5575b0be00b6ap-2\n    A2  = reinterpret<f64>(0xBFDFFFFEF20A4123); // -0x1.ffffef20a4123p-2\n\n  let ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && ux == 0x3f800000) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if ((ux << 1) == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log(inf) == inf.\n    if ((ux >> 31) || (ux << 1) >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp = ux - 0x3F330000;\n  let i   = (tmp >> (23 - LOGF_TABLE_BITS)) & N_MASK;\n  let k   = <i32>tmp >> 23;\n  let iz  = ux - (tmp & 0x1FF << 23);\n\n  let invc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n\n  let z = <f64>reinterpret<f32>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2\n  let r = z * invc - 1;\n  let y0 = logc + <f64>k * Ln2;\n\n  // Pipelined polynomial evaluation to approximate log1p(r).\n  let r2 = r * r;\n  let y  = A1 * r + A2;\n  y += A0 * r2;\n  y = y * r2 + (y0 + r);\n\n  return <f32>y;\n}\n\n//\n// Lookup data for powf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/powf.c\n//\n\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnanf(ux: u32): bool {\n  return (ux << 1) - 1 >= (<u32>0x7f800000 << 1) - 1;\n}\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkintf(iy: u32): i32 {\n  let e = iy >> 23 & 0xFF;\n  if (e < 0x7F     ) return 0;\n  if (e > 0x7F + 23) return 2;\n  e = 1 << (0x7F + 23 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// Subnormal input is normalized so ix has negative biased exponent.\n// Output is multiplied by N (POWF_SCALE) if TOINT_INTRINICS is set.\n// @ts-ignore: decorator\n@inline\nfunction log2f_inline(ux: u32): f64 {\n  const N_MASK = (1 << LOG2F_TABLE_BITS) - 1;\n\n  const\n    A0 = reinterpret<f64>(0x3FD27616C9496E0B), //  0x1.27616c9496e0bp-2\n    A1 = reinterpret<f64>(0xBFD71969A075C67A), // -0x1.71969a075c67ap-2\n    A2 = reinterpret<f64>(0x3FDEC70A6CA7BADD), //  0x1.ec70a6ca7baddp-2\n    A3 = reinterpret<f64>(0xBFE7154748BEF6C8), // -0x1.7154748bef6c8p-1\n    A4 = reinterpret<f64>(0x3FF71547652AB82B); //  0x1.71547652ab82bp+0\n\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ux - 0x3F330000;\n  let i    = usize((tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK);\n  let top  = tmp & 0xFF800000;\n  let uz   = ux - top;\n  let k    = <i32>top >> 23;\n\n  let invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  let z    = <f64>reinterpret<f32>(uz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  let r  = z * invc - 1;\n  let y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  let y = A0 * r + A1;\n  let p = A2 * r + A3;\n  let q = A4 * r + y0;\n\n  r *= r;\n  q += p * r;\n  y  = y * (r * r) + q;\n\n  return y;\n}\n\n// The output of log2 and thus the input of exp2 is either scaled by N\n// (in case of fast toint intrinsics) or not.  The unscaled xd must be\n// in [-1021,1023], sign_bias sets the sign of the result.\n// @ts-ignore: decorator\n@inline\nfunction exp2f_inline(xd: f64, signBias: u32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p+52\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)]\n  let kd = <f64>(xd + shift);\n  let ki = reinterpret<u64>(kd);\n  let r  = xd - (kd - shift);\n  let t: u64, z: f64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += (ki + signBias) << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n  return <f32>y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflowf(sign: u32, y: f32): f32 {\n  return select<f32>(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x70000000)); // 0x1p97f\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x10000000)); // 0x1p-95f\n}\n\n// @ts-ignore: decorator\n@inline\nexport function powf_lut(x: f32, y: f32): f32 {\n  const\n    Ox1p23f     = reinterpret<f32>(0x4B000000), // 0x1p23f\n    UPPER_LIMIT = reinterpret<f64>(0x405FFFFFFFD1D571), // 0x1.fffffffd1d571p+6\n    LOWER_LIMIT = -150.0,\n    SIGN_BIAS   = 1 << (EXP2F_TABLE_BITS + 11);\n\n  let signBias: u32 = 0;\n  let ix = reinterpret<u32>(x);\n  let iy = reinterpret<u32>(y);\n  let ny = 0;\n\n  if (i32(ix - 0x00800000 >= 0x7f800000 - 0x00800000) | (ny = i32(zeroinfnanf(iy)))) {\n    // Either (x < 0x1p-126 or inf or nan) or (y is 0 or inf or nan).\n    if (ny) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3F800000) return NaN; // original: 1.0\n      if ((ix << 1) > (<u32>0x7F800000 << 1) || (iy << 1) > (<u32>0x7F800000 << 1)) return x + y;\n      if ((ix << 1) == (0x3F800000 << 1)) return NaN; // original: 1.0\n      if (((ix << 1) < (0x3F800000 << 1)) == !(iy >> 31)) return 0; // |x| < 1 && y==inf or |x| > 1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnanf(ix)) {\n      let x2 = x * x;\n      if ((ix >> 31) && checkintf(iy) == 1) x2 = -x2;\n      return <i32>iy < 0 ? 1 / x2 : x2;\n    }\n    // x and y are non-zero finite.\n    if (<i32>ix < 0) {\n      // Finite x < 0.\n      let yint = checkintf(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) signBias = SIGN_BIAS;\n      ix &= 0x7FFFFFFF;\n    }\n    if (ix < 0x00800000) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u32>(x * Ox1p23f);\n      ix &= 0x7FFFFFFF;\n      ix -= 23 << 23;\n    }\n  }\n  let logx = log2f_inline(ix);\n  let ylogx = y * logx; // cannot overflow, y is single prec.\n  if ((reinterpret<u64>(ylogx) >> 47 & 0xFFFF) >= 0x80BF) { // reinterpret<u64>(126.0) >> 47\n    // |y * log(x)| >= 126\n    if (ylogx  > UPPER_LIMIT) return oflowf(signBias); // overflow\n    if (ylogx <= LOWER_LIMIT) return uflowf(signBias); // underflow\n  }\n  return exp2f_inline(ylogx, signBias);\n}\n\n//\n// Lookup data for exp. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp.c\n//\n\n// @ts-ignore: decorator\n@inline const EXP_TABLE_BITS = 7;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_DATA_TAB = memory.data<u64>([\n  0x0000000000000000, 0x3FF0000000000000,\n  0x3C9B3B4F1A88BF6E, 0x3FEFF63DA9FB3335,\n  0xBC7160139CD8DC5D, 0x3FEFEC9A3E778061,\n  0xBC905E7A108766D1, 0x3FEFE315E86E7F85,\n  0x3C8CD2523567F613, 0x3FEFD9B0D3158574,\n  0xBC8BCE8023F98EFA, 0x3FEFD06B29DDF6DE,\n  0x3C60F74E61E6C861, 0x3FEFC74518759BC8,\n  0x3C90A3E45B33D399, 0x3FEFBE3ECAC6F383,\n  0x3C979AA65D837B6D, 0x3FEFB5586CF9890F,\n  0x3C8EB51A92FDEFFC, 0x3FEFAC922B7247F7,\n  0x3C3EBE3D702F9CD1, 0x3FEFA3EC32D3D1A2,\n  0xBC6A033489906E0B, 0x3FEF9B66AFFED31B,\n  0xBC9556522A2FBD0E, 0x3FEF9301D0125B51,\n  0xBC5080EF8C4EEA55, 0x3FEF8ABDC06C31CC,\n  0xBC91C923B9D5F416, 0x3FEF829AAEA92DE0,\n  0x3C80D3E3E95C55AF, 0x3FEF7A98C8A58E51,\n  0xBC801B15EAA59348, 0x3FEF72B83C7D517B,\n  0xBC8F1FF055DE323D, 0x3FEF6AF9388C8DEA,\n  0x3C8B898C3F1353BF, 0x3FEF635BEB6FCB75,\n  0xBC96D99C7611EB26, 0x3FEF5BE084045CD4,\n  0x3C9AECF73E3A2F60, 0x3FEF54873168B9AA,\n  0xBC8FE782CB86389D, 0x3FEF4D5022FCD91D,\n  0x3C8A6F4144A6C38D, 0x3FEF463B88628CD6,\n  0x3C807A05B0E4047D, 0x3FEF3F49917DDC96,\n  0x3C968EFDE3A8A894, 0x3FEF387A6E756238,\n  0x3C875E18F274487D, 0x3FEF31CE4FB2A63F,\n  0x3C80472B981FE7F2, 0x3FEF2B4565E27CDD,\n  0xBC96B87B3F71085E, 0x3FEF24DFE1F56381,\n  0x3C82F7E16D09AB31, 0x3FEF1E9DF51FDEE1,\n  0xBC3D219B1A6FBFFA, 0x3FEF187FD0DAD990,\n  0x3C8B3782720C0AB4, 0x3FEF1285A6E4030B,\n  0x3C6E149289CECB8F, 0x3FEF0CAFA93E2F56,\n  0x3C834D754DB0ABB6, 0x3FEF06FE0A31B715,\n  0x3C864201E2AC744C, 0x3FEF0170FC4CD831,\n  0x3C8FDD395DD3F84A, 0x3FEEFC08B26416FF,\n  0xBC86A3803B8E5B04, 0x3FEEF6C55F929FF1,\n  0xBC924AEDCC4B5068, 0x3FEEF1A7373AA9CB,\n  0xBC9907F81B512D8E, 0x3FEEECAE6D05D866,\n  0xBC71D1E83E9436D2, 0x3FEEE7DB34E59FF7,\n  0xBC991919B3CE1B15, 0x3FEEE32DC313A8E5,\n  0x3C859F48A72A4C6D, 0x3FEEDEA64C123422,\n  0xBC9312607A28698A, 0x3FEEDA4504AC801C,\n  0xBC58A78F4817895B, 0x3FEED60A21F72E2A,\n  0xBC7C2C9B67499A1B, 0x3FEED1F5D950A897,\n  0x3C4363ED60C2AC11, 0x3FEECE086061892D,\n  0x3C9666093B0664EF, 0x3FEECA41ED1D0057,\n  0x3C6ECCE1DAA10379, 0x3FEEC6A2B5C13CD0,\n  0x3C93FF8E3F0F1230, 0x3FEEC32AF0D7D3DE,\n  0x3C7690CEBB7AAFB0, 0x3FEEBFDAD5362A27,\n  0x3C931DBDEB54E077, 0x3FEEBCB299FDDD0D,\n  0xBC8F94340071A38E, 0x3FEEB9B2769D2CA7,\n  0xBC87DECCDC93A349, 0x3FEEB6DAA2CF6642,\n  0xBC78DEC6BD0F385F, 0x3FEEB42B569D4F82,\n  0xBC861246EC7B5CF6, 0x3FEEB1A4CA5D920F,\n  0x3C93350518FDD78E, 0x3FEEAF4736B527DA,\n  0x3C7B98B72F8A9B05, 0x3FEEAD12D497C7FD,\n  0x3C9063E1E21C5409, 0x3FEEAB07DD485429,\n  0x3C34C7855019C6EA, 0x3FEEA9268A5946B7,\n  0x3C9432E62B64C035, 0x3FEEA76F15AD2148,\n  0xBC8CE44A6199769F, 0x3FEEA5E1B976DC09,\n  0xBC8C33C53BEF4DA8, 0x3FEEA47EB03A5585,\n  0xBC845378892BE9AE, 0x3FEEA34634CCC320,\n  0xBC93CEDD78565858, 0x3FEEA23882552225,\n  0x3C5710AA807E1964, 0x3FEEA155D44CA973,\n  0xBC93B3EFBF5E2228, 0x3FEEA09E667F3BCD,\n  0xBC6A12AD8734B982, 0x3FEEA012750BDABF,\n  0xBC6367EFB86DA9EE, 0x3FEE9FB23C651A2F,\n  0xBC80DC3D54E08851, 0x3FEE9F7DF9519484,\n  0xBC781F647E5A3ECF, 0x3FEE9F75E8EC5F74,\n  0xBC86EE4AC08B7DB0, 0x3FEE9F9A48A58174,\n  0xBC8619321E55E68A, 0x3FEE9FEB564267C9,\n  0x3C909CCB5E09D4D3, 0x3FEEA0694FDE5D3F,\n  0xBC7B32DCB94DA51D, 0x3FEEA11473EB0187,\n  0x3C94ECFD5467C06B, 0x3FEEA1ED0130C132,\n  0x3C65EBE1ABD66C55, 0x3FEEA2F336CF4E62,\n  0xBC88A1C52FB3CF42, 0x3FEEA427543E1A12,\n  0xBC9369B6F13B3734, 0x3FEEA589994CCE13,\n  0xBC805E843A19FF1E, 0x3FEEA71A4623C7AD,\n  0xBC94D450D872576E, 0x3FEEA8D99B4492ED,\n  0x3C90AD675B0E8A00, 0x3FEEAAC7D98A6699,\n  0x3C8DB72FC1F0EAB4, 0x3FEEACE5422AA0DB,\n  0xBC65B6609CC5E7FF, 0x3FEEAF3216B5448C,\n  0x3C7BF68359F35F44, 0x3FEEB1AE99157736,\n  0xBC93091FA71E3D83, 0x3FEEB45B0B91FFC6,\n  0xBC5DA9B88B6C1E29, 0x3FEEB737B0CDC5E5,\n  0xBC6C23F97C90B959, 0x3FEEBA44CBC8520F,\n  0xBC92434322F4F9AA, 0x3FEEBD829FDE4E50,\n  0xBC85CA6CD7668E4B, 0x3FEEC0F170CA07BA,\n  0x3C71AFFC2B91CE27, 0x3FEEC49182A3F090,\n  0x3C6DD235E10A73BB, 0x3FEEC86319E32323,\n  0xBC87C50422622263, 0x3FEECC667B5DE565,\n  0x3C8B1C86E3E231D5, 0x3FEED09BEC4A2D33,\n  0xBC91BBD1D3BCBB15, 0x3FEED503B23E255D,\n  0x3C90CC319CEE31D2, 0x3FEED99E1330B358,\n  0x3C8469846E735AB3, 0x3FEEDE6B5579FDBF,\n  0xBC82DFCD978E9DB4, 0x3FEEE36BBFD3F37A,\n  0x3C8C1A7792CB3387, 0x3FEEE89F995AD3AD,\n  0xBC907B8F4AD1D9FA, 0x3FEEEE07298DB666,\n  0xBC55C3D956DCAEBA, 0x3FEEF3A2B84F15FB,\n  0xBC90A40E3DA6F640, 0x3FEEF9728DE5593A,\n  0xBC68D6F438AD9334, 0x3FEEFF76F2FB5E47,\n  0xBC91EEE26B588A35, 0x3FEF05B030A1064A,\n  0x3C74FFD70A5FDDCD, 0x3FEF0C1E904BC1D2,\n  0xBC91BDFBFA9298AC, 0x3FEF12C25BD71E09,\n  0x3C736EAE30AF0CB3, 0x3FEF199BDD85529C,\n  0x3C8EE3325C9FFD94, 0x3FEF20AB5FFFD07A,\n  0x3C84E08FD10959AC, 0x3FEF27F12E57D14B,\n  0x3C63CDAF384E1A67, 0x3FEF2F6D9406E7B5,\n  0x3C676B2C6C921968, 0x3FEF3720DCEF9069,\n  0xBC808A1883CCB5D2, 0x3FEF3F0B555DC3FA,\n  0xBC8FAD5D3FFFFA6F, 0x3FEF472D4A07897C,\n  0xBC900DAE3875A949, 0x3FEF4F87080D89F2,\n  0x3C74A385A63D07A7, 0x3FEF5818DCFBA487,\n  0xBC82919E2040220F, 0x3FEF60E316C98398,\n  0x3C8E5A50D5C192AC, 0x3FEF69E603DB3285,\n  0x3C843A59AC016B4B, 0x3FEF7321F301B460,\n  0xBC82D52107B43E1F, 0x3FEF7C97337B9B5F,\n  0xBC892AB93B470DC9, 0x3FEF864614F5A129,\n  0x3C74B604603A88D3, 0x3FEF902EE78B3FF6,\n  0x3C83C5EC519D7271, 0x3FEF9A51FBC74C83,\n  0xBC8FF7128FD391F0, 0x3FEFA4AFA2A490DA,\n  0xBC8DAE98E223747D, 0x3FEFAF482D8E67F1,\n  0x3C8EC3BC41AA2008, 0x3FEFBA1BEE615A27,\n  0x3C842B94C3A9EB32, 0x3FEFC52B376BBA97,\n  0x3C8A64A931D185EE, 0x3FEFD0765B6E4540,\n  0xBC8E37BAE43BE3ED, 0x3FEFDBFDAD9CBE14,\n  0x3C77893B4D91CD9D, 0x3FEFE7C1819E90D8,\n  0x3C5305C14160CC89, 0x3FEFF3C22B8F71F1\n]);\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding. The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase(tmp: f64, sbits: u64, ki: u64): f64 {\n  const\n    Ox1p_1022 = reinterpret<f64>(0x0010000000000000), // 0x1p-1022\n    Ox1p1009  = reinterpret<f64>(0x7F00000000000000); // 0x1p1009\n\n  let scale: f64;\n  if (!(ki & 0x80000000)) {\n    // k > 0, the exponent of scale might have overflowed by <= 460.\n    sbits -= u64(1009) << 52;\n    scale = reinterpret<f64>(sbits);\n    return Ox1p1009 * (scale + scale * tmp); // 0x1p1009\n  }\n  // k < 0, need special care in the subnormal range.\n  sbits += u64(1022) << 52;\n  // Note: sbits is signed scale.\n  scale = reinterpret<f64>(sbits);\n  let y = scale + scale * tmp;\n  if (abs(y) < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range.  So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let one = copysign(1.0, y);\n    let lo = scale - y + scale * tmp;\n    let hi = one + y;\n    lo = one - hi + y + lo;\n    y  = (hi + lo) - one;\n    // Fix the sign of 0.\n    if (y == 0.0) y = reinterpret<f64>(sbits & 0x8000000000000000);\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52;\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  let ux = reinterpret<u64>(x);\n  let abstop = u32(ux >> 52) & 0x7FF;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) {\n        return 1.0 + x;\n      } else {\n        return select<f64>(0, Infinity, <i64>ux < 0);\n      }\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)]\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N]\n  let z = InvLn2N * x;\n  // #if TOINT_INTRINSICS\n  // \tkd = roundtoint(z);\n  // \tki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  // \t// z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  // let kd = z + shift;\n  // let ki = reinterpret<u64>(kd) >> 16;\n  // let kd = <f64><i32>ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes.\n  let kd = z + shift;\n  let ki = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  let r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // 2^(k/N) ~= scale * (1 + tail).\n  let idx = usize((ki & N_MASK) << 1);\n  let top = ki << (52 - EXP_TABLE_BITS);\n\n  let tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()))); // T[idx]\n  // This is only a valid scale when -1023*N < k < 1024*N\n  let sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  let r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp.\n  let tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  let scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n//\n// Lookup data for exp2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp2.c\n//\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding.  The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase2(tmp: f64, sbits: u64, ki: u64): f64 {\n  const Ox1p_1022 = reinterpret<f64>(0x10000000000000); // 0x1p-1022\n  let scale: f64;\n  if ((ki & 0x80000000) == 0) {\n    // k > 0, the exponent of scale might have overflowed by 1\n    sbits -= u64(1) << 52;\n    scale = reinterpret<f64>(sbits);\n    return 2 * (scale * tmp + scale);\n  }\n  // k < 0, need special care in the subnormal range\n  sbits += u64(1022) << 52;\n  scale = reinterpret<f64>(sbits);\n  let y = scale * tmp + scale;\n  if (y < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range. So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let hi: f64, lo: f64;\n    lo = scale - y + scale * tmp;\n    hi = 1.0 + y;\n    lo = 1.0 - hi + y + lo;\n    y = (hi + lo) - 1.0;\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp2_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p52\n\n  const\n    C1 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1\n    C2 = reinterpret<f64>(0x3FCEBFBDFF82C424), // 0x1.ebfbdff82c424p-3\n    C3 = reinterpret<f64>(0x3FAC6B08D70CF4B5), // 0x1.c6b08d70cf4b5p-5\n    C4 = reinterpret<f64>(0x3F83B2ABD24650CC), // 0x1.3b2abd24650ccp-7\n    C5 = reinterpret<f64>(0x3F55D7E09B4E3A84); // 0x1.5d7e09b4e3a84p-10\n\n  let ux = reinterpret<u64>(x);\n  let abstop = u32(ux >> 52) & 0x7ff;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1.0;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) return 1.0 + x;\n      if (<i64>ux >= 0) return Infinity;\n      else if (ux >= 0xC090CC0000000000) return 0;\n    }\n    if ((ux << 1) > 0x811A000000000000) abstop = 0; // Large x is special cased below.\n  }\n\n  // exp2(x) = 2^(k/N) * 2^r, with 2^r in [2^(-1/2N),2^(1/2N)].\n  // x = k/N + r, with int k and r in [-1/2N, 1/2N]\n  let kd = x + shift;\n  let ki = reinterpret<u64>(kd);\n  kd -= shift; // k/N for int k\n  let r = x - kd;\n  // 2^(k/N) ~= scale * (1 + tail)\n  let idx = usize((ki & N_MASK) << 1);\n  let top = ki << (52 - EXP_TABLE_BITS);\n\n  let tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 0 << alignof<u64>())); // T[idx])\n  // This is only a valid scale when -1023*N < k < 1024*N\n  let sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp2(x) = 2^(k/N) * 2^r ~= scale + scale * (tail + 2^r - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution\n  let r2 = r * r;\n  // Without fma the worst case error is 0.5/N ulp larger.\n  // Worst case error is less than 0.5+0.86/N+(abs poly error * 2^53) ulp.\n  let tmp = tail + r * C1 + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase2(tmp, sbits, ki);\n  let scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-65 and scale > 2^-928, so there\n  // is no spurious underflow here even without fma.\n  return scale * tmp + scale;\n}\n\n//\n// Lookup data for log2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log2.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG2_TABLE_BITS = 6;\n\n/* Algorithm:\n\n  x = 2^k z\n  log2(x) = k + log2(c) + log2(z/c)\n  log2(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log2(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p10 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-64 and\n  3) the rounding error in (double)log2(c) is minimized (< 0x1p-68).\n\nNote: 1) ensures that k + logc can be computed without rounding error, 2)\nensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to a\nsingle rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log2(x)| < 0x1p-4, this is not enough so that is special cased. */\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB1 = memory.data<u64>([\n  //     invc       ,        logc\n  0x3FF724286BB1ACF8, 0xBFE1095FEECDB000,\n  0x3FF6E1F766D2CCA1, 0xBFE08494BD76D000,\n  0x3FF6A13D0E30D48A, 0xBFE00143AEE8F800,\n  0x3FF661EC32D06C85, 0xBFDEFEC5360B4000,\n  0x3FF623FA951198F8, 0xBFDDFDD91AB7E000,\n  0x3FF5E75BA4CF026C, 0xBFDCFFAE0CC79000,\n  0x3FF5AC055A214FB8, 0xBFDC043811FDA000,\n  0x3FF571ED0F166E1E, 0xBFDB0B67323AE000,\n  0x3FF53909590BF835, 0xBFDA152F5A2DB000,\n  0x3FF5014FED61ADDD, 0xBFD9217F5AF86000,\n  0x3FF4CAB88E487BD0, 0xBFD8304DB0719000,\n  0x3FF49539B4334FEE, 0xBFD74189F9A9E000,\n  0x3FF460CBDFAFD569, 0xBFD6552BB5199000,\n  0x3FF42D664EE4B953, 0xBFD56B23A29B1000,\n  0x3FF3FB01111DD8A6, 0xBFD483650F5FA000,\n  0x3FF3C995B70C5836, 0xBFD39DE937F6A000,\n  0x3FF3991C4AB6FD4A, 0xBFD2BAA1538D6000,\n  0x3FF3698E0CE099B5, 0xBFD1D98340CA4000,\n  0x3FF33AE48213E7B2, 0xBFD0FA853A40E000,\n  0x3FF30D191985BDB1, 0xBFD01D9C32E73000,\n  0x3FF2E025CAB271D7, 0xBFCE857DA2FA6000,\n  0x3FF2B404CF13CD82, 0xBFCCD3C8633D8000,\n  0x3FF288B02C7CCB50, 0xBFCB26034C14A000,\n  0x3FF25E2263944DE5, 0xBFC97C1C2F4FE000,\n  0x3FF234563D8615B1, 0xBFC7D6023F800000,\n  0x3FF20B46E33EAF38, 0xBFC633A71A05E000,\n  0x3FF1E2EEFDCDA3DD, 0xBFC494F5E9570000,\n  0x3FF1BB4A580B3930, 0xBFC2F9E424E0A000,\n  0x3FF19453847F2200, 0xBFC162595AFDC000,\n  0x3FF16E06C0D5D73C, 0xBFBF9C9A75BD8000,\n  0x3FF1485F47B7E4C2, 0xBFBC7B575BF9C000,\n  0x3FF12358AD0085D1, 0xBFB960C60FF48000,\n  0x3FF0FEF00F532227, 0xBFB64CE247B60000,\n  0x3FF0DB2077D03A8F, 0xBFB33F78B2014000,\n  0x3FF0B7E6D65980D9, 0xBFB0387D1A42C000,\n  0x3FF0953EFE7B408D, 0xBFAA6F9208B50000,\n  0x3FF07325CAC53B83, 0xBFA47A954F770000,\n  0x3FF05197E40D1B5C, 0xBF9D23A8C50C0000,\n  0x3FF03091C1208EA2, 0xBF916A2629780000,\n  0x3FF0101025B37E21, 0xBF7720F8D8E80000,\n  0x3FEFC07EF9CAA76B, 0x3F86FE53B1500000,\n  0x3FEF4465D3F6F184, 0x3FA11CCCE10F8000,\n  0x3FEECC079F84107F, 0x3FAC4DFC8C8B8000,\n  0x3FEE573A99975AE8, 0x3FB3AA321E574000,\n  0x3FEDE5D6F0BD3DE6, 0x3FB918A0D08B8000,\n  0x3FED77B681FF38B3, 0x3FBE72E9DA044000,\n  0x3FED0CB5724DE943, 0x3FC1DCD2507F6000,\n  0x3FECA4B2DC0E7563, 0x3FC476AB03DEA000,\n  0x3FEC3F8EE8D6CB51, 0x3FC7074377E22000,\n  0x3FEBDD2B4F020C4C, 0x3FC98EDE8BA94000,\n  0x3FEB7D6C006015CA, 0x3FCC0DB86AD2E000,\n  0x3FEB20366E2E338F, 0x3FCE840AAFCEE000,\n  0x3FEAC57026295039, 0x3FD0790AB4678000,\n  0x3FEA6D01BC2731DD, 0x3FD1AC056801C000,\n  0x3FEA16D3BC3FF18B, 0x3FD2DB11D4FEE000,\n  0x3FE9C2D14967FEAD, 0x3FD406464EC58000,\n  0x3FE970E4F47C9902, 0x3FD52DBE093AF000,\n  0x3FE920FB3982BCF2, 0x3FD651902050D000,\n  0x3FE8D30187F759F1, 0x3FD771D2CDEAF000,\n  0x3FE886E5EBB9F66D, 0x3FD88E9C857D9000,\n  0x3FE83C97B658B994, 0x3FD9A80155E16000,\n  0x3FE7F405FFC61022, 0x3FDABE186ED3D000,\n  0x3FE7AD22181415CA, 0x3FDBD0F2AEA0E000,\n  0x3FE767DCF99EFF8C, 0x3FDCE0A43DBF4000\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB2 = memory.data<u64>([\n  //      chi       ,         clo\n  0x3FE6200012B90A8E, 0x3C8904AB0644B605,\n  0x3FE66000045734A6, 0x3C61FF9BEA62F7A9,\n  0x3FE69FFFC325F2C5, 0x3C827ECFCB3C90BA,\n  0x3FE6E00038B95A04, 0x3C88FF8856739326,\n  0x3FE71FFFE09994E3, 0x3C8AFD40275F82B1,\n  0x3FE7600015590E10, 0xBC72FD75B4238341,\n  0x3FE7A00012655BD5, 0x3C7808E67C242B76,\n  0x3FE7E0003259E9A6, 0xBC6208E426F622B7,\n  0x3FE81FFFEDB4B2D2, 0xBC8402461EA5C92F,\n  0x3FE860002DFAFCC3, 0x3C6DF7F4A2F29A1F,\n  0x3FE89FFFF78C6B50, 0xBC8E0453094995FD,\n  0x3FE8E00039671566, 0xBC8A04F3BEC77B45,\n  0x3FE91FFFE2BF1745, 0xBC77FA34400E203C,\n  0x3FE95FFFCC5C9FD1, 0xBC76FF8005A0695D,\n  0x3FE9A0003BBA4767, 0x3C70F8C4C4EC7E03,\n  0x3FE9DFFFE7B92DA5, 0x3C8E7FD9478C4602,\n  0x3FEA1FFFD72EFDAF, 0xBC6A0C554DCDAE7E,\n  0x3FEA5FFFDE04FF95, 0x3C867DA98CE9B26B,\n  0x3FEA9FFFCA5E8D2B, 0xBC8284C9B54C13DE,\n  0x3FEADFFFDDAD03EA, 0x3C5812C8EA602E3C,\n  0x3FEB1FFFF10D3D4D, 0xBC8EFADDAD27789C,\n  0x3FEB5FFFCE21165A, 0x3C53CB1719C61237,\n  0x3FEB9FFFD950E674, 0x3C73F7D94194CE00,\n  0x3FEBE000139CA8AF, 0x3C750AC4215D9BC0,\n  0x3FEC20005B46DF99, 0x3C6BEEA653E9C1C9,\n  0x3FEC600040B9F7AE, 0xBC7C079F274A70D6,\n  0x3FECA0006255FD8A, 0xBC7A0B4076E84C1F,\n  0x3FECDFFFD94C095D, 0x3C88F933F99AB5D7,\n  0x3FED1FFFF975D6CF, 0xBC582C08665FE1BE,\n  0x3FED5FFFA2561C93, 0xBC7B04289BD295F3,\n  0x3FED9FFF9D228B0C, 0x3C870251340FA236,\n  0x3FEDE00065BC7E16, 0xBC75011E16A4D80C,\n  0x3FEE200002F64791, 0x3C89802F09EF62E0,\n  0x3FEE600057D7A6D8, 0xBC7E0B75580CF7FA,\n  0x3FEEA00027EDC00C, 0xBC8C848309459811,\n  0x3FEEE0006CF5CB7C, 0xBC8F8027951576F4,\n  0x3FEF2000782B7DCC, 0xBC8F81D97274538F,\n  0x3FEF6000260C450A, 0xBC4071002727FFDC,\n  0x3FEF9FFFE88CD533, 0xBC581BDCE1FDA8B0,\n  0x3FEFDFFFD50F8689, 0x3C87F91ACB918E6E,\n  0x3FF0200004292367, 0x3C9B7FF365324681,\n  0x3FF05FFFE3E3D668, 0x3C86FA08DDAE957B,\n  0x3FF0A0000A85A757, 0xBC57E2DE80D3FB91,\n  0x3FF0E0001A5F3FCC, 0xBC91823305C5F014,\n  0x3FF11FFFF8AFBAF5, 0xBC8BFABB6680BAC2,\n  0x3FF15FFFE54D91AD, 0xBC9D7F121737E7EF,\n  0x3FF1A00011AC36E1, 0x3C9C000A0516F5FF,\n  0x3FF1E00019C84248, 0xBC9082FBE4DA5DA0,\n  0x3FF220000FFE5E6E, 0xBC88FDD04C9CFB43,\n  0x3FF26000269FD891, 0x3C8CFE2A7994D182,\n  0x3FF2A00029A6E6DA, 0xBC700273715E8BC5,\n  0x3FF2DFFFE0293E39, 0x3C9B7C39DAB2A6F9,\n  0x3FF31FFFF7DCF082, 0x3C7DF1336EDC5254,\n  0x3FF35FFFF05A8B60, 0xBC9E03564CCD31EB,\n  0x3FF3A0002E0EAECC, 0x3C75F0E74BD3A477,\n  0x3FF3E000043BB236, 0x3C9C7DCB149D8833,\n  0x3FF4200002D187FF, 0x3C7E08AFCF2D3D28,\n  0x3FF460000D387CB1, 0x3C820837856599A6,\n  0x3FF4A00004569F89, 0xBC89FA5C904FBCD2,\n  0x3FF4E000043543F3, 0xBC781125ED175329,\n  0x3FF51FFFCC027F0F, 0x3C9883D8847754DC,\n  0x3FF55FFFFD87B36F, 0xBC8709E731D02807,\n  0x3FF59FFFF21DF7BA, 0x3C87F79F68727B02,\n  0x3FF5DFFFEBFC3481, 0xBC9180902E30E93E\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log2_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG2_TABLE_BITS) - 1;\n\n  const\n    LO: u64 = 0x3FEEA4AF00000000, // reinterpret<u64>(1.0 - 0x1.5b51p-5)\n    HI: u64 = 0x3FF0B55900000000; // reinterpret<u64>(1.0 + 0x1.6ab2p-5)\n\n  const\n    InvLn2hi = reinterpret<f64>(0x3FF7154765200000), // 0x1.7154765200000p+0\n    InvLn2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 0x1.705fc2eefa200p-33\n    Ox1p52   = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  const\n    B0 = reinterpret<f64>(0xBFE71547652B82FE), // -0x1.71547652b82fep-1\n    B1 = reinterpret<f64>(0x3FDEC709DC3A03F7), //  0x1.ec709dc3a03f7p-2\n    B2 = reinterpret<f64>(0xBFD71547652B7C3F), // -0x1.71547652b7c3fp-2\n    B3 = reinterpret<f64>(0x3FD2776C50F05BE4), //  0x1.2776c50f05be4p-2\n    B4 = reinterpret<f64>(0xBFCEC709DD768FE5), // -0x1.ec709dd768fe5p-3\n    B5 = reinterpret<f64>(0x3FCA61761EC4E736), //  0x1.a61761ec4e736p-3\n    B6 = reinterpret<f64>(0xBFC7153FBC64A79B), // -0x1.7153fbc64a79bp-3\n    B7 = reinterpret<f64>(0x3FC484D154F01B4A), //  0x1.484d154f01b4ap-3\n    B8 = reinterpret<f64>(0xBFC289E4A72C383C), // -0x1.289e4a72c383cp-3\n    B9 = reinterpret<f64>(0x3FC0B32F285AEE66); //  0x1.0b32f285aee66p-3\n\n  const\n    A0 = reinterpret<f64>(0xBFE71547652B8339), // -0x1.71547652b8339p-1\n    A1 = reinterpret<f64>(0x3FDEC709DC3A04BE), //  0x1.ec709dc3a04bep-2\n    A2 = reinterpret<f64>(0xBFD7154764702FFB), // -0x1.7154764702ffbp-2\n    A3 = reinterpret<f64>(0x3FD2776C50034C48), //  0x1.2776c50034c48p-2\n    A4 = reinterpret<f64>(0xBFCEC7B328EA92BC), // -0x1.ec7b328ea92bcp-3\n    A5 = reinterpret<f64>(0x3FCA6225E117F92E); //  0x1.a6225e117f92ep-3\n\n  let ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r = x - 1.0;\n    // #if __FP_FAST_FMA\n    //     hi = r * InvLn2hi;\n    //     lo = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -hi);\n    // #else\n    let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n    let rlo = r - rhi;\n    let hi  = rhi * InvLn2hi;\n    let lo  = rlo * InvLn2hi + r * InvLn2lo;\n    // #endif\n    let r2 = r * r; // rounding error: 0x1p-62\n    let r4 = r2 * r2;\n    // Worst-case error is less than 0.54 ULP (0.55 ULP without fma)\n    let p = r2 * (B0 + r * B1);\n    let y = hi + p;\n    lo += hi - y + p;\n    lo += r4 * (B2 + r * B3 + r2 * (B4 + r * B5) +\n          r4 * (B6 + r * B7 + r2 * (B8 + r * B9)));\n    return y + lo;\n  }\n  let top = u32(ix >> 48);\n  if (top - 0x0010 >= 0x7ff0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan.\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == 0x7FF0000000000000) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ix - 0x3FE6000000000000;\n  let i    = <usize>((tmp >> (52 - LOG2_TABLE_BITS)) & N_MASK);\n  let k    = <i64>tmp >> 52;\n  let iz   = ix - (tmp & 0xFFF0000000000000);\n\n  let invc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  let logc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  let z    = reinterpret<f64>(iz);\n  let kd   = <f64>k;\n\n  // log2(x) = log2(z/c) + log2(c) + k.\n  // r ~= z/c - 1, |r| < 1/(2*N).\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N.\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // \tt1 = r * InvLn2hi;\n  // \tt2 = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -t1);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-65.\n  let chi = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].chi;\n  let clo = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].clo;\n\n  let r   = (z - chi - clo) * invc;\n  let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n  let rlo = r - rhi;\n  let t1  = rhi * InvLn2hi;\n  let t2  = rlo * InvLn2hi + r * InvLn2lo;\n  // #endif\n\n  // hi + lo = r/ln2 + log2(c) + k\n  let t3 = kd + logc;\n  let hi = t3 + t1;\n  let lo = t3 - hi + t1 + t2;\n\n  // log2(r+1) = r/ln2 + r^2*poly(r)\n  // Evaluation is optimized assuming superscalar pipelined execution\n  let r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst-case error if |y| > 0x1p-4: 0.547 ULP (0.550 ULP without fma).\n  // ~ 0.5 + 2/N/ln2 + abs-poly-error*0x1p56 ULP (+ 0.003 ULP without fma).\n  let p = A0 + r * A1 + r2 * (A2 + r * A3) + (r2 * r2) * (A4 + r * A5);\n  return lo + r2 * p + hi;\n}\n\n//\n// Lookup data for log. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p9 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-66 and\n  3) the rounding error in (double)log(c) is minimized (< 0x1p-66).\n\nNote: 1) ensures that k*ln2hi + logc can be computed without rounding error,\n2) ensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to\na single rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log(x)| < 0x1p-4, this is not enough so that is special cased.*/\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB1 = memory.data<u64>([\n  //      invc      ,        logc\n  0x3FF734F0C3E0DE9F, 0xBFD7CC7F79E69000,\n  0x3FF713786A2CE91F, 0xBFD76FEEC20D0000,\n  0x3FF6F26008FAB5A0, 0xBFD713E31351E000,\n  0x3FF6D1A61F138C7D, 0xBFD6B85B38287800,\n  0x3FF6B1490BC5B4D1, 0xBFD65D5590807800,\n  0x3FF69147332F0CBA, 0xBFD602D076180000,\n  0x3FF6719F18224223, 0xBFD5A8CA86909000,\n  0x3FF6524F99A51ED9, 0xBFD54F4356035000,\n  0x3FF63356AA8F24C4, 0xBFD4F637C36B4000,\n  0x3FF614B36B9DDC14, 0xBFD49DA7FDA85000,\n  0x3FF5F66452C65C4C, 0xBFD445923989A800,\n  0x3FF5D867B5912C4F, 0xBFD3EDF439B0B800,\n  0x3FF5BABCCB5B90DE, 0xBFD396CE448F7000,\n  0x3FF59D61F2D91A78, 0xBFD3401E17BDA000,\n  0x3FF5805612465687, 0xBFD2E9E2EF468000,\n  0x3FF56397CEE76BD3, 0xBFD2941B3830E000,\n  0x3FF54725E2A77F93, 0xBFD23EC58CDA8800,\n  0x3FF52AFF42064583, 0xBFD1E9E129279000,\n  0x3FF50F22DBB2BDDF, 0xBFD1956D2B48F800,\n  0x3FF4F38F4734DED7, 0xBFD141679AB9F800,\n  0x3FF4D843CFDE2840, 0xBFD0EDD094EF9800,\n  0x3FF4BD3EC078A3C8, 0xBFD09AA518DB1000,\n  0x3FF4A27FC3E0258A, 0xBFD047E65263B800,\n  0x3FF4880524D48434, 0xBFCFEB224586F000,\n  0x3FF46DCE1B192D0B, 0xBFCF474A7517B000,\n  0x3FF453D9D3391854, 0xBFCEA4443D103000,\n  0x3FF43A2744B4845A, 0xBFCE020D44E9B000,\n  0x3FF420B54115F8FB, 0xBFCD60A22977F000,\n  0x3FF40782DA3EF4B1, 0xBFCCC00104959000,\n  0x3FF3EE8F5D57FE8F, 0xBFCC202956891000,\n  0x3FF3D5D9A00B4CE9, 0xBFCB81178D811000,\n  0x3FF3BD60C010C12B, 0xBFCAE2C9CCD3D000,\n  0x3FF3A5242B75DAB8, 0xBFCA45402E129000,\n  0x3FF38D22CD9FD002, 0xBFC9A877681DF000,\n  0x3FF3755BC5847A1C, 0xBFC90C6D69483000,\n  0x3FF35DCE49AD36E2, 0xBFC87120A645C000,\n  0x3FF34679984DD440, 0xBFC7D68FB4143000,\n  0x3FF32F5CCEFFCB24, 0xBFC73CB83C627000,\n  0x3FF3187775A10D49, 0xBFC6A39A9B376000,\n  0x3FF301C8373E3990, 0xBFC60B3154B7A000,\n  0x3FF2EB4EBB95F841, 0xBFC5737D76243000,\n  0x3FF2D50A0219A9D1, 0xBFC4DC7B8FC23000,\n  0x3FF2BEF9A8B7FD2A, 0xBFC4462C51D20000,\n  0x3FF2A91C7A0C1BAB, 0xBFC3B08ABC830000,\n  0x3FF293726014B530, 0xBFC31B996B490000,\n  0x3FF27DFA5757A1F5, 0xBFC2875490A44000,\n  0x3FF268B39B1D3BBF, 0xBFC1F3B9F879A000,\n  0x3FF2539D838FF5BD, 0xBFC160C8252CA000,\n  0x3FF23EB7AAC9083B, 0xBFC0CE7F57F72000,\n  0x3FF22A012BA940B6, 0xBFC03CDC49FEA000,\n  0x3FF2157996CC4132, 0xBFBF57BDBC4B8000,\n  0x3FF201201DD2FC9B, 0xBFBE370896404000,\n  0x3FF1ECF4494D480B, 0xBFBD17983EF94000,\n  0x3FF1D8F5528F6569, 0xBFBBF9674ED8A000,\n  0x3FF1C52311577E7C, 0xBFBADC79202F6000,\n  0x3FF1B17C74CB26E9, 0xBFB9C0C3E7288000,\n  0x3FF19E010C2C1AB6, 0xBFB8A646B372C000,\n  0x3FF18AB07BB670BD, 0xBFB78D01B3AC0000,\n  0x3FF1778A25EFBCB6, 0xBFB674F145380000,\n  0x3FF1648D354C31DA, 0xBFB55E0E6D878000,\n  0x3FF151B990275FDD, 0xBFB4485CDEA1E000,\n  0x3FF13F0EA432D24C, 0xBFB333D94D6AA000,\n  0x3FF12C8B7210F9DA, 0xBFB22079F8C56000,\n  0x3FF11A3028ECB531, 0xBFB10E4698622000,\n  0x3FF107FBDA8434AF, 0xBFAFFA6C6AD20000,\n  0x3FF0F5EE0F4E6BB3, 0xBFADDA8D4A774000,\n  0x3FF0E4065D2A9FCE, 0xBFABBCECE4850000,\n  0x3FF0D244632CA521, 0xBFA9A1894012C000,\n  0x3FF0C0A77CE2981A, 0xBFA788583302C000,\n  0x3FF0AF2F83C636D1, 0xBFA5715E67D68000,\n  0x3FF09DDB98A01339, 0xBFA35C8A49658000,\n  0x3FF08CABAF52E7DF, 0xBFA149E364154000,\n  0x3FF07B9F2F4E28FB, 0xBF9E72C082EB8000,\n  0x3FF06AB58C358F19, 0xBF9A55F152528000,\n  0x3FF059EEA5ECF92C, 0xBF963D62CF818000,\n  0x3FF04949CDD12C90, 0xBF9228FB8CAA0000,\n  0x3FF038C6C6F0ADA9, 0xBF8C317B20F90000,\n  0x3FF02865137932A9, 0xBF8419355DAA0000,\n  0x3FF0182427EA7348, 0xBF781203C2EC0000,\n  0x3FF008040614B195, 0xBF60040979240000,\n  0x3FEFE01FF726FA1A, 0x3F6FEFF384900000,\n  0x3FEFA11CC261EA74, 0x3F87DC41353D0000,\n  0x3FEF6310B081992E, 0x3F93CEA3C4C28000,\n  0x3FEF25F63CEEADCD, 0x3F9B9FC114890000,\n  0x3FEEE9C8039113E7, 0x3FA1B0D8CE110000,\n  0x3FEEAE8078CBB1AB, 0x3FA58A5BD001C000,\n  0x3FEE741AA29D0C9B, 0x3FA95C8340D88000,\n  0x3FEE3A91830A99B5, 0x3FAD276AEF578000,\n  0x3FEE01E009609A56, 0x3FB07598E598C000,\n  0x3FEDCA01E577BB98, 0x3FB253F5E30D2000,\n  0x3FED92F20B7C9103, 0x3FB42EDD8B380000,\n  0x3FED5CAC66FB5CCE, 0x3FB606598757C000,\n  0x3FED272CAA5EDE9D, 0x3FB7DA76356A0000,\n  0x3FECF26E3E6B2CCD, 0x3FB9AB434E1C6000,\n  0x3FECBE6DA2A77902, 0x3FBB78C7BB0D6000,\n  0x3FEC8B266D37086D, 0x3FBD431332E72000,\n  0x3FEC5894BD5D5804, 0x3FBF0A3171DE6000,\n  0x3FEC26B533BB9F8C, 0x3FC067152B914000,\n  0x3FEBF583EEECE73F, 0x3FC147858292B000,\n  0x3FEBC4FD75DB96C1, 0x3FC2266ECDCA3000,\n  0x3FEB951E0C864A28, 0x3FC303D7A6C55000,\n  0x3FEB65E2C5EF3E2C, 0x3FC3DFC33C331000,\n  0x3FEB374867C9888B, 0x3FC4BA366B7A8000,\n  0x3FEB094B211D304A, 0x3FC5933928D1F000,\n  0x3FEADBE885F2EF7E, 0x3FC66ACD2418F000,\n  0x3FEAAF1D31603DA2, 0x3FC740F8EC669000,\n  0x3FEA82E63FD358A7, 0x3FC815C0F51AF000,\n  0x3FEA5740EF09738B, 0x3FC8E92954F68000,\n  0x3FEA2C2A90AB4B27, 0x3FC9BB3602F84000,\n  0x3FEA01A01393F2D1, 0x3FCA8BED1C2C0000,\n  0x3FE9D79F24DB3C1B, 0x3FCB5B515C01D000,\n  0x3FE9AE2505C7B190, 0x3FCC2967CCBCC000,\n  0x3FE9852EF297CE2F, 0x3FCCF635D5486000,\n  0x3FE95CBAEEA44B75, 0x3FCDC1BD3446C000,\n  0x3FE934C69DE74838, 0x3FCE8C01B8CFE000,\n  0x3FE90D4F2F6752E6, 0x3FCF5509C0179000,\n  0x3FE8E6528EFFD79D, 0x3FD00E6C121FB800,\n  0x3FE8BFCE9FCC007C, 0x3FD071B80E93D000,\n  0x3FE899C0DABEC30E, 0x3FD0D46B9E867000,\n  0x3FE87427AA2317FB, 0x3FD13687334BD000,\n  0x3FE84F00ACB39A08, 0x3FD1980D67234800,\n  0x3FE82A49E8653E55, 0x3FD1F8FFE0CC8000,\n  0x3FE8060195F40260, 0x3FD2595FD7636800,\n  0x3FE7E22563E0A329, 0x3FD2B9300914A800,\n  0x3FE7BEB377DCB5AD, 0x3FD3187210436000,\n  0x3FE79BAA679725C2, 0x3FD377266DEC1800,\n  0x3FE77907F2170657, 0x3FD3D54FFBAF3000,\n  0x3FE756CADBD6130C, 0x3FD432EEE32FE000\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB2 = memory.data<u64>([\n  //      chi       ,         clo\n  0x3FE61000014FB66B, 0x3C7E026C91425B3C,\n  0x3FE63000034DB495, 0x3C8DBFEA48005D41,\n  0x3FE650000D94D478, 0x3C8E7FA786D6A5B7,\n  0x3FE67000074E6FAD, 0x3C61FCEA6B54254C,\n  0x3FE68FFFFEDF0FAE, 0xBC7C7E274C590EFD,\n  0x3FE6B0000763C5BC, 0xBC8AC16848DCDA01,\n  0x3FE6D0001E5CC1F6, 0x3C833F1C9D499311,\n  0x3FE6EFFFEB05F63E, 0xBC7E80041AE22D53,\n  0x3FE710000E869780, 0x3C7BFF6671097952,\n  0x3FE72FFFFC67E912, 0x3C8C00E226BD8724,\n  0x3FE74FFFDF81116A, 0xBC6E02916EF101D2,\n  0x3FE770000F679C90, 0xBC67FC71CD549C74,\n  0x3FE78FFFFA7EC835, 0x3C81BEC19EF50483,\n  0x3FE7AFFFFE20C2E6, 0xBC707E1729CC6465,\n  0x3FE7CFFFED3FC900, 0xBC808072087B8B1C,\n  0x3FE7EFFFE9261A76, 0x3C8DC0286D9DF9AE,\n  0x3FE81000049CA3E8, 0x3C897FD251E54C33,\n  0x3FE8300017932C8F, 0xBC8AFEE9B630F381,\n  0x3FE850000633739C, 0x3C89BFBF6B6535BC,\n  0x3FE87000204289C6, 0xBC8BBF65F3117B75,\n  0x3FE88FFFEBF57904, 0xBC89006EA23DCB57,\n  0x3FE8B00022BC04DF, 0xBC7D00DF38E04B0A,\n  0x3FE8CFFFE50C1B8A, 0xBC88007146FF9F05,\n  0x3FE8EFFFFC918E43, 0x3C83817BD07A7038,\n  0x3FE910001EFA5FC7, 0x3C893E9176DFB403,\n  0x3FE9300013467BB9, 0x3C7F804E4B980276,\n  0x3FE94FFFE6EE076F, 0xBC8F7EF0D9FF622E,\n  0x3FE96FFFDE3C12D1, 0xBC7082AA962638BA,\n  0x3FE98FFFF4458A0D, 0xBC87801B9164A8EF,\n  0x3FE9AFFFDD982E3E, 0xBC8740E08A5A9337,\n  0x3FE9CFFFED49FB66, 0x3C3FCE08C19BE000,\n  0x3FE9F00020F19C51, 0xBC8A3FAA27885B0A,\n  0x3FEA10001145B006, 0x3C74FF489958DA56,\n  0x3FEA300007BBF6FA, 0x3C8CBEAB8A2B6D18,\n  0x3FEA500010971D79, 0x3C88FECADD787930,\n  0x3FEA70001DF52E48, 0xBC8F41763DD8ABDB,\n  0x3FEA90001C593352, 0xBC8EBF0284C27612,\n  0x3FEAB0002A4F3E4B, 0xBC69FD043CFF3F5F,\n  0x3FEACFFFD7AE1ED1, 0xBC823EE7129070B4,\n  0x3FEAEFFFEE510478, 0x3C6A063EE00EDEA3,\n  0x3FEB0FFFDB650D5B, 0x3C5A06C8381F0AB9,\n  0x3FEB2FFFFEAACA57, 0xBC79011E74233C1D,\n  0x3FEB4FFFD995BADC, 0xBC79FF1068862A9F,\n  0x3FEB7000249E659C, 0x3C8AFF45D0864F3E,\n  0x3FEB8FFFF9871640, 0x3C7CFE7796C2C3F9,\n  0x3FEBAFFFD204CB4F, 0xBC63FF27EEF22BC4,\n  0x3FEBCFFFD2415C45, 0xBC6CFFB7EE3BEA21,\n  0x3FEBEFFFF86309DF, 0xBC814103972E0B5C,\n  0x3FEC0FFFE1B57653, 0x3C8BC16494B76A19,\n  0x3FEC2FFFF1FA57E3, 0xBC64FEEF8D30C6ED,\n  0x3FEC4FFFDCBFE424, 0xBC843F68BCEC4775,\n  0x3FEC6FFFED54B9F7, 0x3C847EA3F053E0EC,\n  0x3FEC8FFFEB998FD5, 0x3C7383068DF992F1,\n  0x3FECB0002125219A, 0xBC68FD8E64180E04,\n  0x3FECCFFFDD94469C, 0x3C8E7EBE1CC7EA72,\n  0x3FECEFFFEAFDC476, 0x3C8EBE39AD9F88FE,\n  0x3FED1000169AF82B, 0x3C757D91A8B95A71,\n  0x3FED30000D0FF71D, 0x3C89C1906970C7DA,\n  0x3FED4FFFEA790FC4, 0xBC580E37C558FE0C,\n  0x3FED70002EDC87E5, 0xBC7F80D64DC10F44,\n  0x3FED900021DC82AA, 0xBC747C8F94FD5C5C,\n  0x3FEDAFFFD86B0283, 0x3C8C7F1DC521617E,\n  0x3FEDD000296C4739, 0x3C88019EB2FFB153,\n  0x3FEDEFFFE54490F5, 0x3C6E00D2C652CC89,\n  0x3FEE0FFFCDABF694, 0xBC7F8340202D69D2,\n  0x3FEE2FFFDB52C8DD, 0x3C7B00C1CA1B0864,\n  0x3FEE4FFFF24216EF, 0x3C72FFA8B094AB51,\n  0x3FEE6FFFE88A5E11, 0xBC57F673B1EFBE59,\n  0x3FEE9000119EFF0D, 0xBC84808D5E0BC801,\n  0x3FEEAFFFDFA51744, 0x3C780006D54320B5,\n  0x3FEED0001A127FA1, 0xBC5002F860565C92,\n  0x3FEEF00007BABCC4, 0xBC8540445D35E611,\n  0x3FEF0FFFF57A8D02, 0xBC4FFB3139EF9105,\n  0x3FEF30001EE58AC7, 0x3C8A81ACF2731155,\n  0x3FEF4FFFF5823494, 0x3C8A3F41D4D7C743,\n  0x3FEF6FFFFCA94C6B, 0xBC6202F41C987875,\n  0x3FEF8FFFE1F9C441, 0x3C777DD1F477E74B,\n  0x3FEFAFFFD2E0E37E, 0xBC6F01199A7CA331,\n  0x3FEFD0001C77E49E, 0x3C7181EE4BCEACB1,\n  0x3FEFEFFFF7E0C331, 0xBC6E05370170875A,\n  0x3FF00FFFF465606E, 0xBC8A7EAD491C0ADA,\n  0x3FF02FFFF3867A58, 0xBC977F69C3FCB2E0,\n  0x3FF04FFFFDFC0D17, 0x3C97BFFE34CB945B,\n  0x3FF0700003CD4D82, 0x3C820083C0E456CB,\n  0x3FF08FFFF9F2CBE8, 0xBC6DFFDFBE37751A,\n  0x3FF0B000010CDA65, 0xBC913F7FAEE626EB,\n  0x3FF0D00001A4D338, 0x3C807DFA79489FF7,\n  0x3FF0EFFFFADAFDFD, 0xBC77040570D66BC0,\n  0x3FF110000BBAFD96, 0x3C8E80D4846D0B62,\n  0x3FF12FFFFAE5F45D, 0x3C9DBFFA64FD36EF,\n  0x3FF150000DD59AD9, 0x3C9A0077701250AE,\n  0x3FF170000F21559A, 0x3C8DFDF9E2E3DEEE,\n  0x3FF18FFFFC275426, 0x3C910030DC3B7273,\n  0x3FF1B000123D3C59, 0x3C997F7980030188,\n  0x3FF1CFFFF8299EB7, 0xBC65F932AB9F8C67,\n  0x3FF1EFFFF48AD400, 0x3C937FBF9DA75BEB,\n  0x3FF210000C8B86A4, 0x3C9F806B91FD5B22,\n  0x3FF2300003854303, 0x3C93FFC2EB9FBF33,\n  0x3FF24FFFFFBCF684, 0x3C7601E77E2E2E72,\n  0x3FF26FFFF52921D9, 0x3C7FFCBB767F0C61,\n  0x3FF2900014933A3C, 0xBC7202CA3C02412B,\n  0x3FF2B00014556313, 0xBC92808233F21F02,\n  0x3FF2CFFFEBFE523B, 0xBC88FF7E384FDCF2,\n  0x3FF2F0000BB8AD96, 0xBC85FF51503041C5,\n  0x3FF30FFFFB7AE2AF, 0xBC810071885E289D,\n  0x3FF32FFFFEAC5F7F, 0xBC91FF5D3FB7B715,\n  0x3FF350000CA66756, 0x3C957F82228B82BD,\n  0x3FF3700011FBF721, 0x3C8000BAC40DD5CC,\n  0x3FF38FFFF9592FB9, 0xBC943F9D2DB2A751,\n  0x3FF3B00004DDD242, 0x3C857F6B707638E1,\n  0x3FF3CFFFF5B2C957, 0x3C7A023A10BF1231,\n  0x3FF3EFFFEAB0B418, 0x3C987F6D66B152B0,\n  0x3FF410001532AFF4, 0x3C67F8375F198524,\n  0x3FF4300017478B29, 0x3C8301E672DC5143,\n  0x3FF44FFFE795B463, 0x3C89FF69B8B2895A,\n  0x3FF46FFFE80475E0, 0xBC95C0B19BC2F254,\n  0x3FF48FFFEF6FC1E7, 0x3C9B4009F23A2A72,\n  0x3FF4AFFFE5BEA704, 0xBC94FFB7BF0D7D45,\n  0x3FF4D000171027DE, 0xBC99C06471DC6A3D,\n  0x3FF4F0000FF03EE2, 0x3C977F890B85531C,\n  0x3FF5100012DC4BD1, 0x3C6004657166A436,\n  0x3FF530001605277A, 0xBC96BFCECE233209,\n  0x3FF54FFFECDB704C, 0xBC8902720505A1D7,\n  0x3FF56FFFEF5F54A9, 0x3C9BBFE60EC96412,\n  0x3FF5900017E61012, 0x3C887EC581AFEF90,\n  0x3FF5B00003C93E92, 0xBC9F41080ABF0CC0,\n  0x3FF5D0001D4919BC, 0xBC98812AFB254729,\n  0x3FF5EFFFE7B87A89, 0xBC947EB780ED6904\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG_TABLE_BITS) - 1;\n\n  const\n    B0  = reinterpret<f64>(0xBFE0000000000000), // -0x1p-1\n    B1  = reinterpret<f64>(0x3FD5555555555577), //  0x1.5555555555577p-2\n    B2  = reinterpret<f64>(0xBFCFFFFFFFFFFDCB), // -0x1.ffffffffffdcbp-3\n    B3  = reinterpret<f64>(0x3FC999999995DD0C), //  0x1.999999995dd0cp-3\n    B4  = reinterpret<f64>(0xBFC55555556745A7), // -0x1.55555556745a7p-3\n    B5  = reinterpret<f64>(0x3FC24924A344DE30), //  0x1.24924a344de3p-3\n    B6  = reinterpret<f64>(0xBFBFFFFFA4423D65), // -0x1.fffffa4423d65p-4\n    B7  = reinterpret<f64>(0x3FBC7184282AD6CA), //  0x1.c7184282ad6cap-4\n    B8  = reinterpret<f64>(0xBFB999EB43B068FF), // -0x1.999eb43b068ffp-4\n    B9  = reinterpret<f64>(0x3FB78182F7AFD085), //  0x1.78182f7afd085p-4\n    B10 = reinterpret<f64>(0xBFB5521375D145CD); // -0x1.5521375d145cdp-4\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000001),  // -0x1.0000000000001p-1\n    A1 = reinterpret<f64>(0x3FD555555551305B),  //  0x1.555555551305bp-2\n    A2 = reinterpret<f64>(0xBFCFFFFFFFEB4590),  // -0x1.fffffffeb459p-3\n    A3 = reinterpret<f64>(0x3FC999B324F10111),  //  0x1.999b324f10111p-3\n    A4 = reinterpret<f64>(0xBFC55575E506C89F);  // -0x1.55575e506c89fp-3\n\n  const\n    LO: u64 = 0x3FEE000000000000,\n    HI: u64 = 0x3FF1090000000000;\n\n  const\n    Ln2hi  = reinterpret<f64>(0x3FE62E42FEFA3800), // 0x1.62e42fefa3800p-1\n    Ln2lo  = reinterpret<f64>(0x3D2EF35793C76730), // 0x1.ef35793c76730p-45\n    Ox1p27 = reinterpret<f64>(0x41A0000000000000), // 0x1p27\n    Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  let ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r  = x - 1.0;\n    let r2 = r * r;\n    let r3 = r2 * r;\n    let y =\n      r3 * (B1 + r * B2 + r2 * B3 +\n      r3 * (B4 + r * B5 + r2 * B6 +\n      r3 * (B7 + r * B8 + r2 * B9 + r3 * B10)));\n    // Worst-case error is around 0.507 ULP\n    let w   = r * Ox1p27;\n    let rhi = r + w - w;\n    let rlo = r - rhi;\n    w = rhi * rhi * B0; // B[0] == -0.5\n    let hi = r + w;\n    let lo = r - hi + w;\n    lo += B0 * rlo * (rhi + r);\n    return y + lo + hi;\n  }\n  let top = u32(ix >> 48);\n  if (top - 0x0010 >= 0x7FF0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == reinterpret<u64>(Infinity)) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ix - 0x3FE6000000000000;\n  let i    = <usize>((tmp >> (52 - LOG_TABLE_BITS)) & N_MASK);\n  let k    = <i64>tmp >> 52;\n  let iz   = ix - (tmp & (u64(0xFFF) << 52));\n\n  let invc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  let logc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  let z    = reinterpret<f64>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2.\n  // r ~= z/c - 1, |r| < 1/(2*N)\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-66\n  const chi = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T2[i].chi\n  const clo = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T2[i].clo\n  let r = (z - chi - clo) * invc;\n  // #endif\n  let kd = <f64>k;\n\n  // hi + lo = r + log(c) + k*Ln2\n  let w  = kd * Ln2hi + logc;\n  let hi = w + r;\n  let lo = w - hi + r + kd * Ln2lo;\n\n  // log(x) = lo + (log1p(r) - r) + hi\n  let r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst case error if |y| > 0x1p-5:\n  // 0.5 + 4.13/N + abs-poly-error*2^57 ULP (+ 0.002 ULP without fma)\n  // Worst case error if |y| > 0x1p-4:\n  // 0.5 + 2.06/N + abs-poly-error*2^56 ULP (+ 0.001 ULP without fma).\n  return lo + r2 * A0 + r * r2 * (A1 + r * A2 + r2 * (A3 + r * A4)) + hi;\n}\n\n//\n// Lookup data for pow. See: https://git.musl-libc.org/cgit/musl/tree/src/math/pow.c\n//\n\n// @ts-ignore: decorator\n@inline const POW_LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [0x1.69555p-1; 0x1.69555p0] which is split into N subintervals\nand z falls into the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = round(0x1p43*log(c))/0x1p43\n  tab[i].logctail = (double)(log(c) - logc)\n\nwhere c is chosen near the center of the subinterval such that 1/c has only a\nfew precision bits so z/c - 1 is exactly representible as double:\n\n  1/c = center < 1 ? round(N/center)/N : round(2*N/center)/N/2\n\nNote: |z/c - 1| < 1/N for the chosen c, |log(c) - logc - logctail| < 0x1p-97,\nthe last few bits of logc are rounded away so k*ln2hi + logc has no rounding\nerror and the interval for z is selected such that near x == 1, where log(x)\nis tiny, large cancellation error is avoided in logc + poly(z/c - 1). */\n\n// @ts-ignore: decorator\n@lazy @inline const POW_LOG_DATA_TAB = memory.data<u64>([\n  //      invc      ,pad,       logc       ,       logctail\n  0x3FF6A00000000000, 0, 0xBFD62C82F2B9C800, 0x3CFAB42428375680,\n  0x3FF6800000000000, 0, 0xBFD5D1BDBF580800, 0xBD1CA508D8E0F720,\n  0x3FF6600000000000, 0, 0xBFD5767717455800, 0xBD2362A4D5B6506D,\n  0x3FF6400000000000, 0, 0xBFD51AAD872DF800, 0xBCE684E49EB067D5,\n  0x3FF6200000000000, 0, 0xBFD4BE5F95777800, 0xBD041B6993293EE0,\n  0x3FF6000000000000, 0, 0xBFD4618BC21C6000, 0x3D13D82F484C84CC,\n  0x3FF5E00000000000, 0, 0xBFD404308686A800, 0x3CDC42F3ED820B3A,\n  0x3FF5C00000000000, 0, 0xBFD3A64C55694800, 0x3D20B1C686519460,\n  0x3FF5A00000000000, 0, 0xBFD347DD9A988000, 0x3D25594DD4C58092,\n  0x3FF5800000000000, 0, 0xBFD2E8E2BAE12000, 0x3D267B1E99B72BD8,\n  0x3FF5600000000000, 0, 0xBFD2895A13DE8800, 0x3D15CA14B6CFB03F,\n  0x3FF5600000000000, 0, 0xBFD2895A13DE8800, 0x3D15CA14B6CFB03F,\n  0x3FF5400000000000, 0, 0xBFD22941FBCF7800, 0xBD165A242853DA76,\n  0x3FF5200000000000, 0, 0xBFD1C898C1699800, 0xBD1FAFBC68E75404,\n  0x3FF5000000000000, 0, 0xBFD1675CABABA800, 0x3D1F1FC63382A8F0,\n  0x3FF4E00000000000, 0, 0xBFD1058BF9AE4800, 0xBD26A8C4FD055A66,\n  0x3FF4C00000000000, 0, 0xBFD0A324E2739000, 0xBD0C6BEE7EF4030E,\n  0x3FF4A00000000000, 0, 0xBFD0402594B4D000, 0xBCF036B89EF42D7F,\n  0x3FF4A00000000000, 0, 0xBFD0402594B4D000, 0xBCF036B89EF42D7F,\n  0x3FF4800000000000, 0, 0xBFCFB9186D5E4000, 0x3D0D572AAB993C87,\n  0x3FF4600000000000, 0, 0xBFCEF0ADCBDC6000, 0x3D2B26B79C86AF24,\n  0x3FF4400000000000, 0, 0xBFCE27076E2AF000, 0xBD172F4F543FFF10,\n  0x3FF4200000000000, 0, 0xBFCD5C216B4FC000, 0x3D21BA91BBCA681B,\n  0x3FF4000000000000, 0, 0xBFCC8FF7C79AA000, 0x3D27794F689F8434,\n  0x3FF4000000000000, 0, 0xBFCC8FF7C79AA000, 0x3D27794F689F8434,\n  0x3FF3E00000000000, 0, 0xBFCBC286742D9000, 0x3D194EB0318BB78F,\n  0x3FF3C00000000000, 0, 0xBFCAF3C94E80C000, 0x3CBA4E633FCD9066,\n  0x3FF3A00000000000, 0, 0xBFCA23BC1FE2B000, 0xBD258C64DC46C1EA,\n  0x3FF3A00000000000, 0, 0xBFCA23BC1FE2B000, 0xBD258C64DC46C1EA,\n  0x3FF3800000000000, 0, 0xBFC9525A9CF45000, 0xBD2AD1D904C1D4E3,\n  0x3FF3600000000000, 0, 0xBFC87FA06520D000, 0x3D2BBDBF7FDBFA09,\n  0x3FF3400000000000, 0, 0xBFC7AB890210E000, 0x3D2BDB9072534A58,\n  0x3FF3400000000000, 0, 0xBFC7AB890210E000, 0x3D2BDB9072534A58,\n  0x3FF3200000000000, 0, 0xBFC6D60FE719D000, 0xBD10E46AA3B2E266,\n  0x3FF3000000000000, 0, 0xBFC5FF3070A79000, 0xBD1E9E439F105039,\n  0x3FF3000000000000, 0, 0xBFC5FF3070A79000, 0xBD1E9E439F105039,\n  0x3FF2E00000000000, 0, 0xBFC526E5E3A1B000, 0xBD20DE8B90075B8F,\n  0x3FF2C00000000000, 0, 0xBFC44D2B6CCB8000, 0x3D170CC16135783C,\n  0x3FF2C00000000000, 0, 0xBFC44D2B6CCB8000, 0x3D170CC16135783C,\n  0x3FF2A00000000000, 0, 0xBFC371FC201E9000, 0x3CF178864D27543A,\n  0x3FF2800000000000, 0, 0xBFC29552F81FF000, 0xBD248D301771C408,\n  0x3FF2600000000000, 0, 0xBFC1B72AD52F6000, 0xBD2E80A41811A396,\n  0x3FF2600000000000, 0, 0xBFC1B72AD52F6000, 0xBD2E80A41811A396,\n  0x3FF2400000000000, 0, 0xBFC0D77E7CD09000, 0x3D0A699688E85BF4,\n  0x3FF2400000000000, 0, 0xBFC0D77E7CD09000, 0x3D0A699688E85BF4,\n  0x3FF2200000000000, 0, 0xBFBFEC9131DBE000, 0xBD2575545CA333F2,\n  0x3FF2000000000000, 0, 0xBFBE27076E2B0000, 0x3D2A342C2AF0003C,\n  0x3FF2000000000000, 0, 0xBFBE27076E2B0000, 0x3D2A342C2AF0003C,\n  0x3FF1E00000000000, 0, 0xBFBC5E548F5BC000, 0xBD1D0C57585FBE06,\n  0x3FF1C00000000000, 0, 0xBFBA926D3A4AE000, 0x3D253935E85BAAC8,\n  0x3FF1C00000000000, 0, 0xBFBA926D3A4AE000, 0x3D253935E85BAAC8,\n  0x3FF1A00000000000, 0, 0xBFB8C345D631A000, 0x3D137C294D2F5668,\n  0x3FF1A00000000000, 0, 0xBFB8C345D631A000, 0x3D137C294D2F5668,\n  0x3FF1800000000000, 0, 0xBFB6F0D28AE56000, 0xBD269737C93373DA,\n  0x3FF1600000000000, 0, 0xBFB51B073F062000, 0x3D1F025B61C65E57,\n  0x3FF1600000000000, 0, 0xBFB51B073F062000, 0x3D1F025B61C65E57,\n  0x3FF1400000000000, 0, 0xBFB341D7961BE000, 0x3D2C5EDACCF913DF,\n  0x3FF1400000000000, 0, 0xBFB341D7961BE000, 0x3D2C5EDACCF913DF,\n  0x3FF1200000000000, 0, 0xBFB16536EEA38000, 0x3D147C5E768FA309,\n  0x3FF1000000000000, 0, 0xBFAF0A30C0118000, 0x3D2D599E83368E91,\n  0x3FF1000000000000, 0, 0xBFAF0A30C0118000, 0x3D2D599E83368E91,\n  0x3FF0E00000000000, 0, 0xBFAB42DD71198000, 0x3D1C827AE5D6704C,\n  0x3FF0E00000000000, 0, 0xBFAB42DD71198000, 0x3D1C827AE5D6704C,\n  0x3FF0C00000000000, 0, 0xBFA77458F632C000, 0xBD2CFC4634F2A1EE,\n  0x3FF0C00000000000, 0, 0xBFA77458F632C000, 0xBD2CFC4634F2A1EE,\n  0x3FF0A00000000000, 0, 0xBFA39E87B9FEC000, 0x3CF502B7F526FEAA,\n  0x3FF0A00000000000, 0, 0xBFA39E87B9FEC000, 0x3CF502B7F526FEAA,\n  0x3FF0800000000000, 0, 0xBF9F829B0E780000, 0xBD2980267C7E09E4,\n  0x3FF0800000000000, 0, 0xBF9F829B0E780000, 0xBD2980267C7E09E4,\n  0x3FF0600000000000, 0, 0xBF97B91B07D58000, 0xBD288D5493FAA639,\n  0x3FF0400000000000, 0, 0xBF8FC0A8B0FC0000, 0xBCDF1E7CF6D3A69C,\n  0x3FF0400000000000, 0, 0xBF8FC0A8B0FC0000, 0xBCDF1E7CF6D3A69C,\n  0x3FF0200000000000, 0, 0xBF7FE02A6B100000, 0xBD19E23F0DDA40E4,\n  0x3FF0200000000000, 0, 0xBF7FE02A6B100000, 0xBD19E23F0DDA40E4,\n  0x3FF0000000000000, 0, 0, 0,\n  0x3FF0000000000000, 0, 0, 0,\n  0x3FEFC00000000000, 0, 0x3F80101575890000, 0xBD10C76B999D2BE8,\n  0x3FEF800000000000, 0, 0x3F90205658938000, 0xBD23DC5B06E2F7D2,\n  0x3FEF400000000000, 0, 0x3F98492528C90000, 0xBD2AA0BA325A0C34,\n  0x3FEF000000000000, 0, 0x3FA0415D89E74000, 0x3D0111C05CF1D753,\n  0x3FEEC00000000000, 0, 0x3FA466AED42E0000, 0xBD2C167375BDFD28,\n  0x3FEE800000000000, 0, 0x3FA894AA149FC000, 0xBD197995D05A267D,\n  0x3FEE400000000000, 0, 0x3FACCB73CDDDC000, 0xBD1A68F247D82807,\n  0x3FEE200000000000, 0, 0x3FAEEA31C006C000, 0xBD0E113E4FC93B7B,\n  0x3FEDE00000000000, 0, 0x3FB1973BD1466000, 0xBD25325D560D9E9B,\n  0x3FEDA00000000000, 0, 0x3FB3BDF5A7D1E000, 0x3D2CC85EA5DB4ED7,\n  0x3FED600000000000, 0, 0x3FB5E95A4D97A000, 0xBD2C69063C5D1D1E,\n  0x3FED400000000000, 0, 0x3FB700D30AEAC000, 0x3CEC1E8DA99DED32,\n  0x3FED000000000000, 0, 0x3FB9335E5D594000, 0x3D23115C3ABD47DA,\n  0x3FECC00000000000, 0, 0x3FBB6AC88DAD6000, 0xBD1390802BF768E5,\n  0x3FECA00000000000, 0, 0x3FBC885801BC4000, 0x3D2646D1C65AACD3,\n  0x3FEC600000000000, 0, 0x3FBEC739830A2000, 0xBD2DC068AFE645E0,\n  0x3FEC400000000000, 0, 0x3FBFE89139DBE000, 0xBD2534D64FA10AFD,\n  0x3FEC000000000000, 0, 0x3FC1178E8227E000, 0x3D21EF78CE2D07F2,\n  0x3FEBE00000000000, 0, 0x3FC1AA2B7E23F000, 0x3D2CA78E44389934,\n  0x3FEBA00000000000, 0, 0x3FC2D1610C868000, 0x3D039D6CCB81B4A1,\n  0x3FEB800000000000, 0, 0x3FC365FCB0159000, 0x3CC62FA8234B7289,\n  0x3FEB400000000000, 0, 0x3FC4913D8333B000, 0x3D25837954FDB678,\n  0x3FEB200000000000, 0, 0x3FC527E5E4A1B000, 0x3D2633E8E5697DC7,\n  0x3FEAE00000000000, 0, 0x3FC6574EBE8C1000, 0x3D19CF8B2C3C2E78,\n  0x3FEAC00000000000, 0, 0x3FC6F0128B757000, 0xBD25118DE59C21E1,\n  0x3FEAA00000000000, 0, 0x3FC7898D85445000, 0xBD1C661070914305,\n  0x3FEA600000000000, 0, 0x3FC8BEAFEB390000, 0xBD073D54AAE92CD1,\n  0x3FEA400000000000, 0, 0x3FC95A5ADCF70000, 0x3D07F22858A0FF6F,\n  0x3FEA000000000000, 0, 0x3FCA93ED3C8AE000, 0xBD28724350562169,\n  0x3FE9E00000000000, 0, 0x3FCB31D8575BD000, 0xBD0C358D4EACE1AA,\n  0x3FE9C00000000000, 0, 0x3FCBD087383BE000, 0xBD2D4BC4595412B6,\n  0x3FE9A00000000000, 0, 0x3FCC6FFBC6F01000, 0xBCF1EC72C5962BD2,\n  0x3FE9600000000000, 0, 0x3FCDB13DB0D49000, 0xBD2AFF2AF715B035,\n  0x3FE9400000000000, 0, 0x3FCE530EFFE71000, 0x3CC212276041F430,\n  0x3FE9200000000000, 0, 0x3FCEF5ADE4DD0000, 0xBCCA211565BB8E11,\n  0x3FE9000000000000, 0, 0x3FCF991C6CB3B000, 0x3D1BCBECCA0CDF30,\n  0x3FE8C00000000000, 0, 0x3FD07138604D5800, 0x3CF89CDB16ED4E91,\n  0x3FE8A00000000000, 0, 0x3FD0C42D67616000, 0x3D27188B163CEAE9,\n  0x3FE8800000000000, 0, 0x3FD1178E8227E800, 0xBD2C210E63A5F01C,\n  0x3FE8600000000000, 0, 0x3FD16B5CCBACF800, 0x3D2B9ACDF7A51681,\n  0x3FE8400000000000, 0, 0x3FD1BF99635A6800, 0x3D2CA6ED5147BDB7,\n  0x3FE8200000000000, 0, 0x3FD214456D0EB800, 0x3D0A87DEBA46BAEA,\n  0x3FE7E00000000000, 0, 0x3FD2BEF07CDC9000, 0x3D2A9CFA4A5004F4,\n  0x3FE7C00000000000, 0, 0x3FD314F1E1D36000, 0xBD28E27AD3213CB8,\n  0x3FE7A00000000000, 0, 0x3FD36B6776BE1000, 0x3D116ECDB0F177C8,\n  0x3FE7800000000000, 0, 0x3FD3C25277333000, 0x3D183B54B606BD5C,\n  0x3FE7600000000000, 0, 0x3FD419B423D5E800, 0x3D08E436EC90E09D,\n  0x3FE7400000000000, 0, 0x3FD4718DC271C800, 0xBD2F27CE0967D675,\n  0x3FE7200000000000, 0, 0x3FD4C9E09E173000, 0xBD2E20891B0AD8A4,\n  0x3FE7000000000000, 0, 0x3FD522AE0738A000, 0x3D2EBE708164C759,\n  0x3FE6E00000000000, 0, 0x3FD57BF753C8D000, 0x3D1FADEDEE5D40EF,\n  0x3FE6C00000000000, 0, 0x3FD5D5BDDF596000, 0xBD0A0B2A08A465DC\n]);\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkint(iy: u64): i32 {\n  let e = iy >> 52 & 0x7FF;\n  if (e < 0x3FF     ) return 0;\n  if (e > 0x3FF + 52) return 2;\n  e = u64(1) << (0x3FF + 52 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflow(sign: u32, y: f64): f64 {\n  return select(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x1000000000000000)); // 0x1p-767\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x7000000000000000)); // 0x1p769\n}\n\n// Returns 1 if input is the bit representation of 0, infinity or nan.\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnan(u: u64): bool {\n  return (u << 1) - 1 >= 0xFFE0000000000000 - 1;\n}\n\n// @ts-ignore: decorator\n@lazy let log_tail: f64 = 0;\n\n// Compute y+TAIL = log(x) where the rounded result is y and TAIL has about\n// additional 15 bits precision. IX is the bit representation of x, but\n// normalized in the subnormal range using the sign bit for the exponent.\n// @ts-ignore: decorator\n@inline\nfunction log_inline(ix: u64): f64 {\n  const N = 1 << POW_LOG_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    Ln2hi = reinterpret<f64>(0x3FE62E42FEFA3800),\n    Ln2lo = reinterpret<f64>(0x3D2EF35793C76730);\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000000),\n    A1 = reinterpret<f64>(0xBFE5555555555560),\n    A2 = reinterpret<f64>(0x3FE0000000000006),\n    A3 = reinterpret<f64>(0x3FE999999959554E),\n    A4 = reinterpret<f64>(0xBFE555555529A47A),\n    A5 = reinterpret<f64>(0xBFF2495B9B4845E9),\n    A6 = reinterpret<f64>(0x3FF0002B8B263FC3);\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp = ix - 0x3fE6955500000000;\n  let i   = usize((tmp >> (52 - POW_LOG_TABLE_BITS)) & N_MASK);\n  let k   = <i64>tmp >> 52;\n  let iz  = ix - (tmp & u64(0xFFF) << 52);\n  let z   = reinterpret<f64>(iz);\n  let kd  = <f64>k;\n\n  // log(x) = k*Ln2 + log(c) + log1p(z/c-1).\n  let invc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 0 << alignof<f64>()); // tab[i].invc\n  let logc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 2 << alignof<f64>()); // tab[i].logc\n  let logctail = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 3 << alignof<f64>()); // tab[i].logctail\n\n  // Note: 1/c is j/N or j/N/2 where j is an integer in [N,2N) and\n  // |z/c - 1| < 1/N, so r = z/c - 1 is exactly representible.\n  // Split z such that rhi, rlo and rhi*rhi are exact and |rlo| <= |r|.\n  let zhi = reinterpret<f64>((iz + u64(0x80000000)) & 0xFFFFFFFF00000000);\n  let zlo = z - zhi;\n  let rhi = zhi * invc - 1.0;\n  let rlo = zlo * invc;\n  let r   = rhi + rlo;\n\n  // k * Ln2 + log(c) + r.\n  let t1  = kd * Ln2hi + logc;\n  let t2  = t1 + r;\n  let lo1 = kd * Ln2lo + logctail;\n  let lo2 = t1 - t2 + r;\n\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  let ar  = A0 * r; // A[0] = -0.5\n  let ar2 = r * ar;\n  let ar3 = r * ar2;\n  // k * Ln2 + log(c) + r + A[0] * r * r.\n  let arhi  = A0  * rhi;\n  let arhi2 = rhi * arhi;\n  let hi    = t2  + arhi2;\n  let lo3   = rlo * (ar + arhi);\n  let lo4   = t2 - hi + arhi2;\n\n  // p = log1p(r) - r - A[0] * r * r.\n  let p  = ar3 * (A1 + r * A2 + ar2 * (A3 + r * A4 + ar2 * (A5 + r * A6)));\n  let lo = lo1 + lo2 + lo3 + lo4 + p;\n  let y  = hi + lo;\n  log_tail = hi - y + lo;\n\n  return y;\n}\n\n// @ts-ignore: decorator\n@inline const SIGN_BIAS = 0x800 << EXP_TABLE_BITS;\n\n// Computes sign*exp(x+xtail) where |xtail| < 2^-8/N and |xtail| <= |x|.\n// The sign_bias argument is SIGN_BIAS or 0 and sets the sign to -1 or 1.\n// @ts-ignore: decorator\n@inline\nfunction exp_inline(x: f64, xtail: f64, sign_bias: u32): f64 {\n  const N      = 1 << EXP_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  let abstop: u32;\n  let ki: u64, top: u64, sbits: u64;\n  let idx: usize;\n  // double_t for better performance on targets with FLT_EVAL_METHOD==2.\n  let kd: f64, z: f64, r: f64, r2: f64, scale: f64, tail: f64, tmp: f64;\n\n  let ux = reinterpret<u64>(x);\n  abstop = u32(ux >> 52) & 0x7FF;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) {\n      // Avoid spurious underflow for tiny x.\n      // Note: 0 is common input.\n      return select(-1.0, 1.0, sign_bias);\n    }\n    if (abstop >= 0x409) { // top12(1024.0)\n      // Note: inf and nan are already handled.\n      return <i64>ux < 0\n        ? uflow(sign_bias)\n        : oflow(sign_bias);\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)].\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N].\n  z = InvLn2N * x;\n\n  // #if TOINT_INTRINSICS\n  //   kd = roundtoint(z);\n  //   ki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  //   // z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  //   kd = eval_as_double(z + shift);\n  //   ki = asuint64(kd) >> 16;\n  //   kd = (double_t)(int32_t)ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes\n  kd  = z + shift;\n  ki  = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // The code assumes 2^-200 < |xtail| < 2^-8/N\n  r += xtail;\n  // 2^(k/N) ~= scale * (1 + tail)\n  idx = usize((ki & N_MASK) << 1);\n  top = (ki + sign_bias) << (52 - EXP_TABLE_BITS);\n\n  tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>())));\n  // This is only a valid scale when -1023*N < k < 1024*N\n  sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top;\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp\n  tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function pow_lut(x: f64, y: f64): f64 {\n  const Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  let sign_bias: u32 = 0;\n  let ix = reinterpret<u64>(x);\n  let iy = reinterpret<u64>(y);\n  let topx = ix >> 52;\n  let topy = iy >> 52;\n\n  if (topx - 0x001 >= 0x7FF - 0x001 || (topy & 0x7FF) - 0x3BE >= 0x43e - 0x3BE) {\n    // Note: if |y| > 1075 * ln2 * 2^53 ~= 0x1.749p62 then pow(x,y) = inf/0\n    // and if |y| < 2^-54 / 1075 ~= 0x1.e7b6p-65 then pow(x,y) = +-1.\n    // Special cases: (x < 0x1p-126 or inf or nan) or\n    // (|y| < 0x1p-65 or |y| >= 0x1p63 or nan).\n    if (zeroinfnan(iy)) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3FF0000000000000) return NaN; // original: 1.0\n      if ((ix << 1) > 0xFFE0000000000000 || (iy << 1) > 0xFFE0000000000000) return x + y;\n      if ((ix << 1) == 0x7FE0000000000000) return NaN; // original: 1.0\n      if (((ix << 1) < 0x7FE0000000000000) == !(iy >> 63)) return 0; // |x|<1 && y==inf or |x|>1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnan(ix)) {\n      let x2 = x * x;\n      if (i32(ix >> 63) && checkint(iy) == 1) x2 = -x2;\n      return <i64>iy < 0 ? 1 / x2 : x2;\n    }\n    // Here x and y are non-zero finite\n    if (<i64>ix < 0) {\n      // Finite x < 0\n      let yint = checkint(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) sign_bias = SIGN_BIAS;\n      ix   &= 0x7FFFFFFFFFFFFFFF;\n      topx &= 0x7FF;\n    }\n    if ((topy & 0x7FF) - 0x3BE >= 0x43E - 0x3BE) {\n      // Note: sign_bias == 0 here because y is not odd.\n      if (ix == 0x3FF0000000000000) return 1;\n      if ((topy & 0x7FF) < 0x3BE)   return 1; // |y| < 2^-65, x^y ~= 1 + y*log(x).\n      return (ix > 0x3FF0000000000000) == (topy < 0x800) ? Infinity : 0;\n    }\n    if (topx == 0) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u64>(x * Ox1p52);\n      ix &= 0x7FFFFFFFFFFFFFFF;\n      ix -= u64(52) << 52;\n    }\n  }\n\n  let hi = log_inline(ix);\n  let lo = log_tail;\n  let ehi: f64, elo: f64;\n  // #if __FP_FAST_FMA\n  //   ehi = y * hi;\n  //   elo = y * lo + __builtin_fma(y, hi, -ehi);\n  // #else\n  let yhi = reinterpret<f64>(iy & 0xFFFFFFFFF8000000);\n  let ylo = y - yhi;\n  let lhi = reinterpret<f64>(reinterpret<u64>(hi) & 0xFFFFFFFFF8000000);\n  let llo = hi - lhi + lo;\n  ehi = yhi * lhi;\n  elo = ylo * lhi + y * llo; // |elo| < |ehi| * 2^-25.\n  // #endif\n  return exp_inline(ehi, elo, sign_bias);\n}\n","import {\n  itoa32,\n  utoa32,\n  itoa64,\n  utoa64,\n  dtoa,\n  itoa_buffered,\n  dtoa_buffered,\n  MAX_DOUBLE_LENGTH\n} from \"./number\";\n\nimport {\n  ipow32\n} from \"../math\";\n\n// All tables are stored as two staged lookup tables (static tries)\n// because the full range of Unicode symbols can't be efficiently\n// represented as-is in memory (see Unicode spec ch 5, p.196):\n// https://www.unicode.org/versions/Unicode12.0.0/ch05.pdf\n// Tables have been generated using these forked musl tools:\n// https://github.com/MaxGraey/musl-chartable-tools/tree/case-ignorable\n\n// Lookup table to check if a character is alphanumeric or not\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/alpha.h\n// size: 3904 bytes\n// @ts-ignore\n@inline @lazy const ALPHA_TABLE = memory.data<u8>([\n  18,17,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,17,34,35,36,17,37,38,39,40,\n  41,42,43,44,17,45,46,47,16,16,48,16,16,16,16,16,16,16,49,50,51,16,52,53,16,16,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,54,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,55,17,17,17,17,56,17,57,58,59,60,61,62,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,63,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,64,65,17,66,67,\n  68,69,70,71,72,73,74,17,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,\n  93,94,16,95,96,97,98,17,17,17,99,100,101,16,16,16,16,16,16,16,16,16,16,17,17,\n  17,17,102,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,103,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,17,17,104,105,16,16,106,107,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,108,17,17,17,17,109,110,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  17,111,112,16,16,16,16,16,16,16,16,16,113,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,114,115,116,117,16,16,16,16,16,16,16,16,118,\n  119,120,16,16,16,16,16,121,122,16,16,16,16,123,16,16,124,16,16,16,16,16,16,16,\n  16,16,125,16,16,16,\n  16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,254,255,255,7,254,\n  255,255,7,0,0,0,0,0,4,32,4,255,255,127,255,255,255,127,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,195,255,3,0,31,80,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,223,188,64,215,255,255,\n  251,255,255,255,255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,3,252,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,254,255,255,255,127,2,255,255,255,\n  255,255,1,0,0,0,0,255,191,182,0,255,255,255,135,7,0,0,0,255,7,255,255,255,255,\n  255,255,255,254,255,195,255,255,255,255,255,255,255,255,255,255,255,255,239,\n  31,254,225,255,\n  159,0,0,255,255,255,255,255,255,0,224,255,255,255,255,255,255,255,255,255,255,\n  255,255,3,0,255,255,255,255,255,7,48,4,255,255,255,252,255,31,0,0,255,255,255,\n  1,255,7,0,0,0,0,0,0,255,255,223,255,255,0,240,255,248,3,255,255,255,255,255,\n  255,255,255,255,239,255,223,225,255,207,255,254,255,239,159,249,255,255,253,\n  197,227,159,89,128,176,207,255,3,16,238,135,249,255,255,253,109,195,135,25,2,\n  94,192,255,63,0,238,191,251,255,255,253,237,227,191,27,1,0,207,255,0,30,238,\n  159,249,255,255,253,237,227,159,25,192,176,207,255,2,0,236,199,61,214,24,199,\n  255,195,199,29,129,0,192,255,0,0,239,223,253,255,255,253,255,227,223,29,96,7,\n  207,255,0,0,239,223,253,255,255,253,239,227,223,29,96,64,207,255,6,0,255,223,\n  253,255,255,255,255,231,223,93,240,128,207,255,0,252,238,255,127,252,255,255,\n  251,47,127,128,95,255,192,255,12,0,254,255,255,255,255,127,255,7,63,32,255,3,\n  0,0,0,0,214,247,255,255,175,255,255,59,95,32,255,243,0,0,0,\n  0,1,0,0,0,255,3,0,0,255,254,255,255,255,31,254,255,3,255,255,254,255,255,255,\n  31,0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,249,255,3,255,255,255,255,255,\n  255,255,255,255,63,255,255,255,255,191,32,255,255,255,255,255,247,255,255,255,\n  255,255,255,255,255,255,61,127,61,255,255,255,255,255,61,255,255,255,255,61,\n  127,61,255,127,255,255,255,255,255,255,255,61,255,255,255,255,255,255,255,255,\n  7,0,0,0,0,255,255,0,0,255,255,255,255,255,255,255,255,255,255,63,63,254,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,159,255,255,254,255,255,7,255,255,255,255,255,255,255,255,\n  255,199,255,1,255,223,15,0,255,255,15,0,255,255,15,0,255,223,13,0,255,255,255,\n  255,255,255,207,255,255,1,128,16,255,3,0,0,0,0,255,3,255,255,255,255,255,255,\n  255,255,255,255,255,1,255,255,255,255,255,7,255,255,255,255,255,255,255,255,\n  63,\n  0,255,255,255,127,255,15,255,1,192,255,255,255,255,63,31,0,255,255,255,255,\n  255,15,255,255,255,3,255,3,0,0,0,0,255,255,255,15,255,255,255,255,255,255,255,\n  127,254,255,31,0,255,3,255,3,128,0,0,128,1,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,239,255,239,15,255,3,0,0,0,0,255,255,255,255,255,243,255,255,255,255,255,\n  255,191,255,3,0,255,255,255,255,255,255,127,0,255,227,255,255,255,255,255,63,\n  255,1,255,255,255,255,255,231,0,0,0,0,0,222,111,4,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,\n  128,255,31,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,255,\n  255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,132,252,47,62,80,189,255,243,\n  224,67,0,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,\n  0,255,255,255,255,255,127,255,255,255,255,255,127,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,31,120,12,0,255,255,255,255,191,32,255,\n  255,255,255,255,255,255,128,0,0,255,255,127,0,127,127,127,127,127,127,127,127,\n  255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,224,0,0,0,254,3,62,31,254,255,255,255,255,255,255,255,255,255,127,224,254,\n  255,255,255,255,255,255,255,255,255,255,247,224,255,255,255,255,255,254,255,\n  255,255,255,255,255,255,255,255,255,127,0,0,255,255,255,255,0,0,0,0,0,0,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,\n  31,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,63,255,31,255,255,255,15,0,0,255,255,255,255,\n  255,127,240,143,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,\n  0,128,255,252,255,255,255,255,255,255,255,255,255,255,255,255,249,255,255,255,\n  255,255,255,252,7,0,0,0,0,224,255,191,255,255,255,255,0,0,0,255,255,255,255,\n  255,255,15,0,255,255,255,255,255,255,255,255,47,0,255,3,0,0,252,232,255,255,\n  255,255,255,7,255,255,255,255,7,0,255,255,255,31,255,255,255,255,255,255,247,\n  255,0,128,255,3,255,255,255,127,255,255,255,255,255,255,127,0,255,63,255,3,\n  255,255,127,252,255,255,255,255,255,255,255,127,5,0,0,56,255,255,60,0,126,126,\n  126,0,127,127,255,255,255,255,255,247,255,3,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,7,255,3,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,15,0,255,255,127,248,255,255,255,255,\n  255,\n  15,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,3,0,0,0,0,127,0,248,224,255,253,127,95,219,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,3,0,0,0,248,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,0,0,255,255,255,255,255,255,255,255,\n  252,255,255,255,255,255,255,0,0,0,0,0,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,223,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,255,3,\n  254,255,255,7,254,255,255,7,192,255,255,255,255,255,255,255,255,255,255,127,\n  252,252,252,28,0,0,0,0,255,239,255,255,127,255,255,183,255,63,255,63,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,31,255,255,255,255,255,255,1,0,0,0,0,\n  0,255,255,255,255,0,224,255,255,255,7,255,255,255,255,255,7,255,255,255,63,\n  255,255,255,255,15,255,62,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,255,3,255,255,255,255,15,255,255,255,\n  255,15,255,255,255,255,255,0,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,0,255,255,63,0,255,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,63,253,255,255,255,255,191,145,255,255,63,0,255,255,\n  127,0,255,255,255,127,0,0,0,0,0,0,0,0,255,255,55,0,255,255,63,0,255,255,255,3,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,192,0,0,0,0,0,0,0,0,111,240,239,\n  254,255,255,63,0,0,0,0,0,255,255,255,31,255,255,255,31,0,0,0,0,255,254,255,\n  255,31,0,0,0,255,255,255,255,255,255,63,0,255,255,63,0,255,255,7,0,255,255,3,\n  0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,255,1,0,0,0,0,0,0,255,255,255,255,255,255,7,\n  0,255,255,255,255,255,255,7,0,255,255,255,255,255,0,255,3,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  255,27,3,0,0,0,0,0,0,0,0,0,255,255,255,31,128,0,255,255,63,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,31,0,0,0,255,255,127,0,255,255,255,255,255,255,255,255,63,0,0,\n  0,192,255,0,0,252,255,255,255,255,255,255,1,0,0,255,255,255,1,255,3,255,255,\n  255,255,255,255,199,255,240,0,255,255,255,255,71,0,255,255,255,255,255,255,\n  255,255,30,192,255,23,0,0,0,0,255,255,251,255,255,255,159,64,0,0,0,0,0,0,0,0,\n  127,189,255,191,255,1,255,255,255,255,255,255,255,1,255,3,239,159,249,255,255,\n  253,237,227,159,25,129,224,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,187,7,255,131,3,0,0,0,255,255,255,255,255,\n  255,255,255,179,0,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  255,255,255,63,127,0,0,0,63,0,0,0,0,255,255,255,255,255,255,255,127,17,0,255,\n  3,0,0,0,0,255,255,255,255,255,255,63,1,255,3,0,0,0,0,0,0,255,255,255,231,255,\n  7,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,3,0,128,\n  127,242,111,255,255,255,191,153,7,0,255,3,0,0,0,0,0,0,0,0,255,252,255,255,255,\n  255,255,252,26,0,0,0,255,255,255,255,255,255,231,127,0,0,255,255,255,255,255,\n  255,255,255,255,32,0,0,0,0,255,255,255,255,255,255,255,1,255,253,255,255,255,\n  255,127,127,1,0,255,3,0,0,252,255,255,255,252,255,255,254,127,0,0,0,0,0,0,0,0,\n  0,127,251,255,255,255,255,127,180,203,0,255,3,191,253,255,255,255,127,123,1,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,127,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,\n  0,255,255,255,255,255,255,255,1,255,255,255,127,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,63,0,0,255,255,255,255,255,255,0,0,15,0,255,3,248,255,255,224,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,135,\n  255,255,255,255,255,255,255,128,255,255,0,0,0,0,0,0,0,0,11,0,3,0,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,0,0,0,0,0,\n  255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  127,0,0,0,0,0,0,7,0,240,0,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,15,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,7,255,31,255,1,255,67,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,255,255,255,\n  223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,\n  255,123,95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,63,255,255,255,253,255,255,247,255,255,255,\n  247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,255,253,\n  255,255,255,253,255,255,247,207,255,255,255,255,255,255,127,255,255,249,219,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,31,\n  128,63,255,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,15,255,\n  3,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,31,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,143,8,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,239,255,255,255,150,254,247,10,\n  132,234,150,170,150,247,247,94,255,251,255,15,238,251,255,15,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,3\n]);\n\n// size: 1568 bytes (compressed to ~1380 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASED = memory.data<u8>([\n  18,19,20,21,22,23,16,16,16,16,16,16,16,16,16,16,\n  24,16,16,25,16,16,16,16,16,16,16,16,26,27,17,28,\n  29,30,16,16,31,16,16,16,16,16,16,16,32,33,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,34,35,16,16,16,36,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,37,16,16,16,38,\n  16,16,16,16,39,16,16,16,16,16,16,16,40,16,16,16,\n  16,16,16,16,16,16,16,16,41,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,42,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,43,44,45,46,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,47,16,16,16,16,16,16,\n  16,48,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,254,255,255,7,254,255,255,7,0,0,0,0,0,4,32,4,\n  255,255,127,255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,247,240,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,239,255,255,255,255,1,3,0,0,0,31,0,0,0,\n  0,0,0,0,0,0,0,0,32,0,0,0,0,0,207,188,64,215,255,255,251,255,255,255,\n  255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  3,252,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,255,\n  255,255,127,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  191,32,255,255,255,255,255,231,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,255,255,255,255,255,255,63,63,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,1,255,255,255,255,255,231,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,\n  255,255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,\n  132,252,47,62,80,189,31,242,224,67,0,0,255,255,255,255,24,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,0,255,255,255,255,255,127,255,255,\n  255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,120,12,0,\n  255,255,255,255,191,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,63,0,0,\n  255,255,255,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,255,255,\n  255,255,255,255,255,255,255,255,255,120,255,255,255,255,255,255,252,7,0,0,0,0,96,7,\n  0,0,0,0,0,0,255,255,255,255,255,247,255,1,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,127,0,248,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,254,255,255,7,\n  254,255,255,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,15,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,7,0,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,\n  255,255,255,223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,255,123,\n  95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,\n  253,255,255,247,255,255,255,247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,\n  255,253,255,255,255,253,255,255,247,15,0,0,0,0,0,0,255,255,255,255,255,255,255,255,\n  15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0\n]);\n\n// size: 2976 bytes (compressed to ~2050 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASE_IGNORABLES = memory.data<u8>([\n  18,16,19,20,21,22,23,24,25,26,27,28,29,30,31,32,\n  33,16,16,34,16,16,16,35,36,37,38,39,40,41,16,42,\n  43,16,16,16,16,16,16,16,16,16,16,16,44,45,46,16,\n  47,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  48,16,16,16,49,16,50,51,52,53,54,55,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,56,16,16,57,58,\n  16,59,60,61,16,16,16,16,16,16,62,16,16,63,64,65,\n  66,67,68,69,70,71,72,73,74,75,76,16,77,78,79,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,80,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,81,82,16,16,16,83,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,84,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,85,86,16,16,16,16,16,16,16,87,16,16,16,16,16,\n  88,89,90,16,16,16,16,16,91,92,16,16,16,16,16,16,\n  16,16,16,93,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,128,64,0,4,0,0,0,64,1,0,0,0,0,0,0,0,0,161,144,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,48,4,176,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0,0,0,\n  0,0,254,255,255,255,255,191,182,0,0,0,0,0,16,0,63,0,255,23,0,0,0,0,\n  1,248,255,255,0,0,1,0,0,0,0,0,0,0,0,0,0,0,192,191,255,61,0,0,\n  0,128,2,0,0,0,255,255,255,7,0,0,0,0,0,0,0,0,0,0,192,255,1,0,\n  0,0,0,0,0,248,63,36,0,0,192,255,255,63,0,0,0,0,0,14,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,248,255,255,255,255,255,7,0,0,0,0,0,0,20,\n  254,33,254,0,12,0,2,0,2,0,0,0,0,0,0,16,30,32,0,0,12,0,0,64,\n  6,0,0,0,0,0,0,16,134,57,2,0,0,0,35,0,6,0,0,0,0,0,0,16,\n  190,33,0,0,12,0,0,252,2,0,0,0,0,0,0,144,30,32,96,0,12,0,0,0,\n  4,0,0,0,0,0,0,0,1,32,0,0,0,0,0,0,17,0,0,0,0,0,0,192,\n  193,61,96,0,12,0,0,0,2,0,0,0,0,0,0,144,64,48,0,0,12,0,0,0,\n  3,0,0,0,0,0,0,24,30,32,0,0,12,0,0,0,2,0,0,0,0,0,0,0,\n  0,4,92,0,0,0,0,0,0,0,0,0,0,0,242,7,192,127,0,0,0,0,0,0,\n  0,0,0,0,0,0,242,31,64,63,0,0,0,0,0,0,0,0,0,3,0,0,160,2,\n  0,0,0,0,0,0,254,127,223,224,255,254,255,255,255,31,64,0,0,0,0,0,0,0,\n  0,0,0,0,0,224,253,102,0,0,0,195,1,0,30,0,100,32,0,32,0,0,0,0,\n  0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,224,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,28,0,\n  0,0,12,0,0,0,12,0,0,0,0,0,0,0,176,63,64,254,143,32,0,0,0,0,\n  0,120,0,0,0,0,0,0,8,0,0,0,0,0,0,0,96,0,0,0,0,2,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,135,1,4,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,9,0,0,0,0,\n  0,0,64,127,229,31,248,159,0,0,0,0,128,0,255,255,1,0,0,0,0,0,0,0,\n  15,0,0,0,0,0,208,23,4,0,0,0,0,248,15,0,3,0,0,0,60,59,0,0,\n  0,0,0,0,64,163,3,0,0,0,0,0,0,240,207,0,0,0,0,0,0,0,0,63,\n  0,0,0,0,0,0,0,0,0,0,247,255,253,33,16,3,0,0,0,0,0,240,255,255,\n  255,255,255,255,255,7,0,1,0,0,0,248,255,255,255,255,255,255,255,255,255,255,255,251,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,\n  3,224,0,224,0,224,0,96,0,248,0,3,144,124,0,0,0,0,0,0,223,255,2,128,\n  0,0,255,31,0,0,0,0,0,0,255,255,255,255,1,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,128,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,60,62,8,\n  0,0,0,0,0,0,0,0,0,0,0,126,0,0,0,0,0,0,0,0,0,0,0,112,\n  0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,0,16,0,0,0,0,0,0,\n  0,0,0,0,0,128,247,191,0,0,0,240,0,0,0,0,0,0,0,0,0,0,3,0,\n  255,255,255,255,3,0,0,0,0,0,0,0,0,0,1,0,0,7,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,3,68,8,0,0,96,16,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,48,0,0,0,255,255,3,128,0,0,0,0,192,63,0,0,\n  128,255,3,0,0,0,0,0,7,0,0,0,0,0,200,51,0,128,0,0,96,0,0,0,\n  0,0,0,0,0,126,102,0,8,16,0,0,0,0,1,16,0,0,0,0,0,0,157,193,\n  2,0,0,32,0,48,88,0,0,0,0,0,0,0,0,0,0,0,0,248,0,14,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,32,33,0,0,0,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,3,0,0,0,0,0,0,0,\n  255,255,8,0,255,255,0,0,0,0,36,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,128,128,64,0,4,0,0,0,64,1,0,0,0,0,0,1,0,\n  0,0,0,192,0,0,0,0,0,0,0,0,8,0,0,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,240,0,0,0,0,0,135,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,\n  0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  192,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  2,0,0,0,0,0,0,255,127,0,0,0,0,0,0,128,3,0,0,0,0,0,120,38,\n  0,32,0,0,0,0,0,0,7,0,0,0,128,239,31,0,0,0,0,0,0,0,8,0,\n  3,0,0,0,0,0,192,127,0,158,0,0,0,0,0,0,0,0,0,0,0,128,211,64,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,248,7,0,0,\n  3,0,0,0,0,0,0,24,1,0,0,0,192,31,31,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,92,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,248,133,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,176,1,0,0,48,0,0,0,0,\n  0,0,0,0,0,0,248,167,1,0,0,0,0,0,0,0,0,0,0,0,0,40,191,0,\n  0,0,0,0,0,0,0,0,0,0,0,224,188,15,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,255,6,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,88,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,240,12,1,0,0,0,254,7,0,0,0,0,248,121,128,0,126,14,0,0,0,0,\n  0,252,127,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,191,\n  0,0,0,0,0,0,0,0,0,0,252,255,255,252,109,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,126,180,191,0,0,0,0,0,0,0,0,0,163,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,255,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,31,0,0,0,0,0,0,0,127,0,15,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,128,0,0,0,0,0,0,0,128,255,255,0,0,0,0,0,0,0,0,27,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,15,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,248,255,\n  231,15,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,127,248,255,255,255,255,255,31,32,0,16,0,0,248,254,255,0,0,\n  0,0,0,0,0,0,0,0,127,255,255,249,219,7,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,63,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,127,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  240,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,248\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOWER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  91,92,93,94,95,96,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  123,124,125,126,127\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const UPPER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  91,92,93,94,95,96,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  123,124,125,126,127\n]);\n\n// 23 * 8 = 184 bytes\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<f64>([\n  1e00, 1e01, 1e02, 1e03, 1e04, 1e05, 1e06, 1e07, 1e08, 1e09,\n  1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\n  1e20, 1e21, 1e22\n]);\n\n// @ts-ignore: decorator\n@inline\nexport const enum CharCode {\n  PERCENT = 0x25,\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  I = 0x49,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5A,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  u = 0x75,\n  x = 0x78,\n  z = 0x7A\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isAscii(c: u32): bool {\n  return !(c >> 7);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isLower8(c: u32): bool {\n  return c - CharCode.a < 26;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isUpper8(c: u32): bool {\n  return c - CharCode.A < 26;\n}\n\nexport function isSpace(c: u32): bool {\n  if (c < 0x1680) { // < <LS> (1)\n    // <SP>, <TAB>, <LF>, <VT>, <FF>, <CR> and <NBSP>\n    // (c == 0x20 || c == 0xA0) was optimized to (c | 0x80) == 0xA0\n    return ((c | 0x80) == 0xA0) || (c - 0x09 <= 0x0D - 0x09);\n  }\n  if (c - 0x2000 <= 0x200A - 0x2000) return true;\n  switch (c) {\n    case 0x1680: // <LS> (1)\n    case 0x2028: // <LS> (2)\n    case 0x2029: // <PS>\n    case 0x202F: // <NNS>\n    case 0x205F: // <MMSP>\n    case 0x3000: // <IS>\n    case 0xFEFF: return true; // <ZWNBSP>\n  }\n  return false;\n}\n\nexport function isAlpha(c: u32): bool {\n  if (isAscii(c)) return (c | 32) - CharCode.a < 26;\n  if (c < 0x20000) {\n    // @ts-ignore: cast\n    return stagedBinaryLookup(ALPHA_TABLE, c);\n  }\n  return c < 0x2FFFE;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCased(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0x1F18A && stagedBinaryLookup(CASED, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCaseIgnorable(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0xE01F0 && stagedBinaryLookup(CASE_IGNORABLES, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isFinalSigma(buffer: usize, index: isize, len: isize): bool {\n  const lookaheadLimit = 30; // max lookahead limit\n  let found = false;\n  let pos = index;\n  let minPos = max(0, pos - lookaheadLimit);\n  while (pos > minPos) {\n    let c = codePointBefore(buffer, pos);\n    if (!isCaseIgnorable(c)) {\n      if (isCased(c)) {\n        found = true;\n      } else {\n        return false;\n      }\n    }\n    pos -= isize(c >= 0x10000) + 1;\n  }\n  if (!found) return false;\n  pos = index + 1;\n  let maxPos = min(pos + lookaheadLimit, len);\n  while (pos < maxPos) {\n    let c = <u32>load<u16>(buffer + (pos << 1));\n    if (u32((c & 0xFC00) == 0xD800) & u32(pos + 1 != len)) {\n      let c1 = <u32>load<u16>(buffer + (pos << 1), 2);\n      if ((c1 & 0xFC00) == 0xDC00) {\n        c = (c - 0xD800 << 10) + (c1 - 0xDC00) + 0x10000;\n      }\n    }\n    if (!isCaseIgnorable(c)) {\n      return !isCased(c);\n    }\n    pos += isize(c >= 0x10000) + 1;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction codePointBefore(buffer: usize, index: isize): i32 {\n  if (index <= 0) return -1;\n  let c = <u32>load<u16>(buffer + (index - 1 << 1));\n  if (u32((c & 0xFC00) == 0xDC00) & u32(index - 2 >= 0)) {\n    let c1 = <u32>load<u16>(buffer + (index - 2 << 1));\n    if ((c1 & 0xFC00) == 0xD800) {\n      return ((c1 & 0x3FF) << 10) + (c & 0x3FF) + 0x10000;\n    }\n  }\n  return (c & 0xF800) == 0xD800 ? 0xFFFD : c;\n}\n\n// Search routine for two-staged lookup tables\nfunction stagedBinaryLookup(table: usize, c: u32): bool {\n  return <bool>((load<u8>(table + (<u32>load<u8>(table + (c >>> 8)) << 5) + ((c & 255) >> 3)) >>> (c & 7)) & 1);\n}\n\nexport function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {\n  let ptr1 = changetype<usize>(str1) + (index1 << 1);\n  let ptr2 = changetype<usize>(str2) + (index2 << 1);\n  if (ASC_SHRINK_LEVEL < 2) {\n    if (len >= 4 && !((ptr1 & 7) | (ptr2 & 7))) {\n      do {\n        if (load<u64>(ptr1) != load<u64>(ptr2)) break;\n        ptr1 += 8;\n        ptr2 += 8;\n        len  -= 4;\n      } while (len >= 4);\n    }\n  }\n  while (len--) {\n    let a = <i32>load<u16>(ptr1);\n    let b = <i32>load<u16>(ptr2);\n    if (a != b) return a - b;\n    ptr1 += 2;\n    ptr2 += 2;\n  }\n  return 0;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toLower8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c | u32(isUpper8(c)) << 5;\n  } else {\n    return <u32>load<u8>(LOWER127 + c);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toUpper8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c & ~(u32(isLower8(c)) << 5);\n  } else {\n    return <u32>load<u8>(UPPER127 + c);\n  }\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function strtol<T>(str: string, radix: i32 = 0): T {\n  let len = str.length;\n  if (!len) {\n    if (isFloat<T>()) {\n      // @ts-ignore: cast\n      return <T>NaN;\n    } else {\n      // @ts-ignore: cast\n      return <T>0;\n    }\n  }\n\n  let ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  let code = <u32>load<u16>(ptr);\n\n  // trim white spaces\n  while (isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  // determine sign\n  // @ts-ignore\n  let sign: T = 1;\n  if (code == CharCode.MINUS || code == CharCode.PLUS) {\n    if (!--len) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    if (code == CharCode.MINUS) {\n      // @ts-ignore: type\n      sign = -1;\n    }\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // See https://tc39.es/ecma262/#sec-parseint-string-radix\n  if (radix) {\n    if (radix < 2 || radix > 36) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    // handle case as parseInt(\"0xFF\", 16) by spec\n    if (radix == 16) {\n      if (\n        len > 2 &&\n        code == CharCode._0 &&\n        (<u32>load<u16>(ptr, 2) | 32) == CharCode.x\n      ) {\n        ptr += 4; len -= 2;\n      }\n    }\n  } else {\n    // determine radix by literal prefix\n    if (code == CharCode._0 && len > 2) {\n      switch (<u32>load<u16>(ptr, 2) | 32) {\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n      }\n    }\n    if (!radix) radix = 10;\n  }\n\n  // calculate value\n  // @ts-ignore: type\n  let num: T = 0;\n  let initial = len - 1;\n  while (len--) {\n    code = <u32>load<u16>(ptr);\n    if (code - CharCode._0 < 10) {\n      code -= CharCode._0;\n    } else if (code - CharCode.A <= <u32>(CharCode.Z - CharCode.A)) {\n      code -= CharCode.A - 10;\n    } else if (code - CharCode.a <= <u32>(CharCode.z - CharCode.a)) {\n      code -= CharCode.a - 10;\n    }\n    if (code >= <u32>radix) {\n      if (initial == len) {\n        if (isFloat<T>()) {\n          // @ts-ignore: cast\n          return <T>NaN;\n        } else {\n          // @ts-ignore: cast\n          return <T>0;\n        }\n      }\n      break;\n    }\n    // @ts-ignore: type\n    num = num * radix + code;\n    ptr += 2;\n  }\n  // @ts-ignore: type\n  return sign * num;\n}\n\nexport function strtod(str: string): f64 {\n  let len = str.length;\n  if (!len) return NaN;\n\n  let ptr  = changetype<usize>(str);\n  let code = <u32>load<u16>(ptr);\n\n  let sign = 1.0;\n  // skip white spaces\n  while (len && isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (!len) return NaN;\n\n  // try parse '-' or '+'\n  if (code == CharCode.MINUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // try parse Infinity\n  if (len >= 8 && code == CharCode.I) {\n    if (\n      load<u64>(ptr, 0) == 0x690066006E0049 && // ifnI\n      load<u64>(ptr, 8) == 0x7900740069006E    // ytin\n    ) {\n      return Infinity * sign;\n    }\n    return NaN;\n  }\n  // validate next symbol\n  if (code != CharCode.DOT && <u32>(code - CharCode._0) >= 10) {\n    return NaN;\n  }\n  let savedPtr = ptr;\n  // skip zeros\n  while (code == CharCode._0) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (len <= 0) return 0.0 * sign;\n  const capacity = 19; // int(64 * 0.3010)\n  let pointed = false;\n  let consumed = 0;\n  let position = 0;\n  let x: u64 = 0;\n  if (code == CharCode.DOT) {\n    let noDigits = !(savedPtr - ptr);\n    ptr += 2; --len;\n    if (!len && noDigits) return NaN;\n    for (pointed = true; (code = <u32>load<u16>(ptr)) == CharCode._0; --position, ptr += 2) --len;\n    if (len <= 0) return 0.0 * sign;\n    if (!position && noDigits && code - CharCode._0 >= 10) return NaN;\n  }\n  for (let digit = code - CharCode._0; digit < 10 || (code == CharCode.DOT && !pointed); digit = code - CharCode._0) {\n    if (digit < 10) {\n      x = consumed < capacity ? 10 * x + digit : x | u64(!!digit);\n      ++consumed;\n    } else {\n      position = consumed;\n      pointed = true;\n    }\n    if (!--len) break;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  if (!pointed) position = consumed;\n  return copysign<f64>(scientific(x, position - min(capacity, consumed) + parseExp(ptr, len)), sign);\n}\n\nexport function strtob(str: string): bool {\n  let size: usize = str.length << 1;\n  let offset: usize = 0;\n  if (size > 8) {\n    // try trim end whitespaces first\n    while (size && isSpace(load<u16>(changetype<usize>(str) + size - 2))) size -= 2;\n    if (size > 8) {\n      // trim start whitespaces\n      while (offset < size && isSpace(load<u16>(changetype<usize>(str) + offset))) offset += 2;\n      size -= offset;\n    }\n  }\n  if (size != 8) return false;\n  // \"true\" represents as \\00\\e\\00\\u\\00\\e\\00\\t (00 65 00 75 00 72 00 74)\n  return load<u64>(changetype<usize>(str) + offset) == 0x0065_0075_0072_0074;\n}\n\nexport function joinBooleanArray(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) return select(\"true\", \"false\", load<bool>(dataStart));\n\n  let sepLen = separator.length;\n  let valueLen = 5; // max possible length of element len(\"false\")\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: bool;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<bool>(dataStart + i);\n    valueLen = 4 + i32(!value);\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(select(\"true\", \"false\", value)),\n      <usize>valueLen << 1\n    );\n    offset += valueLen;\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<bool>(dataStart + <usize>lastIndex);\n  valueLen = 4 + i32(!value);\n  memory.copy(\n    changetype<usize>(result) + (<usize>offset << 1),\n    changetype<usize>(select(\"true\", \"false\", value)),\n    valueLen << 1\n  );\n  offset += valueLen;\n\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinIntegerArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    let value = load<T>(dataStart);\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(itoa32(<i32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(itoa64(<i32>value, 10));\n      }\n    } else {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(utoa32(<u32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(utoa64(<u64>value, 10));\n      }\n    }\n  }\n\n  let sepLen = separator.length;\n  const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinFloatArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    return changetype<string>(dtoa(\n      // @ts-ignore: type\n      load<T>(dataStart))\n    );\n  }\n\n  const valueLen = MAX_DOUBLE_LENGTH;\n  let sepLen = separator.length;\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinStringArray(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    // @ts-ignore: type\n    return load<string>(dataStart) || \"\";\n  }\n  let estLen = 0;\n  let value: string;\n  for (let i = 0; i < length; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (changetype<usize>(value) != 0) estLen += value.length;\n  }\n  let offset = 0;\n  let sepLen = separator.length;\n  let result = changetype<string>(__new((estLen + sepLen * lastIndex) << 1, idof<string>()));\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (changetype<usize>(value) != 0) {\n      let valueLen = value.length;\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(value),\n        <usize>valueLen << 1\n      );\n      offset += valueLen;\n    }\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<string>(dataStart + (<usize>lastIndex << alignof<string>()));\n  if (changetype<usize>(value) != 0) {\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(value),\n      <usize>value.length << 1\n    );\n  }\n  return result;\n}\n\nexport function joinReferenceArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  let value: T;\n  if (!lastIndex) {\n    value = load<T>(dataStart);\n    // @ts-ignore: type\n    return value != null ? value.toString() : \"\";\n  }\n  let result = \"\";\n  let sepLen = separator.length;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    if (value != null) result += value.toString();\n    if (sepLen) result += separator;\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  if (value != null) result += value.toString();\n  return result;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction scientific(significand: u64, exp: i32): f64 {\n  if (!significand || exp < -342) return 0;\n  if (exp > 308) return Infinity;\n  // Try use fast path\n  // Use fast path for string-to-double conversion if possible\n  // see http://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion\n  // Simple integer\n  let significandf = <f64>significand;\n  if (!exp) return significandf;\n  if (exp > 22 && exp <= 22 + 15) {\n    significandf *= pow10(exp - 22);\n    exp = 22;\n  }\n  if (significand <= 9007199254740991 && abs(exp) <= 22) {\n    if (exp > 0) return significandf * pow10(exp);\n    return significandf / pow10(-exp);\n  } else if (exp < 0) {\n    return scaledown(significand, exp);\n  } else {\n    return scaleup(significand, exp);\n  }\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaledown(significand: u64, exp: i32): f64 {\n  const denom: u64 = 6103515625; // 1e14 * 0x1p-14\n  const scale = reinterpret<f64>(0x3F06849B86A12B9B); // 1e-14 * 0x1p32\n\n  let shift = clz(significand);\n  significand <<= shift;\n  shift = exp - shift;\n\n  for (; exp <= -14; exp += 14) {\n    let q = significand / denom;\n    let r = significand % denom;\n    let s = clz(q);\n    significand = (q << s) + <u64>nearest(scale * <f64>(r << (s - 18)));\n    shift -= s;\n  }\n  let b = <u64>ipow32(5, -exp);\n  let q = significand / b;\n  let r = significand % b;\n  let s = clz(q);\n  significand = (q << s) + <u64>(reinterpret<f64>(reinterpret<u64>(<f64>r) + (s << 52)) / <f64>b);\n  shift -= s;\n\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaleup(significand: u64, exp: i32): f64 {\n  const coeff: u32 = 1220703125; // 1e13 * 0x1p-13;\n  let shift = ctz(significand);\n  significand >>= shift;\n  shift += exp;\n\n  __fixmulShift = shift;\n  for (; exp >= 13; exp -= 13) {\n    significand = fixmul(significand, coeff);\n  }\n  significand = fixmul(significand, <u32>ipow32(5, exp));\n  shift = __fixmulShift;\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction parseExp(ptr: usize, len: i32): i32 {\n  let sign = 1, magnitude = 0;\n  let code = <u32>load<u16>(ptr);\n  // check code is 'e' or 'E'\n  if ((code | 32) != CharCode.e) return 0;\n\n  if (!--len) return 0;\n  code = <u32>load<u16>(ptr += 2);\n  if (code == CharCode.MINUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  // skip zeros\n  while (code == CharCode._0) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  for (let digit: u32 = code - CharCode._0; len && digit < 10; digit = code - CharCode._0) {\n    if (magnitude >= 3200) return sign * 3200;\n    magnitude = 10 * magnitude + digit;\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  return sign * magnitude;\n}\n\n// @ts-ignore: decorator\n@lazy let __fixmulShift: u64 = 0;\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction fixmul(a: u64, b: u32): u64 {\n  let low  = (a & 0xFFFFFFFF) * b;\n  let high = (a >> 32) * b + (low >> 32);\n  let overflow = <u32>(high >> 32);\n  let space = clz(overflow);\n  let revspace: u64 = 32 - space;\n  __fixmulShift += revspace;\n  return (high << space | (low & 0xFFFFFFFF) >> revspace) + (low << space >> 31 & 1);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pow10(n: i32): f64 {\n  // argument `n` should bounds in [0, 22] range\n  return load<f64>(POWERS10 + (n << alignof<f64>()));\n}\n","import { Typeinfo, TypeinfoFlags } from \"./shared/typeinfo\";\nimport { E_INDEXOUTOFRANGE } from \"./util/error\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __rtti_base: usize;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_globals(cookie: u32): void;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_members(ref: usize, cookie: u32): void;\n\n// @ts-ignore: decorator\n@unsafe\nexport function __typeinfo(id: u32): TypeinfoFlags {\n  let ptr = __rtti_base;\n  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);\n  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newBuffer(size: usize, id: u32, data: usize = 0): usize {\n  let buffer = __new(size, id);\n  if (data) memory.copy(buffer, data, size);\n  return buffer;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {\n  let bufferSize = <usize>length << alignLog2;\n  // make sure `buffer` is tracked by the shadow stack\n  let buffer = changetype<ArrayBuffer>(__newBuffer(bufferSize, idof<ArrayBuffer>(), data));\n  // ...since allocating the array may trigger GC steps\n  let array = __new(offsetof<i32[]>(), id);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"buffer\"));\n  __link(array, changetype<usize>(buffer), false);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"dataStart\"));\n  store<i32>(array, bufferSize, offsetof<ArrayBufferView>(\"byteLength\"));\n  store<i32>(array, length, offsetof<i32[]>(\"length_\"));\n  return array;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nfunction __tostack(ptr: usize): usize { // eslint-disable-line\n  return ptr;\n}\n\n// These are provided by the respective implementation, included as another entry file by asc:\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __alloc(size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __realloc(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __free(ptr: usize): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __new(size: usize, id: u32): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __renew(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __collect(): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __visit(ptr: usize, cookie: u32): void;\n","// Common error messages for use across the standard library. Keeping error messages compact\n// and reusing them where possible ensures minimal static data in binaries.\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_VALUEOUTOFRANGE: string = \"Value out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_EMPTYARRAY: string = \"Array is empty\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALLOCATION_TOO_LARGE: string = \"Allocation too large\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALREADY_PINNED: string = \"Object already pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOT_PINNED: string = \"Object is not pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_URI_MALFORMED: string = \"URI malformed\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDDATE: string = \"Invalid Date\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_UNPAIRED_SURROGATE: string = \"Unpaired surrogate\";\n","import { compareImpl } from \"./string\";\n\ntype Comparator<T> = (a: T, b: T) => i32;\n\n// @ts-ignore: decorator\n@lazy @inline const EMPTY = u32.MAX_VALUE;\n// @ts-ignore: decorator\n@inline const INSERTION_SORT_THRESHOLD = 48;\n// @ts-ignore: decorator\n@inline const MIN_RUN_LENGTH = 32;\n\n// @ts-ignore: decorator\n@inline\nfunction log2u(n: u32): u32 {\n  return 31 - clz(n);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function COMPARATOR<T>(): Comparator<T> {\n  if (isInteger<T>()) {\n    if (isSigned<T>() && sizeof<T>() <= 4) {\n      return (a, b) => i32(a) - i32(b);\n    } else {\n      return (a, b) => i32(a > b) - i32(a < b);\n    }\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) {\n      return (a, b) => {\n        let ia = reinterpret<i32>(f32(a));\n        let ib = reinterpret<i32>(f32(b));\n        ia ^= ia >> 31 >>> 1;\n        ib ^= ib >> 31 >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    } else {\n      return (a, b) => {\n        let ia = reinterpret<i64>(f64(a));\n        let ib = reinterpret<i64>(f64(b));\n        ia ^= ia >> 63 >>> 1;\n        ib ^= ib >> 63 >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    }\n  } else if (isString<T>()) {\n    return (a, b) => {\n      if (\n        changetype<usize>(a) == changetype<usize>(b) ||\n        changetype<usize>(a) == 0 ||\n        changetype<usize>(b) == 0\n      ) return 0;\n      let alen = changetype<string>(a).length;\n      let blen = changetype<string>(b).length;\n      if (!(alen | blen)) return 0;\n      if (!alen) return -1;\n      if (!blen) return  1;\n      let res = compareImpl(\n        changetype<string>(a), 0,\n        changetype<string>(b), 0,\n        <usize>min(alen, blen)\n      );\n      return res ? res : alen - blen;\n    };\n  } else {\n    return (a, b) => i32(a > b) - i32(a < b);\n  }\n}\n\n// Power Sort implementation (stable) from paper \"Nearly-Optimal Mergesorts\"\n// https://arxiv.org/pdf/1805.04154.pdf\n// This method usually outperform TimSort.\n// TODO: refactor c >>> 31 to c < 0 when binaryen will support this opt\nexport function SORT<T>(\n  ptr: usize,\n  len: i32,\n  comparator: Comparator<T>\n): void {\n  if (len <= INSERTION_SORT_THRESHOLD) {\n    if (len <= 1) return;\n    if (ASC_SHRINK_LEVEL < 1) {\n      switch (len) {\n        case 3: {\n          let a = load<T>(ptr, 0);\n          let b = load<T>(ptr, 1 << alignof<T>());\n          let c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 0);\n          a = select<T>(a, b, c);\n          b = load<T>(ptr, 2 << alignof<T>());\n          c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 1 << alignof<T>());\n          store<T>(ptr, select<T>(a, b, c), 2 << alignof<T>());\n        }\n        case 2: {\n          let a = load<T>(ptr, 0);\n          let b = load<T>(ptr, 1 << alignof<T>());\n          let c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 0);\n          store<T>(ptr, select<T>(a, b, c), 1 << alignof<T>());\n          return;\n        }\n      }\n    }\n    insertionSort<T>(ptr, 0, len - 1, 0, comparator);\n    return;\n  }\n\n  let lgPlus2         = log2u(len) + 2;\n  let lgPlus2Size     = lgPlus2 << alignof<u32>();\n  let leftRunStartBuf = __alloc(lgPlus2Size << 1);\n  let leftRunEndBuf   = leftRunStartBuf + lgPlus2Size;\n\n  for (let i: u32 = 0; i < lgPlus2; ++i) {\n    store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\n  }\n\n  let buffer = __alloc(len << alignof<T>());\n\n  let hi   = len - 1;\n  let endA = extendRunRight<T>(ptr, 0, hi, comparator);\n  let lenA = endA + 1;\n\n  if (lenA < MIN_RUN_LENGTH) {\n    endA = min(hi, MIN_RUN_LENGTH - 1);\n    insertionSort<T>(ptr, 0, endA, lenA, comparator);\n  }\n\n  let top: u32 = 0, startA = 0;\n  while (endA < hi) {\n    let startB = endA + 1;\n    let endB = extendRunRight<T>(ptr, startB, hi, comparator);\n    let lenB = endB - startB + 1;\n\n    if (lenB < MIN_RUN_LENGTH) {\n      endB = min(hi, startB + MIN_RUN_LENGTH - 1);\n      insertionSort<T>(ptr, startB, endB, lenB, comparator);\n    }\n\n    let k = nodePower(0, hi, startA, startB, endB);\n\n    for (let i = top; i > k; --i) {\n      let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\n      if (start != EMPTY) {\n        mergeRuns<T>(\n          ptr,\n          start,\n          load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\n          endA,\n          buffer,\n          comparator\n        );\n        startA = start;\n        store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\n      }\n    }\n\n    store<u32>(leftRunStartBuf + (<usize>k << alignof<u32>()), startA);\n    store<u32>(leftRunEndBuf   + (<usize>k << alignof<u32>()), endA);\n    startA = startB;\n    endA = endB;\n    top = k;\n  }\n\n  for (let i = top; i != 0; --i) {\n    let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\n    if (start != EMPTY) {\n      mergeRuns<T>(\n        ptr,\n        start,\n        load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\n        hi,\n        buffer,\n        comparator\n      );\n    }\n  }\n  // dealloc aux buffers\n  __free(buffer);\n  __free(leftRunStartBuf);\n}\n\nfunction insertionSort<T>(\n  ptr: usize,\n  left: i32,\n  right: i32,\n  presorted: i32,\n  comparator: Comparator<T>\n): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    // slightly improved original insertion sort\n    for (let i = left + presorted; i <= right; ++i) {\n      let j = i - 1;\n      let a = load<T>(ptr + (<usize>i << alignof<T>()));\n      while (j >= left) {\n        let b = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, b) < 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), b, 1 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>());\n    }\n  } else {\n    // even-odd two-way insertion sort which allow increase minRunLen\n    let range = right - left + 1;\n    let i = left + select(range & 1, presorted - ((range - presorted) & 1), presorted == 0);\n    for (; i <= right; i += 2) {\n      let a = load<T>(ptr + (<usize>i << alignof<T>()), 0);\n      let b = load<T>(ptr + (<usize>i << alignof<T>()), 1 << alignof<T>());\n      let min = b, max = a;\n      if (comparator(a, b) <= 0) {\n        min = a, max = b;\n      }\n      let j = i - 1;\n      while (j >= left) {\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, max) > 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 2 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), max, 2 << alignof<T>());\n      while (j >= left) {\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, min) > 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), min, 1 << alignof<T>());\n    }\n  }\n}\n\nfunction nodePower(left: u32, right: u32, startA: u32, startB: u32, endB: u32): u32 {\n  let n: u64 = right - left + 1;\n  let s = startB - (left << 1);\n  let l = startA + s;\n  let r = endB   + s + 1;\n  let a = (<u64>l << 30) / n;\n  let b = (<u64>r << 30) / n;\n  return clz(<u32>(a ^ b));\n}\n\nfunction extendRunRight<T>(\n  ptr: usize,\n  i: i32,\n  right: i32,\n  comparator: Comparator<T>\n): i32 {\n  if (i == right) return i;\n  let j = i;\n  if (comparator(\n    load<T>(ptr + (<usize>  j << alignof<T>())),\n    load<T>(ptr + (<usize>++j << alignof<T>()))\n  ) > 0) {\n    while (\n      j < right &&\n      (comparator(\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\n        load<T>(ptr + (<usize>j << alignof<T>()))\n      ) >>> 31) // < 0\n    ) ++j;\n    // reverse\n    let k = j;\n    while (i < k) {\n      let tmp = load<T>(ptr + (<usize>i << alignof<T>()));\n      store<T>(ptr + (<usize>i << alignof<T>()), load<T>(ptr + (<usize>k << alignof<T>()))); ++i;\n      store<T>(ptr + (<usize>k << alignof<T>()), tmp); --k;\n    }\n  } else {\n    while (\n      j < right &&\n      comparator(\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\n        load<T>(ptr + (<usize>j << alignof<T>()))\n      ) >= 0\n    ) ++j;\n  }\n  return j;\n}\n\n// Merges arr[l..m - 1] and arr[m..r]\nfunction mergeRuns<T>(\n  ptr: usize,\n  l: i32,\n  m: i32,\n  r: i32,\n  buffer: usize,\n  comparator: Comparator<T>\n): void {\n  --m;\n  let i: i32, j: i32, t = r + m;\n  for (i = m + 1; i > l; --i) {\n    store<T>(\n      buffer + (<usize>(i - 1) << alignof<T>()),\n      load<T>(ptr + (<usize>(i - 1) << alignof<T>()))\n    );\n  }\n  for (j = m; j < r; ++j) {\n    store<T>(\n      buffer + (<usize>(t - j) << alignof<T>()),\n      load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>())\n    );\n  }\n  for (let k = l; k <= r; ++k) {\n    let a = load<T>(buffer + (<usize>j << alignof<T>()));\n    let b = load<T>(buffer + (<usize>i << alignof<T>()));\n    if (comparator(a, b) < 0) {\n      store<T>(ptr + (<usize>k << alignof<T>()), a);\n      --j;\n    } else {\n      store<T>(ptr + (<usize>k << alignof<T>()), b);\n      ++i;\n    }\n  }\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK_MAXSIZE } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { REVERSE, FILL } from \"./util/bytes\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\nimport { idof, isArray as builtin_isArray } from \"./builtins\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_EMPTYARRAY, E_HOLEYARRAY } from \"./util/error\";\n\n// @ts-ignore: decorator\n@inline @lazy const MIN_SIZE: usize = 8;\n\n/** Ensures that the given array has _at least_ the specified backing size. */\nfunction ensureCapacity(array: usize, newSize: usize, alignLog2: u32, canGrow: bool = true): void {\n  // Depends on the fact that Arrays mimic ArrayBufferView\n  let oldCapacity = <usize>changetype<ArrayBufferView>(array).byteLength;\n  if (newSize > oldCapacity >>> alignLog2) {\n    if (newSize > BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let oldData = changetype<usize>(changetype<ArrayBufferView>(array).buffer);\n    // Grows old capacity by factor of two.\n    // Make sure we don't reach BLOCK_MAXSIZE for new growed capacity.\n    let newCapacity = max(newSize, MIN_SIZE) << alignLog2;\n    if (canGrow) newCapacity = max(min(oldCapacity << 1, BLOCK_MAXSIZE), newCapacity);\n    let newData = __renew(oldData, newCapacity);\n    // __new / __renew already init memory range as zeros in Incremental runtime.\n    // So try to avoid this.\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(newData + oldCapacity, 0, newCapacity - oldCapacity);\n    }\n    if (newData != oldData) { // oldData has been free'd\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"buffer\"));\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"dataStart\"));\n      __link(array, changetype<usize>(newData), false);\n    }\n    store<u32>(array, <u32>newCapacity, offsetof<ArrayBufferView>(\"byteLength\"));\n  }\n}\n\nexport class Array<T> {\n  [key: number]: T;\n\n  // Mimicking ArrayBufferView isn't strictly necessary here but is done to allow glue code\n  // to work with typed and normal arrays interchangeably. Technically, normal arrays do not need\n  // `dataStart` (equals `buffer`) and `byteLength` (equals computed `buffer.byteLength`), but the\n  // block is 16 bytes anyway so it's fine to have a couple extra fields in there.\n\n  private buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  private byteLength: i32; // Uses here as capacity\n\n  // Also note that Array<T> with non-nullable T must guard against uninitialized null values\n  // whenever an element is accessed. Otherwise, the compiler wouldn't be able to guarantee\n  // type-safety anymore. For lack of a better word, such an array is \"holey\".\n\n  private length_: i32;\n\n  static isArray<U>(value: U): bool {\n    return isReference<U>() ? changetype<usize>(value) != 0 && builtin_isArray(value) : false;\n  }\n\n  static create<T>(capacity: i32 = 0): Array<T> {\n    WARNING(\"'Array.create' is deprecated. Use 'new Array' instead, making sure initial elements are initialized.\");\n    let array = new Array<T>(capacity);\n    array.length = 0;\n    return array;\n  }\n\n  constructor(length: i32 = 0) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    // reserve capacity for at least MIN_SIZE elements\n    let bufferSize = max(<usize>length, MIN_SIZE) << alignof<T>();\n    let buffer = changetype<ArrayBuffer>(__new(bufferSize, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, bufferSize);\n    }\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = <i32>bufferSize;\n    this.length_ = length;\n  }\n\n  get length(): i32 {\n    return this.length_;\n  }\n\n  set length(newLength: i32) {\n    ensureCapacity(changetype<usize>(this), newLength, alignof<T>(), false);\n    this.length_ = newLength;\n  }\n\n  every(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (!fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return false;\n    }\n    return true;\n  }\n\n  findIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  findLastIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let i = this.length_ - 1; i >= 0; --i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length_) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(this.dataStart + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length_) {\n      if (index < 0) throw new RangeError(E_INDEXOUTOFRANGE);\n      ensureCapacity(changetype<usize>(this), index + 1, alignof<T>());\n      this.length_ = index + 1;\n    }\n    store<T>(this.dataStart + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  at(index: i32): T {\n    let len = this.length_;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    if (isManaged<T>()) {\n      FILL<usize>(this.dataStart, this.length_, changetype<usize>(value), start, end);\n      __link(changetype<usize>(this), changetype<usize>(value), false);\n    } else {\n      FILL<T>(this.dataStart, this.length_, value, start, end);\n    }\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let len = this.length_;\n      if (len == 0 || fromIndex >= len) return false;\n      if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\n      let ptr = this.dataStart;\n      while (fromIndex < len) {\n        let elem = load<T>(ptr + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    let len = this.length_;\n    if (len == 0 || fromIndex >= len) return -1;\n    if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\n    let ptr = this.dataStart;\n    while (fromIndex < len) {\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length_): i32 {\n    let len = this.length_;\n    if (len == 0) return -1;\n    if (fromIndex < 0) fromIndex = len + fromIndex;\n    else if (fromIndex >= len) fromIndex = len - 1;\n    let ptr = this.dataStart;\n    while (fromIndex >= 0) {\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(value: T): i32 {\n    let oldLen = this.length_;\n    let len = oldLen + 1;\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\n    if (isManaged<T>()) {\n      store<usize>(this.dataStart + (<usize>oldLen << alignof<T>()), changetype<usize>(value));\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    } else {\n      store<T>(this.dataStart + (<usize>oldLen << alignof<T>()), value);\n    }\n    this.length_ = len;\n    return len;\n  }\n\n  concat(other: Array<T>): Array<T> {\n    let thisLen = this.length_;\n    let otherLen = other.length_;\n    let outLen = thisLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    let out = changetype<Array<T>>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n    let outStart = out.dataStart;\n    let thisSize = <usize>thisLen << alignof<T>();\n    if (isManaged<T>()) {\n      let thisStart = this.dataStart;\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\n        let ref = load<usize>(thisStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n      outStart += thisSize;\n      let otherStart = other.dataStart;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(otherStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(outStart, this.dataStart, thisSize);\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Array<T> {\n    let ptr = this.dataStart;\n    let len = this.length_;\n\n    end = min<i32>(end, len);\n\n    let to    = target < 0 ? max(len + target, 0) : min(target, len);\n    let from  = start < 0 ? max(len + start, 0) : min(start, len);\n    let last  = end < 0 ? max(len + end, 0) : min(end, len);\n    let count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      ptr + (<usize>to << alignof<T>()),\n      ptr + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  pop(): T {\n    let len = this.length_;\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\n    let val = load<T>(this.dataStart + (<usize>(--len) << alignof<T>()));\n    this.length_ = len;\n    return val;\n  }\n\n  forEach(fn: (value: T, index: i32, array: Array<T>) => void): void {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\n    let len = this.length_;\n    let out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\n    let outStart = out.dataStart;\n    for (let i = 0; i < min(len, this.length_); ++i) {\n      let result = fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\n    let result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      let value = load<T>(this.dataStart + (<usize>i << alignof<T>()));\n      if (fn(value, i, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = this.length_ - 1; i >= 0; --i) {\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  shift(): T {\n    let len = this.length_;\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\n    let base = this.dataStart;\n    let element = load<T>(base);\n    let lastIndex = len - 1;\n    memory.copy(\n      base,\n      base + sizeof<T>(),\n      <usize>lastIndex << alignof<T>()\n    );\n    if (isReference<T>()) {\n      store<usize>(base + (<usize>lastIndex << alignof<T>()), 0);\n    } else {\n      // @ts-ignore\n      store<T>(base + (<usize>lastIndex << alignof<T>()), <T>0);\n    }\n    this.length_ = lastIndex;\n    return element;\n  }\n\n  some(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return true;\n    }\n    return false;\n  }\n\n  unshift(value: T): i32 {\n    let len = this.length_ + 1;\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\n    let ptr = this.dataStart;\n    memory.copy(\n      ptr + sizeof<T>(),\n      ptr,\n      <usize>(len - 1) << alignof<T>()\n    );\n    store<T>(ptr, value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n    this.length_ = len;\n    return len;\n  }\n\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    let len = this.length_;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end  , len);\n    len = max(end - start, 0);\n    let slice = changetype<Array<T>>(__newArray(len, alignof<T>(), idof<Array<T>>()));\n    let sliceBase = slice.dataStart;\n    let thisBase = this.dataStart + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off = <usize>0;\n      let end = <usize>len << alignof<usize>();\n      while (off < end) {\n        let ref = load<usize>(thisBase + off);\n        store<usize>(sliceBase + off, ref);\n        __link(changetype<usize>(slice), ref, true);\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(sliceBase, thisBase, len << alignof<T>());\n    }\n    return slice;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\n    let len = this.length_;\n    start       = start < 0 ? max<i32>(len + start, 0) : min<i32>(start, len);\n    deleteCount = max<i32>(min<i32>(deleteCount, len - start), 0);\n    let result  = changetype<Array<T>>(__newArray(deleteCount, alignof<T>(), idof<Array<T>>()));\n    let resultStart = result.dataStart;\n    let thisStart = this.dataStart;\n    let thisBase  = thisStart + (<usize>start << alignof<T>());\n    memory.copy(\n      resultStart,\n      thisBase,\n      <usize>deleteCount << alignof<T>()\n    );\n    let offset = start + deleteCount;\n    if (len != offset) {\n      memory.copy(\n        thisBase,\n        thisStart + (<usize>offset << alignof<T>()),\n        <usize>(len - offset) << alignof<T>()\n      );\n    }\n    this.length_ = len - deleteCount;\n    return result;\n  }\n\n  reverse(): Array<T> {\n    REVERSE<T>(this.dataStart, this.length_);\n    return this;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): Array<T> {\n    SORT<T>(this.dataStart, this.length_, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    let ptr = this.dataStart;\n    let len = this.length_;\n    if (isBoolean<T>())   return joinBooleanArray(ptr, len, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(ptr, len, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(ptr, len, separator);\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(ptr, len, separator);\n    }\n    // For rest objects and arrays use general join routine\n    if (isReference<T>()) return joinReferenceArray<T>(ptr, len, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  flat(): T {\n    if (!isArray<T>()) {\n      ERROR(\"Cannot call flat() on Array<T> where T is not an Array.\");\n    }\n    // Get the length and data start values\n    let ptr = this.dataStart;\n    let len = this.length_;\n\n    // calculate the end size with an initial pass\n    let size = 0;\n    for (let i = 0; i < len; ++i) {\n      let child = load<usize>(ptr + (i << alignof<T>()));\n      size += child == 0 ? 0 : load<i32>(child, offsetof<T>(\"length_\"));\n    }\n\n    // calculate the byteLength of the resulting backing ArrayBuffer\n    const align = alignof<valueof<T>>();\n    let byteLength = <usize>size << align;\n    let outBuffer = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\n\n    // create the return value and initialize it\n    let outArray = changetype<T>(__new(offsetof<T>(), idof<T>()));\n    store<i32>(changetype<usize>(outArray), size, offsetof<T>(\"length_\"));\n\n    // byteLength, dataStart, and buffer are all readonly\n    store<i32>(changetype<usize>(outArray), byteLength, offsetof<T>(\"byteLength\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"dataStart\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"buffer\"));\n    __link(changetype<usize>(outArray), changetype<usize>(outBuffer), false);\n\n    // set the elements\n    let resultOffset: usize = 0;\n    for (let i = 0; i < len; ++i) { // for each child\n      let child = load<usize>(ptr + (<usize>i << alignof<T>()));\n\n      // ignore null arrays\n      if (!child) continue;\n\n      // copy the underlying buffer data to the result buffer\n      let childDataLength = <usize>load<i32>(child, offsetof<T>(\"length_\")) << align;\n      memory.copy(\n        changetype<usize>(outBuffer) + resultOffset,\n        load<usize>(child, offsetof<T>(\"dataStart\")),\n        childDataLength\n      );\n\n      // advance the result length\n      resultOffset += childDataLength;\n    }\n\n    // if the `valueof<T>` type is managed, we must link each reference\n    if (isManaged<valueof<T>>()) {\n      for (let i = 0; i < size; ++i) {\n        let ref = load<usize>(changetype<usize>(outBuffer) + (<usize>i << usize(alignof<valueof<T>>())));\n        __link(changetype<usize>(outBuffer), ref, true);\n      }\n    }\n\n    return outArray;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = this.dataStart;\n      let end = cur + (<usize>this.length_ << alignof<T>());\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n    __visit(changetype<usize>(this.buffer), cookie);\n  }\n}\n","/**\n * PVM Type Definitions (AssemblyScript)\n *\n * Core types used throughout the PVM implementation\n */\n\n// Register indices (r0-r12) - use u8 directly\n\n// Register state - array of 13 64-bit registers\nexport type RegisterState = StaticArray<u64> // [13]\n\n/**\n * Instruction execution result\n * - resultCode: null = continue execution, otherwise halt with code\n */\nexport class InstructionResult {\n  // Use i32 where -1 = continue, >= 0 = result code (0=HALT, 1=PANIC, etc.)\n  // This allows us to distinguish between \"continue\" and \"halt with code 0\"\n  resultCode: i32 = -1 // -1 = continue, >= 0 = halt/panic/etc\n  faultAddress: u32 = 0 // Fault address (only valid if hasFaultAddress is true)\n  hasFaultAddress: bool = false // Whether faultAddress is valid\n  \n  constructor(resultCode: i32 = -1, faultAddress: u32 = 0) {\n    this.resultCode = resultCode\n    this.faultAddress = faultAddress\n    this.hasFaultAddress = faultAddress !== 0\n  }\n  \n  // Helper to check if execution should continue\n  shouldContinue(): bool {\n    return this.resultCode === -1\n  }\n  \n  // Get the actual result code (returns -1 if continuing, otherwise the code)\n  getCode(): i32 {\n    return this.resultCode\n  }\n}\n\n/**\n * Instruction execution context\n * Contains all state needed to execute an instruction\n */\n/**\n * Read result for RAM operations\n */\nexport class ReadResult {\n  data: Uint8Array | null\n  faultAddress: u32 // 0 means no fault, otherwise the fault address\n\n  constructor(data: Uint8Array | null, faultAddress: u32) {\n    this.data = data\n    this.faultAddress = faultAddress\n  }\n}\n\n/**\n * Fault check result for RAM operations\n */\nexport class FaultCheckResult {\n  success: bool\n  faultAddress: u32 // 0 means no fault, otherwise the fault address\n\n  constructor(success: bool, faultAddress: u32) {\n    this.success = success\n    this.faultAddress = faultAddress\n  }\n}\n\n/**\n * Write result for RAM operations\n */\nexport class WriteResult {\n  hasFault: bool\n  faultAddress: u32 // Only valid if hasFault is true\n\n  constructor(hasFault: bool, faultAddress: u32) {\n    this.hasFault = hasFault\n    this.faultAddress = faultAddress\n  }\n}\n\n// RAM interface for memory operations\nexport interface RAM {\n  readOctets(address: u32, count: u32): ReadResult\n  writeOctets(address: u32, values: Uint8Array): WriteResult\n  currentHeapPointer: u32\n  allocatePages(startPage: u32, count: u32): void\n  isReadableWithFault(address: u32, size: u32): FaultCheckResult\n  initializeMemoryLayout(argumentData: Uint8Array, readOnlyData: Uint8Array, readWriteData: Uint8Array, stackSize: u32, heapZeroPaddingSize: u32): void\n  isWritableWithFault(address: u32, size: u32): FaultCheckResult\n  // Methods for memory initialization (used by WASM wrapper)\n  setPageAccessRights(address: u32, length: u32, accessType: MemoryAccessType): void\n  initPage(address: u32, length: u32, accessType: MemoryAccessType): void\n  writeOctetsDuringInitialization(address: u32, values: Uint8Array): void\n  // Get page dump for a specific page index (4KB)\n  getPageDump(pageIndex: u32): Uint8Array\n  // Reset RAM to initial state\n  reset(): void\n  // JIP-6 trace support: Track last load/store for each instruction step\n  lastLoadAddress: u32\n  lastLoadValue: u64\n  lastStoreAddress: u32\n  lastStoreValue: u64\n  clearLastMemoryOp(): void\n}\n\n/**\n * Execution result for marshalling invocations\n * Replaces union type `Uint8Array | string` for AssemblyScript compatibility\n */\nexport class ExecutionResult {\n  /** Result type: 0 = data (Uint8Array), 1 = PANIC, 2 = OOG */\n  resultType: u8\n  /** Result data (only valid if resultType === 0) */\n  data: Uint8Array\n\n  constructor(resultType: u8, data: Uint8Array) {\n    this.resultType = resultType\n    this.data = data\n  }\n\n  static fromData(data: Uint8Array): ExecutionResult {\n    return new ExecutionResult(0, data)\n  }\n\n  static fromPanic(): ExecutionResult {\n    return new ExecutionResult(1, new Uint8Array(0))\n  }\n\n  static fromOOG(): ExecutionResult {\n    return new ExecutionResult(2, new Uint8Array(0))\n  }\n\n  isPanic(): bool {\n    return this.resultType === 1\n  }\n\n  isOOG(): bool {\n    return this.resultType === 2\n  }\n\n  isData(): bool {\n    return this.resultType === 0\n  }\n}\n\n\nexport class RunProgramResult {\n  gasConsumed: u32\n  result: ExecutionResult\n\n  constructor(gasConsumed: u32, result: ExecutionResult) {\n    this.gasConsumed = gasConsumed\n    this.result = result\n  }\n}\n\nexport class InstructionContext {\n  code: Uint8Array // Program code\n  bitmask: Uint8Array // Instruction bitmask\n  registers: RegisterState // Register state\n  programCounter: u32 // Current program counter\n  gasRemaining: u32 // Remaining gas\n  operands: Uint8Array // Pre-parsed instruction operands\n  fskip: i32 // Skip distance to next instruction (pre-calculated)\n  jumpTable: u32[] // Jump table for dynamic jumps\n  ram: RAM // RAM interface for memory operations\n  \n  constructor(\n    code: Uint8Array,\n    bitmask: Uint8Array,\n    registers: RegisterState,\n    programCounter: u32,\n    gasRemaining: u32,\n    operands: Uint8Array,\n    fskip: i32,\n    jumpTable: u32[],\n    ram: RAM\n  ) {\n    this.code = code\n    this.bitmask = bitmask\n    this.registers = registers\n    this.programCounter = programCounter\n    this.gasRemaining = gasRemaining\n    this.operands = operands\n    this.fskip = fskip\n    this.jumpTable = jumpTable\n    this.ram = ram\n  }\n}\n\n/**\n * Helper: Convert bytes to hex string\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  let result = ''\n  for (let i = 0; i < bytes.length; i++) {\n    const hex = bytes[i].toString(16)\n    result += (bytes[i] < 16 ? '0' : '') + hex\n  }\n  return result\n}\n\n// Memory access types (using enum instead of string union for AS compatibility)\nexport enum MemoryAccessType {\n  NONE = 0,\n  READ = 1,\n  WRITE = 2,\n}\n\n\n/**\n * VmOutput structure for runProgram result\n */\nexport class VmOutput {\n  status: i32 // Status code (0=OK, 1=HALT, 2=PANIC, 3=FAULT, 4=HOST, 5=OOG)\n  registers: u64[] // Final register state (13 registers)\n  pc: u32 // Final program counter\n  memory: InitialChunk[] // Final memory state (chunks)\n  gas: i64 // Final gas (can be negative if OOG)\n  exitCode: u32 // Exit code (fault address for FAULT status)\n\n  constructor(\n    status: i32,\n    registers: u64[],\n    pc: u32,\n    memory: InitialChunk[],\n    gas: i64,\n    exitCode: u32,\n  ) {\n    this.status = status\n    this.registers = registers\n    this.pc = pc\n    this.memory = memory\n    this.gas = gas\n    this.exitCode = exitCode\n  }\n}","import { RAM, RegisterState } from '../../types'\nimport { ImplicationsPair, Implications, PartialState, CompleteServiceAccount, AccountEntry, ProvisionEntry } from '../../codec'\n\n// Re-export types for convenience\nexport { ImplicationsPair, Implications, PartialState, CompleteServiceAccount, AccountEntry, ProvisionEntry }\n\n// Alias for backward compatibility\nexport type ServiceAccount = CompleteServiceAccount\n\n/**\n * Host function result\n * Uses 255 (0xFF) as sentinel value for null (continue execution)\n */\nexport class HostFunctionResult {\n  resultCode: u8\n  additionalGasCost: u64 // Additional gas to deduct beyond base 10 (e.g., TRANSFER deducts gasLimit on success)\n\n  constructor(resultCode: u8 = 255, additionalGasCost: u64 = u64(0)) {\n    // Use 255 (0xFF) as sentinel value for null (continue execution)\n    // This is safe because valid result codes are 0-5 (HALT, PANIC, etc.)\n    this.resultCode = resultCode\n    this.additionalGasCost = additionalGasCost\n  }\n  \n  // Helper to check if execution should continue\n  shouldContinue(): bool {\n    return this.resultCode === 255\n  }\n}\n\n/**\n * Accumulate host function context\n */\nexport class AccumulateHostFunctionContext {\n  gasCounter: u32\n  registers: RegisterState\n  ram: RAM\n  implications: ImplicationsPair\n  timeslot: u64\n  expungePeriod: u64\n  numCores: u32 // Ccorecount from config\n  numValidators: u32 // Cvalcount from config\n  // JAM version for version-aware behavior\n  jamVersionMajor: u8\n  jamVersionMinor: u8\n  jamVersionPatch: u8\n\n  constructor(\n    gasCounter: u32,\n    registers: RegisterState,\n    ram: RAM,\n    implications: ImplicationsPair,\n    timeslot: u64,\n    expungePeriod: u64,\n    numCores: u32 = 341,\n    numValidators: u32 = 1023,\n    jamVersionMajor: u8 = 0,\n    jamVersionMinor: u8 = 7,\n    jamVersionPatch: u8 = 2,\n  ) {\n    this.gasCounter = gasCounter\n    this.registers = registers\n    this.ram = ram\n    this.implications = implications\n    this.timeslot = timeslot\n    this.expungePeriod = expungePeriod\n    this.numCores = numCores\n    this.numValidators = numValidators\n    this.jamVersionMajor = jamVersionMajor\n    this.jamVersionMinor = jamVersionMinor\n    this.jamVersionPatch = jamVersionPatch\n  }\n}\n\n/**\n * Accumulate error codes\n * Gray Paper: Error codes for accumulation host functions\n * Must be u64 to properly represent values up to 2^64 - 1\n */\nexport const ACCUMULATE_ERROR_NONE: u64 = u64(0xffffffffffffffff) // 2^64 - 1\nexport const ACCUMULATE_ERROR_WHAT: u64 = u64(0xfffffffffffffffe) // 2^64 - 2\nexport const ACCUMULATE_ERROR_OOB: u64 = u64(0xfffffffffffffffd) // 2^64 - 3\nexport const ACCUMULATE_ERROR_WHO: u64 = u64(0xfffffffffffffffc) // 2^64 - 4\nexport const ACCUMULATE_ERROR_FULL: u64 = u64(0xfffffffffffffffb) // 2^64 - 5\nexport const ACCUMULATE_ERROR_CORE: u64 = u64(0xfffffffffffffffa) // 2^64 - 6\nexport const ACCUMULATE_ERROR_CASH: u64 = u64(0xfffffffffffffff9) // 2^64 - 7\nexport const ACCUMULATE_ERROR_LOW: u64 = u64(0xfffffffffffffff8) // 2^64 - 8\nexport const ACCUMULATE_ERROR_HUH: u64 = u64(0xfffffffffffffff7) // 2^64 - 9\nexport const ACCUMULATE_ERROR_OK: u64 = u64(0) // Success\n\n/**\n * Base class for all accumulation host functions\n *\n * Accumulation host functions operate on accumulation context (implications)\n * and can mutate service accounts, manage transfers, and handle blockchain operations.\n * They are different from general host functions as they work with accumulation context\n * rather than just PVM state.\n */\nexport class BaseAccumulateHostFunction {\n  public functionId: u64\n  public name: string\n\n  constructor(functionId: u64 = u64(0), name: string = '') {\n    this.functionId = functionId\n    this.name = name\n  }\n\n  public execute(\n    context: AccumulateHostFunctionContext,\n  ): HostFunctionResult {\n    // This should be overridden by all accumulate host function subclasses\n    return new HostFunctionResult(255)\n  }\n\n  // Helper methods for accumulation-specific operations\n  setAccumulateError(\n    registers: RegisterState,\n    errorCode: u64,\n  ): void {\n    registers[7] = errorCode\n  }\n\n  setAccumulateSuccess(\n    registers: RegisterState,\n    value: u64 = ACCUMULATE_ERROR_OK,\n  ): void {\n    registers[7] = value\n  }\n\n  isMemoryRangeReadable(\n    ram: RAM,\n    offset: u64,\n    length: u64,\n  ): bool {\n    const result = ram.isReadableWithFault(u32(offset), u32(length))\n    if (result.faultAddress !== 0) {\n      return false\n    }\n    return result.success\n  }\n\n  isMemoryRangeWritable(\n    ram: RAM,\n    offset: u64,\n    length: u64,\n  ): bool {\n    const result_writable = ram.isWritableWithFault(u32(offset), u32(length))\n    if (result_writable.faultAddress !== 0) {\n      return false\n    }\n    return result_writable.success\n  }\n\n  // Helper functions for Array-based operations\n  findAccountEntry(accounts: Array<AccountEntry>, serviceId: u64): AccountEntry | null {\n    for (let i = 0; i < accounts.length; i++) {\n      if (u64(accounts[i].serviceId) === serviceId) {\n        return accounts[i]\n      }\n    }\n    return null\n  }\n\n  hasAccountEntry(accounts: Array<AccountEntry>, serviceId: u64): bool {\n    return this.findAccountEntry(accounts, serviceId) !== null\n  }\n\n  setAccountEntry(accounts: Array<AccountEntry>, serviceId: u64, account: CompleteServiceAccount): void {\n    const entry = this.findAccountEntry(accounts, serviceId)\n    if (entry !== null) {\n      entry.account = account\n    } else {\n      accounts.push(new AccountEntry(u32(serviceId), account))\n    }\n  }\n\n  findProvisionEntry(provisions: Array<ProvisionEntry>, serviceId: u64): ProvisionEntry | null {\n    for (let i = 0; i < provisions.length; i++) {\n      if (u64(provisions[i].serviceId) === serviceId) {\n        return provisions[i]\n      }\n    }\n    return null\n  }\n\n  hasProvisionEntry(provisions: Array<ProvisionEntry>, serviceId: u64): bool {\n    return this.findProvisionEntry(provisions, serviceId) !== null\n  }\n\n  setProvisionEntry(provisions: Array<ProvisionEntry>, serviceId: u64, blob: Uint8Array): void {\n    const entry = this.findProvisionEntry(provisions, serviceId)\n    if (entry !== null) {\n      entry.blob = blob\n    } else {\n      provisions.push(new ProvisionEntry(u32(serviceId), blob))\n    }\n  }\n}\n","import { CompleteServiceAccount, getStorageValue, setStorageValue, deleteStorageValue } from '../../codec'\nimport { RESULT_CODE_PANIC } from '../../config'\nimport {\n  ACCUMULATE_ERROR_FULL,\n  ACCUMULATE_ERROR_NONE,\n  HostFunctionResult,\n} from '../accumulate/base'\nimport { HostFunctionContext, HostFunctionParams, WriteParams } from './base'\nimport { BaseHostFunction } from './base'\n\n// Deposit constants (Gray Paper)\nconst C_BASEDEPOSIT: u64 = u64(100) // Base deposit\nconst C_ITEMDEPOSIT: u64 = u64(10) // Per-item deposit\nconst C_BYTEDEPOSIT: u64 = u64(1) // Per-byte deposit\n\n/**\n * WRITE host function (_W)\n *\n * Writes storage data to service accounts\n *\n * Gray Paper Specification:\n * - Function ID: 4 (write)\n * - Gas Cost: 10\n * - Signature: _W(gascounter, registers, memory, s, s)\n *   - s = current service account\n *   - s = current service ID\n * - Uses registers[7:4] to specify key offset, key length, value offset, value length\n * - Writes key-value pair to service account's storage\n * - If value length is 0, deletes the key\n * - Returns FULL if insufficient balance, length of previous value otherwise\n * - Updates service account's storage footprint (items, octets)\n */\n\nexport class WriteHostFunction extends BaseHostFunction {\n  functionId: u64 = u64(4) // WRITE function ID\n  name: string = 'write'\n  gasCost: u64 = u64(10)\n\n  execute(\n    context: HostFunctionContext,\n    params: HostFunctionParams | null,\n  ): HostFunctionResult {\n    if (!params) {\n      return new HostFunctionResult(RESULT_CODE_PANIC)\n    }\n    const writeParams = params as WriteParams\n\n    // Extract parameters from registers\n    // Gray Paper: registers[7:4] = (keyOffset, keyLength, valueOffset, valueLength)\n    const keyOffset = u64(context.registers[7])\n    const keyLength = u64(context.registers[8])\n    const valueOffset = u64(context.registers[9])\n    const valueLength = u64(context.registers[10])\n\n    const serviceAccount = writeParams.serviceAccount\n    const serviceId = u32(writeParams.serviceId)\n\n    // Read key from memory\n    const readResult_key = context.ram.readOctets(u32(keyOffset), u32(keyLength))\n    const key = readResult_key.data\n    const faultAddress = readResult_key.faultAddress\n    if (key === null || faultAddress !== 0) {\n      return new HostFunctionResult(RESULT_CODE_PANIC)\n    }\n\n    // Check if this is a delete operation (value length = 0)\n    if (valueLength === u64(0)) {\n      // Gray Paper: Calculate new account state with deletion, then check balance\n      // Calculate what the new storage footprint would be after deletion\n      const newItems = this.calculateNewItems(serviceAccount, serviceId, key!, true)\n      const newOctets = this.calculateNewOctets(serviceAccount, serviceId, key!, new Uint8Array(0), true)\n      const newMinBalance = this.calculateMinBalance(\n        newItems,\n        newOctets,\n        serviceAccount.gratis,\n      )\n\n      // Gray Paper equation 450: Check if new minbalance > balance\n      // If so, return FULL and keep old state\n      if (newMinBalance > serviceAccount.balance) {\n        context.registers[7] = ACCUMULATE_ERROR_FULL\n        return new HostFunctionResult(255) // continue execution\n      }\n\n      // Delete the key\n      const previousLength = this.doDeleteStorage(serviceAccount, serviceId, key!, newItems, newOctets)\n      context.registers[7] = u64(previousLength)\n    } else {\n      // Read value from memory\n      const readResult_value = context.ram.readOctets(\n        u32(valueOffset),\n        u32(valueLength),\n      )\n      const value = readResult_value.data\n      const _faultAddress = readResult_value.faultAddress\n      if (value === null || _faultAddress !== 0) {\n        return new HostFunctionResult(RESULT_CODE_PANIC)\n      }\n\n      // Calculate what the new storage footprint would be\n      const newItems = this.calculateNewItems(serviceAccount, serviceId, key!, false)\n      const newOctets = this.calculateNewOctets(serviceAccount, serviceId, key!, value!, false)\n      const newMinBalance = this.calculateMinBalance(\n        newItems,\n        newOctets,\n        serviceAccount.gratis,\n      )\n\n      // Check if service account has sufficient balance for the new storage footprint\n      if (newMinBalance > serviceAccount.balance) {\n        // Return FULL (2^64 - 5) for insufficient balance\n        context.registers[7] = ACCUMULATE_ERROR_FULL\n        return new HostFunctionResult(255) // continue execution\n      }\n\n      // Write key-value pair to storage\n      const previousLength = this.writeStorage(serviceAccount, serviceId, key!, value!, newItems, newOctets)\n      context.registers[7] = u64(previousLength)\n    }\n\n    return new HostFunctionResult(255) // continue execution\n  }\n\n  calculateNewItems(\n    serviceAccount: CompleteServiceAccount,\n    serviceId: u32,\n    key: Uint8Array,\n    isDelete: bool,\n  ): u64 {\n    // Gray Paper: items change based on whether key exists\n    // Using rawCshKeyvals helper to check key existence\n    const hasKey = getStorageValue(serviceAccount, serviceId, key) !== null\n    let currentItems = u64(serviceAccount.items)\n\n    if (isDelete) {\n      // If deleting and key exists, reduce items by 1\n      return hasKey ? currentItems - u64(1) : currentItems\n    } else {\n      // If writing and key doesn't exist, increase items by 1\n      return hasKey ? currentItems : currentItems + u64(1)\n    }\n  }\n\n  calculateNewOctets(\n    serviceAccount: CompleteServiceAccount,\n    serviceId: u32,\n    key: Uint8Array,\n    value: Uint8Array,\n    isDelete: bool,\n  ): u64 {\n    // Gray Paper: a_octets = sum over storage of (34 + len(y) + len(x))\n    // Using rawCshKeyvals helper to get current value\n    const previousValue = getStorageValue(serviceAccount, serviceId, key)\n    let currentOctets = serviceAccount.octets\n\n    if (isDelete) {\n      // If deleting and key exists, subtract its octets\n      if (previousValue !== null) {\n        const deletedOctets = u64(34) + u64(key.length) + u64(previousValue.length)\n        return currentOctets > deletedOctets ? currentOctets - deletedOctets : u64(0)\n      }\n      return currentOctets\n    } else {\n      // If updating or adding\n      if (previousValue !== null) {\n        // Updating: adjust for value length change\n        const previousLength = u64(previousValue.length)\n        const newLength = u64(value.length)\n        return currentOctets - previousLength + newLength\n      } else {\n        // Adding new: add 34 + len(key) + len(value)\n        return currentOctets + u64(34) + u64(key.length) + u64(value.length)\n      }\n    }\n  }\n\n  calculateMinBalance(\n    items: u64,\n    octets: u64,\n    gratis: u64,\n  ): u64 {\n    // Gray Paper: a_minbalance = max(0, Cbasedeposit + Citemdeposit * a_items + Cbytedeposit * a_octets - a_gratis)\n    const baseDeposit = C_BASEDEPOSIT\n    const itemDeposit = C_ITEMDEPOSIT * items\n    const byteDeposit = C_BYTEDEPOSIT * octets\n\n    const totalDeposit = baseDeposit + itemDeposit + byteDeposit\n    const minBalance = totalDeposit > gratis ? totalDeposit - gratis : u64(0)\n\n    return minBalance\n  }\n\n  writeStorage(\n    serviceAccount: CompleteServiceAccount,\n    serviceId: u32,\n    key: Uint8Array,\n    value: Uint8Array,\n    newItems: u64,\n    newOctets: u64,\n  ): i64 {\n    // Get previous value length before writing using rawCshKeyvals helper\n    const previousValue = getStorageValue(serviceAccount, serviceId, key)\n    const previousLength = previousValue\n      ? i64(previousValue.length)\n      : ACCUMULATE_ERROR_NONE\n\n    // Write key-value pair to service account's storage using rawCshKeyvals helper\n    setStorageValue(serviceAccount, serviceId, key, value)\n\n    // Update storage footprint (already calculated)\n    serviceAccount.items = u32(newItems)\n    serviceAccount.octets = newOctets\n\n    return previousLength\n  }\n\n  doDeleteStorage(\n    serviceAccount: CompleteServiceAccount,\n    serviceId: u32,\n    key: Uint8Array,\n    newItems: u64,\n    newOctets: u64,\n  ): i64 {\n    // Get previous value length before deleting using rawCshKeyvals helper\n    const previousValue = getStorageValue(serviceAccount, serviceId, key)\n    const previousLength = previousValue\n      ? i64(previousValue.length)\n      : ACCUMULATE_ERROR_NONE\n\n    // Delete key from service account's storage using rawCshKeyvals helper\n    if (previousValue !== null) {\n      deleteStorageValue(serviceAccount, serviceId, key)\n    }\n\n    // Update storage footprint (already calculated)\n    serviceAccount.items = u32(newItems)\n    serviceAccount.octets = newOctets\n\n    return previousLength\n  }\n}\n\n","import { RESULT_CODE_PANIC } from '../../config'\nimport { getRequestValue, setRequestValue, decodeRequestTimeslots, encodeRequestTimeslots } from '../../codec'\nimport {\n  ACCUMULATE_ERROR_FULL,\n  ACCUMULATE_ERROR_HUH,\n  AccumulateHostFunctionContext,\n  BaseAccumulateHostFunction,\n  HostFunctionResult,\n} from './base'\n\n// Deposit constants (Gray Paper)\nconst C_BASEDEPOSIT: u64 = u64(100) // Base deposit\nconst C_ITEMDEPOSIT: u64 = u64(10) // Per-item deposit\nconst C_BYTEDEPOSIT: u64 = u64(1) // Per-byte deposit\n\n// Helper to check for u64 addition overflow\n// Returns true if a + b would overflow\n@inline\nfunction wouldOverflowU64(a: u64, b: u64): bool {\n  return a > u64.MAX_VALUE - b\n}\n\n/**\n * SOLICIT accumulation host function (_S)\n *\n * Solicits preimage request\n *\n * Gray Paper Specification:\n * - Function ID: 23 (solicit)\n * - Gas Cost: 10\n * - Parameters: registers[7-8] = o, z\n *   - o: hash offset in memory (32 bytes)\n *   - z: size of the preimage\n * - Returns: registers[7] = OK or error code\n *\n * Gray Paper Logic:\n * 1. Read hash from memory (32 bytes)\n * 2. Check if request already exists:\n *    - If doesn't exist: create empty request []\n *    - If exists as [x, y]: append current timeslot to make [x, y, t]\n *    - Otherwise: error HUH\n * 3. Check if service has sufficient balance\n * 4. Update service account with new request\n */\nexport class SolicitHostFunction extends BaseAccumulateHostFunction {\n  functionId: u64 = u64(23) // SOLICIT function ID (Gray Paper: 23)\n  name: string = 'solicit'\n  gasCost: u64 = u64(10)\n\n  execute(context: AccumulateHostFunctionContext): HostFunctionResult {\n    const registers = context.registers\n    const ram = context.ram\n    const implications = context.implications\n    const timeslot = context.timeslot\n    // Extract parameters from registers\n    const hashOffset = u64(registers[7])\n    const preimageLength = u64(registers[8])\n\n    // Read hash from memory (32 bytes)\n    // Gray Paper: If memory read fails (h = error), return PANIC without changing registers\n    const readResult_hash = ram.readOctets(u32(hashOffset), u32(32))\n    if (readResult_hash.faultAddress !== 0 || readResult_hash.data === null) {\n      // Gray Paper line 911: (panic, registers_7, ...) when h = error\n      // Do NOT modify registers - just return PANIC\n      return new HostFunctionResult(RESULT_CODE_PANIC)\n    }\n    const hashData = readResult_hash.data!\n\n    // Get the current implications context\n    const imX = implications.regular\n\n    // Get current service account\n    const accountEntry = this.findAccountEntry(imX.state.accounts, imX.id)\n    if (accountEntry === null) {\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_HUH)\n      return new HostFunctionResult(255) // continue execution\n    }\n    const serviceAccount = accountEntry.account\n\n    // Look up existing request using rawCshKeyvals helper\n    const existingRequestValue = getRequestValue(serviceAccount, u32(imX.id), hashData, preimageLength)\n\n    // Determine new request state based on Gray Paper logic\n    let newTimeslots: u32[]\n    let isNewRequest = false\n\n    if (existingRequestValue === null) {\n      // Request doesn't exist - create empty request []\n      newTimeslots = []\n      isNewRequest = true\n    } else {\n      // Decode existing request\n      const existingTimeslots = decodeRequestTimeslots(existingRequestValue)\n      if (existingTimeslots === null) {\n        this.setAccumulateError(registers, ACCUMULATE_ERROR_HUH)\n        return new HostFunctionResult(255) // continue execution\n      }\n\n      if (existingTimeslots.length === 2) {\n        // Request exists as [x, y] - append current timeslot to make [x, y, t]\n        newTimeslots = [existingTimeslots[0], existingTimeslots[1], u32(timeslot)]\n      } else {\n        // Invalid request state - cannot solicit\n        this.setAccumulateError(registers, ACCUMULATE_ERROR_HUH)\n        return new HostFunctionResult(255) // continue execution\n      }\n    }\n\n    // Calculate new items and octets if this is a new request\n    // Gray Paper: items += 2 for each new request (h, z)\n    // Gray Paper: octets += (81 + z) for each new request\n    let newItems = serviceAccount.items\n    let newOctets = serviceAccount.octets\n\n    if (isNewRequest) {\n      newItems = serviceAccount.items + u32(2)\n      \n      // Check for u64 overflow: octets + 81 + preimageLength\n      // TypeScript uses bigint (no overflow), so we must detect overflow and return FULL\n      const octetsIncrement = u64(81) + preimageLength\n      if (wouldOverflowU64(u64(81), preimageLength) || \n          wouldOverflowU64(serviceAccount.octets, octetsIncrement)) {\n        // Overflow would occur - in TypeScript this results in minBalance > balance\n        this.setAccumulateError(registers, ACCUMULATE_ERROR_FULL)\n        return new HostFunctionResult(255) // continue execution\n      }\n      newOctets = serviceAccount.octets + octetsIncrement\n    }\n\n    // Calculate new minimum balance\n    // Gray Paper: a_minbalance = max(0, Cbasedeposit + Citemdeposit * a_items + Cbytedeposit * a_octets - a_gratis)\n    const itemDeposit = C_ITEMDEPOSIT * u64(newItems)\n    const byteDeposit = C_BYTEDEPOSIT * newOctets\n    \n    // Check for overflow in totalDeposit calculation\n    if (wouldOverflowU64(C_BASEDEPOSIT, itemDeposit) ||\n        wouldOverflowU64(C_BASEDEPOSIT + itemDeposit, byteDeposit)) {\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_FULL)\n      return new HostFunctionResult(255) // continue execution\n    }\n    \n    const totalDeposit = C_BASEDEPOSIT + itemDeposit + byteDeposit\n    const newMinBalance = totalDeposit > serviceAccount.gratis ? totalDeposit - serviceAccount.gratis : u64(0)\n\n    // Check if service has sufficient balance for the new request\n    // Gray Paper: If newMinBalance > balance, return FULL error\n    if (newMinBalance > serviceAccount.balance) {\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_FULL)\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Update the service account with the new request using rawCshKeyvals helper\n    setRequestValue(serviceAccount, u32(imX.id), hashData, preimageLength, encodeRequestTimeslots(newTimeslots))\n\n    // Update items and octets if this is a new request\n    if (isNewRequest) {\n      serviceAccount.items = newItems\n      serviceAccount.octets = newOctets\n    }\n\n    // Set success result\n    this.setAccumulateSuccess(registers)\n    return new HostFunctionResult(255) // continue execution\n  }\n}\n","/**\n * @pbnjam/types compatibility layer for AssemblyScript\n * \n * Provides local implementations of types/interfaces from @pbnjam/types\n * to make the code compile in AssemblyScript without external dependencies\n */\n\nimport { RegisterState, RAM } from './types'\nimport { PVM } from './pvm'\nimport { HostFunctionParams } from './host-functions/general/base'\n\n// Re-export types from other modules\nexport { PVM, PVMState } from './pvm'\nexport { RAM, MemoryAccessType } from './types'\n\n// ============================================================================\n// Host Function Types\n// ============================================================================\n\nexport class HostFunctionResult {\n  resultCode: u8\n\n  constructor(resultCode: u8 = 255) {\n    // Use 255 (0xFF) as sentinel value for null (continue execution)\n    // This is safe because valid result codes are 0-5 (HALT, PANIC, etc.)\n    this.resultCode = resultCode\n  }\n}\n\nexport class HostFunctionContext {\n  registers: RegisterState\n  ram: RAM\n  gasCounter: u32\n\n  constructor(gasCounter: u32, registers: RegisterState, ram: RAM) {\n    this.gasCounter = gasCounter\n    this.registers = registers\n    this.ram = ram\n  }\n}\n\n// ============================================================================\n// Service Account Types\n// ============================================================================\n\nexport class ServiceAccount {\n  codehash: string\n  balance: u64\n  minaccgas: u64\n  minmemogas: u64\n  octets: u64\n  gratis: u64\n  items: u64\n  created: u64\n  lastacc: u64\n  parent: u64\n\n  constructor() {\n    this.codehash = ''\n    this.balance = 0\n    this.minaccgas = 0\n    this.minmemogas = 0\n    this.octets = 0\n    this.gratis = 0\n    this.items = 0\n    this.created = 0\n    this.lastacc = 0\n    this.parent = 0\n  }\n}\n\n// ============================================================================\n// Service Interfaces (Stub implementations)\n// ============================================================================\n\n// Removed IServiceAccountService and IConfigService - functionality implemented directly in host functions\n\n// ============================================================================\n// Host Function Parameter Types\n// ============================================================================\n\nexport class LookupParams {\n  serviceId: u64\n  key: Uint8Array\n\n  constructor(serviceId: u64, key: Uint8Array) {\n    this.serviceId = serviceId\n    this.key = key\n  }\n}\n\nexport class HistoricalLookupParams {\n  serviceId: u64\n  hash: Uint8Array\n  timeslot: u64\n\n  constructor(serviceId: u64, hash: Uint8Array, timeslot: u64) {\n    this.serviceId = serviceId\n    this.hash = hash\n    this.timeslot = timeslot\n  }\n}\n\nexport class InfoParams {\n  serviceId: u64\n  outputOffset: u64\n  fromOffset: u64\n  length: u64\n\n  constructor(serviceId: u64, outputOffset: u64, fromOffset: u64, length: u64) {\n    this.serviceId = serviceId\n    this.outputOffset = outputOffset\n    this.fromOffset = fromOffset\n    this.length = length\n  }\n}\n\nexport class FetchParams extends HostFunctionParams {\n  timeslot: u64\n  offset: u64\n\n  constructor(timeslot: u64, offset: u64) {\n    super()\n    this.timeslot = timeslot\n    this.offset = offset\n  }\n}\n\n\n// Placeholder types for compatibility\nexport interface InvokeParams {\n  refineContext: usize // Using usize as generic pointer\n}\n\nexport interface PVMGuest {\n  pvm: PVM\n}\n\nexport interface PVMOptions {\n  // Placeholder - not used in AssemblyScript\n}\n\nexport interface RefineInvocationContext {\n  // Placeholder - not used in AssemblyScript\n}\n\n// ============================================================================\n// Constants (from @pbnjam/types)\n// ============================================================================\n\nexport class WORK_PACKAGE_CONSTANTS {\n  static readonly C_MAXPACKAGEITEMS: i32 = 16\n  static readonly C_MAXPACKAGEXTS: i32 = 128\n  static readonly C_MAXPACKAGEIMPORTS: i32 = 3072\n  static readonly C_MAXPACKAGEEXPORTS: i32 = 3072\n  // Note: Gray Paper v0.7.2 says 13791360, but jamduna test vectors use 13794360\n  static readonly C_MAXBUNDLESIZE: i32 = 13794360\n}\n\nexport class WORK_REPORT_CONSTANTS {\n  static readonly C_MAXREPORTDEPS: i32 = 8\n  static readonly C_REPORTACCGAS: i32 = 10000000\n  static readonly C_MAXREPORTVARSIZE: i32 = 49152 // 48 * 2^10\n}\n\nexport class AUTHORIZATION_CONSTANTS {\n  static readonly C_AUTHPOOLSIZE: i32 = 8\n  static readonly C_AUTHQUEUESIZE: i32 = 80\n  static readonly C_PACKAGEAUTHGAS: i32 = 50000000\n  static readonly C_MAXAUTHCODESIZE: i32 = 64000\n}\n\nexport class GAS_CONSTANTS {\n  static readonly C_PACKAGEREFGAS: i64 = 5000000000\n  static readonly C_BLOCKACCGAS: i64 = 3500000000\n}\n\nexport class SEGMENT_CONSTANTS {\n  static readonly C_ECPIECESIZE: i32 = 684\n  static readonly C_SEGMENTECPIECES: i32 = 6\n  static readonly C_SEGMENTSIZE: i32 = 4104\n}\n\nexport class SERVICE_CONSTANTS {\n  static readonly C_MAXSERVICECODESIZE: i32 = 4000000\n  static readonly C_MINPUBLICINDEX: i32 = 65536\n}\n\nexport class TICKET_CONSTANTS {\n  static readonly C_MAXBLOCKTICKETS: i32 = 16\n  static readonly C_TICKETENTRIES: i32 = 2\n  static readonly C_EPOCHTAILSTART: i32 = 500\n}\n\nexport class TIME_CONSTANTS {\n  static readonly C_ROTATIONPERIOD: i32 = 10\n  static readonly C_ASSURANCETIMEOUTPERIOD: i32 = 5\n  static readonly C_EXPUNGEPERIOD: i32 = 19200\n  static readonly C_MAXLOOKUPANCHORAGE: i32 = 14400\n}\n\nexport class HISTORY_CONSTANTS {\n  static readonly C_RECENTHISTORYLEN: i32 = 8\n}\n\nexport class DEPOSIT_CONSTANTS {\n  static readonly C_BASEDEPOSIT: i32 = 100\n  static readonly C_BYTEDEPOSIT: i32 = 1\n  static readonly C_ITEMDEPOSIT: i32 = 10\n}\n\nexport class TRANSFER_CONSTANTS {\n  static readonly C_MEMOSIZE: i32 = 128\n}\n\nexport class ExportParams {\n  // Add properties as needed\n}\n\n","/**\n * PVM WASM-Compatible Wrapper (AssemblyScript)\n * \n * Implements a WASM-compatible interface for our PVM implementation.\n * This wrapper allows our AssemblyScript PVM to be used with\n * the same interface as WASM PVM shells, enabling drop-in replacement\n * and compatibility testing.\n */\n\nimport {\n  RESULT_CODE_FAULT,\n  RESULT_CODE_HALT,\n  RESULT_CODE_HOST,\n  RESULT_CODE_OOG,\n  RESULT_CODE_PANIC,\n} from './config'\nimport { decodeBlob } from './codec'\nimport { PVM, PVMInstruction } from './pvm'\n\nimport { PVMRAM } from './ram'\nimport { RAM } from './types'\nimport {  MemoryAccessType } from './types'\nimport { HostFunctionRegistry } from './host-functions'\n\n/**\n * PVM execution status codes matching WASM interface\n */\nexport enum Status {\n  OK = 0,        // Execution can continue\n  HALT = 1,      // Halted normally\n  PANIC = 2,     // Panic condition\n  FAULT = 3,     // Page fault\n  HOST = 4,      // Host call\n  OOG = 5,       // Out of gas\n}\n\n/**\n * WASM-compatible PVM shell interface\n * \n * This interface matches the expected WASM PVM shell API,\n * allowing our AssemblyScript implementation to be used as a drop-in replacement.\n */\nexport interface WasmPvmShellInterface {\n  // Core execution\n  resetGeneric(program: Uint8Array, registers: Uint8Array, gas: u64): void\n  resetGenericWithMemory(\n    program: Uint8Array,\n    registers: Uint8Array,\n    pageMap: Uint8Array,\n    chunks: Uint8Array,\n    gas: u64,\n  ): void\n  nextStep(): bool\n  nSteps(steps: i32): bool\n  run(codeBlob: Uint8Array | null): void\n  runBlob(programBytes: Uint8Array): void\n  \n  // State inspection\n  getProgramCounter(): i32\n  setNextProgramCounter(pc: i32): void\n  getGasLeft(): u64\n  setGasLeft(gas: u64): void\n  getStatus(): Status\n  getExitArg(): i32\n  \n  // Register management\n  getRegisters(): Uint8Array\n  setRegisters(registers: Array<u8>): void\n  getRegister(index: u8): u64\n  setRegister(index: u8, value: u64): void\n  \n  // Memory management\n  getPageDump(index: u32): Uint8Array\n  setMemory(address: u32, data: Uint8Array): void\n  initPage(address: u32, length: u32, accessType: MemoryAccessType): void\n\n  // Result extraction\n  getResult(): Uint8Array\n}\n\n/**\n * PVM Wrapper implementing WASM-compatible interface\n * \n * Maps our PVM implementation to the expected WASM interface\n * for compatibility with existing WASM-based PVM shells.\n */\nexport class PVMWasmWrapper implements WasmPvmShellInterface {\n  pvm: PVM\n  lastStatus: Status = Status.OK\n  exitArg: i32 = 0\n  \n  constructor(ram: RAM | null = null) {\n    const registerState = new StaticArray<u64>(13)\n    for (let i: i32 = 0; i < 13; i++) {\n      registerState[i] = 0\n    }\n    // Use provided RAM, or default to PVMRAM\n    const ramInstance = ram ? ram : new PVMRAM()\n    const hostFunctionRegistry = new HostFunctionRegistry()\n    this.pvm = new PVM(registerState, ramInstance, 0, 0, hostFunctionRegistry)\n  }\n  \n  /**\n   * Reset PVM with program and initial registers\n   * \n   * Gray Paper: Initialize PVM state for execution (Y function)\n   * \n   * @param program - PVM program preimage (encoded preimage containing code blob)\n   * @param registers - Initial register values (13 x 8 bytes = 104 bytes, little-endian)\n   * @param gas - Initial gas amount\n   */\n  resetGeneric(program: Uint8Array, registers: Uint8Array, gas: u32): void {\n    this.lastStatus = Status.OK\n    this.exitArg = 0\n    \n    // Decode registers from Uint8Array (13 registers x 8 bytes each, little-endian)\n    const registerValues = this.decodeRegistersFromUint8Array(registers)\n    \n    // Use PVM's initializeProgram (Gray Paper Y function)\n    // Pass empty argument data for now (WASM wrapper doesn't use marshalling invocation)\n    const argumentData = new Uint8Array(0)\n    const codeBlob = this.pvm.initializeProgram(program, argumentData)\n    \n    if (!codeBlob) {\n      this.lastStatus = Status.PANIC\n      return\n    }\n    \n    // Set gas and registers\n    this.pvm.state.gasCounter = gas\n    this.pvm.state.programCounter = 0\n    this.pvm.state.registerState = registerValues\n  }\n  \n  /**\n   * Reset PVM with full memory state\n   * \n   * Restores complete PVM state including memory pages from serialized format.\n   * \n   * @param program - PVM program preimage (encoded preimage containing code blob)\n   * @param registers - Initial register values\n   * @param pageMap - Memory page mapping (page_index: u16, chunk_offset: u32) pairs\n   * @param chunks - Memory chunk data (concatenated 4KB pages)\n   * @param gas - Initial gas amount\n   */\n  resetGenericWithMemory(\n    program: Uint8Array,\n    registers: Uint8Array,\n    pageMap: Uint8Array,\n    chunks: Uint8Array,\n    gas: u32,\n  ): void {\n    // First do generic reset\n    this.resetGeneric(program, registers, gas)\n    \n    // Then restore memory state from pageMap and chunks\n    this.restoreMemoryFromChunks(pageMap, chunks)\n\n  }\n  \n  /**\n   * Execute one instruction\n   * \n   * Gray Paper: Execute single PVM instruction (_1)\n   * \n   * @returns true if execution should continue, false if halted/panicked/OOG\n   */\n  nextStep(): bool {\n    if (this.lastStatus !== Status.OK) {\n      return false\n    }\n    \n    // Check if we're out of gas before executing\n    if (this.pvm.state.gasCounter === 0) {\n      this.lastStatus = Status.OOG\n      return false\n    }\n    \n    // Get current instruction\n    const instructionIndex = i32(this.pvm.state.programCounter)\n    \n    // CRITICAL: Verify code and bitmask are set\n    // If code is empty, this means initializeProgram failed or wasn't called\n    if (this.pvm.state.code.length === 0 || this.pvm.state.bitmask.length === 0) {\n      this.lastStatus = Status.PANIC\n      return false\n    }\n    \n    // Extend code and bitmask if needed (same as run method)\n    const extendedCode = new Uint8Array(this.pvm.state.code.length + 16)\n    extendedCode.set(this.pvm.state.code)\n    \n    const extendedBitmask = new Uint8Array(this.pvm.state.bitmask.length + 16)\n    extendedBitmask.set(this.pvm.state.bitmask)\n    extendedBitmask.fill(1, this.pvm.state.bitmask.length)\n    \n    // Bounds check\n    if (instructionIndex < 0 || instructionIndex >= extendedCode.length) {\n      this.lastStatus = Status.PANIC\n      return false\n    }\n    \n    // Validate opcode (bounds check already done above)\n    const opcode = extendedCode[instructionIndex]\n    \n    // Calculate Fskip(i)\n    const fskip = this.skip(instructionIndex, extendedBitmask)\n    const instructionLength = 1 + fskip\n    \n    // Extract operands\n    const operands = extendedCode.slice(\n      instructionIndex + 1,\n      instructionIndex + instructionLength,\n    )\n    \n    const instruction = new PVMInstruction(\n      opcode,\n      operands,\n      fskip,\n      this.pvm.state.programCounter,\n    )\n    \n    // Execute instruction\n    const resultCode = this.pvm.step(instruction)\n    \n    // Check result code\n    // -1 means continue, >= 0 means halt with that code\n    if (resultCode === -1) {\n      // Continue execution - fall through to gas check\n    } else if (resultCode === i32(RESULT_CODE_HALT)) {\n      this.lastStatus = Status.HALT\n      this.exitArg = i32(this.pvm.state.registerState[7] & u64(0xffffffff))\n      return false\n    } else if (resultCode === i32(RESULT_CODE_PANIC)) {\n      this.lastStatus = Status.PANIC\n      return false\n    } else if (resultCode === i32(RESULT_CODE_OOG)) {\n      this.lastStatus = Status.OOG\n      return false\n    } else if (resultCode === RESULT_CODE_FAULT) {\n      this.lastStatus = Status.FAULT\n      return false\n    } else if (resultCode === i32(RESULT_CODE_HOST)) {\n      this.lastStatus = Status.HOST\n      return false\n    } else {\n      // Unknown result code - treat as continue (likely -1)\n    }\n    \n    // Check gas\n    if (this.pvm.state.gasCounter === 0) {\n      this.lastStatus = Status.OOG\n      return false\n    }\n    \n    return true\n  }\n  \n  /**\n   * Skip function Fskip(i) - determines distance to next instruction\n   * Gray Paper: Fskip(i) = min(24, j  N : (k  {1,1,.})_{i+1+j} = 1)\n   */\n  skip(instructionIndex: i32, opcodeBitmask: Uint8Array): i32 {\n    // Append bitmask with sequence of set bits for final instruction\n    const extendedBitmask = new Uint8Array(opcodeBitmask.length + 25)\n    extendedBitmask.set(opcodeBitmask)\n    extendedBitmask.fill(1, opcodeBitmask.length)\n    \n    // Find next set bit starting from i+1\n    for (let j: i32 = 1; j <= 24; j++) {\n      const bitIndex = instructionIndex + j\n      if (\n        bitIndex < extendedBitmask.length &&\n        extendedBitmask[bitIndex] === 1\n      ) {\n        return j - 1\n      }\n    }\n    \n    return 24 // Maximum skip distance\n  }\n  \n  /**\n   * Execute N instructions\n   * \n   * @param steps - Number of steps to execute\n   * @returns true if execution should continue, false if halted/panicked/OOG\n   */\n  nSteps(steps: i32): bool {\n    for (let i: i32 = 0; i < steps; i++) {\n      if (!this.nextStep()) {\n        return false\n      }\n    }\n    return true\n  }\n  \n  /**\n   * Execute program until termination (Gray Paper  function)\n   * \n   * Uses PVM's run() method to execute until halt/panic/OOG\n   * \n   * @param codeBlob - Optional code blob to decode. If provided, decodes and sets state before running.\n   */\n  run(codeBlob: Uint8Array | null): void {\n    this.pvm.run(codeBlob)\n    \n    // Update status based on final result code\n    const resultCode = this.pvm.state.resultCode\n    if (resultCode === RESULT_CODE_HALT) {\n      this.lastStatus = Status.HALT\n      this.exitArg = i32(this.pvm.state.registerState[7] & u64(0xffffffff))\n    } else if (resultCode === RESULT_CODE_PANIC) {\n      this.lastStatus = Status.PANIC\n    } else if (resultCode === RESULT_CODE_OOG) {\n      this.lastStatus = Status.OOG\n    } else if (resultCode === RESULT_CODE_FAULT) {\n      this.lastStatus = Status.FAULT\n      this.exitArg = this.pvm.state.hasFaultAddress ? i32(this.pvm.state.faultAddress) : 0\n    } else if (resultCode === RESULT_CODE_HOST) {\n      this.lastStatus = Status.HOST\n    } else {\n      this.lastStatus = Status.OK\n    }\n  }\n  \n  /**\n   * Decode program blob without executing (for step-by-step execution)\n   * \n   * Takes raw program bytes in deblob format, decodes them, and sets up PVM state\n   * without executing. This allows for step-by-step execution using nextStep().\n   * \n   * @param blob - Raw program bytes (deblob format) to decode\n   */\n  prepareBlob(blob: Uint8Array): void {\n    // Decode the blob and set state without executing\n    const decoded = decodeBlob(blob)\n    if (!decoded) {\n      this.lastStatus = Status.PANIC\n      this.pvm.state.resultCode = RESULT_CODE_PANIC\n      return\n    }\n    \n    // Set decoded program state\n    this.pvm.state.code = decoded.code\n    this.pvm.state.bitmask = decoded.bitmask\n    this.pvm.state.jumpTable = decoded.jumpTable\n    \n    // Extend code and bitmask (same as run() does)\n    const extendedCode = new Uint8Array(this.pvm.state.code.length + 16)\n    extendedCode.set(this.pvm.state.code)\n    \n    const extendedBitmask = new Uint8Array(this.pvm.state.bitmask.length + 16)\n    extendedBitmask.set(this.pvm.state.bitmask)\n    extendedBitmask.fill(1, this.pvm.state.bitmask.length)\n    \n    this.pvm.state.code = extendedCode\n    this.pvm.state.bitmask = extendedBitmask\n    \n    // Reset status to OK so we can step through\n    this.lastStatus = Status.OK\n    this.pvm.state.resultCode = 0\n  }\n  \n  /**\n   * Execute program with deblob format program bytes\n   * \n   * Takes raw program bytes in deblob format, decodes them, and runs the program.\n   * This is useful for test vectors that provide raw program bytes in deblob format.\n   * \n   * Uses SimpleRAM for simplified memory management (no regions).\n   * \n   * Test vectors use deblob format: encode(len(j)) || encode[1](z) || encode(len(c)) || encode[z](j) || encode(c) || encode(k)\n   * \n   * @param programBytes - Raw program bytes (deblob format) to decode and execute\n   */\n  runBlob(blob: Uint8Array): void {\n    // Run the program using the configured RAM instance\n    this.pvm.run(blob)\n    \n    // Update status based on final result code\n    const resultCode = this.pvm.state.resultCode\n    if (resultCode === RESULT_CODE_HALT) {\n      this.lastStatus = Status.HALT\n      this.exitArg = i32(this.pvm.state.registerState[7] & u64(0xffffffff))\n    } else if (resultCode === RESULT_CODE_PANIC) {\n      this.lastStatus = Status.PANIC\n    } else if (resultCode === RESULT_CODE_OOG) {\n      this.lastStatus = Status.OOG\n    } else if (resultCode === RESULT_CODE_FAULT) {\n      this.lastStatus = Status.FAULT\n      this.exitArg = this.pvm.state.hasFaultAddress ? i32(this.pvm.state.faultAddress) : 0\n    } else if (resultCode === RESULT_CODE_HOST) {\n      this.lastStatus = Status.HOST\n    } else {\n      this.lastStatus = Status.OK\n    }\n  }\n  \n  /**\n   * Get current program counter\n   */\n  getProgramCounter(): u32 {\n    return this.pvm.state.programCounter\n  }\n  \n  /**\n   * Set next program counter\n   */\n  setNextProgramCounter(pc: u32): void {\n    this.pvm.state.programCounter = pc\n  }\n  \n  /**\n   * Get remaining gas\n   */\n  getGasLeft(): u32 {\n    return this.pvm.state.gasCounter\n  }\n  \n  /**\n   * Set remaining gas\n   */\n  setGasLeft(gas: u32): void {\n    this.pvm.state.gasCounter = gas\n  }\n  \n  /**\n   * Get current execution status\n   */\n  getStatus(): Status {\n    return this.lastStatus\n  }\n  \n  /**\n   * Get exit argument (value in r7 when halted)\n   */\n  getExitArg(): i32 {\n    return this.exitArg\n  }\n  \n  /**\n   * Get code array (for debugging/comparison)\n   * @returns Copy of the code array\n   */\n  getCode(): Uint8Array {\n    return this.pvm.state.code.slice()\n  }\n  \n  /**\n   * Get bitmask array (for debugging/comparison)\n   * @returns Copy of the bitmask array\n   */\n  getBitmask(): Uint8Array {\n    return this.pvm.state.bitmask.slice()\n  }\n  \n  /**\n   * Get all registers as Uint8Array\n   * \n   * Gray Paper: Register state serialization (little-endian)\n   * \n   * Uses SimpleRAM PVM if available (for runBlob), otherwise uses default PVM\n   * \n   * @returns 104 bytes (13 registers x 8 bytes each, little-endian)\n   */\n  getRegisters(): Uint8Array {\n    const buffer = new Uint8Array(13 * 8)\n    \n    for (let i: i32 = 0; i < 13; i++) {\n      const value = this.pvm.state.registerState[i]\n      // Write little-endian u64\n      const offset = i * 8\n      buffer[offset] = u8(value & u64(0xff))\n      buffer[offset + 1] = u8((value >> 8) & u64(0xff))\n      buffer[offset + 2] = u8((value >> 16) & u64(0xff))\n      buffer[offset + 3] = u8((value >> 24) & u64(0xff))\n      buffer[offset + 4] = u8((value >> 32) & u64(0xff))\n      buffer[offset + 5] = u8((value >> 40) & u64(0xff))\n      buffer[offset + 6] = u8((value >> 48) & u64(0xff))\n      buffer[offset + 7] = u8((value >> 56) & u64(0xff))\n    }\n    \n    return buffer\n  }\n  \n  /**\n   * Set all registers from Uint8Array\n   * \n   * Uses SimpleRAM PVM if available (for runBlob), otherwise uses default PVM\n   * \n   * @param registers - 104 bytes (13 registers x 8 bytes each, little-endian)\n   */\n  setRegisters(registers: Array<u8>): void {\n    this.pvm.state.registerState = this.decodeRegisters(registers)\n  }\n  \n  /**\n   * Get memory page dump\n   * \n   * Gray Paper: Read 4KB page from memory\n   * \n   * @param index - Page index (page address = index * 4096)\n   * @returns Page data (4096 bytes)\n   */\n  getRegister(index: u8): u64 {\n    return this.pvm.state.registerState[index]\n  }\n  \n  /**\n   * Set register value\n   */\n  setRegister(index: u8, value: u64): void {\n    this.pvm.state.registerState[index] = value\n  }\n  \n\n  getPageDump(index: u32): Uint8Array {\n    // All RAM implementations now have getPageDump method\n    return this.pvm.state.ram.getPageDump(index)\n  }\n\n  /**\n   * Get result blob from execution\n   * \n   * Gray Paper equation 831: When HALT, read result from memory at registers[7] with length registers[8]\n   * This is used to extract the yield hash for accumulation (32 bytes) or other result data.\n   * \n   * @returns Result blob from memory, or empty array if result is not readable\n   */\n  getResult(): Uint8Array {\n    // Result extraction is meaningful for HALT and OK statuses (successful completion)\n    // For PANIC, FAULT, HOST, OOG - result is not valid\n    if (this.lastStatus !== Status.HALT && this.lastStatus !== Status.OK) {\n      return new Uint8Array(0)\n    }\n\n    // Get result range from registers\n    const startOffset = this.pvm.state.registerState[7]\n    const length = this.pvm.state.registerState[8]\n\n    // Empty result\n    if (length === u64(0)) {\n      return new Uint8Array(0)\n    }\n\n    // Validate length is reasonable (avoid overflow)\n    if (length > u64(0xffffffff)) {\n      return new Uint8Array(0)\n    }\n\n    // Read result from memory using RAM's readOctets\n    const readResult = this.pvm.state.ram.readOctets(u32(startOffset), u32(length))\n    \n    // If fault or no data, return empty array\n    if (readResult.faultAddress !== 0 || readResult.data === null) {\n      return new Uint8Array(0)\n    }\n\n    // Safe to return data (AssemblyScript requires explicit non-null handling)\n    return readResult.data!\n  }\n  \n  /**\n   * Write data to memory at address\n   * \n   * Uses SimpleRAM if available (for runBlob), otherwise uses default PVM RAM\n   * \n   * @param address - Starting address\n   * @param data - Data to write\n   */\n  setMemory(address: u32, data: Uint8Array): void {\n      this.pvm.state.ram.writeOctetsDuringInitialization(address, data)\n  }\n  \n  \n  /**\n   * Initialize a memory page (like TypeScript ram.initializePage)\n   * \n   * Sets up page access rights and grows memory arrays for the specified address range.\n   * This matches the TypeScript test helper where ram.initializePage() is called first.\n   * \n   * Uses SimpleRAM if available (for runBlob), otherwise uses default PVM RAM\n   * \n   * @param address - Starting address\n   * @param length - Page length (must be page-aligned)\n   * @param accessType - Access type (0=NONE, 1=READ, 2=WRITE)\n   */\n  initPage(address: u32, length: u32, accessType: MemoryAccessType): void {\n    // Call initPage on the current RAM instance\n    // Works with PVMRAM, SimpleRAM, or MockRAM\n    // MockRAM's initPage is a no-op, so this should never throw\n    this.pvm.state.ram.initPage(address, length, accessType)\n  }\n  \n  // ===== Helper Methods =====\n  \n  /**\n   * Decode registers from Uint8Array (little-endian)\n   * \n   * @param registers - 104 bytes (13 registers x 8 bytes each)\n   * @returns RegisterState\n   */\n  /**\n   * Decode registers from Array<u8>\n   */\n  decodeRegisters(registers: Array<u8>): StaticArray<u64> {\n    if (registers.length !== 13 * 8) {\n      return new StaticArray<u64>(13)\n    }\n    const registerValues = new StaticArray<u64>(13)\n    \n    for (let i: i32 = 0; i < 13; i++) {\n      const offset = i * 8\n      // Read little-endian u64\n      let value: u64 = u64(0)\n      value |= u64(registers[offset])\n      value |= u64(registers[offset + 1]) << 8\n      value |= u64(registers[offset + 2]) << 16\n      value |= u64(registers[offset + 3]) << 24\n      value |= u64(registers[offset + 4]) << 32\n      value |= u64(registers[offset + 5]) << 40\n      value |= u64(registers[offset + 6]) << 48\n      value |= u64(registers[offset + 7]) << 56\n      registerValues[i] = value\n    }\n    \n    return registerValues\n  }\n\n  /**\n   * Decode registers from Uint8Array\n   */\n  decodeRegistersFromUint8Array(registers: Uint8Array): StaticArray<u64> {\n    if (registers.length !== 13 * 8) {\n      return new StaticArray<u64>(13)\n    }\n    const registerValues = new StaticArray<u64>(13)\n    \n    for (let i: i32 = 0; i < 13; i++) {\n      const offset = i * 8\n      // Read little-endian u64\n      let value: u64 = u64(0)\n      value |= u64(registers[offset])\n      value |= u64(registers[offset + 1]) << 8\n      value |= u64(registers[offset + 2]) << 16\n      value |= u64(registers[offset + 3]) << 24\n      value |= u64(registers[offset + 4]) << 32\n      value |= u64(registers[offset + 5]) << 40\n      value |= u64(registers[offset + 6]) << 48\n      value |= u64(registers[offset + 7]) << 56\n      registerValues[i] = value\n    }\n    \n    return registerValues\n  }\n\n  \n  /**\n   * Restore memory from page map and chunks\n   * \n   * Page map format: sequence of (page_index: u16, chunk_offset: u32) pairs (little-endian)\n   * Chunks format: concatenated 4KB page data\n   * \n   * @param pageMap - Page mapping data\n   * @param chunks - Concatenated page chunks\n   */\n  restoreMemoryFromChunks(\n    pageMap: Uint8Array,\n    chunks: Uint8Array\n  ): void {\n    const pageSize: i32 = 4096\n    const entrySize: i32 = 6 // 2 bytes (u16) + 4 bytes (u32)\n    let chunkOffset: i32 = 0\n    \n    for (let mapOffset: i32 = 0; mapOffset < pageMap.length; mapOffset += entrySize) {\n      // Read page index (2 bytes, little-endian)\n      const pageIndex: u16 = u16(\n        pageMap[mapOffset] | (pageMap[mapOffset + 1] << 8)\n      )\n      \n      // Skip chunk offset field (4 bytes) - we read sequentially\n      // (In actual WASM implementation, this would be used for random access)\n      \n      // Read page data from chunks\n      if (chunkOffset + pageSize > chunks.length) {\n        this.lastStatus = Status.PANIC\n        return\n      }\n      const pageData = chunks.slice(chunkOffset, chunkOffset + pageSize)\n      chunkOffset += pageSize\n      \n      // Calculate page address\n      const startAddress = pageIndex * pageSize\n      \n      // IMPORTANT: Initialize page first before writing\n      // This ensures the memory arrays are grown and access rights are set\n      // Use WRITE access type (which includes READ) for pages being restored\n      this.pvm.state.ram.setPageAccessRights(\n          startAddress,\n          pageSize,\n          MemoryAccessType.WRITE,\n        )\n        this.pvm.state.ram.initPage(\n          startAddress,\n          pageSize,\n          MemoryAccessType.WRITE,\n        )\n        \n        // Write to memory using writeOctetsDuringInitialization\n        // This bypasses write checks during initialization\n        this.pvm.state.ram.writeOctetsDuringInitialization(startAddress, pageData)\n      }\n    }\n  }\n\n/**\n * Factory function to create PVM wrapper instance\n * \n * @returns WASM-compatible PVM shell instance\n */\nexport function createPvmShell(): WasmPvmShellInterface {\n  return new PVMWasmWrapper()\n}\n\n","\n// =============================================================================\n// Implications Encoding/Decoding Wrappers for Round-Trip Testing\n// =============================================================================\n\nimport { decodeImplicationsPair, encodeImplicationsPair, decodeImplications, encodeImplications, decodeCompleteServiceAccount, encodeCompleteServiceAccount, decodePartialState, encodePartialState, decodeProgramFromPreimage, DecodedProgram, decodeAccumulateInput, encodeAccumulateInput, decodeVariableSequence, encodeVariableSequenceGeneric, AccumulateInput, createStorageKey, createPreimageKey, createRequestKey, encodeFixedLength, getStorageValue, RawCshKeyvals } from './codec'\nimport { blake2b256 } from './crypto'\n\n/**\n * Round-trip decode and encode single Implications\n * Used for testing interoperability between TypeScript and AssemblyScript\n * \n * This function decodes the input bytes to Implications, then re-encodes them\n * back to bytes, returning the encoded result.\n * \n * @param data - Encoded Implications bytes\n * @param numCores - Number of cores (Ccorecount)\n * @param numValidators - Number of validators (Cvalcount)\n * @param authQueueSize - Authorization queue size (C_authqueuesize)\n * @returns Re-encoded Implications bytes (or empty array on error)\n */\nexport function roundTripSingleImplications(\n  data: Uint8Array,\n  numCores: i32,\n  numValidators: i32,\n  authQueueSize: i32,\n): Uint8Array {\n  // Decode Implications from bytes\n  const decodeResult = decodeImplications(data, numCores, numValidators, authQueueSize)\n  if (!decodeResult) {\n    // Decode failed - return empty array\n    return new Uint8Array(0)\n  }\n  \n  // Encode the implications back to bytes\n  const encoded = encodeImplications(decodeResult.value, numCores, numValidators, authQueueSize)\n  \n  // Ensure we always return a valid Uint8Array (not null/undefined)\n  if (encoded === null || encoded.length === 0) {\n    return new Uint8Array(0)\n  }\n  \n  return encoded\n}\n\n/**\n * Round-trip decode and encode ImplicationsPair\n * Used for testing interoperability between TypeScript and AssemblyScript\n * \n * This function decodes the input bytes to ImplicationsPair, then re-encodes them\n * back to bytes, returning the encoded result.\n * \n * @param data - Encoded ImplicationsPair bytes\n * @param numCores - Number of cores (Ccorecount)\n * @param numValidators - Number of validators (Cvalcount)\n * @param authQueueSize - Authorization queue size (C_authqueuesize)\n * @returns Re-encoded ImplicationsPair bytes (or empty array on error)\n */\nexport function roundTripImplications(\n  data: Uint8Array,\n  numCores: i32,\n  numValidators: i32,\n  authQueueSize: i32,\n): Uint8Array {\n  // Decode ImplicationsPair from bytes\n  const decodeResult = decodeImplicationsPair(data, numCores, numValidators, authQueueSize)\n  if (!decodeResult) {\n    // Decode failed - return empty array\n    return new Uint8Array(0)\n  }\n  \n  // Encode the pair back to bytes\n  const encoded = encodeImplicationsPair(decodeResult.value, numCores, numValidators, authQueueSize)\n  \n  // Ensure we always return a valid Uint8Array (not null/undefined)\n  if (encoded === null || encoded.length === 0) {\n    return new Uint8Array(0)\n  }\n  \n  return encoded\n}\n\n/**\n * Round-trip encode/decode for CompleteServiceAccount\n * \n * Decodes a CompleteServiceAccount from bytes, then re-encodes it.\n * Useful for testing encoding/decoding compatibility between TypeScript and AssemblyScript.\n * \n * @param data - Encoded CompleteServiceAccount bytes\n * @returns Re-encoded CompleteServiceAccount bytes (or empty array on error)\n */\nexport function roundTripServiceAccount(data: Uint8Array): Uint8Array {\n  // Decode CompleteServiceAccount from bytes\n  const decodeResult = decodeCompleteServiceAccount(data)\n  if (!decodeResult) {\n    // Decode failed - return empty array\n    return new Uint8Array(0)\n  }\n  \n  // Encode the account back to bytes\n  const encoded = encodeCompleteServiceAccount(decodeResult.value)\n  \n  // Ensure we always return a valid Uint8Array (not null/undefined)\n  if (encoded === null || encoded.length === 0) {\n    return new Uint8Array(0)\n  }\n  \n  return encoded\n}\n\n/**\n * Round-trip encode/decode for PartialState\n * \n * Decodes a PartialState from bytes, then re-encodes it.\n * Useful for testing encoding/decoding compatibility between TypeScript and AssemblyScript.\n * \n * @param data - Encoded PartialState bytes\n * @param numCores - Number of cores (Ccorecount)\n * @param numValidators - Number of validators (Cvalcount)\n * @param authQueueSize - Authorization queue size (C_authqueuesize)\n * @returns Re-encoded PartialState bytes (or empty array on error)\n */\nexport function roundTripPartialState(\n  data: Uint8Array,\n  numCores: i32,\n  numValidators: i32,\n  authQueueSize: i32,\n): Uint8Array {\n  // Decode PartialState from bytes\n  const decodeResult = decodePartialState(data, numCores, numValidators, authQueueSize)\n  if (!decodeResult) {\n    // Decode failed - return empty array\n    return new Uint8Array(0)\n  }\n  \n  // Encode the state back to bytes\n  const encoded = encodePartialState(decodeResult.value, numCores, numValidators, authQueueSize)\n  \n  // Ensure we always return a valid Uint8Array (not null/undefined)\n  if (encoded === null || encoded.length === 0) {\n    return new Uint8Array(0)\n  }\n  \n  return encoded\n}\n\n/**\n * DecodedProgramFields structure for returning all fields\n */\nexport class DecodedProgramFields {\n  metadata: Uint8Array\n  roDataLength: u32\n  rwDataLength: u32\n  heapZeroPaddingSize: u32\n  stackSize: u32\n  roData: Uint8Array\n  rwData: Uint8Array\n  codeSize: u32\n  code: Uint8Array\n\n  constructor(\n    metadata: Uint8Array,\n    roDataLength: u32,\n    rwDataLength: u32,\n    heapZeroPaddingSize: u32,\n    stackSize: u32,\n    roData: Uint8Array,\n    rwData: Uint8Array,\n    codeSize: u32,\n    code: Uint8Array,\n  ) {\n    this.metadata = metadata\n    this.roDataLength = roDataLength\n    this.rwDataLength = rwDataLength\n    this.heapZeroPaddingSize = heapZeroPaddingSize\n    this.stackSize = stackSize\n    this.roData = roData\n    this.rwData = rwData\n    this.codeSize = codeSize\n    this.code = code\n  }\n}\n\n/**\n * Get all fields from DecodedProgram for comparison testing\n * This decodes the preimage blob and returns all fields for comparison with TypeScript\n * \n * @param preimageBlob - The preimage blob bytes to decode\n * @returns All decoded program fields or null if decode fails\n */\nexport function getDecodedProgramFields(preimageBlob: Uint8Array): DecodedProgramFields | null {\n  // Decode the preimage blob\n  const decoded = decodeProgramFromPreimage(preimageBlob)\n  if (!decoded) {\n    return null\n  }\n  \n  // Return all fields\n  return new DecodedProgramFields(\n    decoded.metadata,\n    decoded.roDataLength,\n    decoded.rwDataLength,\n    decoded.heapZeroPaddingSize,\n    decoded.stackSize,\n    decoded.roData,\n    decoded.rwData,\n    decoded.codeSize,\n    decoded.code,\n  )\n}\n\n// =============================================================================\n// AccumulateInput Encoding/Decoding Wrappers for Round-Trip Testing\n// =============================================================================\n\n/**\n * Round-trip decode and encode AccumulateInputs sequence\n * Used for testing interoperability between TypeScript and AssemblyScript\n * \n * This function decodes the input bytes as a variable-length sequence of AccumulateInputs,\n * then re-encodes them back to bytes, returning the encoded result.\n * \n * @param data - Encoded AccumulateInputs sequence bytes (var{sequence{accinput}})\n * @returns Re-encoded AccumulateInputs sequence bytes (or empty array on error)\n */\nexport function roundTripAccumulateInputs(data: Uint8Array): Uint8Array {\n  // Decode variable-length sequence of AccumulateInputs from bytes\n  const decodeResult = decodeVariableSequence<AccumulateInput>(\n    data,\n    (inputData: Uint8Array) => decodeAccumulateInput(inputData),\n  )\n  \n  if (!decodeResult) {\n    // Decode failed - return empty array\n    return new Uint8Array(0)\n  }\n  \n  const inputs = decodeResult.value\n  \n  // Encode the sequence back to bytes using encodeVariableSequenceGeneric\n  const encoded = encodeVariableSequenceGeneric<AccumulateInput>(\n    inputs,\n    (input: AccumulateInput) => encodeAccumulateInput(input),\n  )\n  \n  // Ensure we always return a valid Uint8Array (not null/undefined)\n  if (encoded === null || encoded.length === 0) {\n    return new Uint8Array(0)\n  }\n  \n  return encoded\n}\n\n/**\n * Round-trip decode and encode a single AccumulateInput\n * Used for testing interoperability between TypeScript and AssemblyScript\n * \n * This function decodes a single AccumulateInput from bytes, then re-encodes it.\n * \n * @param data - Encoded AccumulateInput bytes\n * @returns Re-encoded AccumulateInput bytes (or empty array on error)\n */\nexport function roundTripSingleAccumulateInput(data: Uint8Array): Uint8Array {\n  // Decode single AccumulateInput from bytes\n  const decodeResult = decodeAccumulateInput(data)\n  \n  if (!decodeResult) {\n    // Decode failed - return empty array\n    return new Uint8Array(0)\n  }\n  \n  // Encode the input back to bytes\n  const encoded = encodeAccumulateInput(decodeResult.value)\n  \n  // Ensure we always return a valid Uint8Array (not null/undefined)\n  if (encoded === null || encoded.length === 0) {\n    return new Uint8Array(0)\n  }\n  \n  return encoded\n}\n\n// =============================================================================\n// Key Generation Exports for Testing Equivalence\n// =============================================================================\n\n/**\n * Generate a storage state key for testing\n * C(s, h) where h is the storage key\n * \n * @param serviceId - Service ID (4 bytes little-endian)\n * @param storageKey - Storage key (arbitrary length)\n * @returns 31-byte interleaved state key\n */\nexport function testCreateStorageKey(serviceId: u32, storageKey: Uint8Array): Uint8Array {\n  return createStorageKey(serviceId, storageKey)\n}\n\n/**\n * Generate a preimage state key for testing\n * C(s, h) where h is the preimage hash\n * \n * @param serviceId - Service ID (4 bytes little-endian)\n * @param preimageHash - Preimage hash (32 bytes)\n * @returns 31-byte interleaved state key\n */\nexport function testCreatePreimageKey(serviceId: u32, preimageHash: Uint8Array): Uint8Array {\n  return createPreimageKey(serviceId, preimageHash)\n}\n\n/**\n * Generate a request state key for testing\n * C(s, encode[4]{l} || h) where l is length and h is request hash\n * \n * @param serviceId - Service ID (4 bytes little-endian)\n * @param requestHash - Request hash (32 bytes)\n * @param length - Blob length\n * @returns 31-byte interleaved state key\n */\nexport function testCreateRequestKey(serviceId: u32, requestHash: Uint8Array, length: u64): Uint8Array {\n  return createRequestKey(serviceId, requestHash, length)\n}\n\n/**\n * Test the Blake2b-256 hash function\n * \n * @param data - Data to hash\n * @returns 32-byte Blake2b-256 hash\n */\nexport function testBlake2b256(data: Uint8Array): Uint8Array {\n  return blake2b256(data)\n}\n\n/**\n * Test fixed-length encoding\n * \n * @param value - Value to encode\n * @param length - Number of bytes\n * @returns Encoded bytes (little-endian)\n */\nexport function testEncodeFixedLength(value: u64, length: i32): Uint8Array {\n  return encodeFixedLength(value, length)\n}\n\n// =============================================================================\n// Host Function Logic Exports for Testing Equivalence\n// =============================================================================\n\nimport {\n  CompleteServiceAccount,\n  getRequestValue,\n  setRequestValue,\n  deleteRequestValue,\n  getStorageValue,\n  setStorageValue,\n  deleteStorageValue,\n  getPreimageValue,\n  setPreimageValue,\n  deletePreimageValue,\n  encodeRequestTimeslots,\n  decodeRequestTimeslots,\n  RawCshKeyvals,\n  CshEntry,\n} from './codec'\n\n// Deposit constants (Gray Paper)\nconst C_BASEDEPOSIT: u64 = u64(100) // Base deposit\nconst C_ITEMDEPOSIT: u64 = u64(10) // Per-item deposit\nconst C_BYTEDEPOSIT: u64 = u64(1) // Per-byte deposit\n\n/**\n * Test result for host function operations\n */\nexport class HostFunctionTestResult {\n  /** Result code: 0 = success, negative = error code */\n  resultCode: i64\n  /** Updated service account (encoded) */\n  encodedAccount: Uint8Array\n  /** Additional return value (e.g., previous length for WRITE) */\n  returnValue: u64\n  \n  constructor(resultCode: i64, encodedAccount: Uint8Array, returnValue: u64) {\n    this.resultCode = resultCode\n    this.encodedAccount = encodedAccount\n    this.returnValue = returnValue\n  }\n}\n\n/**\n * Calculate minimum balance based on items and octets\n * Gray Paper: a_minbalance = max(0, Cbasedeposit + Citemdeposit * a_items + Cbytedeposit * a_octets - a_gratis)\n */\nexport function testCalculateMinBalance(items: u64, octets: u64, gratis: u64): u64 {\n  const totalDeposit = C_BASEDEPOSIT + C_ITEMDEPOSIT * items + C_BYTEDEPOSIT * octets\n  return totalDeposit > gratis ? totalDeposit - gratis : u64(0)\n}\n\n/**\n * Test SOLICIT host function logic\n * \n * Tests the core logic of the SOLICIT host function without the full PVM context.\n * \n * @param encodedAccount - Encoded service account\n * @param serviceId - Service ID\n * @param requestHash - 32-byte request hash\n * @param preimageLength - Length of the preimage\n * @param timeslot - Current timeslot\n * @returns HostFunctionTestResult with result code and updated account\n */\nexport function testSolicitLogic(\n  encodedAccount: Uint8Array,\n  serviceId: u32,\n  requestHash: Uint8Array,\n  preimageLength: u64,\n  timeslot: u64,\n): HostFunctionTestResult {\n  // Decode service account\n  const decodeResult = decodeCompleteServiceAccount(encodedAccount)\n  if (!decodeResult) {\n    return new HostFunctionTestResult(i64(-9), new Uint8Array(0), u64(0)) // HUH\n  }\n  const serviceAccount = decodeResult.value\n  \n  // Look up existing request\n  const existingRequestValue = getRequestValue(serviceAccount, serviceId, requestHash, preimageLength)\n  \n  // Determine new request state\n  let newTimeslots: u32[]\n  let isNewRequest = false\n  \n  if (existingRequestValue === null) {\n    // Request doesn't exist - create empty request []\n    newTimeslots = []\n    isNewRequest = true\n  } else {\n    // Decode existing request\n    const existingTimeslots = decodeRequestTimeslots(existingRequestValue)\n    if (existingTimeslots === null) {\n      return new HostFunctionTestResult(i64(-9), new Uint8Array(0), u64(0)) // HUH\n    }\n    \n    if (existingTimeslots.length === 2) {\n      // Request exists as [x, y] - append current timeslot to make [x, y, t]\n      newTimeslots = [existingTimeslots[0], existingTimeslots[1], u32(timeslot)]\n    } else {\n      // Invalid request state - cannot solicit\n      return new HostFunctionTestResult(i64(-9), new Uint8Array(0), u64(0)) // HUH\n    }\n  }\n  \n  // Calculate new items and octets if this is a new request\n  const newItems = isNewRequest\n    ? serviceAccount.items + u32(2)\n    : serviceAccount.items\n  const newOctets = isNewRequest\n    ? serviceAccount.octets + u64(81) + preimageLength\n    : serviceAccount.octets\n  \n  // Calculate new minimum balance\n  const newMinBalance = testCalculateMinBalance(u64(newItems), newOctets, serviceAccount.gratis)\n  \n  // Check if service has sufficient balance\n  if (newMinBalance > serviceAccount.balance) {\n    return new HostFunctionTestResult(i64(-5), new Uint8Array(0), u64(0)) // FULL\n  }\n  \n  // Update service account with new request\n  setRequestValue(serviceAccount, serviceId, requestHash, preimageLength, encodeRequestTimeslots(newTimeslots))\n  \n  // Update items and octets if this is a new request\n  if (isNewRequest) {\n    serviceAccount.items = newItems\n    serviceAccount.octets = newOctets\n  }\n  \n  // Encode updated account\n  const encodedUpdated = encodeCompleteServiceAccount(serviceAccount)\n  \n  return new HostFunctionTestResult(i64(0), encodedUpdated, u64(0)) // OK\n}\n\n/**\n * Test FORGET host function logic\n * \n * @param encodedAccount - Encoded service account\n * @param serviceId - Service ID\n * @param requestHash - 32-byte request hash\n * @param preimageLength - Length of the preimage\n * @param timeslot - Current timeslot\n * @param expungePeriod - Expunge period constant\n * @returns HostFunctionTestResult with result code and updated account\n */\nexport function testForgetLogic(\n  encodedAccount: Uint8Array,\n  serviceId: u32,\n  requestHash: Uint8Array,\n  preimageLength: u64,\n  timeslot: u64,\n  expungePeriod: u64,\n): HostFunctionTestResult {\n  // Decode service account\n  const decodeResult = decodeCompleteServiceAccount(encodedAccount)\n  if (!decodeResult) {\n    return new HostFunctionTestResult(i64(-9), new Uint8Array(0), u64(0)) // HUH\n  }\n  const serviceAccount = decodeResult.value\n  \n  // Get request\n  const requestValue = getRequestValue(serviceAccount, serviceId, requestHash, preimageLength)\n  if (requestValue === null) {\n    return new HostFunctionTestResult(i64(-9), new Uint8Array(0), u64(0)) // HUH\n  }\n  \n  // Decode request timeslots\n  const timeslots = decodeRequestTimeslots(requestValue)\n  if (timeslots === null) {\n    return new HostFunctionTestResult(i64(-9), new Uint8Array(0), u64(0)) // HUH\n  }\n  \n  // Apply Gray Paper logic for different request states\n  if (timeslots.length === 0) {\n    // Case 1: [] - Remove request and preimage completely\n    deleteRequestValue(serviceAccount, serviceId, requestHash, preimageLength)\n    deletePreimageValue(serviceAccount, serviceId, requestHash)\n    // Update items and octets\n    if (serviceAccount.items >= u32(2)) {\n      serviceAccount.items -= u32(2)\n    } else {\n      serviceAccount.items = u32(0)\n    }\n    const octetsDelta = u64(81) + preimageLength\n    if (serviceAccount.octets >= octetsDelta) {\n      serviceAccount.octets -= octetsDelta\n    } else {\n      serviceAccount.octets = u64(0)\n    }\n  } else if (timeslots.length === 2) {\n    // Case 2: [x, y] where y < t - expungePeriod - Remove completely\n    const y = u64(timeslots[1])\n    if (y < timeslot - expungePeriod) {\n      deleteRequestValue(serviceAccount, serviceId, requestHash, preimageLength)\n      deletePreimageValue(serviceAccount, serviceId, requestHash)\n      if (serviceAccount.items >= u32(2)) {\n        serviceAccount.items -= u32(2)\n      } else {\n        serviceAccount.items = u32(0)\n      }\n      const octetsDelta2 = u64(81) + preimageLength\n      if (serviceAccount.octets >= octetsDelta2) {\n        serviceAccount.octets -= octetsDelta2\n      } else {\n        serviceAccount.octets = u64(0)\n      }\n    } else {\n      return new HostFunctionTestResult(i64(-9), new Uint8Array(0), u64(0)) // HUH\n    }\n  } else if (timeslots.length === 1) {\n    // Case 3: [x] - Update to [x, t]\n    const x = timeslots[0]\n    const newTimeslots: u32[] = [x, u32(timeslot)]\n    setRequestValue(serviceAccount, serviceId, requestHash, preimageLength, encodeRequestTimeslots(newTimeslots))\n  } else if (timeslots.length === 3) {\n    // Case 4: [x, y, w] where y < t - expungePeriod - Update to [w, t]\n    const y = u64(timeslots[1])\n    const w = timeslots[2]\n    if (y < timeslot - expungePeriod) {\n      const newTimeslots2: u32[] = [w, u32(timeslot)]\n      setRequestValue(serviceAccount, serviceId, requestHash, preimageLength, encodeRequestTimeslots(newTimeslots2))\n    } else {\n      return new HostFunctionTestResult(i64(-9), new Uint8Array(0), u64(0)) // HUH\n    }\n  } else {\n    return new HostFunctionTestResult(i64(-9), new Uint8Array(0), u64(0)) // HUH\n  }\n  \n  // Encode updated account\n  const encodedUpdated = encodeCompleteServiceAccount(serviceAccount)\n  \n  return new HostFunctionTestResult(i64(0), encodedUpdated, u64(0)) // OK\n}\n\n/**\n * Test QUERY host function logic\n * \n * @param encodedAccount - Encoded service account\n * @param serviceId - Service ID\n * @param requestHash - 32-byte request hash\n * @param preimageLength - Length of the preimage\n * @returns HostFunctionTestResult with registers[7] and registers[8] packed in resultCode and returnValue\n */\nexport function testQueryLogic(\n  encodedAccount: Uint8Array,\n  serviceId: u32,\n  requestHash: Uint8Array,\n  preimageLength: u64,\n): HostFunctionTestResult {\n  // Decode service account\n  const decodeResult = decodeCompleteServiceAccount(encodedAccount)\n  if (!decodeResult) {\n    return new HostFunctionTestResult(i64(-9), new Uint8Array(0), u64(0)) // NONE\n  }\n  const serviceAccount = decodeResult.value\n  \n  // Look up request\n  const requestValue = getRequestValue(serviceAccount, serviceId, requestHash, preimageLength)\n  if (requestValue === null) {\n    return new HostFunctionTestResult(i64(-9), new Uint8Array(0), u64(0)) // NONE\n  }\n  \n  // Decode request timeslots\n  const timeslots = decodeRequestTimeslots(requestValue)\n  if (timeslots === null) {\n    return new HostFunctionTestResult(i64(-9), new Uint8Array(0), u64(0)) // NONE\n  }\n  \n  // Return encoded status\n  const TWO_TO_32: u64 = u64(4294967296)\n  let reg7: u64 = u64(0)\n  let reg8: u64 = u64(0)\n  \n  if (timeslots.length === 0) {\n    reg7 = u64(0)\n    reg8 = u64(0)\n  } else if (timeslots.length === 1) {\n    const x = u64(timeslots[0])\n    reg7 = u64(1) + TWO_TO_32 * x\n    reg8 = u64(0)\n  } else if (timeslots.length === 2) {\n    const x = u64(timeslots[0])\n    const y = u64(timeslots[1])\n    reg7 = u64(2) + TWO_TO_32 * x\n    reg8 = y\n  } else if (timeslots.length === 3) {\n    const x = u64(timeslots[0])\n    const y = u64(timeslots[1])\n    const z = u64(timeslots[2])\n    reg7 = u64(3) + TWO_TO_32 * x\n    reg8 = y + TWO_TO_32 * z\n  } else {\n    return new HostFunctionTestResult(i64(-9), new Uint8Array(0), u64(0)) // NONE\n  }\n  \n  return new HostFunctionTestResult(i64(reg7), new Uint8Array(0), reg8)\n}\n\n/**\n * Test WRITE host function logic\n * \n * @param encodedAccount - Encoded service account\n * @param serviceId - Service ID\n * @param key - Storage key\n * @param value - Storage value (empty to delete)\n * @returns HostFunctionTestResult with result (previous length or error) and updated account\n */\nexport function testWriteLogic(\n  encodedAccount: Uint8Array,\n  serviceId: u32,\n  key: Uint8Array,\n  value: Uint8Array,\n): HostFunctionTestResult {\n  // Decode service account\n  const decodeResult = decodeCompleteServiceAccount(encodedAccount)\n  if (!decodeResult) {\n    return new HostFunctionTestResult(i64(-9), new Uint8Array(0), u64(0)) // HUH\n  }\n  const serviceAccount = decodeResult.value\n  \n  // Get previous value\n  const previousValue = getStorageValue(serviceAccount, serviceId, key)\n  const previousLength = previousValue ? i64(previousValue.length) : i64(-9) // NONE\n  \n  if (value.length === 0) {\n    // Delete operation\n    let newItems = u64(serviceAccount.items)\n    let newOctets = serviceAccount.octets\n    \n    if (previousValue !== null) {\n      newItems = newItems > u64(0) ? newItems - u64(1) : u64(0)\n      const deletedOctets = u64(34) + u64(key.length) + u64(previousValue.length)\n      newOctets = newOctets > deletedOctets ? newOctets - deletedOctets : u64(0)\n    }\n    \n    // Check balance\n    const newMinBalance = testCalculateMinBalance(newItems, newOctets, serviceAccount.gratis)\n    if (newMinBalance > serviceAccount.balance) {\n      return new HostFunctionTestResult(i64(-5), new Uint8Array(0), u64(0)) // FULL\n    }\n    \n    // Delete\n    if (previousValue !== null) {\n      deleteStorageValue(serviceAccount, serviceId, key)\n      serviceAccount.items = u32(newItems)\n      serviceAccount.octets = newOctets\n    }\n  } else {\n    // Write operation\n    let newItems = u64(serviceAccount.items)\n    let newOctets = serviceAccount.octets\n    \n    if (previousValue !== null) {\n      // Updating existing\n      newOctets = newOctets - u64(previousValue.length) + u64(value.length)\n    } else {\n      // Adding new\n      newItems = newItems + u64(1)\n      newOctets = newOctets + u64(34) + u64(key.length) + u64(value.length)\n    }\n    \n    // Check balance\n    const newMinBalance = testCalculateMinBalance(newItems, newOctets, serviceAccount.gratis)\n    if (newMinBalance > serviceAccount.balance) {\n      return new HostFunctionTestResult(i64(-5), new Uint8Array(0), u64(0)) // FULL\n    }\n    \n    // Write\n    setStorageValue(serviceAccount, serviceId, key, value)\n    serviceAccount.items = u32(newItems)\n    serviceAccount.octets = newOctets\n  }\n  \n  // Encode updated account\n  const encodedUpdated = encodeCompleteServiceAccount(serviceAccount)\n  \n  return new HostFunctionTestResult(previousLength, encodedUpdated, u64(0))\n}\n\n/**\n * Test READ host function logic\n * \n * @param encodedAccount - Encoded service account\n * @param serviceId - Service ID\n * @param key - Storage key\n * @param fromOffset - Offset to start reading from\n * @param length - Maximum length to read\n * @returns HostFunctionTestResult with length or error, and the read data\n */\nexport function testReadLogic(\n  encodedAccount: Uint8Array,\n  serviceId: u32,\n  key: Uint8Array,\n  fromOffset: u32,\n  length: u32,\n): HostFunctionTestResult {\n  // Decode service account\n  const decodeResult = decodeCompleteServiceAccount(encodedAccount)\n  if (!decodeResult) {\n    return new HostFunctionTestResult(i64(-9), new Uint8Array(0), u64(0)) // NONE\n  }\n  const serviceAccount = decodeResult.value\n  \n  // Get value\n  const storedValue = getStorageValue(serviceAccount, serviceId, key)\n  if (storedValue === null) {\n    return new HostFunctionTestResult(i64(-9), new Uint8Array(0), u64(0)) // NONE\n  }\n  \n  // Calculate slice\n  const f = min(i32(fromOffset), storedValue.length)\n  const l = min(i32(length), storedValue.length - f)\n  const slicedData = storedValue.slice(f, f + l)\n  \n  return new HostFunctionTestResult(i64(storedValue.length), slicedData, u64(l))\n}\n\n/**\n * Test request timeslot encoding\n * \n * @param timeslots - Array of timeslots (0-3 entries)\n * @returns Encoded bytes\n */\nexport function testEncodeRequestTimeslots(timeslots: u32[]): Uint8Array {\n  return encodeRequestTimeslots(timeslots)\n}\n\n/**\n * Test request timeslot decoding\n * \n * @param data - Encoded request value\n * @returns Decoded timeslots or null\n */\nexport function testDecodeRequestTimeslots(data: Uint8Array): u32[] | null {\n  return decodeRequestTimeslots(data)\n}\n\n// =============================================================================\n// SBRK Instruction Logic Exports for Testing Equivalence\n// =============================================================================\n\nimport { alignToPage } from './alignment-helpers'\nimport { MEMORY_CONFIG, MAX_MEMORY_ADDRESS, PAGE_SIZE, INIT_CONFIG } from './config'\n\n/**\n * Test result for SBRK instruction\n */\nexport class SBRKTestResult {\n  /** Result register value (new heap pointer or 0 on failure) */\n  resultValue: u64\n  /** New current heap pointer after operation */\n  newHeapPointer: u32\n  /** Number of pages allocated */\n  pagesAllocated: u32\n  /** Start page index for allocation */\n  startPageIndex: u32\n  \n  constructor(resultValue: u64, newHeapPointer: u32, pagesAllocated: u32, startPageIndex: u32) {\n    this.resultValue = resultValue\n    this.newHeapPointer = newHeapPointer\n    this.pagesAllocated = pagesAllocated\n    this.startPageIndex = startPageIndex\n  }\n}\n\n/**\n * Test SBRK instruction logic\n * \n * Tests the core SBRK logic without full PVM context.\n * Returns the result value and new heap state.\n * \n * @param currentHeapPointer - Current heap pointer before SBRK\n * @param requestedSize - Requested allocation size (registers[A])\n * @returns SBRKTestResult with all computed values\n */\nexport function testSbrkLogic(\n  currentHeapPointer: u32,\n  requestedSize: u64,\n): SBRKTestResult {\n  // If requestedSize == 0, return current heap pointer (query mode)\n  if (requestedSize === u64(0)) {\n    return new SBRKTestResult(\n      u64(currentHeapPointer),\n      currentHeapPointer,\n      0,\n      0\n    )\n  }\n  \n  // Record current heap pointer to return (before allocation)\n  const result = u64(currentHeapPointer)\n  \n  // Calculate new heap pointer\n  const nextPageBoundary = alignToPage(currentHeapPointer)\n  const newHeapPointer: u32 = currentHeapPointer + u32(requestedSize)\n  \n  // Check for overflow\n  if (newHeapPointer > MAX_MEMORY_ADDRESS) {\n    return new SBRKTestResult(\n      u64(0), // Return 0 on failure\n      currentHeapPointer, // Heap pointer unchanged\n      0,\n      0\n    )\n  }\n  \n  // Calculate pages to allocate\n  let pagesAllocated: u32 = 0\n  let startPageIndex: u32 = 0\n  \n  if (newHeapPointer > nextPageBoundary) {\n    const finalBoundary = alignToPage(newHeapPointer)\n    startPageIndex = nextPageBoundary / PAGE_SIZE\n    const endPageIndex = finalBoundary / PAGE_SIZE\n    pagesAllocated = endPageIndex - startPageIndex\n  }\n  \n  return new SBRKTestResult(\n    result,\n    newHeapPointer,\n    pagesAllocated,\n    startPageIndex\n  )\n}\n\n/**\n * Test page alignment function\n * \n * @param address - Address to align\n * @returns Page-aligned address (aligned up to next page boundary)\n */\nexport function testAlignToPage(address: u32): u32 {\n  return alignToPage(address)\n}\n\n/**\n * Get memory configuration constants for testing\n */\nexport function testGetMemoryConfig(): Uint8Array {\n  // Return 12 bytes: PAGE_SIZE (4), MAX_MEMORY_ADDRESS (4), ZONE_SIZE (4)\n  const buffer = new Uint8Array(12)\n  const pageSize = MEMORY_CONFIG.PAGE_SIZE\n  const maxAddress = MAX_MEMORY_ADDRESS\n  const zoneSize = INIT_CONFIG.ZONE_SIZE\n  \n  // Little-endian encoding\n  buffer[0] = u8(pageSize & 0xFF)\n  buffer[1] = u8((pageSize >> 8) & 0xFF)\n  buffer[2] = u8((pageSize >> 16) & 0xFF)\n  buffer[3] = u8((pageSize >> 24) & 0xFF)\n  \n  buffer[4] = u8(maxAddress & 0xFF)\n  buffer[5] = u8((maxAddress >> 8) & 0xFF)\n  buffer[6] = u8((maxAddress >> 16) & 0xFF)\n  buffer[7] = u8((maxAddress >> 24) & 0xFF)\n  \n  buffer[8] = u8(zoneSize & 0xFF)\n  buffer[9] = u8((zoneSize >> 8) & 0xFF)\n  buffer[10] = u8((zoneSize >> 16) & 0xFF)\n  buffer[11] = u8((zoneSize >> 24) & 0xFF)\n  \n  return buffer\n}\n\n// =============================================================================\n// FETCH Host Function Exports for Testing Equivalence\n// =============================================================================\n\nimport {\n  DEPOSIT_CONSTANTS,\n  HISTORY_CONSTANTS,\n  SERVICE_CONSTANTS,\n  TIME_CONSTANTS,\n  TRANSFER_CONSTANTS,\n  WORK_PACKAGE_CONSTANTS,\n  WORK_REPORT_CONSTANTS,\n  AUTHORIZATION_CONSTANTS,\n} from './pbnj-types-compat'\n\n/**\n * Get system constants as encoded bytes (FETCH selector 0)\n * \n * This matches the encoding in FetchHostFunction.getSystemConstants()\n * allowing comparison with TypeScript implementation.\n * \n * @param numCores - Number of cores\n * @param preimageExpungePeriod - Expunge period\n * @param epochDuration - Epoch duration\n * @param maxBlockGas - Max block gas\n * @param maxRefineGas - Max refine gas\n * @param maxTicketsPerExtrinsic - Max tickets per extrinsic\n * @param ticketsPerValidator - Tickets per validator\n * @param slotDuration - Slot duration (seconds)\n * @param rotationPeriod - Rotation period\n * @param numValidators - Number of validators\n * @param numEcPiecesPerSegment - EC pieces per segment\n * @param contestDuration - Contest duration\n * @param maxLookupAnchorage - Max lookup anchorage\n * @param ecPieceSize - EC piece size\n * @returns 134-byte system constants\n */\nexport function testGetSystemConstants(\n  numCores: u16,\n  preimageExpungePeriod: u32,\n  epochDuration: u32,\n  maxBlockGas: u64,\n  maxRefineGas: u64,\n  maxTicketsPerExtrinsic: u16,\n  ticketsPerValidator: u16,\n  slotDuration: u16,\n  rotationPeriod: u16,\n  numValidators: u16,\n  numEcPiecesPerSegment: u32,\n  contestDuration: u32,\n  maxLookupAnchorage: u32,\n  ecPieceSize: u32,\n): Uint8Array {\n  const buffer = new Uint8Array(134)\n  let offset: i32 = 0\n\n  // encode[8]{Citemdeposit = 10}\n  encodeU64ToBuffer(buffer, offset, u64(DEPOSIT_CONSTANTS.C_ITEMDEPOSIT))\n  offset += 8\n\n  // encode[8]{Cbytedeposit = 1}\n  encodeU64ToBuffer(buffer, offset, u64(DEPOSIT_CONSTANTS.C_BYTEDEPOSIT))\n  offset += 8\n\n  // encode[8]{Cbasedeposit = 100}\n  encodeU64ToBuffer(buffer, offset, u64(DEPOSIT_CONSTANTS.C_BASEDEPOSIT))\n  offset += 8\n\n  // encode[2]{Ccorecount}\n  encodeU16ToBuffer(buffer, offset, numCores)\n  offset += 2\n\n  // encode[4]{Cexpungeperiod}\n  encodeU32ToBuffer(buffer, offset, preimageExpungePeriod)\n  offset += 4\n\n  // encode[4]{Cepochlen}\n  encodeU32ToBuffer(buffer, offset, epochDuration)\n  offset += 4\n\n  // encode[8]{Creportaccgas = 10000000}\n  encodeU64ToBuffer(buffer, offset, u64(WORK_REPORT_CONSTANTS.C_REPORTACCGAS))\n  offset += 8\n\n  // encode[8]{Cpackageauthgas = 50000000}\n  encodeU64ToBuffer(buffer, offset, u64(AUTHORIZATION_CONSTANTS.C_PACKAGEAUTHGAS))\n  offset += 8\n\n  // encode[8]{Cpackagerefgas}\n  encodeU64ToBuffer(buffer, offset, maxRefineGas)\n  offset += 8\n\n  // encode[8]{Cblockaccgas}\n  encodeU64ToBuffer(buffer, offset, maxBlockGas)\n  offset += 8\n\n  // encode[2]{Crecenthistorylen = 8}\n  encodeU16ToBuffer(buffer, offset, u16(HISTORY_CONSTANTS.C_RECENTHISTORYLEN))\n  offset += 2\n\n  // encode[2]{Cmaxpackageitems = 16}\n  encodeU16ToBuffer(buffer, offset, u16(WORK_PACKAGE_CONSTANTS.C_MAXPACKAGEITEMS))\n  offset += 2\n\n  // encode[2]{Cmaxreportdeps = 8}\n  encodeU16ToBuffer(buffer, offset, u16(WORK_REPORT_CONSTANTS.C_MAXREPORTDEPS))\n  offset += 2\n\n  // encode[2]{Cmaxblocktickets}\n  encodeU16ToBuffer(buffer, offset, maxTicketsPerExtrinsic)\n  offset += 2\n\n  // encode[4]{Cmaxlookupanchorage}\n  encodeU32ToBuffer(buffer, offset, maxLookupAnchorage)\n  offset += 4\n\n  // encode[2]{Cticketentries}\n  encodeU16ToBuffer(buffer, offset, ticketsPerValidator)\n  offset += 2\n\n  // encode[2]{Cauthpoolsize = 8}\n  encodeU16ToBuffer(buffer, offset, u16(AUTHORIZATION_CONSTANTS.C_AUTHPOOLSIZE))\n  offset += 2\n\n  // encode[2]{Cslotseconds}\n  encodeU16ToBuffer(buffer, offset, slotDuration)\n  offset += 2\n\n  // encode[2]{Cauthqueuesize = 80}\n  encodeU16ToBuffer(buffer, offset, u16(AUTHORIZATION_CONSTANTS.C_AUTHQUEUESIZE))\n  offset += 2\n\n  // encode[2]{Crotationperiod}\n  encodeU16ToBuffer(buffer, offset, rotationPeriod)\n  offset += 2\n\n  // encode[2]{Cmaxpackagexts = 128}\n  encodeU16ToBuffer(buffer, offset, u16(WORK_PACKAGE_CONSTANTS.C_MAXPACKAGEXTS))\n  offset += 2\n\n  // encode[2]{Cassurancetimeoutperiod = 5}\n  encodeU16ToBuffer(buffer, offset, u16(TIME_CONSTANTS.C_ASSURANCETIMEOUTPERIOD))\n  offset += 2\n\n  // encode[2]{Cvalcount}\n  encodeU16ToBuffer(buffer, offset, numValidators)\n  offset += 2\n\n  // encode[4]{Cmaxauthcodesize = 64000}\n  encodeU32ToBuffer(buffer, offset, AUTHORIZATION_CONSTANTS.C_MAXAUTHCODESIZE)\n  offset += 4\n\n  // encode[4]{Cmaxbundlesize = 13791360}\n  encodeU32ToBuffer(buffer, offset, WORK_PACKAGE_CONSTANTS.C_MAXBUNDLESIZE)\n  offset += 4\n\n  // encode[4]{Cmaxservicecodesize = 4000000}\n  encodeU32ToBuffer(buffer, offset, SERVICE_CONSTANTS.C_MAXSERVICECODESIZE)\n  offset += 4\n\n  // encode[4]{Cecpiecesize}\n  encodeU32ToBuffer(buffer, offset, ecPieceSize)\n  offset += 4\n\n  // encode[4]{Cmaxpackageimports = 3072}\n  encodeU32ToBuffer(buffer, offset, WORK_PACKAGE_CONSTANTS.C_MAXPACKAGEIMPORTS)\n  offset += 4\n\n  // encode[4]{Csegmentecpieces}\n  encodeU32ToBuffer(buffer, offset, numEcPiecesPerSegment)\n  offset += 4\n\n  // encode[4]{Cmaxreportvarsize = 49152}\n  encodeU32ToBuffer(buffer, offset, WORK_REPORT_CONSTANTS.C_MAXREPORTVARSIZE)\n  offset += 4\n\n  // encode[4]{Cmemosize = 128}\n  encodeU32ToBuffer(buffer, offset, TRANSFER_CONSTANTS.C_MEMOSIZE)\n  offset += 4\n\n  // encode[4]{Cmaxpackageexports = 3072}\n  encodeU32ToBuffer(buffer, offset, WORK_PACKAGE_CONSTANTS.C_MAXPACKAGEEXPORTS)\n  offset += 4\n\n  // encode[4]{Cepochtailstart}\n  encodeU32ToBuffer(buffer, offset, contestDuration)\n\n  return buffer\n}\n\n// Helper functions for buffer encoding\nfunction encodeU64ToBuffer(buffer: Uint8Array, offset: i32, value: u64): void {\n  for (let i: i32 = 0; i < 8; i++) {\n    buffer[offset + i] = u8((value >> (u64(i) * 8)) & 0xff)\n  }\n}\n\nfunction encodeU32ToBuffer(buffer: Uint8Array, offset: i32, value: u32): void {\n  for (let i: i32 = 0; i < 4; i++) {\n    buffer[offset + i] = u8((value >> (i * 8)) & 0xff)\n  }\n}\n\nfunction encodeU16ToBuffer(buffer: Uint8Array, offset: i32, value: u16): void {\n  buffer[offset] = u8(value & 0xff)\n  buffer[offset + 1] = u8((value >> 8) & 0xff)\n}\n\n/**\n * Debug function to decode ImplicationsPair and check rawCshKeyvals contents\n * Returns the number of entries in rawCshKeyvals for service 0\n * \n * @param data - Encoded ImplicationsPair bytes\n * @param numCores - Number of cores\n * @param numValidators - Number of validators\n * @param authQueueSize - Authorization queue size\n * @returns Number of rawCshKeyvals entries for service 0, or -1 on error\n */\nexport function debugDecodeAndCheckStorage(\n  data: Uint8Array,\n  numCores: i32,\n  numValidators: i32,\n  authQueueSize: i32,\n): i32 {\n  // Decode ImplicationsPair\n  const decodeResult = decodeImplicationsPair(data, numCores, numValidators, authQueueSize)\n  if (!decodeResult) {\n    return -1 // Decode failed\n  }\n  \n  const imPair = decodeResult.value\n  const imX = imPair.regular\n  \n  // Find service account 0\n  const state = imX.state\n  for (let i = 0; i < state.accounts.length; i++) {\n    if (state.accounts[i].serviceId === 0) {\n      const account = state.accounts[i].account\n      return account.rawCshKeyvals.entries.length\n    }\n  }\n  \n  return -2 // Service 0 not found\n}\n\n/**\n * Debug function to test storage lookup\n * \n * @param data - Encoded ImplicationsPair bytes\n * @param numCores - Number of cores\n * @param numValidators - Number of validators\n * @param authQueueSize - Authorization queue size\n * @param storageKey - The original storage key to look up\n * @returns Storage value length if found, -1 if not found, -2 if decode error\n */\nexport function debugStorageLookup(\n  data: Uint8Array,\n  numCores: i32,\n  numValidators: i32,\n  authQueueSize: i32,\n  storageKey: Uint8Array,\n): i32 {\n  // Decode ImplicationsPair\n  const decodeResult = decodeImplicationsPair(data, numCores, numValidators, authQueueSize)\n  if (!decodeResult) {\n    return -2 // Decode failed\n  }\n  \n  const imPair = decodeResult.value\n  const imX = imPair.regular\n  \n  // Find service account 0\n  const state = imX.state\n  for (let i = 0; i < state.accounts.length; i++) {\n    if (state.accounts[i].serviceId === 0) {\n      const account = state.accounts[i].account\n      const value = getStorageValue(account, 0, storageKey)\n      if (value) {\n        return value.length\n      } else {\n        return -1 // Not found\n      }\n    }\n  }\n  \n  return -3 // Service 0 not found\n}\n\n/**\n * Debug function to get the first key from rawCshKeyvals for service 0\n * \n * @param data - Encoded ImplicationsPair bytes\n * @param numCores - Number of cores\n * @param numValidators - Number of validators\n * @param authQueueSize - Authorization queue size\n * @returns First key as Uint8Array, or empty array on error\n */\nexport function debugGetFirstStorageKey(\n  data: Uint8Array,\n  numCores: i32,\n  numValidators: i32,\n  authQueueSize: i32,\n): Uint8Array {\n  // Decode ImplicationsPair\n  const decodeResult = decodeImplicationsPair(data, numCores, numValidators, authQueueSize)\n  if (!decodeResult) {\n    return new Uint8Array(0)\n  }\n  \n  const imPair = decodeResult.value\n  const imX = imPair.regular\n  \n  // Find service account 0\n  const state = imX.state\n  for (let i = 0; i < state.accounts.length; i++) {\n    if (state.accounts[i].serviceId === 0) {\n      const account = state.accounts[i].account\n      if (account.rawCshKeyvals.entries.length > 0) {\n        return account.rawCshKeyvals.entries[0].key\n      }\n      return new Uint8Array(0)\n    }\n  }\n  \n  return new Uint8Array(0)\n}\n","// =============================================================================\n// Internal module exports (for use within AssemblyScript, not exported to WASM)\n// =============================================================================\n\n// Core utilities\nexport * from './alignment-helpers'\nexport * from './codec'\nexport * from './config'\nexport * from './crypto'\nexport * from './pbnj-types-compat'\n\n// Host functions\nexport * from './host-functions'\n\n// Instructions\nexport * from './instructions'\n\n// Invocations\nexport * from './parser'\n\n// Core PVM implementation\nexport * from './pvm'\nexport * from './ram'\nexport * from './types'\n\n// WASM wrapper (internal use)\nexport * from './wasm-wrapper'\n\nexport * from './test-exports'\n\n// =============================================================================\n// WASM API - Top-level exported functions for WASM usage\n// Only these functions are exported to WASM, not the internal classes\n// =============================================================================\n\nimport { PVMWasmWrapper, Status } from './wasm-wrapper'\nimport { SimpleRAM } from './simple-ram'\nimport { MockRAM } from './mock-ram'\nimport { RAM , RunProgramResult, MemoryAccessType, ExecutionResult } from './types'\nimport { AccumulateInvocationResult } from './pvm'\n\n// Global PVM instance (singleton for WASM usage)\nlet pvmInstance: PVMWasmWrapper | null = null\n\n/**\n * RAM type enumeration for init() function\n */\nexport enum RAMType {\n  PVMRAM = 0,    // Default: Full PVM RAM with regions (Gray Paper compliant)\n  SimpleRAM = 1, // Simple flat memory for test vectors and runBlob\n  MockRAM = 2,   // No-op mock RAM for testing (does nothing)\n}\n\n/**\n * Initialize PVM (create global instance)\n * Must be called before any other PVM operations\n * Safe to call multiple times - will reset the instance if it already exists\n * \n * @param ramType - Type of RAM to use (default: PVMRAM)\n */\nexport function init(ramType: i32): void {\n  // Reset instance if it already exists (allows re-initialization between tests)\n  let ram: RAM | null = null\n  \n  if (ramType === RAMType.SimpleRAM) {\n    ram = new SimpleRAM()\n  } else if (ramType === RAMType.MockRAM) {\n    ram = new MockRAM()\n  }\n  // If ramType === RAMType.PVMRAM (0), ram stays null and PVMWasmWrapper will use PVMRAM\n  \n  pvmInstance = new PVMWasmWrapper(ram)\n  // Explicitly reset PVM state to ensure clean state\n  pvmInstance!.pvm.reset()\n}\n\n/**\n * Reset PVM state (explicit reset function for test cleanup)\n * Safe to call multiple times\n */\nexport function reset(): void {\n  if (!pvmInstance) return\n  // Use non-null assertion since we've checked for null above\n  pvmInstance!.pvm.reset()\n  pvmInstance!.lastStatus = Status.OK\n  pvmInstance!.exitArg = 0\n}\n\n/**\n * Reset PVM with program and initial registers\n * \n * @param program - Program data (host bindings handle conversion)\n * @param registers - Register data (104 bytes, 13x8 bytes little-endian, host bindings handle conversion)\n * @param gas - Initial gas amount\n */\nexport function resetGeneric(\n  program: Uint8Array,\n  registers: Uint8Array,\n  gas: u32\n): void {\n  pvmInstance!.resetGeneric(program, registers, gas)\n}\n\n/**\n * Reset PVM with full memory state\n * \n * @param programPtr - Pointer to program data\n * @param programLen - Length of program data\n * @param registersPtr - Pointer to registers (104 bytes)\n * @param pageMapPtr - Pointer to page map data\n * @param pageMapLen - Length of page map\n * @param chunksPtr - Pointer to memory chunks\n * @param chunksLen - Length of chunks\n * @param gas - Initial gas\n */\nexport function resetGenericWithMemory(\n  programPtr: Uint8Array,\n  registersPtr: Uint8Array,\n  pageMapPtr: Uint8Array,\n  chunksPtr: Uint8Array,\n  gas: u32\n): void {\n\n  // Lift Uint8Arrays from pointers (from __lowerTypedArray)\n  pvmInstance!.resetGenericWithMemory(programPtr, registersPtr, pageMapPtr, chunksPtr, gas)\n}\n\n/**\n * Execute one instruction step\n * @returns true if execution should continue, false if halted/panicked/OOG\n */\nexport function nextStep(): bool {\n  if (!pvmInstance) return false\n  return pvmInstance!.nextStep()\n}\n\n/**\n * Execute N instruction steps\n * @param steps - Number of steps to execute\n * @returns true if execution should continue, false if halted/panicked/OOG\n */\nexport function nSteps(steps: i32): bool {\n  if (!pvmInstance) return false\n  return pvmInstance!.nSteps(steps)\n}\n\n\n\n/**\n * Run program from blob\n * @param program - Program blob (Uint8Array, host bindings handle conversion)\n */\nexport function runBlob(program: Uint8Array): void {\n  if (!pvmInstance) return\n  pvmInstance!.runBlob(program)\n}\n\n/**\n * Prepare program blob for step-by-step execution (decode without executing)\n * @param program - Program blob bytes (deblob format)\n */\nexport function prepareBlob(program: Uint8Array): void {\n  if (!pvmInstance) return\n  pvmInstance!.prepareBlob(program)\n}\n\n//TODO: we cannot pass in closures, find another way to pass in context\n// export function executeMarshallingInvocation(\n//   programPtr: Uint8Array,\n//   initialPC: u32,\n//   gasLimit: u32,\n//   encodedArgs: Uint8Array,\n// ): void {\n//   if (!pvmInstance) return\n//   pvmInstance!.executeMarshallingInvocation(programPtr, initialPC, gasLimit, encodedArgs)\n// }\n\nexport function accumulateInvocation(\n  gasLimit: u32,\n  program: Uint8Array,\n  args: Uint8Array,\n  context: Uint8Array,\n  numCores: i32,\n  numValidators: i32,\n  authQueueSize: i32,\n  entropyAccumulator: Uint8Array,\n  encodedWorkItems: Uint8Array,\n  configNumCores: i32 = 341,\n  configPreimageExpungePeriod: u32 = 19200,\n  configEpochDuration: u32 = 600,\n  configMaxBlockGas: u64 = u64(3500000000),\n  configTicketsPerValidator: u16 = 2,\n  configSlotDuration: u16 = 6,\n  configRotationPeriod: u16 = 10,\n  configNumValidators: u16 = 1023,\n): AccumulateInvocationResult {\n  if (!pvmInstance) {\n    // Return error result if PVM not initialized\n    return new AccumulateInvocationResult(\n      0,\n      ExecutionResult.fromPanic(),\n      new Uint8Array(0),\n    )\n  }\n  return pvmInstance!.pvm.accumulateInvocation(\n    gasLimit,\n    program,\n    args,\n    context,\n    numCores,\n    numValidators,\n    authQueueSize,\n    entropyAccumulator,\n    encodedWorkItems,\n    configNumCores,\n    configPreimageExpungePeriod,\n    configEpochDuration,\n    configMaxBlockGas,\n    configTicketsPerValidator,\n    configSlotDuration,\n    configRotationPeriod,\n    configNumValidators,\n  )\n}\n\n/**\n * Set up accumulation invocation without executing (for step-by-step execution)\n * @param gasLimit - Gas limit for execution\n * @param program - Program preimage blob\n * @param args - Encoded arguments\n * @param context - Encoded implications pair context\n * @param numCores - Number of cores\n * @param numValidators - Number of validators\n * @param authQueueSize - Auth queue size\n */\nexport function setupAccumulateInvocation(\n  gasLimit: u32,\n  program: Uint8Array,\n  args: Uint8Array,\n  context: Uint8Array,\n  numCores: i32,\n  numValidators: i32,\n  authQueueSize: i32,\n  entropyAccumulator: Uint8Array,\n  encodedWorkItems: Uint8Array,\n  configNumCores: i32 = 341,\n  configPreimageExpungePeriod: u32 = 19200,\n  configEpochDuration: u32 = 600,\n  configMaxBlockGas: u64 = u64(3500000000),\n  configMaxRefineGas: u64 = u64(5000000000),\n  configMaxTicketsPerExtrinsic: u16 = 16,\n  configTicketsPerValidator: u16 = 2,\n  configSlotDuration: u16 = 6,\n  configRotationPeriod: u16 = 10,\n  configNumValidators: u16 = 1023,\n  configNumEcPiecesPerSegment: u32 = 6,\n  configContestDuration: u32 = 500,\n  configMaxLookupAnchorage: u32 = 14400,\n  configEcPieceSize: u32 = 684,\n  jamVersionMajor: u8 = 0,\n  jamVersionMinor: u8 = 7,\n  jamVersionPatch: u8 = 2,\n): void {\n  if (!pvmInstance) return\n  pvmInstance!.pvm.setupAccumulateInvocation(\n    gasLimit,\n    program,\n    args,\n    context,\n    numCores,\n    numValidators,\n    authQueueSize,\n    entropyAccumulator,\n    encodedWorkItems,\n    configNumCores,\n    configPreimageExpungePeriod,\n    configEpochDuration,\n    configMaxBlockGas,\n    configMaxRefineGas,\n    configMaxTicketsPerExtrinsic,\n    configTicketsPerValidator,\n    configSlotDuration,\n    configRotationPeriod,\n    configNumValidators,\n    configNumEcPiecesPerSegment,\n    configContestDuration,\n    configMaxLookupAnchorage,\n    configEcPieceSize,\n    jamVersionMajor,\n    jamVersionMinor,\n    jamVersionPatch,\n  )\n}\n\n/**\n * Set accumulate inputs for FETCH host function\n * This is called from the WASM executor to provide accumulate inputs for selectors 14 and 15\n */\nexport function setAccumulateInputs(inputs: Array<AccumulateInput> | null): void {\n  if (!pvmInstance) return\n  pvmInstance!.pvm.setAccumulateInputs(inputs)\n}\n\n/**\n * Set up refine invocation without executing (for step-by-step execution)\n * Gray Paper equation 78-89: _R(coreIndex, workItemIndex, workPackage, authorizerTrace, importSegments, exportSegmentOffset)\n * \n * @param gasLimit - Gas limit for execution (from work item refgaslimit)\n * @param program - Program preimage blob\n * @param args - Encoded refine arguments: encode{c, i, w.serviceindex, var{w.payload}, blake{p}}\n * @param workPackage - Work package (for FETCH host function)\n * @param authorizerTrace - Authorizer trace (for FETCH host function)\n * @param importSegments - Import segments (for FETCH host function)\n * @param exportSegmentOffset - Export segment offset (for EXPORT host function)\n * @param serviceAccount - Service account (for HISTORICAL_LOOKUP host function)\n * @param lookupAnchorTimeslot - Lookup anchor timeslot (for HISTORICAL_LOOKUP host function)\n */\nexport function setupRefineInvocation(\n  gasLimit: u32,\n  program: Uint8Array,\n  args: Uint8Array,\n  workPackage: WorkPackage | null,\n  authorizerTrace: Uint8Array | null,\n  importSegments: Array<Array<Uint8Array>> | null,\n  exportSegmentOffset: u32,\n  serviceAccount: CompleteServiceAccount | null,\n  lookupAnchorTimeslot: u64,\n): void {\n  if (!pvmInstance) return\n  pvmInstance!.pvm.setupRefineInvocation(\n    gasLimit,\n    program,\n    args,\n    workPackage,\n    authorizerTrace,\n    importSegments,\n    exportSegmentOffset,\n    serviceAccount,\n    lookupAnchorTimeslot,\n  )\n}\n\nexport function runProgram(\n): RunProgramResult {\n  if (!pvmInstance) {\n    return new RunProgramResult(0, ExecutionResult.fromPanic())\n  }\n  return pvmInstance!.pvm.runProgram()\n}\n\n/**\n * Get current program counter\n * @returns Current PC value\n */\nexport function getProgramCounter(): u32 {\n  if (!pvmInstance) return 0\n  return pvmInstance!.getProgramCounter()\n}\n\n\n/**\n * Set next program counter\n * @param pc - New PC value\n */\nexport function setNextProgramCounter(pc: u32): void {\n  if (!pvmInstance) return\n  pvmInstance!.setNextProgramCounter(pc)\n}\n\n/**\n * Get remaining gas\n * @returns Gas left\n */\nexport function getGasLeft(): u32 {\n  if (!pvmInstance) return 0\n  return pvmInstance!.getGasLeft()\n}\n\n/**\n * Set remaining gas\n * @param gas - New gas value\n */\nexport function setGasLeft(gas: i64): void {\n  if (!pvmInstance) return\n  pvmInstance!.setGasLeft(u32(gas))\n}\n\n/**\n * Get current execution status\n * @returns Status code (0=OK, 1=HALT, 2=PANIC, 3=FAULT, 4=HOST, 5=OOG)\n */\nexport function getStatus(): Status {\n  if (!pvmInstance) return Status.PANIC\n  return pvmInstance!.getStatus()\n}\n\n/**\n * Get exit argument (value in r7 when halted)\n * @returns Exit code from r7\n */\nexport function getExitArg(): u32 {\n  if (!pvmInstance) return 0\n  return pvmInstance!.getExitArg()\n}\n\n/**\n * Get result code from last execution\n * @returns Result code (0=OK, 1=HALT, 2=PANIC, 3=FAULT, 4=HOST, 5=OOG)\n */\nexport function getResultCode(): u32 {\n  if (!pvmInstance) return 2 // PANIC\n  return pvmInstance!.pvm.state.resultCode\n}\n\n/**\n * Get result blob from execution\n * Gray Paper equation 831: When HALT, read result from memory at registers[7] with length registers[8]\n * @returns Result blob from memory, or empty array if not available\n */\nexport function getResult(): Uint8Array {\n  if (!pvmInstance) return new Uint8Array(0)\n  \n  // Get result offset and length from registers\n  const offset = pvmInstance!.pvm.state.registerState[7]\n  const length = pvmInstance!.pvm.state.registerState[8]\n  \n  // Empty result\n  if (length === u64(0)) {\n    return new Uint8Array(0)\n  }\n  \n  // Validate length is reasonable\n  if (length > u64(0xffffffff)) {\n    return new Uint8Array(0)\n  }\n  \n  // Read directly from memory\n  const readResult = pvmInstance!.pvm.state.ram.readOctets(u32(offset), u32(length))\n  \n  // If fault or no data, return empty\n  if (readResult.faultAddress !== 0 || readResult.data === null) {\n    return new Uint8Array(0)\n  }\n  \n  return readResult.data!\n}\n\n// ============================================================================\n// JIP-6 Trace Support Functions\n// ============================================================================\n\n/**\n * Get last load address from RAM (for JIP-6 trace support)\n * @returns Last address read from\n */\nexport function getLastLoadAddress(): u32 {\n  if (!pvmInstance) return 0\n  return pvmInstance!.pvm.state.ram.lastLoadAddress\n}\n\n/**\n * Get last load value from RAM (for JIP-6 trace support)\n * @returns Last value read (up to 8 bytes, little-endian u64)\n */\nexport function getLastLoadValue(): u64 {\n  if (!pvmInstance) return 0\n  return pvmInstance!.pvm.state.ram.lastLoadValue\n}\n\n/**\n * Get last store address from RAM (for JIP-6 trace support)\n * @returns Last address written to\n */\nexport function getLastStoreAddress(): u32 {\n  if (!pvmInstance) return 0\n  return pvmInstance!.pvm.state.ram.lastStoreAddress\n}\n\n/**\n * Get last store value from RAM (for JIP-6 trace support)\n * @returns Last value stored (up to 8 bytes, little-endian u64)\n */\nexport function getLastStoreValue(): u64 {\n  if (!pvmInstance) return 0\n  return pvmInstance!.pvm.state.ram.lastStoreValue\n}\n\n/**\n * Clear last memory operation tracking (call at start of each instruction)\n */\nexport function clearLastMemoryOp(): void {\n  if (!pvmInstance) return\n  pvmInstance!.pvm.state.ram.clearLastMemoryOp()\n}\n\n/**\n * Get code array (for debugging/comparison)\n * @returns Copy of the code array\n */\nexport function getCode(): Uint8Array {\n  if (!pvmInstance) return new Uint8Array(0)\n  return pvmInstance!.getCode()\n}\n\n/**\n * Get bitmask array (for debugging/comparison)\n * @returns Copy of the bitmask array\n */\nexport function getBitmask(): Uint8Array {\n  if (!pvmInstance) return new Uint8Array(0)\n  return pvmInstance!.getBitmask()\n}\n\n/**\n * Get all registers as bytes (104 bytes = 13 registers x 8 bytes each, little-endian)\n * @returns Uint8Array - loader automatically handles TypedArray returns\n */\nexport function getRegisters(): Uint8Array {\n  if (!pvmInstance) return new Uint8Array(0)\n  return pvmInstance!.getRegisters()\n}\n\n/**\n * Set all registers from Array<u8>\n * @param registers - Array<u8> (104 bytes) - loader automatically converts Uint8Array\n */\nexport function setRegisters(registers: Array<u8>): void {\n  if (!pvmInstance) return\n  pvmInstance!.setRegisters(registers)\n}\n\n/**\n * Get single register value\n * @param index - Register index (0-12)\n * @returns Register value\n */\nexport function getRegister(index: u8): u64 {\n  if (!pvmInstance || index < 0 || index >= 13) return 0\n  return pvmInstance!.getRegister(index)\n}\n\n/**\n * Set single register value\n * @param index - Register index (0-12)\n * @param value - New register value\n */\nexport function setRegister(index: u8, value: u64): void {\n  if (!pvmInstance || index < 0 || index >= 13) return\n  pvmInstance!.setRegister(index, value)\n}\n\n/**\n * Get memory page dump (4KB)\n * @param pageIndex - Page index (page address = index * 4096)\n * @returns Pointer to 4096 bytes of page data in WASM memory (header pointer from __lowerTypedArray)\n */\nexport function getPageDump(pageIndex: i32): i32 {\n  if (!pvmInstance) return 0\n  const page = pvmInstance!.getPageDump(pageIndex)\n  // Allocate new Uint8Array in WASM memory and copy data\n  // This ensures the data is in WASM linear memory and can be read by the test helper\n  const pageCopy = new Uint8Array(page.length)\n  pageCopy.set(page)\n  // Return header pointer (similar to getRegisters)\n  return changetype<i32>(pageCopy)\n}\n\n/**\n * Write data to memory at address\n * @param address - Starting address\n * @param data - Data to write (Array<u8>) - loader automatically converts Uint8Array\n */\nexport function setMemory(address: u32, data: Uint8Array): void {\n  if (!pvmInstance) return\n  pvmInstance!.setMemory(address, data)\n}\n\n/**\n * Get the current accumulation context (ImplicationsPair) after execution\n * \n * This function encodes the current ImplicationsPair from the PVM's accumulationContext\n * and returns it as bytes, which can be decoded by the TypeScript side.\n * \n * @param numCores - Number of cores for encoding\n * @param numValidators - Number of validators for encoding\n * @param authQueueSize - Auth queue size for encoding\n * @returns Encoded ImplicationsPair bytes, or empty array if no context\n */\nexport function getAccumulationContext(\n  numCores: i32,\n  numValidators: i32,\n  authQueueSize: i32,\n): Uint8Array {\n  if (!pvmInstance) return new Uint8Array(0)\n  const context = pvmInstance!.pvm.accumulationContext\n  if (context === null) return new Uint8Array(0)\n  \n  // Encode the ImplicationsPair using the codec\n  const encoded = encodeImplicationsPair(context, numCores, numValidators, authQueueSize)\n  return encoded\n}\n\n/**\n * Get refine context export segments\n * Returns the export segments from the refine context\n */\nexport function getRefineContextExportSegments(): Array<Uint8Array> {\n  if (!pvmInstance || !pvmInstance!.pvm.refineContext) {\n    return []\n  }\n  return pvmInstance!.pvm.refineContext!.exportSegments\n}\n\n/**\n * Check if accumulation context is set\n * @returns true if accumulationContext is not null\n */\nexport function hasAccumulationContext(): bool {\n  if (!pvmInstance) return false\n  return pvmInstance!.pvm.accumulationContext !== null\n}\n\n/**\n * Initialize a memory page (like TypeScript ram.initializePage)\n * Sets up page access rights and grows memory arrays.\n * @param address - Starting address\n * @param length - Page length (must be page-aligned)\n * @param accessType - Access type (0=NONE, 1=READ, 2=WRITE)\n */\nexport function initPage(address: u32, length: u32, accessType: MemoryAccessType): void {\n  if (!pvmInstance) return\n  pvmInstance!.initPage(address, length, accessType)\n}\n\n\n/**\n * Prepare a program for execution\n * Sets up internal PVM state with decoded program, memory, and registers\n * \n * @param program - Program blob bytes\n * @param initialRegisters - Initial register state (13 registers as u64[])\n * @param initialPageMap - Initial page map (memory pages to initialize)\n * @param initialMemory - Initial memory chunks (data to write)\n * @param args - Argument data (for SPI programs)\n */\nexport function initializeProgram(\n  program: Uint8Array,\n  args: Uint8Array,\n): void {\n  if (!pvmInstance) {\n    // Initialize with PVMRAM if not already initialized\n    init(RAMType.PVMRAM)\n  }\n  // All parameters are already Uint8Array, use directly\n  pvmInstance!.pvm.initializeProgram(program, args)\n}\n\n","/**\n * Simple RAM Implementation (AssemblyScript)\n *\n * A simplified RAM implementation with page access rights but without regions.\n * Uses a flat memory space with per-page access control (READ, WRITE, NONE).\n * Used for runBlob and test vectors where we want a simple memory model.\n */\n\nimport { FaultCheckResult, ReadResult, RAM, MemoryAccessType, WriteResult } from './types'\nimport { MEMORY_CONFIG } from './config'\n\n/**\n * Simple RAM - flat memory space with page access rights\n * \n * Uses a single contiguous Uint8Array for memory storage that grows as needed.\n * Tracks page access rights (READ, WRITE, NONE) per page using a Map for efficient\n * sparse storage of only initialized pages.\n */\nexport class SimpleRAM implements RAM {\n  // Single contiguous memory storage (grows as needed)\n  private memory: Uint8Array = new Uint8Array(0)\n  \n  // Page access rights: Map from page index to MemoryAccessType\n  // Only stores pages that have been explicitly initialized\n  // Uninitialized pages default to NONE\n  private pageAccess: Map<u32, MemoryAccessType> = new Map<u32, MemoryAccessType>()\n  \n  // Track current heap pointer for SBRK operations\n  currentHeapPointer: u32 = 0\n\n  // JIP-6 trace support: Track last load/store for each instruction step\n  lastLoadAddress: u32 = 0\n  lastLoadValue: u64 = 0\n  lastStoreAddress: u32 = 0\n  lastStoreValue: u64 = 0\n\n  /**\n   * Clear last load/store tracking (call at start of each instruction)\n   */\n  clearLastMemoryOp(): void {\n    this.lastLoadAddress = 0\n    this.lastLoadValue = 0\n    this.lastStoreAddress = 0\n    this.lastStoreValue = 0\n  }\n\n  /**\n   * Get page index for an address\n   */\n  private getPageIndex(address: u32): u32 {\n    return address / MEMORY_CONFIG.PAGE_SIZE\n  }\n\n\n  /**\n   * Ensure memory is large enough for the given address range\n   * Grows the single contiguous memory array as needed\n   */\n  private ensureMemorySize(requiredSize: u32): void {\n    if (u32(this.memory.length) >= requiredSize) {\n      return // Already large enough\n    }\n    \n    // Grow to next page boundary\n    const alignedSize = ((requiredSize / MEMORY_CONFIG.PAGE_SIZE) + 1) * MEMORY_CONFIG.PAGE_SIZE\n    const newMemory = new Uint8Array(alignedSize)\n    \n    // Copy existing data\n    if (this.memory.length > 0) {\n      newMemory.set(this.memory, 0)\n    }\n    \n    // New memory is zero-initialized by default\n    this.memory = newMemory\n  }\n\n  /**\n   * Get page access type for a page index\n   * Returns NONE by default for uninitialized pages\n   */\n  private getPageAccess(pageIndex: u32): MemoryAccessType {\n    // Check if page exists in map, return NONE if not found\n    return this.pageAccess.has(pageIndex) ? this.pageAccess.get(pageIndex) : MemoryAccessType.NONE\n  }\n\n  /**\n   * Check if an address range has the required access type\n   * Returns fault address (page start) if access is denied, 0 if allowed\n   */\n  private checkAccess(address: u32, size: u32, requiredAccess: MemoryAccessType): u32 {\n    const startPage = this.getPageIndex(address)\n    const endPage = this.getPageIndex(address + size - 1)\n    \n    for (let pageIndex = startPage; pageIndex <= endPage; pageIndex++) {\n      const pageAccess = this.getPageAccess(pageIndex)\n      \n      // Check if page has required access\n      if (requiredAccess === MemoryAccessType.READ) {\n        // For READ, need READ or WRITE\n        if (pageAccess === MemoryAccessType.NONE) {\n          return pageIndex * MEMORY_CONFIG.PAGE_SIZE\n        }\n      } else if (requiredAccess === MemoryAccessType.WRITE) {\n        // For WRITE, need WRITE\n        if (pageAccess !== MemoryAccessType.WRITE) {\n          return pageIndex * MEMORY_CONFIG.PAGE_SIZE\n        }\n      }\n    }\n    \n    return 0 // No fault\n  }\n\n  /**\n   * Read multiple octets from memory\n   */\n  readOctets(address: u32, count: u32): ReadResult {\n    if (count === 0) {\n      return new ReadResult(new Uint8Array(0), 0)\n    }\n\n    // Check read access\n    const faultAddress = this.checkAccess(address, count, MemoryAccessType.READ)\n    if (faultAddress !== 0) {\n      return new ReadResult(null, faultAddress)\n    }\n\n    // Ensure memory is allocated\n    this.ensureMemorySize(address + count)\n    \n    // Read directly from contiguous memory\n    const result = new Uint8Array(count)\n    const sourceView = this.memory.subarray(address, address + count)\n    result.set(sourceView, 0)\n\n    // JIP-6 trace support: Track last load address and value\n    this.lastLoadAddress = address\n    if (count > 0) {\n      let value: u64 = 0\n      const bytesToRead = min(count, 8)\n      for (let i: u32 = 0; i < bytesToRead; i++) {\n        value |= u64(result[i]) << (i * 8)\n      }\n      this.lastLoadValue = value\n    }\n\n    return new ReadResult(result, 0) // No faults\n  }\n\n  /**\n   * Write multiple octets to memory\n   */\n  writeOctets(address: u32, values: Uint8Array): WriteResult {\n    if (values.length === 0) {\n      return new WriteResult(false, 0)\n    }\n\n    // Check write access (same pattern as ram.ts)\n    const writableResult = this.isWritableWithFault(address, u32(values.length))\n    if (!writableResult.success) {\n      return new WriteResult(true, writableResult.faultAddress !== 0 ? writableResult.faultAddress : 0xFFFFFFFF)\n    }\n\n    // Ensure memory is allocated\n    this.ensureMemorySize(address + values.length)\n    \n    // Write directly to contiguous memory\n    this.memory.set(values, address)\n\n    // Update heap pointer if writing beyond current heap\n    if (address + values.length > this.currentHeapPointer) {\n      this.currentHeapPointer = address + values.length\n    }\n\n    // JIP-6 trace support: Track last store address and value\n    this.lastStoreAddress = address\n    if (values.length > 0) {\n      let value: u64 = 0\n      const bytesToRead = min(u32(values.length), 8)\n      for (let i: u32 = 0; i < bytesToRead; i++) {\n        value |= u64(values[i]) << (i * 8)\n      }\n      this.lastStoreValue = value\n    }\n\n    return new WriteResult(false, 0) // No faults\n  }\n\n  /**\n   * Allocate pages (for SBRK)\n   */\n  allocatePages(startPage: u32, count: u32): void {\n    // Ensure memory is allocated for these pages\n    const startAddress = startPage * MEMORY_CONFIG.PAGE_SIZE\n    const endAddress = (startPage + count) * MEMORY_CONFIG.PAGE_SIZE\n    this.ensureMemorySize(endAddress)\n    \n    // Update heap pointer\n    if (endAddress > this.currentHeapPointer) {\n      this.currentHeapPointer = endAddress\n    }\n  }\n\n  /**\n   * Check if memory is readable\n   */\n  isReadableWithFault(address: u32, size: u32 = u32(1)): FaultCheckResult {\n    const faultAddress = this.checkAccess(address, size, MemoryAccessType.READ)\n    return new FaultCheckResult(faultAddress === 0, faultAddress)\n  }\n\n  /**\n   * Check if memory is writable\n   * Matches ram.ts implementation: finds minimum inaccessible address, returns page start\n   */\n  isWritableWithFault(address: u32, size: u32 = u32(1)): FaultCheckResult {\n    const endRequestedAddress = address + size\n    let minInaccessibleAddress: u32 = 0xFFFFFFFF // Sentinel value for \"not found\"\n\n    // Check each address in the range to find the first one that's not writable\n    for (let addr: u32 = address; addr < endRequestedAddress; addr++) {\n      const pageIndex = this.getPageIndex(addr)\n      const pageAccess = this.getPageAccess(pageIndex)\n      \n      // For WRITE, need WRITE access\n      if (pageAccess !== MemoryAccessType.WRITE) {\n        minInaccessibleAddress = addr\n        break\n      }\n    }\n\n    if (minInaccessibleAddress !== 0xFFFFFFFF) {\n      // Gray Paper: fault address is page start of the minimum inaccessible address\n      const faultAddress = this.getPageIndex(minInaccessibleAddress) * MEMORY_CONFIG.PAGE_SIZE\n      return new FaultCheckResult(false, faultAddress)\n    }\n\n    return new FaultCheckResult(true, 0)\n  }\n\n  /**\n   * Initialize memory layout (no-op for SimpleRAM)\n   */\n  initializeMemoryLayout(\n    argumentData: Uint8Array,\n    readOnlyData: Uint8Array,\n    readWriteData: Uint8Array,\n    stackSize: u32,\n    heapZeroPaddingSize: u32,\n  ): void {\n    // No-op: SimpleRAM doesn't use regions\n    // If needed, we could write the data to appropriate addresses\n    // For now, just update heap pointer\n    if (readWriteData.length > 0) {\n      // Assume heap starts at 2 * 65536 (standard heap start)\n      const heapStart = 2 * 65536\n      this.writeOctets(heapStart, readWriteData)\n    }\n  }\n\n  /**\n   * Set page access rights for an address range\n   */\n  setPageAccessRights(address: u32, length: u32, accessType: MemoryAccessType): void {\n    if (length === 0) {\n      return // Nothing to set\n    }\n    \n    const startPage = this.getPageIndex(address)\n    // Calculate end page: (address + length - 1) / PAGE_SIZE\n    // Use safe calculation to avoid underflow\n    const endAddress = address + length - 1\n    const endPage = this.getPageIndex(endAddress)\n    \n    // Set access rights for all pages in the range\n    for (let pageIndex = startPage; pageIndex <= endPage; pageIndex++) {\n      this.pageAccess.set(pageIndex, accessType)\n    }\n  }\n\n  /**\n   * Initialize a memory page (creates the page if needed and sets access rights)\n   * This is the interface method required by RAM interface\n   */\n  initPage(address: u32, length: u32, accessType: MemoryAccessType): void {\n    if (length === 0) {\n      return // Nothing to initialize\n    }\n    \n    // Ensure memory is allocated for this address range\n    this.ensureMemorySize(address + length)\n    \n    const startPage = this.getPageIndex(address)\n    // Calculate end page: (address + length - 1) / PAGE_SIZE\n    // Use safe calculation to avoid underflow\n    const endAddress = address + length - 1\n    const endPage = this.getPageIndex(endAddress)\n    \n    // Set access rights for all pages in the range\n    for (let pageIndex = startPage; pageIndex <= endPage; pageIndex++) {\n      this.pageAccess.set(pageIndex, accessType)\n    }\n  }\n\n  /**\n   * Write to memory during initialization (bypasses access rights)\n   */\n  writeOctetsDuringInitialization(address: u32, values: Uint8Array): void {\n    // Bypass access rights checking during initialization\n    // This allows writing to read-only pages during setup\n    if (values.length === 0) {\n      return\n    }\n\n    // Ensure memory is allocated (bypasses access check)\n    this.ensureMemorySize(address + values.length)\n    \n    // Write directly to contiguous memory\n    this.memory.set(values, address)\n\n    // Update heap pointer if writing beyond current heap\n    if (address + values.length > this.currentHeapPointer) {\n      this.currentHeapPointer = address + values.length\n    }\n  }\n\n  /**\n   * Get page dump for a specific page index\n   * Returns a copy of the page data (4KB) or zeros if page doesn't exist\n   */\n  getPageDump(pageIndex: u32): Uint8Array {\n    const pageSize = MEMORY_CONFIG.PAGE_SIZE\n    const startAddress = pageIndex * pageSize\n    const endAddress = startAddress + pageSize\n    \n    // Ensure memory is large enough\n    this.ensureMemorySize(endAddress)\n    \n    // Extract page data\n    const pageData = new Uint8Array(pageSize)\n    const sourceView = this.memory.subarray(startAddress, endAddress)\n    pageData.set(sourceView, 0)\n    \n    return pageData\n  }\n\n  /**\n   * Reset RAM to initial state\n   * Clears all memory, page access rights, and resets heap pointer\n   */\n  reset(): void {\n    // Clear memory (reset to empty array)\n    this.memory = new Uint8Array(0)\n    \n    // Clear page access rights\n    this.pageAccess.clear()\n    \n    // Reset heap pointer\n    this.currentHeapPointer = 0\n  }\n}\n\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { idof } from \"./builtins\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\n\nexport abstract class ArrayBufferView {\n\n  readonly buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  readonly byteLength: i32;\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\n  }\n\n  protected constructor(length: i32, alignLog2: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let buffer = changetype<ArrayBuffer>(__new(length = length << alignLog2, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    }\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = length;\n  }\n}\n\n@final export class ArrayBuffer {\n\n  static isView<T>(value: T): bool {\n    if (isNullable<T>()) {\n      if (changetype<usize>(value) == 0) return false;\n    }\n    if (value instanceof Int8Array) return true;\n    if (value instanceof Uint8Array) return true;\n    if (value instanceof Uint8ClampedArray) return true;\n    if (value instanceof Int16Array) return true;\n    if (value instanceof Uint16Array) return true;\n    if (value instanceof Int32Array) return true;\n    if (value instanceof Uint32Array) return true;\n    if (value instanceof Int64Array) return true;\n    if (value instanceof Uint64Array) return true;\n    if (value instanceof Float32Array) return true;\n    if (value instanceof Float64Array) return true;\n    if (value instanceof DataView) return true;\n    return false;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);\n    let buffer = changetype<ArrayBuffer>(__new(<usize>length, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    }\n    return buffer;\n  }\n\n  get byteLength(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n  }\n\n  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {\n    let length = this.byteLength;\n    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);\n    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);\n    let outSize = <usize>max(end - begin, 0);\n    let out = changetype<ArrayBuffer>(__new(outSize, idof<ArrayBuffer>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + <usize>begin, outSize);\n    return out;\n  }\n\n  toString(): string {\n    return \"[object ArrayBuffer]\";\n  }\n}\n","import { COMPARATOR, SORT } from \"./util/sort\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_NOTIMPLEMENTED } from \"./util/error\";\nimport { joinIntegerArray, joinFloatArray } from \"./util/string\";\nimport { REVERSE, FILL } from \"./util/bytes\";\nimport { idof } from \"./builtins\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\nexport class Int8Array extends ArrayBufferView {\n  [key: number]: i8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i8>();\n\n  constructor(length: i32) {\n    super(length, alignof<i8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i8 {\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i8>): void {\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  at(index: i32): i8 {\n    let len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: i8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i8, b: i8) => i32 = COMPARATOR<i8>()): Int8Array {\n    SORT<i8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SLICE<Int8Array, i8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SUBARRAY<Int8Array, i8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int8Array {\n    return COPY_WITHIN<Int8Array, i8>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i8, index: i32, self: Int8Array) => i8): Int8Array {\n    return MAP<Int8Array, i8>(this, fn);\n  }\n\n  filter(fn: (value: i8, index: i32, self: Int8Array) => bool): Int8Array {\n    return FILTER<Int8Array, i8>(this, fn);\n  }\n\n  findIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_INDEX<Int8Array, i8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int8Array, i8>(this, fn);\n  }\n\n  some(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return SOME<Int8Array, i8>(this, fn);\n  }\n\n  every(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return EVERY<Int8Array, i8>(this, fn);\n  }\n\n  forEach(fn: (value: i8, index: i32, self: Int8Array) => void): void {\n    FOREACH<Int8Array, i8>(this, fn);\n  }\n\n  reverse(): Int8Array {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i8>(this.dataStart, this.length, separator);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int8Array {\n    return WRAP<Int8Array, i8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8Array extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  at(index: i32): u8 {\n    let len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8Array {\n    SORT<u8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SLICE<Uint8Array, u8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SUBARRAY<Uint8Array, u8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return COPY_WITHIN<Uint8Array, u8>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8Array) => u8): Uint8Array {\n    return MAP<Uint8Array, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8Array) => bool): Uint8Array {\n    return FILTER<Uint8Array, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_INDEX<Uint8Array, u8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint8Array, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return SOME<Uint8Array, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return EVERY<Uint8Array, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8Array) => void): void {\n    FOREACH<Uint8Array, u8>(this, fn);\n  }\n\n  reverse(): Uint8Array {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8Array {\n    return WRAP<Uint8Array, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8ClampedArray extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  at(index: i32): u8 {\n    let len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    value = ~(value >> 31) & (((255 - value) >> 31) | value);\n    FILL<u8>(this.dataStart, this.length, u8(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8ClampedArray {\n    SORT<u8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SLICE<Uint8ClampedArray, u8>(this, begin, end);\n  }\n\n  subarray(start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SUBARRAY<Uint8ClampedArray, u8>(this, start, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return COPY_WITHIN<Uint8ClampedArray, u8>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8ClampedArray) => u8): Uint8ClampedArray {\n    return MAP<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): Uint8ClampedArray {\n    return FILTER<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_INDEX<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_LAST_INDEX<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return SOME<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return EVERY<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8ClampedArray) => void): void {\n    FOREACH<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  reverse(): Uint8ClampedArray {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8ClampedArray {\n    return WRAP<Uint8ClampedArray, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int16Array extends ArrayBufferView {\n  [key: number]: i16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i16>();\n\n  constructor(length: i32) {\n    super(length, alignof<i16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i16 {\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i16>): void {\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  at(index: i32): i16 {\n    let len = this.byteLength >>> alignof<i16>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  includes(searchElement: i16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    FILL<u16>(this.dataStart, this.length, u16(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i16, b: i16) => i32 = COMPARATOR<i16>()): Int16Array {\n    SORT<i16>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SLICE<Int16Array, i16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SUBARRAY<Int16Array, i16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int16Array {\n    return COPY_WITHIN<Int16Array, i16>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i16, index: i32, self: Int16Array) => i16): Int16Array {\n    return MAP<Int16Array, i16>(this, fn);\n  }\n\n  filter(fn: (value: i16, index: i32, self: Int16Array) => bool): Int16Array {\n    return FILTER<Int16Array, i16>(this, fn);\n  }\n\n  findIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_INDEX<Int16Array, i16>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int16Array, i16>(this, fn);\n  }\n\n  some(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return SOME<Int16Array, i16>(this, fn);\n  }\n\n  every(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return EVERY<Int16Array, i16>(this, fn);\n  }\n\n  forEach(fn: (value: i16, index: i32, self: Int16Array) => void): void {\n    FOREACH<Int16Array, i16>(this, fn);\n  }\n\n  reverse(): Int16Array {\n    REVERSE<u16>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i16>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int16Array {\n    return WRAP<Int16Array, i16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint16Array extends ArrayBufferView {\n  [key: number]: u16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u16>();\n\n  constructor(length: i32) {\n    super(length, alignof<u16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u16 {\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u16>): void {\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  at(index: i32): u16 {\n    let len = this.byteLength >>> alignof<u16>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  includes(searchElement: u16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    FILL<u16>(this.dataStart, this.length, u16(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u16, b: u16) => i32 = COMPARATOR<u16>()): Uint16Array {\n    SORT<u16>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SLICE<Uint16Array, u16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SUBARRAY<Uint16Array, u16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return COPY_WITHIN<Uint16Array, u16>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u16, index: i32, self: Uint16Array) => u16): Uint16Array {\n    return MAP<Uint16Array, u16>(this, fn);\n  }\n\n  filter(fn: (value: u16, index: i32, self: Uint16Array) => bool): Uint16Array {\n    return FILTER<Uint16Array, u16>(this, fn);\n  }\n\n  findIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_INDEX<Uint16Array, u16>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint16Array, u16>(this, fn);\n  }\n\n  some(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return SOME<Uint16Array, u16>(this, fn);\n  }\n\n  every(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return EVERY<Uint16Array, u16>(this, fn);\n  }\n\n  forEach(fn: (value: u16, index: i32, self: Uint16Array) => void): void {\n    FOREACH<Uint16Array, u16>(this, fn);\n  }\n\n  reverse(): Uint16Array {\n    REVERSE<u16>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u16>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint16Array {\n    return WRAP<Uint16Array, u16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int32Array extends ArrayBufferView {\n  [key: number]: i32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i32>();\n\n  constructor(length: i32) {\n    super(length, alignof<i32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i32 {\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i32): void {\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  at(index: i32): i32 {\n    let len = this.byteLength >>> alignof<i32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  includes(searchElement: i32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    FILL<u32>(this.dataStart, this.length, u32(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i32, b: i32) => i32 = COMPARATOR<i32>()): Int32Array {\n    SORT<i32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SLICE<Int32Array, i32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SUBARRAY<Int32Array, i32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int32Array {\n    return COPY_WITHIN<Int32Array, i32>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i32, index: i32, self: Int32Array) => i32): Int32Array {\n    return MAP<Int32Array, i32>(this, fn);\n  }\n\n  filter(fn: (value: i32, index: i32, self: Int32Array) => bool): Int32Array {\n    return FILTER<Int32Array, i32>(this, fn);\n  }\n\n  findIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_INDEX<Int32Array, i32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int32Array, i32>(this, fn);\n  }\n\n  some(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return SOME<Int32Array, i32>(this, fn);\n  }\n\n  every(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return EVERY<Int32Array, i32>(this, fn);\n  }\n\n  forEach(fn: (value: i32, index: i32, self: Int32Array) => void): void {\n    FOREACH<Int32Array, i32>(this, fn);\n  }\n\n  reverse(): Int32Array {\n    REVERSE<u32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int32Array {\n    return WRAP<Int32Array, i32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint32Array extends ArrayBufferView {\n  [key: number]: u32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u32>();\n\n  constructor(length: i32) {\n    super(length, alignof<u32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u32 {\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u32): void {\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  at(index: i32): u32 {\n    let len = this.byteLength >>> alignof<u32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  includes(searchElement: u32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    FILL<u32>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u32, b: u32) => i32 = COMPARATOR<u32>()): Uint32Array {\n    SORT<u32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SLICE<Uint32Array, u32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SUBARRAY<Uint32Array, u32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return COPY_WITHIN<Uint32Array, u32>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u32, index: i32, self: Uint32Array) => u32): Uint32Array {\n    return MAP<Uint32Array, u32>(this, fn);\n  }\n\n  filter(fn: (value: u32, index: i32, self: Uint32Array) => bool): Uint32Array {\n    return FILTER<Uint32Array, u32>(this, fn);\n  }\n\n  findIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_INDEX<Uint32Array, u32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint32Array, u32>(this, fn);\n  }\n\n  some(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return SOME<Uint32Array, u32>(this, fn);\n  }\n\n  every(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return EVERY<Uint32Array, u32>(this, fn);\n  }\n\n  forEach(fn: (value: u32, index: i32, self: Uint32Array) => void): void {\n    FOREACH<Uint32Array, u32>(this, fn);\n  }\n\n  reverse(): Uint32Array {\n    REVERSE<u32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint32Array {\n    return WRAP<Uint32Array, u32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int64Array extends ArrayBufferView {\n  [key: number]: i64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i64>();\n\n  constructor(length: i32) {\n    super(length, alignof<i64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i64 {\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i64): void {\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  at(index: i32): i64 {\n    let len = this.byteLength >>> alignof<i64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  includes(searchElement: i64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    FILL<u64>(this.dataStart, this.length, u64(value), start, end);\n    return this;\n  }\n\n  sort(comparator: (a: i64, b: i64) => i32 = COMPARATOR<i64>()): Int64Array {\n    SORT<i64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SLICE<Int64Array, i64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SUBARRAY<Int64Array, i64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int64Array {\n    return COPY_WITHIN<Int64Array, i64>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i64, index: i32, self: Int64Array) => i64): Int64Array {\n    return MAP<Int64Array, i64>(this, fn);\n  }\n\n  filter(fn: (value: i64, index: i32, self: Int64Array) => bool): Int64Array {\n    return FILTER<Int64Array, i64>(this, fn);\n  }\n\n  findIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_INDEX<Int64Array, i64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int64Array, i64>(this, fn);\n  }\n\n  some(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return SOME<Int64Array, i64>(this, fn);\n  }\n\n  every(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return EVERY<Int64Array, i64>(this, fn);\n  }\n\n  forEach(fn: (value: i64, index: i32, self: Int64Array) => void): void {\n    FOREACH<Int64Array, i64>(this, fn);\n  }\n\n  reverse(): Int64Array {\n    REVERSE<u64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int64Array {\n    return WRAP<Int64Array, i64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint64Array extends ArrayBufferView {\n  [key: number]: u64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u64>();\n\n  constructor(length: i32) {\n    super(length, alignof<u64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u64 {\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u64): void {\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  at(index: i32): u64 {\n    let len = this.byteLength >>> alignof<u64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  includes(searchElement: u64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    FILL<u64>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: u64, b: u64) => i32 = COMPARATOR<u64>()): Uint64Array {\n    SORT<u64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SLICE<Uint64Array, u64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SUBARRAY<Uint64Array, u64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return COPY_WITHIN<Uint64Array, u64>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u64, index: i32, self: Uint64Array) => u64): Uint64Array {\n    return MAP<Uint64Array, u64>(this, fn);\n  }\n\n  filter(fn: (value: u64, index: i32, self: Uint64Array) => bool): Uint64Array {\n    return FILTER<Uint64Array, u64>(this, fn);\n  }\n\n  findIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_INDEX<Uint64Array, u64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint64Array, u64>(this, fn);\n  }\n\n  some(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return SOME<Uint64Array, u64>(this, fn);\n  }\n\n  every(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return EVERY<Uint64Array, u64>(this, fn);\n  }\n\n  forEach(fn: (value: u64, index: i32, self: Uint64Array) => void): void {\n    FOREACH<Uint64Array, u64>(this, fn);\n  }\n\n  reverse(): Uint64Array {\n    REVERSE<u64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint64Array {\n    return WRAP<Uint64Array, u64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float32Array extends ArrayBufferView {\n  [key: number]: f32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f32>();\n\n  constructor(length: i32) {\n    super(length, alignof<f32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f32 {\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f32): void {\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  at(index: i32): f32 {\n    let len = this.byteLength >>> alignof<f32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  includes(searchElement: f32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    FILL<f32>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: f32, b: f32) => i32 = COMPARATOR<f32>()): Float32Array {\n    SORT<f32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SLICE<Float32Array, f32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SUBARRAY<Float32Array, f32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float32Array {\n    return COPY_WITHIN<Float32Array, f32>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f32, index: i32, self: Float32Array) => f32): Float32Array {\n    return MAP<Float32Array, f32>(this, fn);\n  }\n\n  filter(fn: (value: f32, index: i32, self: Float32Array) => bool): Float32Array {\n    return FILTER<Float32Array, f32>(this, fn);\n  }\n\n  findIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_INDEX<Float32Array, f32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Float32Array, f32>(this, fn);\n  }\n\n  some(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return SOME<Float32Array, f32>(this, fn);\n  }\n\n  every(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return EVERY<Float32Array, f32>(this, fn);\n  }\n\n  forEach(fn: (value: f32, index: i32, self: Float32Array) => void): void {\n    FOREACH<Float32Array, f32>(this, fn);\n  }\n\n  reverse(): Float32Array {\n    REVERSE<f32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinFloatArray<f32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float32Array {\n    return WRAP<Float32Array, f32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float64Array extends ArrayBufferView {\n  [key: number]: f64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f64>();\n\n  constructor(length: i32) {\n    super(length, alignof<f64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f64 {\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f64): void {\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  at(index: i32): f64 {\n    let len = this.byteLength >>> alignof<f64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  includes(searchElement: f64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    FILL<f64>(this.dataStart, this.length, value, start, end);\n    return this;\n  }\n\n  sort(comparator: (a: f64, b: f64) => i32 = COMPARATOR<f64>()): Float64Array {\n    SORT<f64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SLICE<Float64Array, f64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SUBARRAY<Float64Array, f64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float64Array {\n    return COPY_WITHIN<Float64Array, f64>(this, target, start, end);\n  }\n\n  reduce<T extends number>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T extends number>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f64, index: i32, self: Float64Array) => f64): Float64Array {\n    return MAP<Float64Array, f64>(this, fn);\n  }\n\n  filter(fn: (value: f64, index: i32, self: Float64Array) => bool): Float64Array {\n    return FILTER<Float64Array, f64>(this, fn);\n  }\n\n  findIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_INDEX<Float64Array, f64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Float64Array, f64>(this, fn);\n  }\n\n  some(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return SOME<Float64Array, f64>(this, fn);\n  }\n\n  every(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return EVERY<Float64Array, f64>(this, fn);\n  }\n\n  forEach(fn: (value: f64, index: i32, self: Float64Array) => void): void {\n    FOREACH<Float64Array, f64>(this, fn);\n  }\n\n  reverse(): Float64Array {\n    REVERSE<f64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinFloatArray<f64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayLike<number>>(source: U, offset: i32 = 0): void {\n    SET(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float64Array {\n    return WRAP<Float64Array, f64>(buffer, byteOffset, length);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SLICE<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  start: i32,\n  end: i32\n): TArray {\n  let len = array.length;\n  start  = start < 0 ? max(start + len, 0) : min(start, len);\n  end    = end   < 0 ? max(end   + len, 0) : min(end  , len);\n  len = max(end - start, 0);\n  let slice = instantiate<TArray>(len);\n  memory.copy(\n    slice.dataStart,\n    array.dataStart + (<usize>start << alignof<T>()),\n    <usize>len << alignof<T>()\n  );\n  return slice;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SUBARRAY<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  begin: i32,\n  end: i32\n): TArray {\n  let len = array.length;\n  begin = begin < 0 ? max(len + begin, 0) : min(begin, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  end   = max(end, begin);\n\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  let buf = changetype<usize>(array.buffer);\n  store<usize>(changetype<usize>(out), buf, offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), buf, false);\n  store<usize>(changetype<usize>(out), array.dataStart + (<usize>begin << alignof<T>()), offsetof<TArray>(\"dataStart\"));\n  store<u32>(changetype<usize>(out), (end - begin) << alignof<T>(), offsetof<TArray>(\"byteLength\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction COPY_WITHIN<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  target: i32,\n  start: i32,\n  end: i32\n): TArray {\n  let len = array.length;\n  let ptr = array.dataStart;\n\n  end   = min<i32>(end, len);\n  let to    = target < 0 ? max(len + target, 0) : min(target, len);\n  let from  = start < 0 ? max(len + start, 0) : min(start, len);\n  let last  = end < 0 ? max(len + end, 0) : min(end, len);\n  let count = min(last - from, len - to);\n\n  memory.copy(\n    ptr + (<usize>to << alignof<T>()),\n    ptr + (<usize>from << alignof<T>()),\n    <usize>count << alignof<T>()\n  );\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE<TArray extends ArrayBufferView, T extends number, TRet extends number>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE_RIGHT<TArray extends ArrayBufferView, T extends number, TRet extends number>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  let ptr = array.dataStart;\n  for (let i = array.length - 1; i >= 0; i--) {\n    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction MAP<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => T,\n): TArray {\n  let len = array.length;\n  let ptr = array.dataStart;\n\n  let byteLength = len << alignof<T>();\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  let buf = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\n  for (let i = 0; i < len; i++) {\n    store<T>(\n      changetype<usize>(buf) + (<usize>i << alignof<T>()),\n      fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)\n    );\n  }\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), changetype<usize>(buf), false);\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\"dataStart\"));\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FILTER<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => bool,\n): TArray {\n  let len = array.length;\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  let buf = changetype<ArrayBuffer>(__new(len << alignof<T>(), idof<ArrayBuffer>()));\n  let dataStart  = array.dataStart;\n  let j: usize = 0;\n  for (let i = 0; i < len; i++) {\n    let value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    if (fn(value, i, array)) {\n      store<T>(\n        changetype<usize>(buf) + (j++ << alignof<T>()),\n        value\n      );\n    }\n  }\n  // shrink output buffer\n  let byteLength = j << alignof<T>();\n  let data = __renew(changetype<usize>(buf), byteLength);\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), data, false);\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\"dataStart\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FIND_INDEX<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FIND_LAST_INDEX<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  let ptr = array.dataStart;\n  for (let i = array.length - 1; i >= 0; --i) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INCLUDES<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): bool {\n  if (isFloat<T>()) {\n    let index: isize = fromIndex;\n    let len: isize = array.length;\n    if (len == 0 || index >= len) return false;\n    if (index < 0) index = max(len + index, 0);\n    let dataStart = array.dataStart;\n    while (index < len) {\n      let elem = load<T>(dataStart + (index << alignof<T>()));\n      // @ts-ignore\n      if (elem == searchElement || isNaN(elem) & isNaN(searchElement)) return true;\n      ++index;\n    }\n    return false;\n  } else {\n    return INDEX_OF<TArray, T>(array, searchElement, fromIndex) >= 0;\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INDEX_OF<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  let index: isize = fromIndex;\n  let len: isize = array.length;\n  if (len == 0 || index >= len) return -1;\n  if (index < 0) index = max(len + index, 0);\n  let dataStart = array.dataStart;\n  while (index < len) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    ++index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction LAST_INDEX_OF<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  let index: isize = fromIndex;\n  let len: isize = array.length;\n  if (len == 0) return -1;\n  if (index < 0) index = len + index; // no need to clamp\n  else if (index >= len) index = len - 1;\n  let dataStart = array.dataStart;\n  while (index >= 0) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    --index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SOME<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return true;\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction EVERY<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) continue;\n    return false;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FOREACH<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => void,\n): void {\n  let ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction WRAP<TArray extends ArrayBufferView, T>(\n  buffer: ArrayBuffer,\n  byteOffset: i32 = 0,\n  len: i32 = -1\n): TArray {\n  let byteLength: i32;\n  let bufferByteLength = buffer.byteLength;\n  const mask: u32 = sizeof<T>() - 1;\n  if (i32(<u32>byteOffset > <u32>bufferByteLength) | (byteOffset & mask)) {\n    throw new RangeError(E_INDEXOUTOFRANGE);\n  }\n  if (len < 0) {\n    if (len == -1) {\n      if (bufferByteLength & mask) {\n        throw new RangeError(E_INVALIDLENGTH);\n      }\n      byteLength = bufferByteLength - byteOffset;\n    } else {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  } else {\n    byteLength = len << alignof<T>();\n    if (byteOffset + byteLength > bufferByteLength) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  }\n  let out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer), offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), changetype<usize>(buffer), false);\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer) + <usize>byteOffset, offsetof<TArray>(\"dataStart\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SET<\n  TArray extends ArrayLike<number>,\n  UArray extends ArrayLike<number>\n>(\n  target: TArray,\n  source: UArray,\n  offset: i32 = 0\n): void {\n  // need to assert at compile time that U is not a reference or a function\n  if (isReference<valueof<UArray>>()) {\n    ERROR(E_NOTIMPLEMENTED);\n  }\n  let sourceLen = source.length;\n  if (offset < 0 || sourceLen + offset > target.length) {\n    // offset is out of bounds\n    throw new RangeError(E_INDEXOUTOFRANGE);\n  }\n  // @ts-ignore: dataStart\n  let targetStart = target.dataStart + (<usize>offset << (alignof<valueof<TArray>>()));\n  // @ts-ignore: dataStart\n  let sourceStart = source.dataStart;\n  // if the types align and match, use memory.copy() instead of manual loop\n  if (\n    isInteger<valueof<TArray>>() == isInteger<valueof<UArray>>() &&\n    alignof<valueof<TArray>>() == alignof<valueof<UArray>>() &&\n    !(isSigned<valueof<UArray>>() && target instanceof Uint8ClampedArray)\n  ) {\n    memory.copy(targetStart, sourceStart, <usize>sourceLen << (alignof<valueof<UArray>>()));\n  } else {\n    for (let i = 0; i < sourceLen; i++) {\n      let ptr = targetStart + (<usize>i << (alignof<valueof<TArray>>()));\n      let value = load<valueof<UArray>>(sourceStart + (<usize>i << (alignof<valueof<UArray>>())));\n      // if TArray is Uint8ClampedArray, then values must be clamped\n      if (target instanceof Uint8ClampedArray) {\n        if (isFloat<valueof<UArray>>()) {\n          store<valueof<TArray>>(ptr,\n            isFinite<valueof<UArray>>(value)\n              ? <valueof<TArray>>max<valueof<UArray>>(0, min<valueof<UArray>>(255, value))\n              : 0\n          );\n        } else {\n          if (!isSigned<valueof<UArray>>()) {\n            store<valueof<TArray>>(ptr, min<valueof<UArray>>(255, value));\n          } else if (sizeof<valueof<TArray>>() <= 4) {\n            store<valueof<TArray>>(ptr, ~(<i32>value >> 31) & (((255 - <i32>value) >> 31) | value));\n          } else {\n            store<valueof<TArray>>(ptr, ~(<i64>value >> 63) & (((255 - <i64>value) >> 63) | value));\n          }\n        }\n      } else {\n        if (isFloat<valueof<UArray>>() && !isFloat<valueof<TArray>>()) {\n          store<valueof<TArray>>(ptr, isFinite<valueof<UArray>>(value) ? <valueof<TArray>>value : 0);\n        } else {\n          store<valueof<TArray>>(ptr, <valueof<TArray>>value);\n        }\n      }\n    }\n  }\n}\n","export function HASH<T>(key: T): u32 {\n  if (isString<T>()) {\n    return hashStr(changetype<string>(key));\n  } else if (isReference<T>()) {\n    if (sizeof<T>() == 4) return hash32(changetype<u32>(key));\n    if (sizeof<T>() == 8) return hash64(changetype<u64>(key));\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) return hash32(reinterpret<u32>(f32(key)));\n    if (sizeof<T>() == 8) return hash64(reinterpret<u64>(f64(key)));\n  } else {\n    if (sizeof<T>() <= 4) return hash32(u32(key), sizeof<T>());\n    if (sizeof<T>() == 8) return hash64(u64(key));\n  }\n  return unreachable();\n}\n\n// XXHash 32-bit as a starting point, see: https://cyan4973.github.io/xxHash\n\n// primes\n// @ts-ignore: decorator\n@inline const XXH32_P1: u32 = 2654435761;\n// @ts-ignore: decorator\n@inline const XXH32_P2: u32 = 2246822519;\n// @ts-ignore: decorator\n@inline const XXH32_P3: u32 = 3266489917;\n// @ts-ignore: decorator\n@inline const XXH32_P4: u32 = 668265263;\n// @ts-ignore: decorator\n@inline const XXH32_P5: u32 = 374761393;\n// @ts-ignore: decorator\n@inline const XXH32_SEED: u32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction hash32(key: u32, len: u32 = 4): u32 {\n  let h: u32 = XXH32_SEED + XXH32_P5 + len;\n  h += key * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction hash64(key: u64): u32 {\n  let h: u32 = XXH32_SEED + XXH32_P5 + 8;\n  h += <u32>key * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h += <u32>(key >> 32) * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction mix(h: u32, key: u32): u32 {\n  return rotl(h + key * XXH32_P2, 13) * XXH32_P1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction hashStr(key: string): u32 {\n  if (changetype<usize>(key) == 0) return XXH32_SEED;\n\n  let h: u32 = key.length << 1;\n  let len: usize = h;\n  let pos = changetype<usize>(key);\n\n  if (len >= 16) {\n    let s1 = XXH32_SEED + XXH32_P1 + XXH32_P2;\n    let s2 = XXH32_SEED + XXH32_P2;\n    let s3 = XXH32_SEED;\n    let s4 = XXH32_SEED - XXH32_P1;\n\n    let end = len + pos - 16;\n    while (pos <= end) {\n      s1 = mix(s1, load<u32>(pos    ));\n      s2 = mix(s2, load<u32>(pos,  4));\n      s3 = mix(s3, load<u32>(pos,  8));\n      s4 = mix(s4, load<u32>(pos, 12));\n      pos += 16;\n    }\n    h += rotl(s1, 1) + rotl(s2, 7) + rotl(s3, 12) + rotl(s4, 18);\n  } else {\n    h += XXH32_SEED + XXH32_P5;\n  }\n\n  let end = changetype<usize>(key) + len - 4;\n  while (pos <= end) {\n    h += load<u32>(pos) * XXH32_P3;\n    h = rotl(h, 17) * XXH32_P4;\n    pos += 4;\n  }\n\n  end = changetype<usize>(key) + len;\n  while (pos < end) {\n    h += <u32>load<u8>(pos) * XXH32_P5;\n    h = rotl(h, 11) * XXH32_P1;\n    pos++;\n  }\n\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { HASH } from \"./util/hash\";\nimport { E_KEYNOTFOUND } from \"./util/error\";\n\n// A deterministic hash map based on CloseTable from https://github.com/jorendorff/dht\n\n// @ts-ignore: decorator\n@inline const INITIAL_CAPACITY = 4;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_N = 8;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_D = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_N = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_D = 4;\n\n/** Structure of a map entry. */\n@unmanaged class MapEntry<K,V> {\n  key: K;\n  value: V;\n  taggedNext: usize; // LSB=1 indicates EMPTY\n}\n\n/** Empty bit. */\n// @ts-ignore: decorator\n@inline const EMPTY: usize = 1 << 0;\n\n/** Size of a bucket. */\n// @ts-ignore: decorator\n@inline const BUCKET_SIZE = sizeof<usize>();\n\n/** Computes the alignment of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_ALIGN<K,V>(): usize {\n  // can align to 4 instead of 8 if 32-bit and K/V is <= 32-bits\n  const maxkv = sizeof<K>() > sizeof<V>() ? sizeof<K>() : sizeof<V>();\n  const align = (maxkv > sizeof<usize>() ? maxkv : sizeof<usize>()) - 1;\n  return align;\n}\n\n/** Computes the aligned size of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_SIZE<K,V>(): usize {\n  const align = ENTRY_ALIGN<K,V>();\n  const size = (offsetof<MapEntry<K,V>>() + align) & ~align;\n  return size;\n}\n\nexport class Map<K,V> {\n\n  // buckets referencing their respective first entry, usize[bucketsMask + 1]\n  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n  private bucketsMask: u32 = INITIAL_CAPACITY - 1;\n\n  // entries in insertion order, MapEntry<K,V>[entriesCapacity]\n  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n  private entriesCapacity: i32 = INITIAL_CAPACITY;\n  private entriesOffset: i32 = 0;\n  private entriesCount: i32 = 0;\n\n  constructor() {\n    /* nop */\n  }\n\n  get size(): i32 {\n    return this.entriesCount;\n  }\n\n  clear(): void {\n    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n    this.bucketsMask = INITIAL_CAPACITY - 1;\n    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n    this.entriesCapacity = INITIAL_CAPACITY;\n    this.entriesOffset = 0;\n    this.entriesCount = 0;\n  }\n\n  private find(key: K, hashCode: u32): MapEntry<K,V> | null {\n    let entry = load<MapEntry<K,V>>( // unmanaged!\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE\n    );\n    while (entry) {\n      let taggedNext = entry.taggedNext;\n      if (!(taggedNext & EMPTY) && entry.key == key) return entry;\n      entry = changetype<MapEntry<K,V>>(taggedNext & ~EMPTY);\n    }\n    return null;\n  }\n\n  has(key: K): bool {\n    return this.find(key, HASH<K>(key)) != null;\n  }\n\n  @operator(\"[]\")\n  get(key: K): V {\n    let entry = this.find(key, HASH<K>(key));\n    if (!entry) throw new Error(E_KEYNOTFOUND); // cannot represent `undefined`\n    return entry.value;\n  }\n\n  @operator(\"[]=\")\n  set(key: K, value: V): this {\n    let hashCode = HASH<K>(key);\n    let entry = this.find(key, hashCode); // unmanaged!\n    if (entry) {\n      entry.value = value;\n      if (isManaged<V>()) {\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n    } else {\n      // check if rehashing is necessary\n      if (this.entriesOffset == this.entriesCapacity) {\n        this.rehash(\n          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\n        );\n      }\n      // append new entry\n      let entries = this.entries;\n      entry = changetype<MapEntry<K,V>>(changetype<usize>(entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<K,V>());\n      // link with the map\n      entry.key = key;\n      if (isManaged<K>()) {\n        __link(changetype<usize>(this), changetype<usize>(key), true);\n      }\n      entry.value = value;\n      if (isManaged<V>()) {\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n      ++this.entriesCount;\n      // link with previous entry in bucket\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\n      entry.taggedNext = load<usize>(bucketPtrBase);\n      store<usize>(bucketPtrBase, changetype<usize>(entry));\n    }\n    return this;\n  }\n\n  delete(key: K): bool {\n    let entry = this.find(key, HASH<K>(key));\n    if (!entry) return false;\n    entry.taggedNext |= EMPTY;\n    --this.entriesCount;\n    // check if rehashing is appropriate\n    let halfBucketsMask = this.bucketsMask >> 1;\n    if (\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\n      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n    ) this.rehash(halfBucketsMask);\n    return true;\n  }\n\n  private rehash(newBucketsMask: u32): void {\n    let newBucketsCapacity = <i32>(newBucketsMask + 1);\n    let newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\n    let newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;\n    let newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K,V>());\n\n    // copy old entries to new entries\n    let oldPtr = changetype<usize>(this.entries);\n    let oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n    let newPtr = changetype<usize>(newEntries);\n    while (oldPtr != oldEnd) {\n      let oldEntry = changetype<MapEntry<K,V>>(oldPtr);\n      if (!(oldEntry.taggedNext & EMPTY)) {\n        let newEntry = changetype<MapEntry<K,V>>(newPtr);\n        let oldEntryKey = oldEntry.key;\n        newEntry.key = oldEntryKey;\n        newEntry.value = oldEntry.value;\n        let newBucketIndex = HASH<K>(oldEntryKey) & newBucketsMask;\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\n        newEntry.taggedNext = load<usize>(newBucketPtrBase);\n        store<usize>(newBucketPtrBase, newPtr);\n        newPtr += ENTRY_SIZE<K,V>();\n      }\n      oldPtr += ENTRY_SIZE<K,V>();\n    }\n\n    this.buckets = newBuckets;\n    this.bucketsMask = newBucketsMask;\n    this.entries = newEntries;\n    this.entriesCapacity = newEntriesCapacity;\n    this.entriesOffset = this.entriesCount;\n  }\n\n  keys(): K[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    let start = changetype<usize>(this.entries);\n    let size = this.entriesOffset;\n    let keys = new Array<K>(size);\n    let length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        unchecked(keys[length++] = entry.key);\n      }\n    }\n    keys.length = length;\n    return keys;\n  }\n\n  values(): V[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    let start = changetype<usize>(this.entries);\n    let size = this.entriesOffset;\n    let values = new Array<V>(size);\n    let length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        unchecked(values[length++] = entry.value);\n      }\n    }\n    values.length = length;\n    return values;\n  }\n\n  toString(): string {\n    return \"[object Map]\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    __visit(changetype<usize>(this.buckets), cookie);\n    let entries = changetype<usize>(this.entries);\n    if (isManaged<K>() || isManaged<V>()) {\n      let cur = entries;\n      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n      while (cur < end) {\n        let entry = changetype<MapEntry<K,V>>(cur);\n        if (!(entry.taggedNext & EMPTY)) {\n          if (isManaged<K>()) {\n            let val = changetype<usize>(entry.key);\n            if (isNullable<K>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n          if (isManaged<V>()) {\n            let val = changetype<usize>(entry.value);\n            if (isNullable<V>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n        }\n        cur += ENTRY_SIZE<K,V>();\n      }\n    }\n    __visit(entries, cookie);\n  }\n}\n","/**\n * Mock RAM implementation for testing\n * \n * A no-op implementation that satisfies the RAM interface but does nothing.\n * Useful for testing when you don't need actual memory functionality,\n * or to isolate issues that might be in RAM implementation code.\n */\n\nimport { FaultCheckResult, ReadResult, RAM, MemoryAccessType, WriteResult } from './types'\nimport { MEMORY_CONFIG } from './config'\n\nexport class MockRAM implements RAM {\n  currentHeapPointer: u32 = 0\n\n  // JIP-6 trace support: Track last load/store (no-op, always 0)\n  lastLoadAddress: u32 = 0\n  lastLoadValue: u64 = 0\n  lastStoreAddress: u32 = 0\n  lastStoreValue: u64 = 0\n\n  /**\n   * Clear last load/store tracking (no-op)\n   */\n  clearLastMemoryOp(): void {\n    this.lastLoadAddress = 0\n    this.lastLoadValue = 0\n    this.lastStoreAddress = 0\n    this.lastStoreValue = 0\n  }\n\n  /**\n   * Read multiple octets from memory (no-op)\n   * Returns zero-filled data with no faults\n   */\n  readOctets(address: u32, count: u32): ReadResult {\n    // Return zero-filled data, no fault\n    return new ReadResult(new Uint8Array(count), 0)\n  }\n\n  /**\n   * Write multiple octets to memory (no-op)\n   * Always succeeds\n   */\n  writeOctets(address: u32, values: Uint8Array): WriteResult {\n    // Always succeed (no fault)\n    return new WriteResult(false, 0)\n  }\n\n  /**\n   * Allocate pages (no-op)\n   */\n  allocatePages(startPage: u32, count: u32): void {\n    // Do nothing\n  }\n\n  /**\n   * Check if memory is readable (no-op)\n   * Always returns readable\n   */\n  isReadableWithFault(address: u32, size: u32 = u32(1)): FaultCheckResult {\n    // Always readable (no fault)\n    return new FaultCheckResult(true, 0)\n  }\n\n  /**\n   * Check if memory is writable (no-op)\n   * Always returns writable\n   */\n  isWritableWithFault(address: u32, size: u32 = u32(1)): FaultCheckResult {\n    // Always writable (no fault)\n    return new FaultCheckResult(true, 0)\n  }\n\n  /**\n   * Initialize memory layout (no-op)\n   */\n  initializeMemoryLayout(\n    argumentData: Uint8Array,\n    readOnlyData: Uint8Array,\n    readWriteData: Uint8Array,\n    stackSize: u32,\n    heapZeroPaddingSize: u32,\n  ): void {\n    // Do nothing\n  }\n\n  /**\n   * Set page access rights (no-op)\n   */\n  setPageAccessRights(address: u32, length: u32, accessType: MemoryAccessType): void {\n    // Do nothing\n  }\n\n  /**\n   * Initialize a memory page (no-op)\n   */\n  initPage(address: u32, length: u32, accessType: MemoryAccessType): void {\n    // Do nothing\n  }\n\n  /**\n   * Write to memory during initialization (no-op)\n   */\n  writeOctetsDuringInitialization(address: u32, values: Uint8Array): void {\n    // Do nothing\n  }\n\n  /**\n   * Get page dump for a specific page index (no-op)\n   * Returns zeros for mock implementation\n   */\n  getPageDump(pageIndex: u32): Uint8Array {\n    // Return zeros (mock implementation)\n    return new Uint8Array(MEMORY_CONFIG.PAGE_SIZE)\n  }\n\n  /**\n   * Reset RAM to initial state\n   * Resets heap pointer (no-op for mock)\n   */\n  reset(): void {\n    // Reset heap pointer\n    this.currentHeapPointer = 0\n  }\n}\n\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { REVERSE, FILL } from \"./util/bytes\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_HOLEYARRAY } from \"./util/error\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\n\n@final\nexport class StaticArray<T> {\n  [key: number]: T;\n\n  // Note that the interface of StaticArray instances must be a semantically\n  // compatible subset of Array<T> in order for syntax highlighting to work\n  // properly, for instance when creating static arrays from array literals.\n  // The additionally provided static methods take care of dealing with static\n  // arrays exclusively, without having to convert to Array<T> first.\n\n  static fromArray<T>(source: Array<T>): StaticArray<T> {\n    let length = source.length;\n    let outSize = <usize>length << alignof<T>();\n    let out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    if (isManaged<T>()) {\n      let sourcePtr = source.dataStart;\n      for (let i = 0; i < length; ++i) {\n        let off = <usize>i << alignof<T>();\n        let ref = load<usize>(sourcePtr + off);\n        store<usize>(changetype<usize>(out) + off, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(changetype<usize>(out), source.dataStart, outSize);\n    }\n    return out;\n  }\n\n  /** @deprecated Please use source.concat<StaticArray<T>> instead. */\n  static concat<T>(source: StaticArray<T>, other: StaticArray<T>): StaticArray<T> {\n    return source.concat<StaticArray<T>>(other);\n  }\n\n  /** @deprecated Please use source.slice<StaticArray<T>> instead. */\n  static slice<T>(source: StaticArray<T>, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    return source.slice<StaticArray<T>>(start, end);\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    let outSize = <usize>length << alignof<T>();\n    let out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(out), 0, outSize);\n    }\n    return out;\n  }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >>> alignof<T>();\n  }\n\n  at(index: i32): T {\n    let len = this.length;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    this.__uset(index, value);\n  }\n\n  @unsafe @operator(\"{}=\") private __uset(index: i32, value: T): void {\n    store<T>(changetype<usize>(this) + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    if (isManaged<T>()) {\n      FILL<usize>(changetype<usize>(this), this.length, changetype<usize>(value), start, end);\n      __link(changetype<usize>(this), changetype<usize>(value), false);\n    } else {\n      FILL<T>(changetype<usize>(this), this.length, value, start, end);\n    }\n    return this;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    let ptr = changetype<usize>(this);\n    let len = this.length;\n\n    end = min<i32>(end, len);\n\n    let to    = target < 0 ? max(len + target, 0) : min(target, len);\n    let from  = start < 0 ? max(len + start, 0) : min(start, len);\n    let last  = end < 0 ? max(len + end, 0) : min(end, len);\n    let count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      ptr + (<usize>to << alignof<T>()),\n      ptr + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let length = this.length;\n      if (length == 0 || fromIndex >= length) return false;\n      if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n      while (fromIndex < length) {\n        let elem = load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    let length = this.length;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    while (fromIndex < length) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length): i32 {\n    let length = this.length;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex;\n    else if (fromIndex >= length) fromIndex = length - 1;\n    while (fromIndex >= 0) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  concat<U extends ArrayLike<T> = Array<T>>(other: U): U {\n    let sourceLen = this.length;\n    let otherLen = other.length;\n    let outLen = sourceLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) {\n      throw new Error(E_INVALIDLENGTH);\n    }\n    let sourceSize = <usize>sourceLen << alignof<T>();\n    let out = changetype<U>(this); // FIXME: instanceof needs *some* value\n\n    if (out instanceof Array<T>) {\n      out = changetype<U>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n      // ^ FIXME: Function returns type U, but can't __newArray(U extends Array<T>)\n      let outStart = changetype<Array<T>>(out).dataStart;\n      let otherStart = changetype<Array<T>>(other).dataStart;\n      let thisStart = changetype<usize>(this);\n\n      if (isManaged<T>()) {\n        for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\n          let ref = load<usize>(thisStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n        outStart += sourceSize;\n        let otherSize = <usize>otherLen << alignof<T>();\n        for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n          let ref = load<usize>(otherStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n      } else {\n        memory.copy(outStart, thisStart, sourceSize);\n        memory.copy(outStart + sourceSize, otherStart, <usize>otherLen << alignof<T>());\n      }\n    } else if (out instanceof StaticArray<T>) {\n      out = changetype<U>(__new(<usize>outLen << alignof<T>(), idof<StaticArray<T>>()));\n      let outStart = changetype<usize>(out);\n      let otherStart = changetype<usize>(other);\n      let thisStart = changetype<usize>(this);\n\n      if (isManaged<T>()) {\n        for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\n          let ref = load<usize>(thisStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n        outStart += sourceSize;\n        let otherSize = <usize>otherLen << alignof<T>();\n        for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n          let ref = load<usize>(otherStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n      } else {\n        memory.copy(outStart, thisStart, sourceSize);\n        memory.copy(outStart + sourceSize, otherStart, <usize>otherLen << alignof<T>());\n      }\n    } else {\n      ERROR(\"Only Array<T> and StaticArray<T> accept for 'U' parameter\");\n    }\n    return out;\n  }\n\n  slice<U extends ArrayLike<T> = Array<T>>(start: i32 = 0, end: i32 = i32.MAX_VALUE): U {\n    let length = this.length;\n    start = start < 0 ? max(start + length, 0) : min(start, length);\n    end   = end   < 0 ? max(end   + length, 0) : min(end,   length);\n    length = max(end - start, 0);\n\n    let sourceStart = changetype<usize>(this) + (<usize>start << alignof<T>());\n    let size = <usize>length << alignof<T>();\n    let out = changetype<U>(this); // FIXME: instanceof needs *some* value\n\n    if (out instanceof Array<T>) {\n      // return Array\n      out = changetype<U>(__newArray(length, alignof<T>(), idof<Array<T>>()));\n      // ^ FIXME: Function returns type U, but can't __newArray(U extends Array<T>)\n      let outStart = changetype<Array<T>>(out).dataStart;\n      if (isManaged<T>()) {\n        let off: usize = 0;\n        while (off < size) {\n          let ref = load<usize>(sourceStart + off);\n          store<usize>(outStart + off, ref);\n          __link(changetype<usize>(out), ref, true);\n          off += sizeof<usize>();\n        }\n      } else {\n        memory.copy(outStart, sourceStart, size);\n      }\n    } else if (out instanceof StaticArray<T>) {\n      // return StaticArray\n      out = changetype<U>(__new(size, idof<StaticArray<T>>()));\n      let outStart = changetype<usize>(out);\n      if (isManaged<T>()) {\n        let off: usize = 0;\n        while (off < size) {\n          let ref = load<usize>(sourceStart + off);\n          store<usize>(outStart + off, ref);\n          __link(outStart, ref, true);\n          off += sizeof<usize>();\n        }\n      } else {\n        memory.copy(outStart, sourceStart, size);\n      }\n    } else {\n      ERROR(\"Only Array<T> and StaticArray<T> accept for 'U' parameter\");\n    }\n    return out;\n  }\n\n  findIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  findLastIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\n    for (let i = this.length - 1; i >= 0; --i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  forEach(fn: (value: T, index: i32, array: StaticArray<T>) => void): void {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: StaticArray<T>) => U): Array<U> {\n    let len = this.length;\n    let out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\n    let outStart = out.dataStart;\n    for (let i = 0; i < len; ++i) {\n      let result = fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: StaticArray<T>) => bool): Array<T> {\n    let result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let i = 0, len = this.length; i < len; ++i) {\n      let value = load<T>(changetype<usize>(this) + (<usize>i << alignof<T>()));\n      if (fn(value, i, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = 0, len = this.length; i < len; ++i) {\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = this.length - 1; i >= 0; --i) {\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  every(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (!fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return false;\n    }\n    return true;\n  }\n\n  some(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return true;\n    }\n    return false;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): StaticArray<T> {\n    SORT<T>(changetype<usize>(this), this.length, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    if (isBoolean<T>())   return joinBooleanArray(changetype<usize>(this), this.length, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(changetype<usize>(this), this.length, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(changetype<usize>(this), this.length, separator);\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(changetype<usize>(this), this.length, separator);\n    }\n    if (isReference<T>()) return joinReferenceArray<T>(changetype<usize>(this), this.length, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  reverse(): StaticArray<T> {\n    REVERSE<T>(changetype<usize>(this), this.length);\n    return this;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = changetype<usize>(this);\n      let end = cur + changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n  }\n}\n","/**\n * PVM RAM Implementation (AssemblyScript)\n *\n * Implements Gray Paper RAM specification using contiguous memory regions\n * Gray Paper reference: pvm.tex equation 770-802\n */\n\nimport { alignToPage, alignToZone } from './alignment-helpers'\nimport { INIT_CONFIG, MEMORY_CONFIG, REGISTER_INIT_ARGS_SEGMENT_START, REGISTER_INIT_STACK_SEGMENT_END } from './config'\nimport { FaultCheckResult, MemoryAccessType, RAM, ReadResult, WriteResult } from './types'\n\n/**\n * Page map entry\n */\nexport class PageMapEntry {\n  address: u64\n  length: i32\n  isWritable: bool\n  accessType: MemoryAccessType\n\n  constructor(address: u64, length: i32, isWritable: bool, accessType: MemoryAccessType) {\n    this.address = address\n    this.length = length\n    this.isWritable = isWritable\n    this.accessType = accessType\n  }\n}\n\n/**\n * PVM RAM Implementation\n *\n * Manages all PVM memory regions according to Gray Paper specification\n */\nexport class PVMRAM implements RAM {\n  // Fixed addresses according to Gray Paper (pvm.tex equation 770-802)\n  roDataAddress: u32 = INIT_CONFIG.ZONE_SIZE // 65536 (2^16)\n  argumentDataAddress: u32 = REGISTER_INIT_ARGS_SEGMENT_START() // 0xFEFF0000\n  stackAddressEnd: u32 = REGISTER_INIT_STACK_SEGMENT_END() // 0xFEFE0000\n\n  // Variable addresses (set during initialization)\n  stackAddress: u32 = 0\n  heapStartAddress: u32 = 0\n  heapEndAddress: u32 = 0\n  roDataAddressEnd: u32 = 0\n  currentHeapPointer: u32 = 0\n  argumentDataEnd: u32 = 0\n\n  // Page-based memory: Map from page index to Uint8Array(4096)\n  // Each page is a separate 4KB array - created on-demand when initPage is called\n  pages: Map<u32, Uint8Array> = new Map<u32, Uint8Array>()\n\n  // Page access tracking: Map from page index to access type\n  // Only stores pages that have been explicitly initialized\n  pageAccess: Map<u32, MemoryAccessType> = new Map<u32, MemoryAccessType>()\n\n  MAX_ADDRESS: u32 = 0xffffffff // 4GB address space\n\n  // JIP-6 trace support: Track last load/store for each instruction step\n  // These are updated by readOctets/writeOctets and should be cleared after each instruction\n  lastLoadAddress: u32 = 0\n  lastLoadValue: u64 = 0\n  lastStoreAddress: u32 = 0\n  lastStoreValue: u64 = 0\n\n  /**\n   * Clear last load/store tracking (call at start of each instruction)\n   */\n  clearLastMemoryOp(): void {\n    this.lastLoadAddress = 0\n    this.lastLoadValue = 0\n    this.lastStoreAddress = 0\n    this.lastStoreValue = 0\n  }\n\n  /**\n   * Initialize memory layout according to Gray Paper equation 770-802\n   *\n   * @param argumentData - Argument data (a)\n   * @param readOnlyData - Read-only data section (o)\n   * @param heapData - Read-write data section (w) -> initial heap data\n   * @param stackSize - Stack size (s)\n   * @param heapZeroPaddingSize - Heap zero padding size (z) (in number of pages)\n   */\n  initializeMemoryLayout(\n    argumentData: Uint8Array,\n    readOnlyData: Uint8Array,\n    heap: Uint8Array,\n    stackSize: u32,\n    heapZeroPaddingSize: u32,\n  ): void {\n    const readOnlyDataLength = readOnlyData.length\n    const heapSize = heap.length\n    const argumentDataLength = argumentData.length\n\n    // Calculate addresses\n    const heapStartAddress =\n      2 * INIT_CONFIG.ZONE_SIZE + alignToZone(readOnlyDataLength)\n    const heapEndAddress = heapStartAddress + alignToPage(heapSize)\n    const heapZerosEndAddress =\n      heapEndAddress + heapZeroPaddingSize * MEMORY_CONFIG.PAGE_SIZE\n    // const heapSizeWithPadding = heapZerosEndAddress - heapStartAddress\n\n    const argumentDataStartAddress = this.argumentDataAddress\n    const argumentDataEndAddress =\n      argumentDataStartAddress + alignToPage(argumentDataLength)\n    const argumentDataZeroPaddingEndAddress =\n      argumentDataEndAddress + alignToPage(argumentDataLength)\n\n    const stackEndAddress = this.stackAddressEnd\n    const stackStartAddress = stackEndAddress - alignToPage(stackSize)\n\n    const readOnlyZoneStartAddress = this.roDataAddress\n    const readOnlyZoneEndAddress =\n      readOnlyZoneStartAddress + alignToPage(readOnlyDataLength)\n\n    // Create pages for all memory regions and copy data\n    // Pages are created on-demand, but we initialize them here for efficiency\n    \n    // Copy argument data to pages\n    if (argumentDataLength > 0) {\n      this.writeOctetsDuringInitialization(argumentDataStartAddress, argumentData)\n    }\n    \n    // Copy read-only data to pages\n    if (readOnlyDataLength > 0) {\n      this.writeOctetsDuringInitialization(readOnlyZoneStartAddress, readOnlyData)\n    }\n    \n    // Copy heap data to pages\n    if (heapSize > 0) {\n      this.writeOctetsDuringInitialization(heapStartAddress, heap)\n    }\n    \n    // Update variable addresses\n    this.argumentDataEnd = argumentDataZeroPaddingEndAddress\n    this.roDataAddressEnd = readOnlyZoneEndAddress\n    this.stackAddress = stackStartAddress\n    this.heapStartAddress = heapStartAddress\n    this.heapEndAddress = heapEndAddress\n    this.currentHeapPointer = heapZerosEndAddress\n\n    // Initialize pages and set access rights for all memory regions using initPage\n    // This ensures pages are created and access rights are set together\n    \n    // Read-only data region (READ access)\n    if (readOnlyDataLength > 0) {\n      const roDataSize = readOnlyZoneEndAddress - readOnlyZoneStartAddress\n      this.initPage(\n        readOnlyZoneStartAddress,\n        roDataSize,\n        MemoryAccessType.READ,\n      )\n    }\n\n    // Argument data region (READ access)\n    if (argumentDataLength > 0) {\n      const argsSize = argumentDataZeroPaddingEndAddress - argumentDataStartAddress\n\n      this.initPage(\n        argumentDataStartAddress,\n        argsSize,\n        MemoryAccessType.READ,\n      )\n    }\n\n    // Stack region (WRITE access, zero-initialized per Gray Paper)\n    if (stackStartAddress < stackEndAddress) {\n      const stackSizeActual = stackEndAddress - stackStartAddress\n      this.initPage(\n        stackStartAddress,\n        stackSizeActual,\n        MemoryAccessType.WRITE,\n      )\n    }\n\n    // Heap region (WRITE access)\n    if (heapSize > 0) {\n      const heapSizeActual = heapEndAddress - heapStartAddress\n      \n      this.initPage(\n        heapStartAddress,\n        heapSizeActual,\n        MemoryAccessType.WRITE,\n      )\n    }\n    \n    // Heap zero padding region (WRITE access)\n    if (heapEndAddress < heapZerosEndAddress) {\n      const heapPaddingSize = heapZerosEndAddress - heapEndAddress\n\n      this.initPage(\n        heapEndAddress,\n        heapPaddingSize,\n        MemoryAccessType.WRITE,\n      )\n    }\n\n  }\n\n  /**\n   * Allocate additional pages for dynamic heap growth (SBRK)\n   */\n  allocatePages(startPage: u32, count: u32): void {\n    // Create pages and set access rights\n    const endPage = startPage + count\n    for (let pageIndex = startPage; pageIndex < endPage; pageIndex++) {\n      // Create page if it doesn't exist\n      this.getOrCreatePage(pageIndex)\n      // Set write access\n      this.pageAccess.set(pageIndex, MemoryAccessType.WRITE)\n    }\n\n    // Update heap pointer to reflect allocated pages\n    const endAddress = endPage * MEMORY_CONFIG.PAGE_SIZE\n    if (endAddress > this.currentHeapPointer) {\n      this.currentHeapPointer = endAddress\n    }\n  }\n\n  /**\n   * Get page index for an address\n   */\n  getPageIndex(address: u32): u32 {\n    return address / MEMORY_CONFIG.PAGE_SIZE\n  }\n\n  /**\n   * Get page offset within a page for an address\n   */\n  private getPageOffset(address: u32): u32 {\n    return address % MEMORY_CONFIG.PAGE_SIZE\n  }\n\n  /**\n   * Get or create a page at the given page index\n   * Returns null if page cannot be created\n   */\n  private getOrCreatePage(pageIndex: u32): Uint8Array | null {\n    if (this.pages.has(pageIndex)) {\n      return this.pages.get(pageIndex) as Uint8Array\n    }\n    // Create new page (4KB)\n    const page = new Uint8Array(MEMORY_CONFIG.PAGE_SIZE)\n    this.pages.set(pageIndex, page)\n    return page\n  }\n\n  /**\n   * Get a page at the given page index (returns null if not exists)\n   */\n  private getPage(pageIndex: u32): Uint8Array | null {\n    if (this.pages.has(pageIndex)) {\n      const page = this.pages.get(pageIndex)\n      return page !== null ? page : null\n    }\n    return null\n  }\n\n  /**\n   * Initialize a memory page (used for test vectors)\n   * Creates 4KB pages as needed, regardless of region\n   */\n  initPage(\n    address: u32,\n    length: u32,\n    accessType: MemoryAccessType,\n  ): void {\n    if (length === 0) {\n      return // Nothing to initialize\n    }\n\n    // Calculate which pages this address range covers\n    const startPage = this.getPageIndex(address)\n    const endAddress = address + length - 1\n    const endPage = this.getPageIndex(endAddress)\n    \n\n    // Create/ensure all pages in the range exist\n    for (let pageIndex = startPage; pageIndex <= endPage; pageIndex++) {\n      const pageAddress = pageIndex * MEMORY_CONFIG.PAGE_SIZE\n      // Get or create the page (creates a new 4KB array if needed)\n      const page = this.getOrCreatePage(pageIndex)\n      \n      if (page === null) {\n        // Failed to create page\n        return\n      }\n      \n        // Set page access rights\n        this.pageAccess.set(pageIndex, accessType)\n    }\n  }\n\n  /**\n   * Set memory page access rights for a range of pages\n   */\n  setPageAccessRightsForRange(\n    startPage: u32,\n    endPage: u32,\n    accessType: MemoryAccessType,\n  ): void {\n    for (let pageIndex = startPage; pageIndex < endPage; pageIndex++) {\n      this.pageAccess.set(pageIndex, accessType)\n    }\n  }\n\n  /**\n   * Set memory page access rights for an address range\n   */\n  setPageAccessRights(\n    address: u32,\n    length: u32,\n    accessType: MemoryAccessType,\n  ): void {\n    const startPage = this.getPageIndex(address)\n    const endAddress = address + length - 1\n    const endPage = this.getPageIndex(endAddress)\n    \n    for (let pageIndex = startPage; pageIndex <= endPage; pageIndex++) {\n      this.pageAccess.set(pageIndex, accessType)\n    }\n  }\n\n\n  /**\n   * Get memory page access type for an address\n   */\n  getPageAccessType(address: u64): MemoryAccessType {\n    const pageIndex = this.getPageIndex(u32(address))\n    return this.pageAccess.has(pageIndex) ? (this.pageAccess.get(pageIndex) as MemoryAccessType) : MemoryAccessType.NONE\n  }\n\n  /**\n   * Read multiple octets from memory\n   * Uses page-based memory access\n   */\n  readOctets(\n    address: u32,\n    count: u32,\n  ): ReadResult {\n    const readableResult = this.isReadableWithFault(address, count)\n    if (!readableResult.success) {\n      return new ReadResult(null, readableResult.faultAddress)\n    }\n\n    const addr = u32(address)\n    const length = u32(count)\n    const result = new Uint8Array(length)\n    let resultOffset = 0\n    let currentAddr = addr\n    const endAddr = addr + length\n\n    // Read across pages if needed\n    while (currentAddr < endAddr) {\n      const pageIndex = this.getPageIndex(currentAddr)\n      const pageOffset = this.getPageOffset(currentAddr)\n      const page = this.getPage(pageIndex)\n      \n      if (page === null) {\n        // Page doesn't exist - fault\n        return new ReadResult(null, pageIndex * MEMORY_CONFIG.PAGE_SIZE)\n      }\n\n      // Calculate how many bytes to read from this page\n      const bytesInPage = min(length - resultOffset, MEMORY_CONFIG.PAGE_SIZE - pageOffset)\n      const pageEnd = pageOffset + bytesInPage\n      \n      // Copy data from page to result\n      const pageData: Uint8Array = page // Explicit type after null check\n      for (let i = pageOffset; i < pageEnd; i++) {\n        result[resultOffset++] = pageData[i]\n      }\n      \n      currentAddr += bytesInPage\n    }\n\n    // JIP-6 trace support: Track last load address and value\n    this.lastLoadAddress = addr\n    // Convert result bytes to u64 value (little-endian, up to 8 bytes)\n    if (length > 0) {\n      let value: u64 = 0\n      const bytesToRead = min(length, 8)\n      for (let i: u32 = 0; i < bytesToRead; i++) {\n        value |= u64(result[i]) << (i * 8)\n      }\n      this.lastLoadValue = value\n    }\n\n    return new ReadResult(result, 0)\n  }\n\n  /**\n   * Write multiple octets to memory\n   * Uses page-based memory access\n   */\n  writeOctets(address: u32, values: Uint8Array): WriteResult {\n    const writableResult = this.isWritableWithFault(\n      address,\n      u32(values.length),\n    )\n    if (!writableResult.success) {\n      return new WriteResult(true, writableResult.faultAddress !== 0 ? writableResult.faultAddress : 0xFFFFFFFF)\n    }\n\n    const addr = u32(address)\n    const length = values.length\n    let valuesOffset = 0\n    let currentAddr = addr\n    const endAddr = addr + length\n\n    // Write across pages if needed\n    while (currentAddr < endAddr) {\n      const pageIndex = this.getPageIndex(currentAddr)\n      const pageOffset = this.getPageOffset(currentAddr)\n      const page = this.getPage(pageIndex)\n      \n      if (page === null) {\n        // Page doesn't exist - fault\n        return new WriteResult(true, pageIndex * MEMORY_CONFIG.PAGE_SIZE)\n      }\n\n      // Calculate how many bytes to write to this page\n      const bytesInPage = min(length - valuesOffset, MEMORY_CONFIG.PAGE_SIZE - pageOffset)\n      const pageEnd = pageOffset + bytesInPage\n      \n      // Copy data from values to page\n      const pageData: Uint8Array = page // Explicit type after null check\n      for (let i = pageOffset; i < pageEnd; i++) {\n        pageData[i] = values[valuesOffset++]\n      }\n      \n      currentAddr += bytesInPage\n    }\n\n    // JIP-6 trace support: Track last store address and value\n    this.lastStoreAddress = addr\n    // Convert values bytes to u64 value (little-endian, up to 8 bytes)\n    if (length > 0) {\n      let value: u64 = 0\n      const bytesToRead = min(length, 8)\n      for (let i: i32 = 0; i < bytesToRead; i++) {\n        value |= u64(values[i]) << (i * 8)\n      }\n      this.lastStoreValue = value\n    }\n\n    return new WriteResult(false, 0)\n  }\n\n  /**\n   * Write to memory during initialization, bypassing writable checks\n   * Uses page-based memory access\n   */\n  writeOctetsDuringInitialization(address: u32, values: Uint8Array): void {\n    const addr = u32(address)\n    const length = values.length\n    let valuesOffset = 0\n    let currentAddr = addr\n    const endAddr = addr + length\n\n    // Write across pages if needed\n    while (currentAddr < endAddr) {\n      const pageIndex = this.getPageIndex(currentAddr)\n      const pageOffset = this.getPageOffset(currentAddr)\n      \n      // Get or create the page (creates if needed during initialization)\n      const page = this.getOrCreatePage(pageIndex)\n      if (page === null) {\n        return // Failed to create page\n      }\n\n      // Calculate how many bytes to write to this page\n      const pageData: Uint8Array = page // Explicit type after null check\n      const bytesInPage = min(length - valuesOffset, MEMORY_CONFIG.PAGE_SIZE - pageOffset)\n      const pageEnd = pageOffset + bytesInPage\n      \n      // Copy data from values to page\n      for (let i = pageOffset; i < pageEnd; i++) {\n        pageData[i] = values[valuesOffset++]\n      }\n      \n      currentAddr += bytesInPage\n    }\n  }\n\n  isReadableWithFault(address: u32, size: u32 = u32(1)): FaultCheckResult {\n    // Gray Paper: Empty range is trivially readable - return empty array\n    if (size === 0) {\n      return new FaultCheckResult(true, 0)\n    }\n\n    // Check for overflow before adding - if size is so large that address + size overflows,\n    // or if address + size exceeds MAX_ADDRESS, then it's a fault\n    // Use 64-bit arithmetic to avoid overflow\n    const endAddress = u64(address) + u64(size)\n    if (endAddress > u64(this.MAX_ADDRESS)) {\n      return new FaultCheckResult(false, address)\n    }\n\n    const endRequestedAddress = address + size\n    const startPage = this.getPageIndex(address)\n    const endPage = this.getPageIndex(endRequestedAddress - 1)\n      \n    // Check all pages in the range have READ or WRITE access\n    for (let pageIndex = startPage; pageIndex <= endPage; pageIndex++) {\n      const accessType = this.pageAccess.has(pageIndex) \n        ? (this.pageAccess.get(pageIndex) as MemoryAccessType)\n        : MemoryAccessType.NONE\n      \n      if (accessType === MemoryAccessType.NONE) {\n        // Page not accessible - return fault at page start\n        return new FaultCheckResult(false, pageIndex * MEMORY_CONFIG.PAGE_SIZE)\n      }\n    }\n    \n    return new FaultCheckResult(true, 0)\n  }\n\n  isWritableWithFault(address: u32, size: u32 = u32(1)): FaultCheckResult {\n    // Gray Paper: Empty range is trivially writable\n    if (size === 0) {\n      return new FaultCheckResult(true, 0)\n    }\n\n    // Check for overflow before adding - if size is so large that address + size overflows,\n    // or if address + size exceeds MAX_ADDRESS, then it's a fault\n    // Use 64-bit arithmetic to avoid overflow\n    const endAddress = u64(address) + u64(size)\n    if (endAddress > u64(this.MAX_ADDRESS)) {\n      const faultAddress =\n        this.getPageIndex(address) * MEMORY_CONFIG.PAGE_SIZE\n      return new FaultCheckResult(false, faultAddress)\n    }\n\n    const endRequestedAddress = address + size\n    const startPage = this.getPageIndex(address)\n    const endPage = this.getPageIndex(endRequestedAddress - 1)\n    \n    // Check all pages in the range have WRITE access\n    for (let pageIndex = startPage; pageIndex <= endPage; pageIndex++) {\n      const pageAddress = pageIndex * MEMORY_CONFIG.PAGE_SIZE\n      const hasAccess = this.pageAccess.has(pageIndex)\n      const accessType = hasAccess\n        ? (this.pageAccess.get(pageIndex) as MemoryAccessType)\n        : MemoryAccessType.NONE\n      \n      const accessTypeStr = accessType === MemoryAccessType.READ ? 'READ' : \n                           accessType === MemoryAccessType.WRITE ? 'WRITE' : 'NONE'\n      \n      if (accessType !== MemoryAccessType.WRITE) {\n        // Page not writable - return fault at page start\n        return new FaultCheckResult(false, pageAddress)\n      }\n    }\n\n    return new FaultCheckResult(true, 0)\n  }\n\n  /**\n   * Get a summary of all allocated RAM pages with their access rights\n   */\n  getPageMap(): PageMapEntry[] {\n    const pages: PageMapEntry[] = []\n\n    const pageIndices = this.pageAccess.keys()\n    for (let i: i32 = 0; i < i32(pageIndices.length); i++) {\n      const pageIndex = pageIndices[i]\n      if (this.pageAccess.has(pageIndex)) {\n        const accessType = this.pageAccess.get(pageIndex) as MemoryAccessType\n        const startAddress = u64(pageIndex * MEMORY_CONFIG.PAGE_SIZE)\n          pages.push(new PageMapEntry(\n          startAddress,\n          MEMORY_CONFIG.PAGE_SIZE,\n            accessType === MemoryAccessType.WRITE,\n            accessType,\n          ))\n      }\n    }\n\n    return pages\n  }\n\n  /**\n   * Get memory contents for a specific address range\n   * Uses page-based memory access\n   */\n  getMemoryContents(address: u64, length: i32): u64[] {\n    const addr = u32(address)\n    const result: u64[] = []\n    let currentAddr = addr\n    const endAddr = addr + length\n\n    // Read across pages if needed\n    while (currentAddr < endAddr) {\n      const pageIndex = this.getPageIndex(currentAddr)\n      const pageOffset = this.getPageOffset(currentAddr)\n      const page = this.getPage(pageIndex)\n      \n      if (page === null) {\n        // Page doesn't exist - return zeros\n        const remaining = endAddr - currentAddr\n        for (let i = 0; i < remaining; i++) {\n          result.push(u64(0))\n    }\n        break\n      }\n\n      // Calculate how many bytes to read from this page\n      const pageData: Uint8Array = page // Explicit type after null check\n      const bytesInPage = min(i32(endAddr - currentAddr), i32(MEMORY_CONFIG.PAGE_SIZE - pageOffset))\n      const pageEnd = pageOffset + bytesInPage\n      \n      // Copy data from page to result\n      for (let i = pageOffset; i < pageEnd; i++) {\n        result.push(u64(pageData[i]))\n      }\n      \n      currentAddr += u32(bytesInPage)\n    }\n\n    return result\n  }\n\n  /**\n   * Clear all memory (zero out pages but keep them allocated)\n   */\n  clear(): void {\n    // Clear all pages (zero them out)\n    const pageIndices = this.pages.keys()\n    for (let i: i32 = 0; i < i32(pageIndices.length); i++) {\n      const pageIndex = pageIndices[i]\n      const page = this.pages.get(pageIndex)!\n      page.fill(0)\n    }\n    \n    // Reset address variables\n    this.stackAddress = 0\n    this.heapStartAddress = 0\n    this.heapEndAddress = 0\n    this.roDataAddressEnd = 0\n    this.currentHeapPointer = 0\n    this.argumentDataEnd = 0\n  }\n\n  /**\n   * Reset RAM to initial state\n   * Clears all memory, page access rights, and resets all address variables\n   */\n  reset(): void {\n    // Clear page access rights\n    this.pageAccess.clear()\n    \n    // Clear all pages\n    this.pages.clear()\n    \n    // Reset all address variables\n    this.stackAddress = 0\n    this.heapStartAddress = 0\n    this.heapEndAddress = 0\n    this.roDataAddressEnd = 0\n    this.currentHeapPointer = 0\n    this.argumentDataEnd = 0\n  }\n\n  /**\n   * Get page dump for a specific page index\n   * Returns a copy of the page data (4KB) or zeros if page doesn't exist\n   */\n  getPageDump(pageIndex: u32): Uint8Array {\n    const page = this.getPage(pageIndex)\n    if (page === null) {\n      // Return zeros if page doesn't exist\n      return new Uint8Array(MEMORY_CONFIG.PAGE_SIZE)\n    }\n    // Return a copy of the page\n    const result = new Uint8Array(MEMORY_CONFIG.PAGE_SIZE)\n    const pageData: Uint8Array = page // Explicit type to help flow analysis\n    result.set(pageData)\n    return result\n  }\n}\n","import { BaseHostFunction } from './base'\nimport { ExportHostFunction } from './export'\nimport { ExpungeHostFunction } from './expunge'\nimport { FetchHostFunction } from './fetch'\nimport { GasHostFunction } from './gas'\nimport { HistoricalLookupHostFunction } from './historical-lookup'\nimport { InfoHostFunction } from './info'\nimport { InvokeHostFunction } from './invoke'\nimport { LogHostFunction } from './log'\nimport { LookupHostFunction } from './lookup'\nimport { MachineHostFunction } from './machine'\nimport { PagesHostFunction } from './pages'\nimport { PeekHostFunction } from './peek'\nimport { PokeHostFunction } from './poke'\nimport { ReadHostFunction } from './read'\nimport { WriteHostFunction } from './write'\n\n/**\n * Registry for managing all host functions\n *\n * Similar to the instruction registry, this maintains a mapping of\n * function IDs to their corresponding implementations.\n */\nexport class HostFunctionRegistry {\n  functions: Map<u64, BaseHostFunction> = new Map<u64, BaseHostFunction>()\n\n  constructor() {\n    this.registerHostFunctions()\n  }\n\n  registerHostFunctions(): void {\n    this.register(new GasHostFunction())\n    this.register(new FetchHostFunction())\n    this.register(new HistoricalLookupHostFunction())\n    this.register(new LookupHostFunction())\n    this.register(new ReadHostFunction())\n    this.register(new WriteHostFunction())\n    this.register(new InfoHostFunction())\n    this.register(new ExportHostFunction())\n    this.register(new MachineHostFunction(this))\n    this.register(new PeekHostFunction())\n    this.register(new PokeHostFunction())\n    this.register(new PagesHostFunction())\n    this.register(new InvokeHostFunction())\n    this.register(new ExpungeHostFunction())\n    this.register(new LogHostFunction())\n  }\n\n  register(hostFunction: BaseHostFunction): void {\n    this.functions.set(hostFunction.functionId, hostFunction)\n  }\n\n  get(functionId: u64): BaseHostFunction | null {\n    if (this.functions.has(functionId)) {\n      return this.functions.get(functionId)!\n    }\n    return null\n  }\n}\n","import { PVM } from '../../pvm'\nimport { RAM, RegisterState } from '../../types'\nimport { HostFunctionResult } from '../accumulate/base'\nimport { CompleteServiceAccount, WorkPackage, WorkItem, AccumulateInput } from '../../codec'\nimport { RefineInvocationContext } from '../../pbnj-types-compat'\n\n/**\n * PVM Guest - represents a PVM machine instance\n */\nexport class PVMGuest {\n  pvm: PVM\n\n  constructor(pvm: PVM) {\n    this.pvm = pvm\n  }\n}\n\n/**\n * Refine Invocation Context\n * Gray Paper: (m, e) where m = machines, e = export segments\n */\nexport class RefineInvocationContext {\n  machines: Map<u64, PVMGuest>\n  exportSegments: Array<Uint8Array>\n\n  constructor() {\n    this.machines = new Map<u64, PVMGuest>()\n    this.exportSegments = [] as Uint8Array[]\n  }\n}\n\n/**\n * Base params type for all host function parameters\n * AssemblyScript doesn't support union types, so we use a base type\n */\nexport class HostFunctionParams {\n  // This is a marker class - actual implementations will extend this\n}\n\n/**\n * Host function context for general host functions\n */\nexport class HostFunctionContext {\n  gasCounter: u32\n  registers: RegisterState\n  ram: RAM\n\n  constructor(\n    gasCounter: u32,\n    registers: RegisterState,\n    ram: RAM,\n  ) {\n    this.gasCounter = gasCounter\n    this.registers = registers\n    this.ram = ram\n  }\n}\n\n/**\n * Host function parameter types\n */\nexport class ReadParams extends HostFunctionParams {\n  serviceId: u64\n  serviceAccount: CompleteServiceAccount | null\n  accounts: Map<u64, CompleteServiceAccount>\n\n  constructor(\n    serviceId: u64,\n    serviceAccount: CompleteServiceAccount | null,\n    accounts: Map<u64, CompleteServiceAccount>,\n  ) {\n    super()\n    this.serviceId = serviceId\n    this.serviceAccount = serviceAccount\n    this.accounts = accounts\n  }\n}\n\nexport class WriteParams extends HostFunctionParams {\n  serviceId: u64\n  serviceAccount: CompleteServiceAccount\n\n  constructor(serviceId: u64, serviceAccount: CompleteServiceAccount) {\n    super()\n    this.serviceId = serviceId\n    this.serviceAccount = serviceAccount\n  }\n}\n\nexport class InfoParams extends HostFunctionParams {\n  serviceId: u64\n  accounts: Map<u64, CompleteServiceAccount>\n\n  constructor(serviceId: u64, accounts: Map<u64, CompleteServiceAccount>) {\n    super()\n    this.serviceId = serviceId\n    this.accounts = accounts\n  }\n}\n\nexport class LookupParams extends HostFunctionParams {\n  serviceId: u64\n  accounts: Map<u64, CompleteServiceAccount>\n\n  constructor(serviceId: u64, accounts: Map<u64, CompleteServiceAccount>) {\n    super()\n    this.serviceId = serviceId\n    this.accounts = accounts\n  }\n}\n\nexport class HistoricalLookupParams extends HostFunctionParams {\n  serviceId: u64\n  accounts: Map<u64, CompleteServiceAccount>\n  lookupTimeslot: u64\n\n  constructor(\n    serviceId: u64,\n    accounts: Map<u64, CompleteServiceAccount>,\n    lookupTimeslot: u64,\n  ) {\n    super()\n    this.serviceId = serviceId\n    this.accounts = accounts\n    this.lookupTimeslot = lookupTimeslot\n  }\n}\n\nexport class InvokeParams extends HostFunctionParams {\n  refineContext: RefineInvocationContext | null\n\n  constructor(refineContext: RefineInvocationContext | null) {\n    super()\n    this.refineContext = refineContext\n  }\n}\n\nexport class ExpungeParams extends HostFunctionParams {\n  refineContext: RefineInvocationContext | null\n\n  constructor(refineContext: RefineInvocationContext | null) {\n    super()\n    this.refineContext = refineContext\n  }\n}\n\nexport class LogParams extends HostFunctionParams {\n  // LogParams doesn't need any properties - all data comes from registers\n  constructor() {\n    super()\n  }\n}\n\nexport class MachineParams extends HostFunctionParams {\n  refineContext: RefineInvocationContext | null\n\n  constructor(refineContext: RefineInvocationContext | null) {\n    super()\n    this.refineContext = refineContext\n  }\n}\n\nexport class PagesParams extends HostFunctionParams {\n  refineContext: RefineInvocationContext | null\n\n  constructor(refineContext: RefineInvocationContext | null) {\n    super()\n    this.refineContext = refineContext\n  }\n}\n\nexport class PeekPokeParams extends HostFunctionParams {\n  refineContext: RefineInvocationContext | null\n\n  constructor(refineContext: RefineInvocationContext | null) {\n    super()\n    this.refineContext = refineContext\n  }\n}\n\nexport class FetchParams extends HostFunctionParams {\n  timeslot: u64\n  offset: u64\n  workPackage: WorkPackage | null = null\n  workPackageHash: Uint8Array | null = null\n  authorizerTrace: Uint8Array | null = null\n  workItemIndex: u64 = u64(0xFFFFFFFFFFFFFFFF) // Use MAX_VALUE as sentinel for null (0 is a valid index)\n  importSegments: Array<Array<Uint8Array>> | null = null\n  exportSegments: Array<Array<Uint8Array>> | null = null\n  // i (mathbf{i}): accumulate inputs sequence (or null)\n  // Gray Paper pvm_invocations.tex line 150: sequence{accinput}\n  // Used by selectors 14 and 15 in accumulation context\n  accumulateInputs: Array<AccumulateInput> | null = null\n\n  constructor(timeslot: u64, offset: u64) {\n    super()\n    this.timeslot = timeslot\n    this.offset = offset\n  }\n}\n\nexport class ExportParams extends HostFunctionParams {\n  refineContext: RefineInvocationContext | null\n  segmentOffset: i64\n\n  constructor(\n    refineContext: RefineInvocationContext | null,\n    segmentOffset: i64 = 0,\n  ) {\n    super()\n    this.refineContext = refineContext\n    this.segmentOffset = segmentOffset\n  }\n}\n\n/**\n * Base class for all host functions\n *\n * Host functions are called by PVM programs via host call instructions.\n * They provide access to system resources, storage, and other PVM instances.\n */\nexport class BaseHostFunction {\n  /**\n   * The unique identifier for this host function\n   * Must match the ID in GENERAL_FUNCTIONS, REFINE_FUNCTIONS, or ACCUMULATE_FUNCTIONS\n   */\n  functionId: u64 = 0\n\n  /**\n   * Human-readable name for this host function\n   */\n  name: string = ''\n\n  /**\n   * Execute the host function\n   *\n   * @param context - Host function context (will be mutated)\n   * @param params - Optional parameters (function-specific)\n   * @returns Result code\n   */\n  execute(\n    context: HostFunctionContext,\n    params: HostFunctionParams | null,\n  ): HostFunctionResult {\n    // Base implementation - should be overridden by subclasses\n    return new HostFunctionResult(255) // 255 = continue execution\n  }\n}\n","import { HostFunctionResult } from '../accumulate/base'\nimport { HostFunctionContext, HostFunctionParams } from './base'\nimport { BaseHostFunction } from './base'\n\n/**\n * GAS host function (_G)\n *\n * Returns the current gas counter value\n *\n * Gray Paper Specification:\n * - Function ID: 0 (gas)\n * - Gas Cost: 10\n * - Sets registers[7] = gascounter (remaining gas)\n * - Returns gascounter - 10 (gas consumed)\n */\nexport class GasHostFunction extends BaseHostFunction {\n  functionId: u64 = u64(0) // GAS function ID\n  name: string = 'gas'\n\n  execute(context: HostFunctionContext, params: HostFunctionParams | null): HostFunctionResult {\n    // Set registers[7] = gascounter (remaining gas)\n    // Explicit cast to u64 since gasCounter is u32 and registers are u64\n    context.registers[7] = u64(context.gasCounter)\n\n    // Return updated gas counter\n    return new HostFunctionResult(255)\n  }\n}\n","import {\n  encodeAccumulateInput,\n  encodeRefineContext,\n  encodeVariableSequence,\n  encodeWorkItem,\n  encodeWorkItemSummary,\n  encodeWorkPackage,\n  AccumulateInput,\n} from '../../codec'\nimport { HostFunctionResult } from '../accumulate/base'\nimport { HostFunctionContext, HostFunctionParams, FetchParams } from './base'\nimport { PVM } from '../../pvm'\nimport {\n  AUTHORIZATION_CONSTANTS,\n  DEPOSIT_CONSTANTS,\n  HISTORY_CONSTANTS,\n  SERVICE_CONSTANTS,\n  TIME_CONSTANTS,\n  TRANSFER_CONSTANTS,\n  WORK_PACKAGE_CONSTANTS,\n  WORK_REPORT_CONSTANTS,\n} from '../../pbnj-types-compat'\nimport {\n  ACCUMULATE_ERROR_CODES,\n  GENERAL_FUNCTIONS,\n  RESULT_CODES,\n} from '../../config'\nimport { BaseHostFunction } from './base'\n\n/**\n * FETCH host function (_Y)\n *\n * Fetches various system constants and data\n *\n * Gray Paper Specification:\n * - Function ID: 1 (fetch)\n * - Gas Cost: 10\n * - Uses registers[10] as selector to determine what to fetch\n * - Can return system constants, work package data, import/export segments, etc.\n * - Writes fetched data to memory at registers[7] offset\n * - Returns length of fetched data in registers[7]\n */\n\nexport class FetchHostFunction extends BaseHostFunction {\n  functionId: u64 = GENERAL_FUNCTIONS.FETCH\n  name: string = 'fetch'\n\n  pvmInstance: PVM | null = null // Reference to PVM instance to access entropy accumulator\n  \n  setPvmInstance(pvm: PVM): void {\n    this.pvmInstance = pvm\n  }\n\n  execute(\n    context: HostFunctionContext,\n    params: HostFunctionParams | null,\n  ): HostFunctionResult {\n    if (!params) {\n      return new HostFunctionResult(RESULT_CODES.PANIC)\n    }\n    const fetchParams = params as FetchParams\n    const selector = context.registers[10] & 0xffffffff\n    const outputOffset = context.registers[7] // memory offset to write the data to\n    const fromOffset = context.registers[8] // start offset in the fetched data\n    const length = context.registers[9] // number of bytes to write to memory\n\n\n    // Fetch data based on selector according to Gray Paper specification\n    // Note: We always fetch to determine available length, even if requested length is 0\n    const fetchedData = this.fetchData(selector, context, fetchParams)\n\n    // Write result to memory\n    if (fetchedData === null) {\n      // Return NONE (2^64 - 1) for not found\n      context.registers[7] = ACCUMULATE_ERROR_CODES.NONE\n    } else {\n      // Gray Paper pvm_invocations.tex lines 363-370:\n      // f = min(registers_8, len(v))\n      // l = min(registers_9, len(v) - f)\n      // (execst', registers'_7, memory'[o:l])  {\n      //   (panic, registers_7, memory[o:l])  when Nrange{o}{l}  writable(memory)\n      //   (continue, NONE, memory[o:l])       when v = none\n      //   (continue, len(v), v[f:l])          otherwise\n      // }\n      const clampedFromOffset = min(i32(fromOffset), fetchedData.length)\n      const availableLength = fetchedData.length - clampedFromOffset\n      // Gray Paper: l = min(registers_9, len(v) - f)\n      // When registers_9 = 0, l = 0 (no write operation)\n      const actualLength = min(i32(length), availableLength)\n\n      // Only perform memory write when l > 0\n      // Gray Paper: Empty range (l = 0) is always writable, but we don't write anything\n      if (actualLength > 0) {\n        const dataToWrite = fetchedData.slice(\n          clampedFromOffset,\n          clampedFromOffset + actualLength,\n        )\n\n        // Check if memory range is writable before writing\n        // Gray Paper: panic when Nrange{o}{l}  writable(memory)\n        const writeResult = context.ram.writeOctets(u32(outputOffset), dataToWrite)\n        if (writeResult.hasFault) {\n          return new HostFunctionResult(RESULT_CODES.PANIC)\n        }\n      }\n\n      // Return length of fetched data (len(v))\n      // Gray Paper: registers'_7 = len(v)\n      context.registers[7] = u64(fetchedData.length)\n    }\n\n    return new HostFunctionResult(255) // continue execution\n  }\n\n  fetchData(\n    selector: u64,\n    context: HostFunctionContext,\n    params: FetchParams\n  ): Uint8Array | null {\n    // Gray Paper: _Y(gascounter, registers, memory, p, n, r, i, i, x, i, .)\n    // where p = work package, n = work package hash, r = authorizer trace,\n    // i = work item index, i = import segments, x = export segments\n\n    switch (u32(selector)) {\n      case 0:\n        // Gray Paper pvm_invocations.tex line 307-344: registers[10] = 0\n        // Returns: c (system constants)\n        // Encoded sequence of all system constants: Citemdeposit, Cbytedeposit, Cbasedeposit,\n        // Ccorecount, Cexpungeperiod, Cepochlen, Creportaccgas, Cpackageauthgas, Cpackagerefgas,\n        // Cblockaccgas, Crecenthistorylen, Cmaxpackageitems, Cmaxreportdeps, Cmaxblocktickets,\n        // Cmaxlookupanchorage, Cticketentries, Cauthpoolsize, Cslotseconds, Cauthqueuesize,\n        // Crotationperiod, Cmaxpackagexts, Cassurancetimeoutperiod, Cvalcount, Cmaxauthcodesize,\n        // Cmaxbundlesize, Cmaxservicecodesize, Cecpiecesize, Cmaxpackageimports, Csegmentecpieces,\n        // Cmaxreportvarsize, Cmemosize, Cmaxpackageexports, Cepochtailstart\n        return this.getSystemConstants()\n\n      case 1:\n        // Gray Paper pvm_invocations.tex line 345: registers[10] = 1\n        // Returns: n when n  none\n        // In accumulate invocation (line 189): n = entropyaccumulator' (entropy accumulator)\n        // In refine invocation (line 96): n = zerohash (work package hash, but set to zero/none)\n        // In is-authorized invocation (line 49): n = none (not available)\n        // Get entropy accumulator from PVM instance (passed in setup)\n        if (this.pvmInstance && this.pvmInstance!.entropyAccumulator) {\n          return this.pvmInstance!.entropyAccumulator\n        }\n\n        return null\n\n      case 2: {\n        // Gray Paper pvm_invocations.tex line 346: registers[10] = 2\n        // Returns: r (authorizer trace) when r  none\n        // The authorizer trace parameter passed to _Y\n        if (!params.authorizerTrace) {\n          return null\n        }\n        return params.authorizerTrace\n      }\n      case 3: {\n        if (!params.exportSegments) {\n          return null\n        }\n        const workItemIndex = context.registers[11]\n        const extrinsicIndex = context.registers[12]\n        const workItemIdx = i32(workItemIndex)\n        const extrinsicIdx = i32(extrinsicIndex)\n        const exportSegments3 = params.exportSegments!\n        if (workItemIdx >= exportSegments3.length) {\n          return null\n        }\n        const segments = exportSegments3[workItemIdx]\n        if (extrinsicIdx >= segments.length) {\n          return null\n        }\n        return segments[extrinsicIdx]\n      }\n\n      case 4: {\n        // Gray Paper pvm_invocations.tex line 348: registers[10] = 4\n        // Returns: x[i][registers[11]] when x  none  i  none\n        // Export segments/extrinsics by work item: x[i] is the sequence for work item i,\n        // accessed at index registers[11]. Requires: registers[11] < len(x[i])\n        // Check if workItemIndex is set (not the sentinel value u64.MAX_VALUE)\n        if (!params.exportSegments || params.workItemIndex === u64(0xFFFFFFFFFFFFFFFF)) {\n          return null\n        }\n        const workItemIdx = i32(params.workItemIndex)\n        const segmentIdx = i32(context.registers[11])\n        const exportSegments4 = params.exportSegments!\n        if (workItemIdx >= exportSegments4.length) {\n          return null\n        }\n        const segments = exportSegments4[workItemIdx]\n        if (segmentIdx >= segments.length) {\n          return null\n        }\n        return segments[segmentIdx]\n      }\n      case 5: {\n        // Gray Paper pvm_invocations.tex line 349: registers[10] = 5\n        // Returns: i[registers[11]][registers[12]] when i  none\n        // Import segments: i is a nested sequence, accessed by flat index registers[11]\n        // and sub-index registers[12]. Requires: registers[11] < len(i) and registers[12] < len(i[registers[11]])\n        if (!params.importSegments) {\n          return null\n        }\n        const workItemIndex = context.registers[11]\n        const importIndex = context.registers[12]\n        const workItemIdx = i32(workItemIndex)\n        const importIdx = i32(importIndex)\n        const importSegments5 = params.importSegments!\n        if (workItemIdx >= importSegments5.length) {\n          return null\n        }\n        const segments = importSegments5[workItemIdx]\n        if (importIdx >= segments.length) {\n          return null\n        }\n        return segments[importIdx]\n      }\n      case 6: {\n        // Gray Paper pvm_invocations.tex line 350: registers[10] = 6\n        // Returns: i[i][registers[11]] when i  none  i  none\n        // Import segments by work item: i[i] is the sequence for work item i,\n        // accessed at index registers[11]. Requires: registers[11] < len(i[i])\n        // Check if workItemIndex is set (not the sentinel value u64.MAX_VALUE)\n        if (!params.importSegments || params.workItemIndex === u64(0xFFFFFFFFFFFFFFFF)) {\n          return null\n        }\n        const workItemIdx = i32(params.workItemIndex)\n        const segmentIdx = i32(context.registers[11])\n        const importSegments6 = params.importSegments!\n        if (workItemIdx >= importSegments6.length) {\n          return null\n        }\n        const segments = importSegments6[workItemIdx]\n        if (segmentIdx >= segments.length) {\n          return null\n        }\n        return segments[segmentIdx]\n      }\n\n      case 7: {\n        if(!params.workPackage) {\n          return null\n        }\n        const workPackage7 = params.workPackage!\n        const encoded = encodeWorkPackage(workPackage7)\n        return encoded\n      }\n\n      case 8: {\n        // Gray Paper pvm_invocations.tex line 352: registers[10] = 8\n        // Returns: p.authconfig when p  none\n        // Work package authorization configuration blob\n        if(!params.workPackage) {\n          return null\n        }\n        const workPackage = params.workPackage!\n        return workPackage.authConfig\n      }\n\n      case 9:\n        // Gray Paper pvm_invocations.tex line 353: registers[10] = 9\n        // Returns: p.authtoken when p  none\n        // Work package authorization token blob\n        if(!params.workPackage) {\n          return null\n        }\n        const workPackage9 = params.workPackage!\n        return workPackage9.authToken\n\n      case 10: {\n        // Gray Paper pvm_invocations.tex line 354: registers[10] = 10\n        // Returns: encode(p.context) when p  none\n        // Encoded work package context\n        if(!params.workPackage) {\n          return null\n        }\n        const workPackage10 = params.workPackage!\n        const encoded = encodeRefineContext(workPackage10.context)\n        return encoded\n      }\n\n      case 11: {\n        // Gray Paper pvm_invocations.tex line 355: registers[10] = 11\n        // Returns: encode({S(w) | w  p.workitems}) when p  none\n        // Encoded sequence of work item summaries S(w) for all work items in p.workitems\n        // S(w) = encode{encode[4]{w.serviceindex}, w.codehash, encode[8]{w.refgaslimit, w.accgaslimit},\n        // encode[2]{w.exportcount, len(w.importsegments), len(w.extrinsics)}, encode[4]{len(w.payload)}}\n        if (!params.workPackage) {\n          return null\n        }\n        const workPackage11 = params.workPackage!\n        // Encode each work item summary and collect into array\n        const summaries = new Array<Uint8Array>(workPackage11.workItems.length)\n        for (let i: i32 = 0; i < workPackage11.workItems.length; i++) {\n          summaries[i] = encodeWorkItemSummary(workPackage11.workItems[i])\n        }\n        const encoded = encodeVariableSequence(summaries)\n        return encoded\n      }\n\n      case 12: {\n        // Gray Paper pvm_invocations.tex line 356-357: registers[10] = 12\n        // Returns: S(p.workitems[registers[11]]) when p  none  registers[11] < len(p.workitems)\n        // Work item summary S(w) for work item at index registers[11]\n        // S(w) = encode{encode[4]{w.serviceindex}, w.codehash, encode[8]{w.refgaslimit, w.accgaslimit},\n        // encode[2]{w.exportcount, len(w.importsegments), len(w.extrinsics)}, encode[4]{len(w.payload)}}\n        if (!params.workPackage) {\n          return null\n        }\n        const workPackage12 = params.workPackage!\n        const workItems = workPackage12.workItems\n        const itemIdx = i32(context.registers[11])\n        if (itemIdx >= workItems.length) {\n          return null\n        }\n        const workItem = workItems[itemIdx]\n        const encoded = encodeWorkItemSummary(workItem)\n        return encoded\n\n      }\n      case 13: {\n        // Gray Paper pvm_invocations.tex line 358: registers[10] = 13\n        // Returns: p.workitems[registers[11]].payload when p  none  registers[11] < len(p.workitems)\n        // Payload blob of work item at index registers[11]\n        return this.getWorkItemPayload(params, context.registers[11])\n      }\n\n      case 14: {\n        // Gray Paper pvm_invocations.tex line 359: registers[10] = 14\n        // Returns: encode{var{i}} when i  none\n        // Where i is sequence{accinput} - the accumulate inputs sequence\n        // Gray Paper equation 126: accinput = operandtuple  defxfer\n        // Gray Paper equations 289-292: encode(AccumulateInput) format\n        if(!params.accumulateInputs) {\n          return null\n        }\n        const accInputs14 = params.accumulateInputs!\n        // Encode each accumulate input and collect into array\n        // Pass JAM version from PVM instance for version-aware encoding\n        const jamMajor = this.pvmInstance ? this.pvmInstance!.jamVersionMajor : u8(0)\n        const jamMinor = this.pvmInstance ? this.pvmInstance!.jamVersionMinor : u8(7)\n        const jamPatch = this.pvmInstance ? this.pvmInstance!.jamVersionPatch : u8(2)\n        const encodedInputs = new Array<Uint8Array>(accInputs14.length)\n        for (let i: i32 = 0; i < accInputs14.length; i++) {\n          encodedInputs[i] = encodeAccumulateInput(accInputs14[i], jamMajor, jamMinor, jamPatch)\n        }\n        // encodeVariableSequence will encode length prefix (0 for empty array) + items\n        // This always returns a Uint8Array (even for empty sequence, it's length prefix 0x00)\n        const encoded = encodeVariableSequence(encodedInputs)\n        return encoded\n      }\n\n      case 15: {\n        // Gray Paper pvm_invocations.tex line 360: registers[10] = 15\n        // Returns: encode{i[registers[11]]} when i  none  registers[11] < len(i)\n        // Encoded single AccumulateInput at index registers[11] from i sequence\n        return this.getAccumulateInputByIndex(params, context.registers[11])\n      }\n      default:\n        // Unknown selector - return NONE\n        return null\n    }\n  }\n\n  // Helper to encode u64 to little-endian bytes\n  encodeU64(value: u64): Uint8Array {\n    const bytes = new Uint8Array(8)\n    for (let i: i32 = 0; i < 8; i++) {\n      bytes[i] = u8((value >> (u64(i) * 8)) & 0xff)\n    }\n    return bytes\n  }\n\n  // Helper to encode u32 to little-endian bytes\n  encodeU32(value: u32): Uint8Array {\n    const bytes = new Uint8Array(4)\n    for (let i: i32 = 0; i < 4; i++) {\n      bytes[i] = u8((value >> (i * 8)) & 0xff)\n    }\n    return bytes\n  }\n\n  // Helper to encode u16 to little-endian bytes\n  encodeU16(value: u16): Uint8Array {\n    const bytes = new Uint8Array(2)\n    bytes[0] = u8(value & 0xff)\n    bytes[1] = u8((value >> 8) & 0xff)\n    return bytes\n  }\n\n  getSystemConstants(): Uint8Array {\n    // Gray Paper: System constants encoded as per specification\n    // encode[8]{Citemdeposit}, encode[8]{Cbytedeposit}, encode[8]{Cbasedeposit},\n    // encode[2]{Ccorecount}, encode[4]{Cexpungeperiod}, encode[4]{Cepochlen},\n    // encode[8]{Creportaccgas}, encode[8]{Cpackageauthgas}, encode[8]{Cpackagerefgas},\n    // encode[8]{Cblockaccgas}, encode[2]{Crecenthistorylen}, encode[2]{Cmaxpackageitems},\n    // encode[2]{Cmaxreportdeps}, encode[2]{Cmaxblocktickets}, encode[4]{Cmaxlookupanchorage},\n    // encode[2]{Cticketentries}, encode[2]{Cauthpoolsize}, encode[2]{Cslotseconds},\n    // encode[2]{Cauthqueuesize}, encode[2]{Crotationperiod}, encode[2]{Cmaxpackagexts},\n    // encode[2]{Cassurancetimeoutperiod}, encode[2]{Cvalcount}, encode[4]{Cmaxauthcodesize},\n    // encode[4]{Cmaxbundlesize}, encode[4]{Cmaxservicecodesize}, encode[4]{Cecpiecesize},\n    // encode[4]{Cmaxpackageimports}, encode[4]{Csegmentecpieces}, encode[4]{Cmaxreportvarsize},\n    // encode[4]{Cmemosize}, encode[4]{Cmaxpackageexports}, encode[4]{Cepochtailstart}\n\n    const buffer = new Uint8Array(134) // Total size: 8+8+8+2+4+4+8+8+8+8+2+2+2+2+4+2+2+2+2+2+2+2+2+4+4+4+4+4+4+4+4+4+4+4 = 134 bytes (per Gray Paper pvm_invocations.tex lines 308-343)\n    let offset: i32 = 0\n\n    // encode[8]{Citemdeposit = 10}\n    const itemDepositBytes = this.encodeU64(u64(DEPOSIT_CONSTANTS.C_ITEMDEPOSIT))\n    buffer.set(itemDepositBytes, offset)\n    offset += 8\n\n    // encode[8]{Cbytedeposit = 1}\n    const byteDepositBytes = this.encodeU64(u64(DEPOSIT_CONSTANTS.C_BYTEDEPOSIT))\n    buffer.set(byteDepositBytes, offset)\n    offset += 8\n\n    // encode[8]{Cbasedeposit = 100}\n    const baseDepositBytes = this.encodeU64(u64(DEPOSIT_CONSTANTS.C_BASEDEPOSIT))\n    buffer.set(baseDepositBytes, offset)\n    offset += 8\n\n    // encode[2]{Ccorecount = 341}\n    if (!this.pvmInstance) {\n      abort('getSystemConstants: pvmInstance not set - config values required')\n      unreachable()\n    }\n    const numCores = this.pvmInstance!.configNumCores\n    const coreCountBytes = this.encodeU16(u16(numCores))\n    buffer.set(coreCountBytes, offset)\n    offset += 2\n\n    // encode[4]{Cexpungeperiod = 19200}\n    const preimageExpungePeriod = this.pvmInstance!.configPreimageExpungePeriod\n    const expungePeriodBytes = this.encodeU32(preimageExpungePeriod)\n    buffer.set(expungePeriodBytes, offset)\n    offset += 4\n\n    // encode[4]{Cepochlen = 600}\n    const epochDuration = this.pvmInstance!.configEpochDuration\n    const epochLenBytes = this.encodeU32(epochDuration)\n    buffer.set(epochLenBytes, offset)\n    offset += 4\n\n    // encode[8]{Creportaccgas = 10000000}\n    const reportAccGasBytes = this.encodeU64(u64(WORK_REPORT_CONSTANTS.C_REPORTACCGAS))\n    buffer.set(reportAccGasBytes, offset)\n    offset += 8\n\n    // encode[8]{Cpackageauthgas = 50000000}\n    const packageAuthGasBytes = this.encodeU64(u64(AUTHORIZATION_CONSTANTS.C_PACKAGEAUTHGAS))\n    buffer.set(packageAuthGasBytes, offset)\n    offset += 8\n\n    // encode[8]{Cpackagerefgas = configMaxRefineGas}\n    const maxRefineGas = this.pvmInstance!.configMaxRefineGas\n    const packageRefGasBytes = this.encodeU64(maxRefineGas)\n    buffer.set(packageRefGasBytes, offset)\n    offset += 8\n\n    // encode[8]{Cblockaccgas = 3500000000}\n    const maxBlockGas = this.pvmInstance!.configMaxBlockGas\n    const blockAccGasBytes = this.encodeU64(maxBlockGas)\n    buffer.set(blockAccGasBytes, offset)\n    offset += 8\n\n    // encode[2]{Crecenthistorylen = 8}\n    const recentHistoryLenBytes = this.encodeU16(u16(HISTORY_CONSTANTS.C_RECENTHISTORYLEN))\n    buffer.set(recentHistoryLenBytes, offset)\n    offset += 2\n\n    // encode[2]{Cmaxpackageitems = 16}\n    const maxPackageItemsBytes = this.encodeU16(u16(WORK_PACKAGE_CONSTANTS.C_MAXPACKAGEITEMS))\n    buffer.set(maxPackageItemsBytes, offset)\n    offset += 2\n\n    // encode[2]{Cmaxreportdeps = 8}\n    const maxReportDepsBytes = this.encodeU16(u16(WORK_REPORT_CONSTANTS.C_MAXREPORTDEPS))\n    buffer.set(maxReportDepsBytes, offset)\n    offset += 2\n\n    // encode[2]{Cmaxblocktickets = configMaxTicketsPerExtrinsic}\n    const maxTicketsPerExtrinsic = this.pvmInstance!.configMaxTicketsPerExtrinsic\n    const maxBlockTicketsBytes = this.encodeU16(u16(maxTicketsPerExtrinsic))\n    buffer.set(maxBlockTicketsBytes, offset)\n    offset += 2\n\n    // encode[4]{Cmaxlookupanchorage = 14400}\n    const maxLookupAnchorage = this.pvmInstance!.configMaxLookupAnchorage\n    const maxLookupAnchorageBytes = this.encodeU32(maxLookupAnchorage)\n    buffer.set(maxLookupAnchorageBytes, offset)\n    offset += 4\n\n    // encode[2]{Cticketentries = 2}\n    const ticketsPerValidator = this.pvmInstance!.configTicketsPerValidator\n    const ticketEntriesBytes = this.encodeU16(ticketsPerValidator)\n    buffer.set(ticketEntriesBytes, offset)\n    offset += 2\n\n    // encode[2]{Cauthpoolsize = 8}\n    const authPoolSizeBytes = this.encodeU16(u16(AUTHORIZATION_CONSTANTS.C_AUTHPOOLSIZE))\n    buffer.set(authPoolSizeBytes, offset)\n    offset += 2\n\n    // encode[2]{Cslotseconds = 6}\n    // Note: configSlotDuration is in seconds (not milliseconds like TypeScript)\n    const slotDuration = this.pvmInstance!.configSlotDuration\n    const slotSecondsBytes = this.encodeU16(slotDuration)\n    buffer.set(slotSecondsBytes, offset)\n    offset += 2\n\n    // encode[2]{Cauthqueuesize = 80}\n    const authQueueSizeBytes = this.encodeU16(u16(AUTHORIZATION_CONSTANTS.C_AUTHQUEUESIZE))\n    buffer.set(authQueueSizeBytes, offset)\n    offset += 2\n\n    // encode[2]{Crotationperiod = 10}\n    const rotationPeriod = this.pvmInstance!.configRotationPeriod\n    const rotationPeriodBytes = this.encodeU16(rotationPeriod)\n    buffer.set(rotationPeriodBytes, offset)\n    offset += 2\n\n    // encode[2]{Cmaxpackagexts = 128}\n    const maxPackageXtsBytes = this.encodeU16(u16(WORK_PACKAGE_CONSTANTS.C_MAXPACKAGEXTS))\n    buffer.set(maxPackageXtsBytes, offset)\n    offset += 2\n\n    // encode[2]{Cassurancetimeoutperiod = 5}\n    const assuranceTimeoutPeriodBytes = this.encodeU16(u16(TIME_CONSTANTS.C_ASSURANCETIMEOUTPERIOD))\n    buffer.set(assuranceTimeoutPeriodBytes, offset)\n    offset += 2\n\n    // encode[2]{Cvalcount = 1023}\n    const numValidators = this.pvmInstance!.configNumValidators\n    const valCountBytes = this.encodeU16(numValidators)\n    buffer.set(valCountBytes, offset)\n    offset += 2\n\n    // encode[4]{Cmaxauthcodesize = 64000}\n    const maxAuthCodeSizeBytes = this.encodeU32(AUTHORIZATION_CONSTANTS.C_MAXAUTHCODESIZE)\n    buffer.set(maxAuthCodeSizeBytes, offset)\n    offset += 4\n\n    // encode[4]{Cmaxbundlesize = 13791360}\n    const maxBundleSizeBytes = this.encodeU32(WORK_PACKAGE_CONSTANTS.C_MAXBUNDLESIZE)\n    buffer.set(maxBundleSizeBytes, offset)\n    offset += 4\n\n    // encode[4]{Cmaxservicecodesize = 4000000}\n    const maxServiceCodeSizeBytes = this.encodeU32(SERVICE_CONSTANTS.C_MAXSERVICECODESIZE)\n    buffer.set(maxServiceCodeSizeBytes, offset)\n    offset += 4\n\n    // encode[4]{Cecpiecesize = 684}\n    const ecPieceSize = this.pvmInstance!.configEcPieceSize\n    const ecPieceSizeBytes = this.encodeU32(ecPieceSize)\n    buffer.set(ecPieceSizeBytes, offset)\n    offset += 4\n\n    // encode[4]{Cmaxpackageimports = 3072}\n    const maxPackageImportsBytes = this.encodeU32(WORK_PACKAGE_CONSTANTS.C_MAXPACKAGEIMPORTS)\n    buffer.set(maxPackageImportsBytes, offset)\n    offset += 4\n\n    // encode[4]{Csegmentecpieces = configNumEcPiecesPerSegment}\n    const numEcPiecesPerSegment = this.pvmInstance!.configNumEcPiecesPerSegment\n    const segmentEcPiecesBytes = this.encodeU32(numEcPiecesPerSegment)\n    buffer.set(segmentEcPiecesBytes, offset)\n    offset += 4\n\n    // encode[4]{Cmaxreportvarsize = 48*2^10 = 49152}\n    const maxReportVarSizeBytes = this.encodeU32(WORK_REPORT_CONSTANTS.C_MAXREPORTVARSIZE)\n    buffer.set(maxReportVarSizeBytes, offset)\n    offset += 4\n\n    // encode[4]{Cmemosize = 128}\n    const memoSizeBytes = this.encodeU32(TRANSFER_CONSTANTS.C_MEMOSIZE)\n    buffer.set(memoSizeBytes, offset)\n    offset += 4\n\n    // encode[4]{Cmaxpackageexports = 3072}\n    const maxPackageExportsBytes = this.encodeU32(WORK_PACKAGE_CONSTANTS.C_MAXPACKAGEEXPORTS)\n    buffer.set(maxPackageExportsBytes, offset)\n    offset += 4\n\n    // encode[4]{Cepochtailstart = configContestDuration}\n    const contestDuration = this.pvmInstance!.configContestDuration\n    const epochTailStartBytes = this.encodeU32(contestDuration)\n    buffer.set(epochTailStartBytes, offset)\n\n    return buffer\n  }\n\n\n  getWorkItemPayload(\n    params: FetchParams,\n    itemIndex: u64,\n  ): Uint8Array | null {\n    // Gray Paper: p.workitems[registers[11]].payload when p  none  registers[10] = 13\n    // Returns payload of specific work item\n\n    if (!params.workPackage) {\n      return null\n    }\n\n    const workPackage = params.workPackage!\n    const workItems = workPackage.workItems\n    const itemIdx = i32(itemIndex)\n\n    if (itemIdx >= workItems.length) {\n      return null\n    }\n\n    const workItem = workItems[itemIdx]\n    return workItem.payload\n  }\n\n\n  getAccumulateInputByIndex(\n    params: FetchParams,\n    itemIndex: u64,\n  ): Uint8Array | null {\n    // Gray Paper pvm_invocations.tex line 360: registers[10] = 15\n    // Returns: encode{i[registers[11]]} when i  none  registers[11] < len(i)\n    // Where i is sequence{accinput} - the accumulate inputs sequence\n    // Gray Paper equation 126: accinput = operandtuple  defxfer\n\n    if (!params.accumulateInputs) {\n      return null\n    }\n\n    const inputs = params.accumulateInputs!\n    const idx = i32(itemIndex)\n\n    if (idx >= inputs.length) {\n      return null\n    }\n\n    const input = inputs[idx]\n    // Pass JAM version from PVM instance for version-aware encoding\n    const jamMajor = this.pvmInstance ? this.pvmInstance!.jamVersionMajor : u8(0)\n    const jamMinor = this.pvmInstance ? this.pvmInstance!.jamVersionMinor : u8(7)\n    const jamPatch = this.pvmInstance ? this.pvmInstance!.jamVersionPatch : u8(2)\n    const encoded = encodeAccumulateInput(input, jamMajor, jamMinor, jamPatch)\n    return encoded\n  }\n}\n","import { CompleteServiceAccount, PreimageRequestStatus, getPreimageValue, getRequestValue, decodeRequestTimeslots } from '../../codec'\nimport { HostFunctionResult } from '../accumulate/base'\nimport { HostFunctionContext, HostFunctionParams, HistoricalLookupParams } from './base'\nimport {\n  ACCUMULATE_ERROR_CODES,\n  GENERAL_FUNCTIONS,\n  RESULT_CODES,\n} from '../../config'\nimport { BaseHostFunction } from './base'\n\n/**\n * HISTORICAL_LOOKUP host function (_H)\n *\n * Performs historical lookup of preimages using histlookup function\n *\n * Gray Paper Specification:\n * - Function ID: 6 (historical_lookup)\n * - Gas Cost: 10\n * - Signature: _H(gascounter, registers, memory, (m, e), s, d, t)\n *   - (m, e) = refine context (machines, export segments)\n *   - s = current service ID\n *   - d = accounts dictionary\n *   - t = timeslot for historical lookup\n * - Uses registers[7] to specify service account (NONE for self)\n * - Uses registers[8:2] to specify hash and output offset in memory\n * - Uses registers[10:2] to specify from offset and length\n * - Uses histlookup(serviceAccount, timeslot, hash) to get historical data\n * - Writes result to memory at specified offset\n * - Returns NONE if not found, length if found\n *\n * Gray Paper Logic:\n * a = service account (self if registers[7] = NONE, otherwise accounts[registers[7]])\n * h = memory[registers[8]:32] (hash)\n * o = registers[9] (output offset)\n * f = registers[10] (from offset)\n * l = registers[11] (length)\n * v = histlookup(a, t, h) if a exists, NONE otherwise\n * if v != NONE: write v[f:f+l] to memory[o:o+l], return len(v)\n * else: return NONE\n */\n\nexport class HistoricalLookupHostFunction extends BaseHostFunction {\n  functionId: u64 = GENERAL_FUNCTIONS.HISTORICAL_LOOKUP\n  name: string = 'historical_lookup'\n\n  execute(\n    context: HostFunctionContext,\n    params: HostFunctionParams | null,\n  ): HostFunctionResult {\n    if (!params) {\n      return new HostFunctionResult(RESULT_CODES.PANIC)\n    }\n    const lookupParams = params as HistoricalLookupParams\n    // Gray Paper: Extract parameters from registers\n    // registers[7] = service ID selector (NONE for self, or specific service ID)\n    // registers[8:2] = (hash offset, output offset)\n    // registers[10:2] = (from offset, length)\n    const requestedServiceId = context.registers[7]\n    const hashOffset = context.registers[8]\n    const outputOffset = context.registers[9]\n    const fromOffset = context.registers[10]\n    const length = context.registers[11]\n\n    // Gray Paper equation 508-511: Determine service account\n    // a = {\n    //   d[s] if registers[7] = NONE (2^64 - 1) AND s in keys(d)\n    //   d[registers[7]] if registers[7] in keys(d)\n    //   none otherwise\n    // }\n    let serviceAccount: CompleteServiceAccount | null = null\n    if (\n      requestedServiceId === ACCUMULATE_ERROR_CODES.NONE &&\n      lookupParams.accounts.has(lookupParams.serviceId)\n    ) {\n      // registers[7] = NONE, use self (s)\n      serviceAccount = lookupParams.accounts.get(lookupParams.serviceId) || null\n    } else if (lookupParams.accounts.has(requestedServiceId)) {\n      // registers[7] specifies a service ID in accounts\n      serviceAccount = lookupParams.accounts.get(requestedServiceId) || null\n    }\n\n    if (!serviceAccount) {\n      // Gray Paper: Return NONE if service account not found\n      context.registers[7] = ACCUMULATE_ERROR_CODES.NONE\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Gray Paper: Read hash from memory (32 bytes at hashOffset)\n    const readResult_hashData = context.ram.readOctets(u32(hashOffset), 32)\n    const hashData = readResult_hashData.data\n    const readFaultAddress = readResult_hashData.faultAddress\n    if (hashData === null || readFaultAddress !== 0) {\n      // Gray Paper: Return panic if memory range not readable\n      return new HostFunctionResult(RESULT_CODES.PANIC)\n    }\n\n    // Gray Paper equation 517: histlookup(a, t, memory[h:32])\n    // Perform historical lookup using histlookup function\n    // We use the service account we determined from the lookup logic\n    // serviceAccount is guaranteed to be non-null here due to check above\n    \n    // Determine actual service ID for the lookup\n    const actualServiceId: u32 = requestedServiceId === ACCUMULATE_ERROR_CODES.NONE\n      ? u32(lookupParams.serviceId)\n      : u32(requestedServiceId)\n    \n    const preimage = this.histLookupServiceAccount(\n      serviceAccount,\n      actualServiceId,\n      hashData,\n      lookupParams.lookupTimeslot,\n    )\n    if (!preimage) {\n      // Return NONE (2^64 - 1) for not found\n      context.registers[7] = ACCUMULATE_ERROR_CODES.NONE\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Calculate slice parameters\n    const f = i32(fromOffset)\n    const l = i32(length)\n    const preimageLength = preimage.length\n\n    // Calculate actual slice length\n    const actualLength = min(l, preimageLength - f)\n\n    if (actualLength <= 0) {\n      // Return NONE if no data to copy\n      context.registers[7] = ACCUMULATE_ERROR_CODES.NONE\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Extract data slice\n    const dataToWrite = preimage.slice(f, f + actualLength)\n\n    // Write preimage slice to memory\n    const writeResult = context.ram.writeOctets(u32(outputOffset), dataToWrite)\n    if (writeResult.hasFault) {\n      return new HostFunctionResult(RESULT_CODES.PANIC)\n    }\n\n    // Return length of preimage\n    context.registers[7] = u64(preimageLength)\n\n    return new HostFunctionResult(255) // continue execution\n  }\n\n  /**\n   * Gray Paper histlookup function\n   *\n   * Gray Paper equation 115-127:\n   * histlookup(a, t, h)  a.sa_preimages[h] when h  keys(a.sa_preimages)  I(a.sa_requests[h, len(a.sa_preimages[h])], t)\n   *\n   * @param serviceAccount - Service account containing preimages and requests\n   * @param serviceId - Service ID for the account\n   * @param hashBytes - Hash to lookup (as Uint8Array)\n   * @param timeslot - Timeslot for historical lookup\n   * @returns Preimage blob or null if not found/not available\n   */\n  private histLookupServiceAccount(\n    serviceAccount: CompleteServiceAccount,\n    serviceId: u32,\n    hashBytes: Uint8Array,\n    timeslot: u64,\n  ): Uint8Array | null {\n    // Get the preimage for this hash using rawCshKeyvals helper\n    const preimage = getPreimageValue(serviceAccount, serviceId, hashBytes)\n    if (!preimage) {\n      return null\n    }\n\n    const length = u64(preimage.length)\n\n    // Get the request status for this hash and length using rawCshKeyvals helper\n    const requestValue = getRequestValue(serviceAccount, serviceId, hashBytes, length)\n    if (!requestValue) {\n      return null\n    }\n    \n    // Decode the request timeslots\n    const timeslots = decodeRequestTimeslots(requestValue)\n    if (!timeslots) {\n      return null\n    }\n\n    // Apply the Gray Paper histlookup logic using I(l, t) function\n    const isValid = this.checkRequestValidityArray(timeslots, timeslot)\n\n    if (!isValid) {\n      return null\n    }\n\n    return preimage\n  }\n\n  /**\n   * Check if a request is available at a given time using Gray Paper function I(l, t)\n   *\n   * Gray Paper equation 120-125:\n   * I(l, t) = false when [] = l\n   * I(l, t) = x  t when [x] = l\n   * I(l, t) = x  t < y when [x, y] = l\n   * I(l, t) = x  t < y  z  t when [x, y, z] = l\n   *\n   * @param timeslots - Array of timeslots (up to 3)\n   * @param timeslot - Timeslot to check availability\n   * @returns True if preimage is available at the given timeslot\n   */\n  private checkRequestValidityArray(\n    timeslots: u32[],\n    timeslot: u64,\n  ): bool {\n    switch (timeslots.length) {\n      case 0:\n        // Empty request - not available\n        return false\n\n      case 1:\n        // [x] - available from x onwards\n        return u64(timeslots[0]) <= timeslot\n\n      case 2:\n        // [x, y] - available from x to y (exclusive)\n        return u64(timeslots[0]) <= timeslot && timeslot < u64(timeslots[1])\n\n      case 3:\n        // [x, y, z] - available from x to y OR from z onwards\n        return (\n          (u64(timeslots[0]) <= timeslot && timeslot < u64(timeslots[1])) ||\n          u64(timeslots[2]) <= timeslot\n        )\n\n      default:\n        // Invalid request format - not available\n        return false\n    }\n  }\n}\n","import { HostFunctionResult } from '../accumulate/base'\nimport {\n  HostFunctionContext,\n  HostFunctionParams,\n  LookupParams,\n} from './base'\nimport { CompleteServiceAccount, getPreimageValue } from '../../codec'\nimport {\n  ACCUMULATE_ERROR_CODES,\n  GENERAL_FUNCTIONS,\n  RESULT_CODES,\n} from '../../config'\nimport { BaseHostFunction } from './base'\n\n/**\n * LOOKUP host function (_L)\n *\n * Looks up preimages from service account storage\n *\n * Gray Paper Specification (pvm_invocations.tex lines 374-396):\n * - Function ID: 2 (lookup)\n * - Gas Cost: 10\n * - Signature: _L(gascounter, registers, memory, s, s, d)\n *   - s = current service account\n *   - s = current service ID\n *   - d = accounts dictionary\n *\n * Service account selection (a):\n *   a = s (current service)       when registers[7]  {s, 2^64 - 1}\n *   a = d[registers[7]]           when registers[7]  keys{d}\n *   a = none                      otherwise\n *\n * Register usage:\n *   registers[7] = service ID to query (or s/2^64-1 for self)\n *   registers[8] = hash offset (h) - 32 bytes to read from memory\n *   registers[9] = output offset (o) - where to write result\n *   registers[10] = from offset (f) in preimage\n *   registers[11] = length (l) to copy\n *\n * Value lookup (v):\n *   v = error  when hash memory not readable\n *   v = none   when a = none OR memory[h:32]  keys{a.preimages}\n *   v = a.preimages[memory[h:32]] otherwise\n *\n * Slice parameters:\n *   f = min(registers[10], len{v})\n *   l = min(registers[11], len{v} - f)\n *\n * Result:\n *   - PANIC if v = error OR output memory not writable\n *   - registers[7] = NONE if v = none\n *   - registers[7] = len{v}, memory[o:l] = v[f:l] otherwise\n *\n * NOTE: LOOKUP is READ-ONLY - it does NOT modify service accounts!\n */\n\nexport class LookupHostFunction extends BaseHostFunction {\n  functionId: u64 = GENERAL_FUNCTIONS.LOOKUP\n  name: string = 'lookup'\n\n  execute(\n    context: HostFunctionContext,\n    params: HostFunctionParams | null,\n  ): HostFunctionResult {\n    if (!params) {\n      return new HostFunctionResult(RESULT_CODES.PANIC)\n    }\n    const lookupParams = params as LookupParams\n    const queryServiceId = context.registers[7]\n    const hashOffset = context.registers[8]\n    const outputOffset = context.registers[9]\n    const fromOffset = context.registers[10]\n    const length = context.registers[11]\n\n    // Gray Paper: a = service account to query\n    // a = s (self)       when registers_7  {s, 2^64 - 1}\n    // a = d[registers_7] when registers_7  keys{d}\n    // a = none           otherwise\n    const MAX_U64: u64 = u64.MAX_VALUE // 2^64 - 1\n\n    let serviceAccount: CompleteServiceAccount | null = null\n\n    if (\n      queryServiceId == lookupParams.serviceId ||\n      queryServiceId == MAX_U64\n    ) {\n      // Query self\n      if (lookupParams.accounts.has(lookupParams.serviceId)) {\n        serviceAccount = lookupParams.accounts.get(lookupParams.serviceId)\n      }\n    } else if (lookupParams.accounts.has(queryServiceId)) {\n      // Query another service from accounts dictionary\n      serviceAccount = lookupParams.accounts.get(queryServiceId)\n    }\n    // else: serviceAccount remains null (a = none)\n\n    // Read hash from memory (32 bytes)\n    // Gray Paper: v = error when N[h,32]  readable{memory}\n    const readResult_hashData = context.ram.readOctets(u32(hashOffset), 32)\n    const hashData = readResult_hashData.data\n    const hashFaultAddress = readResult_hashData.faultAddress\n    if (hashData === null || hashFaultAddress !== 0) {\n      // v = error - memory not readable\n      return new HostFunctionResult(RESULT_CODES.PANIC)\n    }\n\n    // Gray Paper: v = none when a = none  memory[h:32]  keys{a.preimages}\n    if (serviceAccount === null) {\n      // a = none - service account not found\n      context.registers[7] = ACCUMULATE_ERROR_CODES.NONE\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Determine the actual service ID to use for the lookup\n    // Gray Paper: a = s when registers[7]  {s, 2^64 - 1}\n    const actualServiceId: u32 = queryServiceId == MAX_U64 \n      ? u32(lookupParams.serviceId) \n      : u32(queryServiceId)\n\n    // Look up preimage by hash using rawCshKeyvals helper\n    // This matches TypeScript's getServicePreimageValue()\n    const preimage = getPreimageValue(serviceAccount, actualServiceId, hashData)\n    if (!preimage) {\n      // v = none - preimage not found\n      context.registers[7] = ACCUMULATE_ERROR_CODES.NONE\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // v found - calculate slice parameters\n    // Gray Paper: f = min(registers[10], len{v})\n    //             l = min(registers[11], len{v} - f)\n    const preimageLength = preimage.length\n    const f: i32 = fromOffset < u64(preimageLength)\n      ? i32(fromOffset)\n      : preimageLength\n    const remainingAfterF: i32 = preimageLength - f\n    const l: i32 = length < u64(remainingAfterF)\n      ? i32(length)\n      : remainingAfterF\n\n    // Only write if there's data to write\n    if (l > 0) {\n    // Extract data slice\n      const dataToWrite = preimage.slice(f, f + l)\n\n    // Write preimage slice to memory\n      // Gray Paper: PANIC if N[o,l]  writable{memory}\n    const writeResult = context.ram.writeOctets(u32(outputOffset), dataToWrite)\n    if (writeResult.hasFault) {\n      return new HostFunctionResult(RESULT_CODES.PANIC)\n      }\n    }\n\n    // Gray Paper: Return len{v} (full preimage length, not slice length)\n    context.registers[7] = u64(preimageLength)\n\n    return new HostFunctionResult(255) // continue execution\n  }\n}\n","import { RESULT_CODE_PANIC } from '../../config'\nimport { CompleteServiceAccount, getStorageValue } from '../../codec'\nimport {\n  ACCUMULATE_ERROR_NONE,\n  HostFunctionResult,\n} from '../accumulate/base'\nimport { HostFunctionContext, HostFunctionParams, ReadParams } from './base'\nimport { BaseHostFunction } from './base'\n\n/**\n * READ host function (_R)\n *\n * Reads storage data from service accounts\n *\n * Gray Paper Specification:\n * - Function ID: 3 (read)\n * - Gas Cost: 10 (plus cold read costs)\n * - Uses registers[7] to specify service account (or self if 2^64-1)\n * - Uses registers[8:3] to specify key offset, key length, and output offset\n * - Reads storage value by key from service account's storage\n * - Writes result to memory at specified offset\n * - Returns NONE if not found, length if found\n */\n\nexport class ReadHostFunction extends BaseHostFunction {\n  functionId: u64 = u64(3) // READ function ID\n  name: string = 'read'\n  gasCost: u64 = u64(10)\n\n  execute(\n    context: HostFunctionContext,\n    params: HostFunctionParams | null,\n  ): HostFunctionResult {\n    if (!params) {\n      context.registers[7] = ACCUMULATE_ERROR_NONE\n      return new HostFunctionResult(255)\n    }\n    const readParams = params as ReadParams\n\n    // Gray Paper equation 404-407: Determine service account\n    // s^* = s when registers[7] = 2^64 - 1 (NONE), otherwise registers[7]\n    const requestedServiceId =\n      u64(context.registers[7]) === ACCUMULATE_ERROR_NONE\n        ? readParams.serviceId\n        : u64(context.registers[7])\n\n    // Gray Paper equation 408-412: Select service account\n    // a = s when s^* = s, otherwise d[s^*] if s^* in keys(d), otherwise none\n    let serviceAccount: CompleteServiceAccount | null = null\n    if (requestedServiceId === readParams.serviceId) {\n      serviceAccount = readParams.serviceAccount\n    } else if (readParams.accounts.has(requestedServiceId)) {\n      serviceAccount = readParams.accounts.get(requestedServiceId)\n    }\n\n    const keyOffset = u64(context.registers[8])\n    const keyLength = u64(context.registers[9])\n    const outputOffset = u64(context.registers[10])\n    const fromOffset = u64(context.registers[11])\n    const length = u64(context.registers[12])\n\n    // Read key from memory\n    const readResult_key = context.ram.readOctets(u32(keyOffset), u32(keyLength))\n    const key = readResult_key.data\n    const faultAddress = readResult_key.faultAddress\n    if (key === null || faultAddress !== 0) {\n      // Gray Paper line 420: registers_7 remains UNCHANGED on panic\n      // Do NOT set context.registers[7] - just return PANIC\n      return new HostFunctionResult(RESULT_CODE_PANIC)\n    }\n\n    // Gray Paper equation 423: Return NONE if service account not found\n    if (!serviceAccount) {\n      context.registers[7] = ACCUMULATE_ERROR_NONE\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Gray Paper equation 414-418: Read storage value by key using rawCshKeyvals helper\n    // v = a_storage[k] if a != none and k in keys(a_storage), otherwise none\n    const value = getStorageValue(serviceAccount, u32(requestedServiceId), key!)\n    if (!value) {\n      // Gray Paper equation 423: Return NONE if storage key not found\n      context.registers[7] = ACCUMULATE_ERROR_NONE\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Gray Paper equation 419-420: Calculate slice parameters\n    // f = min(registers[11], len(v))\n    // l = min(registers[12], len(v) - f)\n    const f = min(i32(fromOffset), value.length)\n    const l = min(i32(length), value.length - f)\n    const dataToWrite = value.slice(f, f + l)\n\n    // Gray Paper equation 421-425: Write to memory and return result\n    // Write v[f:l] to memory at offset o (registers[10])\n    const writeResult = context.ram.writeOctets(u32(outputOffset), dataToWrite)\n    if (writeResult.hasFault) {\n      // Gray Paper equation 422: Return panic if memory not writable\n      return new HostFunctionResult(RESULT_CODE_PANIC)\n    }\n\n    // Gray Paper equation 424: Return len(v) in registers[7]\n    context.registers[7] = u64(value.length)\n\n    return new HostFunctionResult(255) // continue execution\n  }\n}\n","import { CompleteServiceAccount } from '../../codec'\nimport { HostFunctionResult } from '../accumulate/base'\nimport { HostFunctionContext, HostFunctionParams, InfoParams } from './base'\nimport {\n  ACCUMULATE_ERROR_CODES,\n  GENERAL_FUNCTIONS,\n  RESULT_CODES,\n} from '../../config'\nimport { BaseHostFunction } from './base'\n\n/**\n * INFO host function (_I)\n *\n * Gets information about service accounts\n *\n * Gray Paper Specification (pvm-invocations.tex line 193, 457-482):\n * - Function ID: 5 (info)\n * - Gas Cost: 10\n * - Signature: _I(gascounter, registers, memory, s, d)\n *   - s = service ID (from Implications)\n *   - d = accounts dictionary (from PartialState)\n * - Uses registers[7] to specify service account (NONE for self, or specific service ID)\n * - Uses registers[8] for output offset (o)\n * - Uses registers[9] for from offset (f)\n * - Uses registers[10] for length (l)\n * - Returns encoded service account info (codehash, balance, gas limits, etc.)\n * - Writes result to memory at specified offset\n */\n\nexport class InfoHostFunction extends BaseHostFunction {\n  functionId: u64 = GENERAL_FUNCTIONS.INFO\n  name: string = 'info'\n\n  execute(\n    context: HostFunctionContext,\n    params: HostFunctionParams | null,\n  ): HostFunctionResult {\n    if (!params) {\n      return new HostFunctionResult(RESULT_CODES.PANIC)\n    }\n    const infoParams = params as InfoParams\n    // Gray Paper: Extract parameters from registers\n    // registers[7] = service ID selector (NONE for self, or specific service ID)\n    // registers[8] = output offset (o)\n    // registers[9] = from offset (f)\n    // registers[10] = length (l)\n    const requestedServiceId = context.registers[7]\n    const outputOffset = context.registers[8]\n    const fromOffset = context.registers[9]\n    const length = context.registers[10]\n\n    // Gray Paper equation 460-463: Determine service account\n    // a = {\n    //   d[s] if registers[7] = NONE (2^64 - 1)\n    //   d[registers[7]] otherwise\n    // }\n    let serviceAccount: CompleteServiceAccount | null = null\n    if (requestedServiceId === ACCUMULATE_ERROR_CODES.NONE) {\n      // registers[7] = NONE, use self (s)\n      serviceAccount = infoParams.accounts.get(infoParams.serviceId) || null\n    } else if (infoParams.accounts.has(requestedServiceId)) {\n      // registers[7] specifies a service ID in accounts\n      serviceAccount = infoParams.accounts.get(requestedServiceId) || null\n    }\n\n    if (!serviceAccount) {\n      // Gray Paper: Return NONE if service account not found\n      context.registers[7] = ACCUMULATE_ERROR_CODES.NONE\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Gray Paper equation 466-473: Encode service account info for INFO host function\n    // INFO uses a different format than merklization (pvm_invocations.tex vs merklization.tex)\n    // Format: codehash + encode[8]{balance, minbalance, minaccgas, minmemogas, octets} +\n    //         encode[4]{items} + encode[8]{gratis} + encode[4]{created, lastacc, parent}\n    // Total: 32 + 40 + 4 + 8 + 12 = 96 bytes\n\n    // Calculate minbalance: max(0, Cbasedeposit + Citemdeposit * items + Cbytedeposit * octets - gratis)\n    const C_BASEDEPOSIT: u64 = u64(100)\n    const C_ITEMDEPOSIT: u64 = u64(10)\n    const C_BYTEDEPOSIT: u64 = u64(1)\n    const baseDeposit = C_BASEDEPOSIT\n    const itemDeposit = C_ITEMDEPOSIT * serviceAccount.items\n    const byteDeposit = C_BYTEDEPOSIT * serviceAccount.octets\n    const totalDeposit = baseDeposit + itemDeposit + byteDeposit\n    const minbalance =\n      totalDeposit > serviceAccount.gratis\n        ? totalDeposit - serviceAccount.gratis\n        : u64(0)\n\n    // Encode using INFO-specific format (96 bytes, includes minbalance)\n    // Gray Paper pvm_invocations.tex format (NOT merklization format)\n    const info = new Uint8Array(96) // Total: 32 + 40 + 4 + 8 + 12 = 96 bytes\n    const view = new DataView(info.buffer)\n\n    // 1. codehash (32 bytes)\n    // codehash is already a Uint8Array in CompleteServiceAccount\n    info.set(serviceAccount.codehash, 0)\n\n    // 2. encode[8]{balance, minbalance, minaccgas, minmemogas, octets} (40 bytes)\n    view.setUint64(32, serviceAccount.balance, true) // balance at offset 32\n    view.setUint64(40, minbalance, true) // minbalance at offset 40\n    view.setUint64(48, serviceAccount.minaccgas, true) // minaccgas at offset 48\n    view.setUint64(56, serviceAccount.minmemogas, true) // minmemogas at offset 56\n    view.setUint64(64, serviceAccount.octets, true) // octets at offset 64\n\n    // 3. encode[4]{items} (4 bytes)\n    view.setUint32(72, serviceAccount.items, true) // items at offset 72\n\n    // 4. encode[8]{gratis} (8 bytes)\n    view.setUint64(76, serviceAccount.gratis, true) // gratis at offset 76\n\n    // 5. encode[4]{created, lastacc, parent} (12 bytes)\n    view.setUint32(84, serviceAccount.created, true) // created at offset 84\n    view.setUint32(88, serviceAccount.lastacc, true) // lastacc at offset 88\n    view.setUint32(92, serviceAccount.parent, true) // parent at offset 92\n\n    // Gray Paper equation 475-476: Calculate slice parameters\n    // f = min(registers[9], len(v))\n    // l = min(registers[10], len(v) - f)\n    const f = min(i32(fromOffset), info.length)\n    const l = min(i32(length), info.length - f)\n\n    if (l <= 0) {\n      // Return NONE if no data to copy\n      context.registers[7] = ACCUMULATE_ERROR_CODES.NONE\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Gray Paper equation 480: Extract slice v[f:f+l]\n    const dataSlice = info.slice(f, f + l)\n    \n    // Pad to requested length if needed (to match jamduna behavior)\n    // Gray Paper equation 478: Write to memory[o:o+l]\n    // Note: l is the actual slice length, but if requested length > actual length,\n    // jamduna pads with zeros to the requested length\n    const requestedWriteLength = i32(length)\n    let dataToWrite: Uint8Array\n    if (requestedWriteLength > dataSlice.length) {\n      // Pad with zeros to requested length\n      dataToWrite = new Uint8Array(requestedWriteLength)\n      for (let i = 0; i < dataSlice.length; i++) {\n        dataToWrite[i] = dataSlice[i]\n      }\n      // Remaining bytes are already zero (default Uint8Array initialization)\n    } else {\n      dataToWrite = dataSlice\n    }\n\n    // Gray Paper equation 478: Write to memory[o:o+l]\n    const writeResult = context.ram.writeOctets(u32(outputOffset), dataToWrite)\n    if (writeResult.hasFault) {\n      // Gray Paper: Return panic if memory not writable\n      return new HostFunctionResult(RESULT_CODES.PANIC)\n    }\n\n    // Gray Paper equation 480: Return length of full info data (v)\n    // Like FETCH, INFO returns len(v) = 96 (the full info length), not the written slice length\n    context.registers[7] = u64(info.length)\n\n    return new HostFunctionResult(255) // continue execution\n  }\n}\n","import { HostFunctionResult } from '../accumulate/base'\nimport { HostFunctionContext, HostFunctionParams, ExportParams } from './base'\nimport {\n  ACCUMULATE_ERROR_CODES,\n  GENERAL_FUNCTIONS,\n  MAX_PACKAGE_EXPORTS,\n  RESULT_CODES,\n  SEGMENT_SIZE,\n} from '../../config'\nimport { BaseHostFunction } from './base'\n\n/**\n * EXPORT host function (_E)\n *\n * Gray Paper Specification (pvm_invocations.tex, lines 529-544):\n * - Function ID: 7 (export)\n * - Gas Cost: 10\n * - Uses registers[7] for memory offset (p)\n * - Uses registers[8] for length, capped at Csegmentsize (4104)\n * - Creates zero-padded segment of exactly Csegmentsize\n * - Appends segment to export sequence\n * - Returns FULL if segoff + len() >= Cmaxpackageexports (3072)\n * - Otherwise returns segoff + len()\n */\n\nexport class ExportHostFunction extends BaseHostFunction {\n  functionId: u64 = GENERAL_FUNCTIONS.EXPORT\n  name: string = 'export'\n\n  execute(\n    context: HostFunctionContext,\n    params: HostFunctionParams | null,\n  ): HostFunctionResult {\n    if (!params) {\n      return new HostFunctionResult(RESULT_CODES.PANIC)\n    }\n    const exportParams = params as ExportParams\n    if (!exportParams.refineContext) {\n      return new HostFunctionResult(RESULT_CODES.PANIC)\n    }\n\n    // Gray Paper: p = registers[7]\n    const memoryOffset = u32(context.registers[7])\n    // Gray Paper: z = min(registers[8], Csegmentsize)\n    const rawLength = u32(context.registers[8])\n    const cappedLength =\n      rawLength < SEGMENT_SIZE\n        ? rawLength\n        : SEGMENT_SIZE\n\n    // Gray Paper: Check if Nrange[p][z]  readable[memory]\n    const readableResult = context.ram.isReadableWithFault(\n      memoryOffset,\n      cappedLength,\n    )\n    const readable = readableResult.success\n    const readableFaultAddress = readableResult.faultAddress\n    if (!readable) {\n      // Gray Paper: Return PANIC if memory not readable\n      context.registers[7] = u64(0)\n      return new HostFunctionResult(RESULT_CODES.PANIC)\n    }\n\n    // Gray Paper: Read data from memory\n    const readResult = context.ram.readOctets(\n      memoryOffset,\n      cappedLength,\n    )\n    const data = readResult.data\n    const readFaultAddress = readResult.faultAddress\n    if (data === null || readFaultAddress !== 0) {\n      context.registers[7] = u64(0)\n      return new HostFunctionResult(RESULT_CODES.PANIC)\n    }\n\n    // Gray Paper: Create zero-padded segment of Csegmentsize\n    const segment = this.createZeroPaddedSegment(data)\n\n    // Gray Paper: Append to export sequence and check limits\n    const result = this.appendToExports(exportParams, segment)\n\n    if (result === -1) {\n      // Gray Paper: Return FULL (2^64 - 5)\n      context.registers[7] = ACCUMULATE_ERROR_CODES.FULL\n    } else {\n      // Gray Paper: Return segoff + len()\n      context.registers[7] = u64(result)\n    }\n\n    return new HostFunctionResult(255) // Continue execution\n  }\n\n  /**\n   * Gray Paper: Create zero-padded segment of exactly Csegmentsize\n   * zeropad{Csegmentsize}{mem[p:p+z]}\n   */\n  createZeroPaddedSegment(data: Uint8Array): Uint8Array {\n    const segment = new Uint8Array(SEGMENT_SIZE)\n    segment.set(data, 0)\n    // Remaining bytes are already zero (Uint8Array initialization)\n    return segment\n  }\n\n  /**\n   * Gray Paper: Append segment to export sequence ()\n   * Check if segoff + len() >= Cmaxpackageexports\n   * Return FULL if limit exceeded, otherwise return segoff + len()\n   */\n  appendToExports(\n    params: ExportParams,\n    segment: Uint8Array,\n  ): i64 {\n    if (!params.refineContext) {\n      return -1 // FULL indicator\n    }\n    const exportSegments = params.refineContext!.exportSegments\n    const segoff = params.segmentOffset\n\n    // Gray Paper: Check if segoff + len() >= Cmaxpackageexports\n    const currentLength = i64(exportSegments.length)\n    if (segoff + currentLength >= i64(MAX_PACKAGE_EXPORTS)) {\n      return -1 // FULL indicator\n    }\n\n    // Gray Paper: Append segment\n    exportSegments.push(segment)\n\n    // Gray Paper: Return segoff + len()\n    return segoff + currentLength\n  }\n}\n","import { RefineInvocationContext } from '../../pbnj-types-compat'\nimport { PVMGuest } from './base'\nimport { HostFunctionResult } from '../accumulate/base'\nimport { HostFunctionContext, HostFunctionParams, MachineParams } from './base'\nimport {\n  ACCUMULATE_ERROR_CODES,\n  GENERAL_FUNCTIONS,\n  RESULT_CODES,\n} from '../../config'\nimport { PVM } from '../../pvm'\nimport { BaseHostFunction } from './base'\nimport { HostFunctionRegistry } from './registry'\nimport { PVMRAM } from '../../ram'\n\n/**\n * MACHINE host function (_M)\n *\n * Creates a new PVM machine instance\n *\n * Gray Paper Specification:\n * - Function ID: 8 (machine)\n * - Gas Cost: 10\n * - Uses registers[7:3] to specify program offset, length, and initial PC\n * - Creates new PVM guest machine with specified program\n * - Returns machine ID in registers[7]\n * - Returns HUH if program is invalid\n */\nexport class MachineHostFunction extends BaseHostFunction {\n  functionId: u64 = GENERAL_FUNCTIONS.MACHINE\n  name: string = 'machine'\n  gasCost: u64 = 10\n\n  hostFunctionRegistry: HostFunctionRegistry\n  constructor(hostFunctionRegistry: HostFunctionRegistry) {\n    super()\n    this.hostFunctionRegistry = hostFunctionRegistry\n  }\n\n  execute(\n    context: HostFunctionContext,\n    params: HostFunctionParams | null,\n  ): HostFunctionResult {\n    if (!params) {\n      return new HostFunctionResult(RESULT_CODES.PANIC)\n    }\n    const machineParams = params as MachineParams\n    if (!machineParams.refineContext) {\n      return new HostFunctionResult(RESULT_CODES.PANIC)\n    }\n    // Validate execution\n    if (context.gasCounter < u32(this.gasCost)) {\n      return new HostFunctionResult(RESULT_CODES.OOG)\n    }\n\n    context.gasCounter -= u32(this.gasCost)\n\n    const programOffset = u32(context.registers[7])\n    const programLength = u32(context.registers[8])\n    const initialPC = context.registers[9]\n\n    // Read program from memory\n    const readResult_programData = context.ram.readOctets(\n      programOffset,\n      programLength,\n    )\n    const programData = readResult_programData.data\n    const programFaultAddress = readResult_programData.faultAddress\n    if (programData === null || programFaultAddress !== 0) {\n      return new HostFunctionResult(u8(RESULT_CODES.FAULT))\n    }\n\n    const refineContext = machineParams.refineContext!\n    const machines = refineContext.machines\n\n    // Create new PVM machine\n    const machineId = this.createPVMMachine(machines, programData, initialPC)\n\n    // Return machine ID\n    context.registers[7] = machineId\n\n    return new HostFunctionResult(255) // continue execution\n  }\n\n  createPVMMachine(\n    machines: Map<u64, PVMGuest>,\n    program: Uint8Array,\n    initialPC: u64,\n  ): u64 {\n    // Generate new machine ID\n    const machineId = u64(machines.size + 1)\n\n    // Create PVM instance\n    // Initialize with empty registers, new RAM, initial PC, and default gas\n    const registerState = new StaticArray<u64>(13)\n    for (let i: i32 = 0; i < 13; i++) {\n      registerState[i] = 0\n    }\n    const ram = new PVMRAM()\n    const pvm = new PVM(registerState, ram, u32(initialPC), 0, this.hostFunctionRegistry)\n\n    // Add machine to context\n    const guest = new PVMGuest(pvm)\n    machines.set(machineId, guest)\n\n    return machineId\n  }\n}\n","import { RESULT_CODE_PANIC } from '../../config'\nimport {\n  ACCUMULATE_ERROR_OK,\n  ACCUMULATE_ERROR_OOB,\n  ACCUMULATE_ERROR_WHO,\n  HostFunctionResult,\n} from '../accumulate/base'\nimport {\n  HostFunctionContext,\n  HostFunctionParams,\n  PeekPokeParams,\n  PVMGuest,\n  RefineInvocationContext,\n} from './base'\nimport { BaseHostFunction } from './base'\n\n/**\n * PEEK host function (_P)\n *\n * Reads memory from a PVM machine instance\n *\n * *** GRAY PAPER FORMULA ***\n * Gray Paper: pvm_invocations.tex, _P (peek = 9)\n *\n * Parameters: [n, o, s, z] = registers[7:4]\n * - n: machine ID\n * - o: destination offset in current memory\n * - s: source offset in machine's memory\n * - z: length\n *\n * Return states (equation 571-577):\n * - panic when Nrange{o}{z} not  writable[memory]  (destination not writable)\n * - continue with WHO when n not  keys(m)  (machine doesn't exist)\n * - continue with OOB when Nrange{s}{z} not  readable{m[n].ram}  (source not readable)\n * - continue with OK otherwise\n *\n * Memory update: mem'[o:z] = (m[n].ram)[s:z]\n */\nexport class PeekHostFunction extends BaseHostFunction {\n  functionId: u64 = u64(9) // PEEK function ID\n  name: string = 'peek'\n  gasCost: u64 = u64(10)\n\n  execute(\n    context: HostFunctionContext,\n    params: HostFunctionParams | null,\n  ): HostFunctionResult {\n    if (!params) {\n      return new HostFunctionResult(255) // continue execution\n    }\n    const peekParams = params as PeekPokeParams\n    if (!peekParams.refineContext) {\n      context.registers[7] = ACCUMULATE_ERROR_WHO\n      return new HostFunctionResult(RESULT_CODE_PANIC)\n    }\n\n    // Gray Paper: [n, o, s, z] = registers[7:4]\n    const machineId = u64(context.registers[7])\n    const destOffset = u64(context.registers[8]) // o: destination\n    const sourceOffset = u64(context.registers[9]) // s: source\n    const length = u64(context.registers[10]) // z: length\n\n    // Gray Paper error check order:\n    // 1. Check if machine exists  WHO\n    const refineContext = peekParams.refineContext!\n    const machine = this.getPVMMachine(refineContext, machineId)\n    if (!machine) {\n      context.registers[7] = ACCUMULATE_ERROR_WHO\n      return new HostFunctionResult(255) // continue (not HALT)\n    }\n\n    // 2. Check if source range is readable  OOB\n    if (!this.isMachineMemoryReadable(machine, sourceOffset, length)) {\n      context.registers[7] = ACCUMULATE_ERROR_OOB\n      return new HostFunctionResult(255) // continue (not HALT)\n    }\n\n    // Read data from machine's memory\n    const data = this.readFromMachineMemory(machine, sourceOffset, length)\n    if (data === null) {\n      context.registers[7] = ACCUMULATE_ERROR_OOB\n      return new HostFunctionResult(255) // continue\n    }\n\n    // Gray Paper: mem'[o:z] = (m[n].ram)[s:z]\n    const writeResult = context.ram.writeOctets(u32(destOffset), data)\n    if (writeResult.hasFault) {\n      return new HostFunctionResult(RESULT_CODE_PANIC)\n    }\n\n    // Return OK (0) for success\n    context.registers[7] = ACCUMULATE_ERROR_OK\n    return new HostFunctionResult(255) // continue execution\n  }\n\n  getPVMMachine(\n    refineContext: RefineInvocationContext,\n    machineId: u64,\n  ): PVMGuest | null {\n    // Get PVM machine by ID from context\n    if (refineContext.machines.has(machineId)) {\n      return refineContext.machines.get(machineId)!\n    }\n    return null\n  }\n\n  isMachineMemoryReadable(\n    machine: PVMGuest,\n    offset: u64,\n    length: u64,\n  ): bool {\n    const result_readable = machine.pvm.state.ram.isReadableWithFault(\n      u32(offset),\n      u32(length),\n    )\n    const readable = result_readable.success\n    const faultAddress = result_readable.faultAddress\n    if (faultAddress !== 0) {\n      return false\n    }\n    return readable\n  }\n\n  readFromMachineMemory(\n    machine: PVMGuest,\n    offset: u64,\n    length: u64,\n  ): Uint8Array | null {\n    // Read data from machine's memory\n    const readResult_data = machine.pvm.state.ram.readOctets(u32(offset), u32(length))\n    const data = readResult_data.data\n    const faultAddress = readResult_data.faultAddress\n    if (data === null || faultAddress !== 0) {\n      return null\n    }\n    return data\n  }\n}\n","import { RESULT_CODE_PANIC } from '../../config'\nimport {\n  ACCUMULATE_ERROR_OK,\n  ACCUMULATE_ERROR_OOB,\n  ACCUMULATE_ERROR_WHO,\n  HostFunctionResult,\n} from '../accumulate/base'\nimport {\n  HostFunctionContext,\n  HostFunctionParams,\n  PeekPokeParams,\n  PVMGuest,\n  RefineInvocationContext,\n} from './base'\nimport { BaseHostFunction } from './base'\n\n/**\n * POKE host function (_O)\n *\n * Writes memory to a PVM machine instance\n *\n * *** GRAY PAPER FORMULA ***\n * Gray Paper: pvm_invocations.tex, _O (poke = 10)\n *\n * Parameters: [n, s, o, z] = registers[7:4]\n * - n: machine ID\n * - s: source offset in current memory\n * - o: destination offset in machine's memory\n * - z: length\n *\n * Return states (equation 586-593):\n * - panic when Nrange{s}{z} not  readable[memory]  (source not readable)\n * - continue with WHO when n not  keys(m)  (machine doesn't exist)\n * - continue with OOB when Nrange{o}{z} not  writable{m[n].ram}  (destination not writable)\n * - continue with OK otherwise\n *\n * Memory update: (m'[n].ram)[o:z] = mem[s:z]\n */\nexport class PokeHostFunction extends BaseHostFunction {\n  functionId: u64 = u64(10) // POKE function ID\n  name: string = 'poke'\n  gasCost: u64 = u64(10)\n\n  execute(\n    context: HostFunctionContext,\n    params: HostFunctionParams | null,\n  ): HostFunctionResult {\n    if (!params) {\n      return new HostFunctionResult(255) // continue execution\n    }\n    const pokeParams = params as PeekPokeParams\n    if (!pokeParams.refineContext) {\n      context.registers[7] = ACCUMULATE_ERROR_WHO\n      return new HostFunctionResult(RESULT_CODE_PANIC)\n    }\n\n    // Gray Paper: [n, s, o, z] = registers[7:4]\n    const machineId = u64(context.registers[7])\n    const sourceOffset = u64(context.registers[8]) // s: source\n    const destOffset = u64(context.registers[9]) // o: destination\n    const length = u64(context.registers[10]) // z: length\n\n    // Gray Paper error check order:\n    // 1. Check if source range is readable in current memory  panic\n    // Read data from current PVM's memory\n    const readResult_data = context.ram.readOctets(\n      u32(sourceOffset),\n      u32(length),\n    )\n    const data = readResult_data.data\n    const readFaultAddress = readResult_data.faultAddress\n    if (data === null || readFaultAddress !== 0) {\n      return new HostFunctionResult(RESULT_CODE_PANIC)\n    }\n\n    // 2. Check if machine exists  WHO\n    const refineContext = pokeParams.refineContext!\n    const machine = this.getPVMMachine(refineContext, machineId)\n    if (!machine) {\n      context.registers[7] = ACCUMULATE_ERROR_WHO\n      return new HostFunctionResult(255) // continue\n    }\n\n    // 3. Check if destination range is writable  OOB\n    // Gray Paper: (m'[n].ram)[o:z] = mem[s:z]\n    const writeResult = machine.pvm.state.ram.writeOctets(u32(destOffset), data)\n    if (writeResult.hasFault) {\n      context.registers[7] = ACCUMULATE_ERROR_OOB\n      return new HostFunctionResult(255) // continue (not HALT)\n    }\n\n    // Return OK (0) for success\n    context.registers[7] = ACCUMULATE_ERROR_OK\n\n    return new HostFunctionResult(255) // continue execution\n  }\n\n  getPVMMachine(\n    refineContext: RefineInvocationContext,\n    machineId: u64,\n  ): PVMGuest | null {\n    if (refineContext.machines.has(machineId)) {\n      return refineContext.machines.get(machineId)!\n    }\n    return null\n  }\n}\n","import { RAM, RefineInvocationContext } from '../../pbnj-types-compat'\nimport { MemoryAccessType } from '../../types'\nimport { PVMGuest } from './base'\nimport { HostFunctionResult } from '../accumulate/base'\nimport { HostFunctionContext, HostFunctionParams, PagesParams } from './base'\nimport { BaseHostFunction } from './base'\nimport {\n  ACCUMULATE_ERROR_CODES,\n  GENERAL_FUNCTIONS,\n  MEMORY_CONFIG,\n  RESULT_CODES,\n} from '../../config'\n\n/**\n * PAGES host function (_Z)\n *\n * Manages memory pages in PVM machine instances\n *\n * Gray Paper Specification (pvm-invocations.tex line 102, 597-622):\n * - Function ID: 11 (pages)\n * - Gas Cost: 10\n * - Signature: _Z(gascounter, registers, memory, (m, e))\n *   - (m, e) = refine context pair (machines, export segments)\n * - Uses registers[7:4] = (n, p, c, r) where:\n *   - n = machine ID\n *   - p = page start index (must be >= 16)\n *   - c = page count\n *   - r = access mode (0=none, 1=R, 2=W, 3=R+preserve, 4=W+preserve)\n *\n * Access rights (equation 610-614):\n * (u'_ram_access)[p:c] = {\n *   {none, none, .}  when r = 0\n *   {R, R, .}        when r = 1  r = 3\n *   {W, W, .}        when r = 2  r = 4\n * }\n *\n * Page data (equation 606-609):\n * (u'_ram_value)[p*Cpvmpagesize.(p+c)*Cpvmpagesize] = {\n *   {0, 0, .}                when r < 3  (clear data)\n *   (u_ram_value)[p*Cpvmpagesize.(p+c)*Cpvmpagesize]  when r >= 3 (preserve data)\n * }\n *\n * Return codes:\n * - registers[7] = WHO when n  keys(m)\n * - registers[7] = HUH when r > 4  p < 16  p+c >= 2^32/Cpvmpagesize\n * - registers[7] = HUH when r > 2  (u_ram_access)[p:c]  none\n * - registers[7] = OK otherwise\n */\nexport class PagesHostFunction extends BaseHostFunction {\n  functionId: u64 = GENERAL_FUNCTIONS.PAGES\n  name: string = 'pages'\n  gasCost: u64 = 10\n\n  execute(\n    context: HostFunctionContext,\n    params: HostFunctionParams | null,\n  ): HostFunctionResult {\n    if (!params) {\n      return new HostFunctionResult(RESULT_CODES.PANIC)\n    }\n    const pagesParams = params as PagesParams\n    if (!pagesParams.refineContext) {\n      return new HostFunctionResult(RESULT_CODES.PANIC)\n    }\n    \n    // Gray Paper: Extract parameters from registers\n    // registers[7:4] = (n, p, c, r)\n    const machineId = context.registers[7]\n    const pageStart = u32(context.registers[8])\n    const pageCount = u32(context.registers[9])\n    const accessRights = u32(context.registers[10])\n\n    // Gray Paper equation 601-604: Get machine RAM\n    // u = m[n].ram if n in keys(m), error otherwise\n    const refineContext = pagesParams.refineContext!\n    const machine = refineContext.machines.get(machineId)\n    if (!machine) {\n      // Gray Paper equation 617: Return WHO if machine doesn't exist\n      context.registers[7] = ACCUMULATE_ERROR_CODES.WHO\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Gray Paper equation 618: Validate parameters\n    // Return HUH if r > 4  p < 16  p+c >= 2^32/Cpvmpagesize\n    const MIN_PAGE_INDEX: u32 = 16 // Gray Paper: p < 16 is invalid\n    const MAX_PAGE_INDEX: u32 = u32((u64(2) ** 32) / u64(MEMORY_CONFIG.PAGE_SIZE)) // Gray Paper: p+c >= 2^32/Cpvmpagesize is invalid\n\n    if (\n      accessRights > 4 ||\n      pageStart < MIN_PAGE_INDEX ||\n      pageStart + pageCount >= MAX_PAGE_INDEX\n    ) {\n      // Gray Paper equation 619: Return HUH if invalid parameters\n      context.registers[7] = ACCUMULATE_ERROR_CODES.HUH\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Gray Paper equation 619: Additional validation\n    // Return HUH if r > 2  (u_ram_access)[p:c]  none\n    if (accessRights > 2) {\n      const hasInaccessiblePages = this.checkForInaccessiblePages(\n        machine.pvm.state.ram,\n        pageStart,\n        pageCount,\n      )\n      if (hasInaccessiblePages) {\n        context.registers[7] = ACCUMULATE_ERROR_CODES.HUH\n        return new HostFunctionResult(255) // continue execution\n      }\n    }\n\n    // Gray Paper equation 605-614: Set memory page access rights and data\n    this.setMemoryPageAccessRights(\n      machine,\n      pageStart,\n      pageCount,\n      accessRights,\n    )\n\n    // Gray Paper equation 620: Return OK for success\n    context.registers[7] = ACCUMULATE_ERROR_CODES.OK\n\n    return new HostFunctionResult(255) // continue execution\n  }\n\n  checkForInaccessiblePages(\n    ram: RAM,\n    pageStart: u32,\n    pageCount: u32,\n  ): bool {\n    // Gray Paper equation 619: r > 2  (u_ram_access)[p:c]  none\n    // Check if any pages in the range have 'none' access\n    const PAGE_SIZE = MEMORY_CONFIG.PAGE_SIZE\n    for (let i: u32 = 0; i < pageCount; i++) {\n      const pageIndex = pageStart + i\n      const pageAddress = u32(pageIndex * PAGE_SIZE)\n\n      // Check if the page has 'none' access\n      const accessResult = ram.isReadableWithFault(pageAddress, PAGE_SIZE)\n      if (!accessResult.success) {\n        return true // Found inaccessible page\n      }\n    }\n    return false\n  }\n\n  /**\n   * Set memory page access rights and optionally clear data\n   *\n   * Gray Paper equation 605-614:\n   * 1. Clear data if r < 3: (u'_ram_value) = {0, 0, .}\n   * 2. Preserve data if r >= 3: (u'_ram_value) = (u_ram_value)\n   * 3. Set access rights per convertAccessRights()\n   */\n  setMemoryPageAccessRights(\n    machine: PVMGuest,\n    pageStart: u32,\n    pageCount: u32,\n    accessRights: u32,\n  ): void {\n    const PAGE_SIZE = u32(MEMORY_CONFIG.PAGE_SIZE)\n    const accessType = this.convertAccessRights(accessRights)\n    // accessRights is already validated to be <= 4, so accessType should never be null\n    if (!accessType) {\n      // Return early instead of throwing to avoid WASM abort\n      return\n    }\n\n    for (let i: u32 = 0; i < pageCount; i++) {\n      const pageIndex = pageStart + i\n      const pageAddress = u32(pageIndex * PAGE_SIZE)\n\n      // Gray Paper equation 606-609: Clear page data when r < 3\n      if (accessRights < 3) {\n        this.clearPageData(\n          machine.pvm.state.ram,\n          pageAddress,\n          PAGE_SIZE,\n        )\n      }\n\n      // Gray Paper equation 610-614: Set access rights\n      machine.pvm.state.ram.setPageAccessRights(\n        pageAddress,\n        PAGE_SIZE,\n        accessType,\n      )\n    }\n  }\n\n  /**\n   * Convert access rights parameter r to MemoryAccessType\n   *\n   * Gray Paper equation 610-614:\n   * r = 0  none access (no read/write)\n   * r = 1 or 3  read access only (R)\n   * r = 2 or 4  write access only (W)\n   */\n  convertAccessRights(accessRights: u32): MemoryAccessType {\n    switch (accessRights) {\n      case 0:\n        return MemoryAccessType.NONE // r = 0\n      case 1:\n      case 3:\n        return MemoryAccessType.READ // r = 1  r = 3  R\n      case 2:\n      case 4:\n        return MemoryAccessType.WRITE // r = 2  r = 4  W\n      default:\n        return MemoryAccessType.NONE // Invalid r - default to NONE\n    }\n  }\n\n  /**\n   * Clear page data by writing zeros\n   *\n   * Gray Paper equation 606-609:\n   * (u'_ram_value)[p*Cpvmpagesize.(p+c)*Cpvmpagesize] = {0, 0, .}\n   */\n  clearPageData(ram: RAM, startAddress: u32, size: u32): void {\n    const zeroData = new Uint8Array(size)\n    ram.writeOctets(startAddress, zeroData)\n  }\n}\n","import { PVMState, RAM } from '../../pbnj-types-compat'\nimport { HostFunctionResult } from '../accumulate/base'\nimport { HostFunctionContext, HostFunctionParams, InvokeParams } from './base'\nimport {\n  ACCUMULATE_ERROR_CODES,\n  GENERAL_FUNCTIONS,\n  RESULT_CODES,\n} from '../../config'\nimport { BaseHostFunction } from './base'\n\n/**\n * INVOKE host function (_K)\n *\n * Invokes execution on a PVM machine instance\n *\n * Gray Paper Specification (pvm-invocations.tex line 103, 626-653):\n * - Function ID: 12 (invoke)\n * - Gas Cost: 10\n * - Signature: _K(gascounter, registers, memory, (m, e))\n *   - (m, e) = refine context pair (machines, export segments)\n * - Uses registers[7] for machine ID (n)\n * - Uses registers[8] for memory offset (o)\n * - Reads gas limit (8 bytes) and register values (13  8 = 104 bytes) from memory[o:112]\n * - Executes PVM machine with specified parameters\n * - Returns execution result (HALT, PANIC, FAULT, OOG, HOST)\n * - Updates machine state (RAM and PC) and writes results back to memory\n */\n\n\nexport class InvokeHostFunction extends BaseHostFunction {\n  functionId: u64 = GENERAL_FUNCTIONS.INVOKE\n  name: string = 'invoke'\n  gasCost: u64 = 10\n\n  execute(\n    context: HostFunctionContext,\n    params: HostFunctionParams | null,\n  ): HostFunctionResult {\n    if (!params) {\n      return new HostFunctionResult(RESULT_CODES.PANIC)\n    }\n    const invokeParams = params as InvokeParams\n    if (!invokeParams.refineContext) {\n      return new HostFunctionResult(RESULT_CODES.PANIC)\n    }\n    \n    // Gray Paper: Extract parameters from registers\n    // registers[7] = machine ID (n)\n    // registers[8] = memory offset (o)\n    const machineId = context.registers[7]\n    const memoryOffset = context.registers[8]\n\n    const refineContext = invokeParams.refineContext!\n    const machines = refineContext.machines\n\n    // Gray Paper equation 646: Check if machine exists\n    // Return WHO if n not in m\n    const machine = machines.get(machineId)\n    if (!machine) {\n      context.registers[7] = ACCUMULATE_ERROR_CODES.WHO\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Gray Paper equation 630-633: Read gas limit and register values from memory\n    // (g, w) = decode[8]{g} || decode[8]{w} = memory[o:112]\n    // where memory[o:112] must be readable\n    const readResult_gasLimitData = context.ram.readOctets(\n      u32(memoryOffset),\n      8,\n    )\n    const gasLimitData = readResult_gasLimitData.data\n    const gasFaultAddress = readResult_gasLimitData.faultAddress\n    if (gasLimitData === null || gasFaultAddress !== 0) {\n      // Gray Paper equation 645: Return panic if memory not readable\n      return new HostFunctionResult(RESULT_CODES.PANIC)\n    }\n    const gasLimit = this.decodeU64(gasLimitData)\n\n    // Gray Paper: Read register values (13 registers * 8 bytes each = 104 bytes)\n    const readResult_registersData = context.ram.readOctets(\n      u32(memoryOffset + 8),\n      104,\n    )\n    const registersData = readResult_registersData.data\n    const registersFaultAddress = readResult_registersData.faultAddress\n    if (registersData === null || registersFaultAddress !== 0) {\n      // Gray Paper equation 645: Return panic if memory not readable\n      return new HostFunctionResult(RESULT_CODES.PANIC)\n    }\n\n    // Decode register values (13 registers * 8 bytes each = 104 bytes)\n    const registers = new StaticArray<u64>(13)\n    for (let i: i32 = 0; i < 13; i++) {\n      const registerData = registersData.slice(i * 8, (i + 1) * 8)\n      registers[i] = this.decodeU64(registerData)\n    }\n\n    // Gray Paper equation 635: Execute PVM machine\n    // (c, i', g', w', u') = (code, pc, g, w, ram)\n    // Get code, bitmask, and jumpTable from machine's current state\n    const pvm = machine.pvm\n    pvm.invoke(\n      u32(gasLimit),\n      registers,\n      pvm.state.code,\n      pvm.state.bitmask,\n      pvm.state.jumpTable,\n    )\n\n    const pvmState = pvm.state\n\n    // Gray Paper equation 636: Update memory\n    // memory*[o:112] = encode[8]{g'} || encode[8]{w'}\n    this.writeInvokeResults(context.ram, memoryOffset, pvmState)\n\n    // Gray Paper equation 637-642: Update machine state\n    // m*[n].ram = u' (already updated in machine.pvm.state.ram)\n    // m*[n].pc = i' + fskip(i') + 1 if HOST, else i' (already updated in machine.pvm.state.programCounter)\n    // Note: The PVM state is already updated by the invoke call, so no explicit assignment needed\n\n    // Gray Paper equation 644-652: Return result code in registers[7] and registers[8]\n    const resultCode = pvmState.resultCode\n    if (resultCode === RESULT_CODES.HOST) {\n      // Gray Paper equation 647: Return HOST with host call ID\n      context.registers[7] = u64(RESULT_CODES.HOST)\n      context.registers[8] = u64(pvmState.hostCallId || 0)\n    } else if (resultCode === RESULT_CODES.FAULT) {\n      // Gray Paper equation 648: Return FAULT with fault address\n      context.registers[7] = u64(RESULT_CODES.FAULT)\n      context.registers[8] = u64(pvmState.faultAddress || 0)\n    } else if (resultCode === RESULT_CODES.OOG) {\n      // Gray Paper equation 649: Return OOG\n      context.registers[7] = u64(RESULT_CODES.OOG)\n    } else if (resultCode === RESULT_CODES.PANIC) {\n      // Gray Paper equation 650: Return PANIC\n      context.registers[7] = u64(RESULT_CODES.PANIC)\n    } else if (resultCode === RESULT_CODES.HALT) {\n      // Gray Paper equation 651: Return HALT\n      context.registers[7] = u64(RESULT_CODES.HALT)\n    }\n\n    return new HostFunctionResult(255) // continue execution\n  }\n\n  writeInvokeResults(ram: RAM, offset: u64, pvm: PVMState): void {\n    // Gray Paper: mem*[o:112] = encode[8]{g'}  encode[8]{w'}\n    // Write final gas (8 bytes)\n    const gasData = this.encodeU64(pvm.gasCounter)\n    const gasWriteResult = ram.writeOctets(u32(offset), gasData)\n    if (gasWriteResult.hasFault) {\n      return // Ignore write errors\n    }\n\n    // Write final registers (13 registers * 8 bytes each = 104 bytes)\n    const registersData = new Uint8Array(104)\n    for (let i: i32 = 0; i < 13; i++) {\n      const registerValue = pvm.registerState[i] || u64(0)\n      const registerBytes = this.encodeU64(registerValue)\n      registersData.set(registerBytes, i * 8)\n    }\n    const registersWriteResult = ram.writeOctets(u32(offset + 8), registersData)\n    if (registersWriteResult.hasFault) {\n      return // Ignore write errors\n    }\n  }\n\n  // Helper to decode u64 from little-endian bytes\n  decodeU64(bytes: Uint8Array): u64 {\n    let value: u64 = u64(0)\n    for (let i: i32 = 0; i < 8 && i < bytes.length; i++) {\n      value |= (u64(bytes[i]) << (u64(i) * 8))\n    }\n    return value\n  }\n\n  // Helper to encode u64 to little-endian bytes\n  encodeU64(value: u64): Uint8Array {\n    const bytes = new Uint8Array(8)\n    for (let i: i32 = 0; i < 8; i++) {\n      bytes[i] = u8((value >> (u64(i) * 8)) & 0xff)\n    }\n    return bytes\n  }\n}\n","import { RESULT_CODES } from '../../config'\nimport { ACCUMULATE_ERROR_WHO, HostFunctionResult } from '../accumulate/base'\nimport { ExpungeParams, HostFunctionContext, HostFunctionParams } from './base'\nimport { BaseHostFunction } from './base'\n\n/**\n * EXPUNGE host function (_X)\n *\n * Removes a PVM machine instance\n *\n * Gray Paper Specification:\n * - Function ID: 13 (expunge)\n * - Gas Cost: 10\n * - Uses registers[7] to specify machine ID\n * - Removes machine from context\n * - Returns WHO if machine doesn't exist, machine's PC otherwise\n *\n * Gray Paper Logic:\n * n = registers[7]\n * if n not in keys(machines):\n *   registers[7] = WHO\n * else:\n *   pc = machines[n].pc\n *   machines = machines \\ {n}\n *   registers[7] = pc\n */\nexport class ExpungeHostFunction extends BaseHostFunction {\n  functionId: u64 = u64(13) // EXPUNGE function ID\n  name: string = 'expunge'\n  gasCost: u64 = u64(10)\n\n  execute(\n    context: HostFunctionContext,\n    params: HostFunctionParams | null,\n  ): HostFunctionResult {\n    if (!params) {\n      return new HostFunctionResult(RESULT_CODES.PANIC)\n    }\n    const expungeParams = params as ExpungeParams\n    if (!expungeParams.refineContext) {\n      return new HostFunctionResult(RESULT_CODES.PANIC)\n    }\n    \n    const machineId = u64(context.registers[7])\n    const refineContext = expungeParams.refineContext!\n    const machines = refineContext.machines\n\n    // Check if machine exists\n    if (!machines.has(machineId)) {\n      // Return WHO (2^64 - 4) if machine doesn't exist\n      context.registers[7] = ACCUMULATE_ERROR_WHO\n      return new HostFunctionResult(RESULT_CODES.HALT)\n    }\n\n    // Get machine's PC before removal\n    const machine = machines.get(machineId)!\n    const pvm = machine.pvm\n    const pc = pvm.state.programCounter\n\n    // Remove machine from context\n    machines.delete(machineId)\n\n    // Return machine's PC\n    context.registers[7] = pc\n\n    return new HostFunctionResult(255)\n  }\n}\n","import { HostFunctionResult } from '../accumulate/base'\nimport { HostFunctionContext, HostFunctionParams, LogParams } from './base'\nimport { BaseHostFunction } from './base'\n\n/**\n * LOG host function (JIP-1)\n *\n * Debug message host call for logging to the node operator\n *\n * JIP-1 Specification:\n * - Function ID: 100 (log)\n * - Gas Cost: 0\n * - Input registers: 7, 8, 9, 10, 11\n *   - level = 7\n *   - target = [8.+9] when 8  0  9  0, otherwise \n *   - message = [10.+11]\n * - Output registers: {}\n * - Side-effects: Log message to user-agent (no side-effects if memory access is invalid)\n */\nexport class LogHostFunction extends BaseHostFunction {\n  functionId: u64 = u64(100) // LOG function ID (JIP-1)\n  name: string = 'log'\n  gasCost: u64 = u64(0)\n\n  execute(\n    context: HostFunctionContext,\n    params: HostFunctionParams | null,\n  ): HostFunctionResult {\n    if (!params) {\n      return new HostFunctionResult(255) // continue execution\n    }\n    const logParams = params as LogParams\n    const level = i32(context.registers[7])\n    const targetOffset = u64(context.registers[8])\n    const targetLength = u64(context.registers[9])\n    const messageOffset = u64(context.registers[10])\n    const messageLength = u64(context.registers[11])\n\n    // Read target from memory if both offset and length are non-zero\n    let target: string | null = null\n    if (targetOffset !== u64(0) && targetLength !== u64(0)) {\n      const readResult_targetData = context.ram.readOctets(\n        u32(targetOffset),\n        u32(targetLength),\n      )\n      const targetData = readResult_targetData.data\n      const targetFaultAddress = readResult_targetData.faultAddress\n      if (targetData === null || targetFaultAddress !== 0) {\n        // Invalid memory access - no side effects, continue execution\n        return new HostFunctionResult(255)\n      }\n      // Decode target as UTF-8 string (simplified - AssemblyScript doesn't have TextDecoder)\n      // For now, just use bytes as string representation\n      target = this.bytesToString(targetData)\n    }\n\n    // Read message from memory\n    const readResult_messageData = context.ram.readOctets(\n      u32(messageOffset),\n      u32(messageLength),\n    )\n    const messageData = readResult_messageData.data\n    const messageFaultAddress = readResult_messageData.faultAddress\n    if (messageData === null || messageFaultAddress !== 0) {\n      // Invalid memory access - no side effects, continue execution\n      return new HostFunctionResult(255)\n    }\n\n    // Decode message as UTF-8 string (simplified)\n    const message = this.bytesToString(messageData)\n\n    // Map level to log level and format message according to JIP-1\n    // Format: <YYYY-MM-DD hh-mm-ss> <LEVEL>[@<CORE>]?[#<SERVICE_ID>]? [<TARGET>]? <MESSAGE>\n    let levelString = 'INFO'\n    if (level === 0) {\n      levelString = 'FATAL'\n    } else if (level === 1) {\n      levelString = 'WARN'\n    } else if (level === 2) {\n      levelString = 'INFO'\n    } else if (level === 3) {\n      levelString = 'DEBUG'\n    } else if (level === 4) {\n      levelString = 'TRACE'\n    }\n\n    // Build formatted message (simplified - no timestamp, serviceId, or coreIndex in AssemblyScript)\n    // Format: <LEVEL> [<TARGET>]? <MESSAGE>\n    let formattedMessage = levelString\n    if (target !== null) {\n      formattedMessage = formattedMessage + ' [' + target + ']'\n    }\n    formattedMessage = formattedMessage + ' ' + message\n\n    // Log according to level using AssemblyScript console\n    if (level === 0) {\n      // Fatal error\n      console.error(formattedMessage)\n    } else if (level === 1) {\n      // Warning\n      console.warn(formattedMessage)\n    } else if (level === 2) {\n      // Important information\n      console.info(formattedMessage)\n    } else if (level === 3 || level === 4) {\n      // Helpful or pedantic information\n      console.debug(formattedMessage)\n    } else {\n      // Default to info\n      console.info(formattedMessage)\n    }\n\n    return new HostFunctionResult(255) // continue execution\n  }\n\n  bytesToString(bytes: Uint8Array): string {\n    // Simplified UTF-8 decoding for AssemblyScript\n    // Note: Full UTF-8 decoding would require more complex logic\n    let result = ''\n    for (let i: i32 = 0; i < bytes.length; i++) {\n      const byte = bytes[i]\n      if (byte >= 32 && byte < 127) {\n        // Printable ASCII\n        result += String.fromCharCode(byte)\n      } else {\n        // Non-printable or extended - use hex representation\n        result += '\\\\x' + (byte < 16 ? '0' : '') + byte.toString(16)\n      }\n    }\n    return result\n  }\n}\n","/**\n * Instruction Registry\n *\n * Central registry that imports and manages all PVM instruction handlers.\n * Acts as a dispatcher for the PVM runtime.\n */\n\n\nimport {\n  AND_INVInstruction,\n  OR_INVInstruction,\n  XNORInstruction,\n} from './advanced-bitwise'\nimport {\n  ADD_IMM_32Instruction,\n  ADD_IMM_64Instruction,\n  MUL_IMM_32Instruction,\n  MUL_IMM_64Instruction,\n} from './arithmetic'\nimport {\n  ADD_32Instruction,\n  DIV_S_32Instruction,\n  DIV_U_32Instruction,\n  MUL_32Instruction,\n  REM_S_32Instruction,\n  REM_U_32Instruction,\n  SUB_32Instruction,\n} from './arithmetic-32'\nimport {\n  ADD_64Instruction,\n  DIV_S_64Instruction,\n  DIV_U_64Instruction,\n  MUL_64Instruction,\n  REM_S_64Instruction,\n  REM_U_64Instruction,\n  SUB_64Instruction,\n} from './arithmetic-64'\nimport { PVMInstructionHandler } from './base'\nimport {\n  AND_IMMInstruction,\n  OR_IMMInstruction,\n  XOR_IMMInstruction,\n} from './bitwise'\nimport {\n  ANDInstruction,\n  ORInstruction,\n  XORInstruction,\n} from './bitwise-register'\nimport {\n  BRANCH_EQ_IMMInstruction,\n  BRANCH_EQInstruction,\n  BRANCH_GE_S_IMMInstruction,\n  BRANCH_GE_SInstruction,\n  BRANCH_GE_U_IMMInstruction,\n  BRANCH_GE_UInstruction,\n  BRANCH_GT_S_IMMInstruction,\n  BRANCH_GT_U_IMMInstruction,\n  BRANCH_LE_S_IMMInstruction,\n  BRANCH_LE_U_IMMInstruction,\n  BRANCH_LT_S_IMMInstruction,\n  BRANCH_LT_SInstruction,\n  BRANCH_LT_U_IMMInstruction,\n  BRANCH_LT_UInstruction,\n  BRANCH_NE_IMMInstruction,\n  BRANCH_NEInstruction,\n} from './branching'\nimport {\n  SET_GT_S_IMMInstruction,\n  SET_GT_U_IMMInstruction,\n  SET_LT_S_IMMInstruction,\n  SET_LT_U_IMMInstruction,\n} from './comparison'\nimport { SET_LT_SInstruction, SET_LT_UInstruction } from './comparison-register'\nimport { CMOV_IZ_IMMInstruction, CMOV_NZ_IMMInstruction } from './conditional'\nimport { CMOV_IZInstruction, CMOV_NZInstruction } from './conditional-register'\n// Import all instruction classes\nimport {\n  FALLTHROUGHInstruction,\n  JUMP_INDInstruction,\n  JUMPInstruction,\n  LOAD_IMM_JUMP_INDInstruction,\n  LOAD_IMM_JUMPInstruction,\n  TRAPInstruction,\n} from './control-flow'\nimport {\n  LOAD_I8Instruction,\n  LOAD_I16Instruction,\n  LOAD_I32Instruction,\n  LOAD_IMM_64Instruction,\n  LOAD_IMMInstruction,\n  LOAD_U8Instruction,\n  LOAD_U16Instruction,\n  LOAD_U32Instruction,\n  LOAD_U64Instruction,\n  STORE_IMM_IND_U8Instruction,\n  STORE_IMM_IND_U16Instruction,\n  STORE_IMM_IND_U32Instruction,\n  STORE_IMM_IND_U64Instruction,\n  STORE_IMM_U8Instruction,\n  STORE_IMM_U16Instruction,\n  STORE_IMM_U32Instruction,\n  STORE_IMM_U64Instruction,\n  STORE_U8Instruction,\n  STORE_U16Instruction,\n  STORE_U32Instruction,\n  STORE_U64Instruction,\n} from './memory'\nimport {\n  LOAD_IND_I8Instruction,\n  LOAD_IND_I16Instruction,\n  LOAD_IND_I32Instruction,\n  LOAD_IND_U8Instruction,\n  LOAD_IND_U16Instruction,\n  LOAD_IND_U32Instruction,\n  LOAD_IND_U64Instruction,\n  STORE_IND_U8Instruction,\n  STORE_IND_U16Instruction,\n  STORE_IND_U32Instruction,\n  STORE_IND_U64Instruction,\n} from './memory-indirect'\nimport {\n  MAX_UInstruction,\n  MAXInstruction,\n  MIN_UInstruction,\n  MINInstruction,\n} from './min-max'\nimport {\n  MUL_UPPER_S_SInstruction,\n  MUL_UPPER_S_UInstruction,\n  MUL_UPPER_U_UInstruction,\n} from './multiplication-upper'\nimport {\n  COUNT_SET_BITS_32Instruction,\n  COUNT_SET_BITS_64Instruction,\n  LEADING_ZERO_BITS_32Instruction,\n  LEADING_ZERO_BITS_64Instruction,\n  MOVE_REGInstruction,\n  REVERSE_BYTESInstruction,\n  SBRKInstruction,\n  SIGN_EXTEND_8Instruction,\n  SIGN_EXTEND_16Instruction,\n  TRAILING_ZERO_BITS_32Instruction,\n  TRAILING_ZERO_BITS_64Instruction,\n  ZERO_EXTEND_16Instruction,\n} from './register'\nimport {\n  ROT_L_32Instruction,\n  ROT_L_64Instruction,\n  ROT_R_32Instruction,\n  ROT_R_64Instruction,\n} from './rotation-register'\nimport {\n  ROT_R_32_IMM_ALTInstruction,\n  ROT_R_32_IMMInstruction,\n  ROT_R_64_IMM_ALTInstruction,\n  ROT_R_64_IMMInstruction,\n} from './rotations'\nimport {\n  NEG_ADD_IMM_32Instruction,\n  SHAR_R_IMM_32Instruction,\n  SHLO_L_IMM_32Instruction,\n  SHLO_R_IMM_32Instruction,\n} from './shifts'\nimport {\n  SHAR_R_32Instruction,\n  SHLO_L_32Instruction,\n  SHLO_R_32Instruction,\n} from './shifts-32-register'\nimport {\n  NEG_ADD_IMM_64Instruction,\n  SHAR_R_IMM_64Instruction,\n  SHLO_L_IMM_64Instruction,\n  SHLO_R_IMM_64Instruction,\n} from './shifts-64'\nimport {\n  SHAR_R_64Instruction,\n  SHLO_L_64Instruction,\n  SHLO_R_64Instruction,\n} from './shifts-64-register'\nimport {\n  SHAR_R_IMM_ALT_32Instruction,\n  SHLO_L_IMM_ALT_32Instruction,\n  SHLO_R_IMM_ALT_32Instruction,\n} from './shifts-alt'\nimport {\n  SHAR_R_IMM_ALT_64Instruction,\n  SHLO_L_IMM_ALT_64Instruction,\n  SHLO_R_IMM_ALT_64Instruction,\n} from './shifts-alt-64'\nimport { ECALLIInstruction } from './system'\n\n/**\n * Instruction Registry\n *\n * Singleton registry for all PVM instruction handlers.\n * Maps opcodes to their corresponding instruction implementations.\n */\nexport class InstructionRegistry {\n  handlers: Map<i32, PVMInstructionHandler> = new Map()\n\n  constructor() {\n    this.registerInstructions()\n  }\n  /**\n   * Register all instruction handlers\n   */\n  registerInstructions(): void {\n    // Control flow instructions\n    this.register(new TRAPInstruction())\n    this.register(new FALLTHROUGHInstruction())\n    this.register(new JUMPInstruction())\n    this.register(new JUMP_INDInstruction())\n    this.register(new LOAD_IMM_JUMPInstruction())\n    this.register(new LOAD_IMM_JUMP_INDInstruction())\n\n    // System instructions\n    this.register(new ECALLIInstruction())\n\n    // Memory instructions\n    this.register(new LOAD_IMM_64Instruction())\n    this.register(new STORE_IMM_U8Instruction())\n    this.register(new STORE_IMM_U16Instruction())\n    this.register(new STORE_IMM_U32Instruction())\n    this.register(new STORE_IMM_U64Instruction())\n    this.register(new LOAD_IMMInstruction())\n    this.register(new LOAD_U8Instruction())\n    this.register(new LOAD_I8Instruction())\n    this.register(new LOAD_U16Instruction())\n    this.register(new LOAD_I16Instruction())\n    this.register(new LOAD_U32Instruction())\n    this.register(new LOAD_I32Instruction())\n    this.register(new LOAD_U64Instruction())\n    this.register(new STORE_U8Instruction())\n    this.register(new STORE_U16Instruction())\n    this.register(new STORE_U32Instruction())\n    this.register(new STORE_U64Instruction())\n    this.register(new STORE_IMM_IND_U8Instruction())\n    this.register(new STORE_IMM_IND_U16Instruction())\n    this.register(new STORE_IMM_IND_U32Instruction())\n    this.register(new STORE_IMM_IND_U64Instruction())\n\n    // Indirect memory instructions\n    this.register(new STORE_IND_U8Instruction())\n    this.register(new STORE_IND_U16Instruction())\n    this.register(new STORE_IND_U32Instruction())\n    this.register(new STORE_IND_U64Instruction())\n    this.register(new LOAD_IND_U8Instruction())\n    this.register(new LOAD_IND_I8Instruction())\n    this.register(new LOAD_IND_U16Instruction())\n    this.register(new LOAD_IND_I16Instruction())\n    this.register(new LOAD_IND_U32Instruction())\n    this.register(new LOAD_IND_I32Instruction())\n    this.register(new LOAD_IND_U64Instruction())\n\n    // Arithmetic instructions\n    this.register(new ADD_IMM_32Instruction())\n    this.register(new MUL_IMM_32Instruction())\n    this.register(new ADD_IMM_64Instruction())\n    this.register(new MUL_IMM_64Instruction())\n\n    // Bitwise instructions\n    this.register(new AND_IMMInstruction())\n    this.register(new XOR_IMMInstruction())\n    this.register(new OR_IMMInstruction())\n\n    // Comparison instructions\n    this.register(new SET_LT_U_IMMInstruction())\n    this.register(new SET_LT_S_IMMInstruction())\n    this.register(new SET_GT_U_IMMInstruction())\n    this.register(new SET_GT_S_IMMInstruction())\n\n    // Conditional instructions\n    this.register(new CMOV_IZ_IMMInstruction())\n    this.register(new CMOV_NZ_IMMInstruction())\n\n    // Shift instructions\n    this.register(new SHLO_L_IMM_32Instruction())\n    this.register(new SHLO_R_IMM_32Instruction())\n    this.register(new SHAR_R_IMM_32Instruction())\n    this.register(new NEG_ADD_IMM_32Instruction())\n\n    // Alternative shift instructions\n    this.register(new SHLO_L_IMM_ALT_32Instruction())\n    this.register(new SHLO_R_IMM_ALT_32Instruction())\n    this.register(new SHAR_R_IMM_ALT_32Instruction())\n\n    // 64-bit shift instructions\n    this.register(new SHLO_L_IMM_64Instruction())\n    this.register(new SHLO_R_IMM_64Instruction())\n    this.register(new SHAR_R_IMM_64Instruction())\n    this.register(new NEG_ADD_IMM_64Instruction())\n\n    // Alternative 64-bit shift instructions\n    this.register(new SHLO_L_IMM_ALT_64Instruction())\n    this.register(new SHLO_R_IMM_ALT_64Instruction())\n    this.register(new SHAR_R_IMM_ALT_64Instruction())\n\n    // Rotation instructions\n    this.register(new ROT_R_64_IMMInstruction())\n    this.register(new ROT_R_64_IMM_ALTInstruction())\n    this.register(new ROT_R_32_IMMInstruction())\n    this.register(new ROT_R_32_IMM_ALTInstruction())\n\n    // Branching instructions\n    this.register(new BRANCH_EQ_IMMInstruction())\n    this.register(new BRANCH_NE_IMMInstruction())\n    this.register(new BRANCH_LT_U_IMMInstruction())\n    this.register(new BRANCH_LE_U_IMMInstruction())\n    this.register(new BRANCH_GE_U_IMMInstruction())\n    this.register(new BRANCH_GT_U_IMMInstruction())\n    this.register(new BRANCH_LT_S_IMMInstruction())\n    this.register(new BRANCH_LE_S_IMMInstruction())\n    this.register(new BRANCH_GE_S_IMMInstruction())\n    this.register(new BRANCH_GT_S_IMMInstruction())\n\n    // Register-based branching instructions\n    this.register(new BRANCH_EQInstruction())\n    this.register(new BRANCH_NEInstruction())\n    this.register(new BRANCH_LT_UInstruction())\n    this.register(new BRANCH_LT_SInstruction())\n    this.register(new BRANCH_GE_UInstruction())\n    this.register(new BRANCH_GE_SInstruction())\n\n    // 32-bit arithmetic instructions\n    this.register(new ADD_32Instruction())\n    this.register(new SUB_32Instruction())\n    this.register(new MUL_32Instruction())\n    this.register(new DIV_U_32Instruction())\n    this.register(new DIV_S_32Instruction())\n    this.register(new REM_U_32Instruction())\n    this.register(new REM_S_32Instruction())\n\n    // 32-bit shift instructions\n    this.register(new SHLO_L_32Instruction())\n    this.register(new SHLO_R_32Instruction())\n    this.register(new SHAR_R_32Instruction())\n\n    // 64-bit arithmetic instructions\n    this.register(new ADD_64Instruction())\n    this.register(new SUB_64Instruction())\n    this.register(new MUL_64Instruction())\n    this.register(new DIV_U_64Instruction())\n    this.register(new DIV_S_64Instruction())\n    this.register(new REM_U_64Instruction())\n    this.register(new REM_S_64Instruction())\n\n    // 64-bit shift instructions\n    this.register(new SHLO_L_64Instruction())\n    this.register(new SHLO_R_64Instruction())\n    this.register(new SHAR_R_64Instruction())\n\n    // Bitwise instructions\n    this.register(new ANDInstruction())\n    this.register(new XORInstruction())\n    this.register(new ORInstruction())\n\n    // Multiplication upper bits instructions\n    this.register(new MUL_UPPER_S_SInstruction())\n    this.register(new MUL_UPPER_U_UInstruction())\n    this.register(new MUL_UPPER_S_UInstruction())\n\n    // Comparison instructions\n    this.register(new SET_LT_UInstruction())\n    this.register(new SET_LT_SInstruction())\n\n    // Conditional move instructions\n    this.register(new CMOV_IZInstruction())\n    this.register(new CMOV_NZInstruction())\n\n    // Rotation instructions\n    this.register(new ROT_L_64Instruction())\n    this.register(new ROT_L_32Instruction())\n    this.register(new ROT_R_64Instruction())\n    this.register(new ROT_R_32Instruction())\n\n    // Advanced bitwise instructions\n    this.register(new AND_INVInstruction())\n    this.register(new OR_INVInstruction())\n    this.register(new XNORInstruction())\n\n    // Min/Max instructions\n    this.register(new MINInstruction())\n    this.register(new MIN_UInstruction())\n    this.register(new MAXInstruction())\n    this.register(new MAX_UInstruction())\n\n    // Register operations\n    this.register(new MOVE_REGInstruction())\n    this.register(new SBRKInstruction())\n    this.register(new COUNT_SET_BITS_64Instruction())\n    this.register(new COUNT_SET_BITS_32Instruction())\n    this.register(new LEADING_ZERO_BITS_64Instruction())\n    this.register(new LEADING_ZERO_BITS_32Instruction())\n    this.register(new TRAILING_ZERO_BITS_64Instruction())\n    this.register(new TRAILING_ZERO_BITS_32Instruction())\n    this.register(new SIGN_EXTEND_8Instruction())\n    this.register(new SIGN_EXTEND_16Instruction())\n    this.register(new ZERO_EXTEND_16Instruction())\n    this.register(new REVERSE_BYTESInstruction())\n  }\n\n  /**\n   * Register an instruction handler\n   */\n  register(handler: PVMInstructionHandler): void {\n    this.handlers.set(handler.opcode, handler)\n  }\n\n  /**\n   * Get instruction handler by opcode\n   */\n  getHandler(opcode: i32): PVMInstructionHandler | null {\n    return this.handlers.has(opcode) ? this.handlers.get(opcode) : null\n  }\n\n  /**\n   * Check if opcode is registered\n   */\n  hasHandler(opcode: i32): boolean {\n    return this.handlers.has(opcode)\n  }\n\n  /**\n   * Get all registered opcodes\n   */\n  getRegisteredOpcodes(): Array<i32> {\n    return this.handlers.keys()\n  }\n\n  /**\n   * Get all registered handlers\n   */\n  getAllHandlers(): PVMInstructionHandler[] {\n    return Array.from(this.handlers.values())\n  }\n\n  /**\n   * Clear all handlers (for testing)\n   */\n  clear(): void {\n    this.handlers.clear()\n  }\n}\n","/**\n * Base PVM Instruction System (AssemblyScript)\n *\n * Defines the base interfaces and class for all PVM instructions.\n */\n\nimport { isTerminationInstruction, RESULT_CODE_PANIC } from '../config'\nimport { bytesToHex, InstructionContext, InstructionResult, RegisterState } from '../types'\n\n/**\n * Result class for parseRegisterAndOneImmediate\n */\nexport class RegisterAndImmediateResult {\n  registerA: u8\n  immediateX: i64\n  \n  constructor(registerA: u8, immediateX: i64) {\n    this.registerA = registerA\n    this.immediateX = immediateX\n  }\n}\n\n/**\n * Result class for parseTwoRegistersAndImmediate (with length)\n */\nexport class TwoRegistersAndImmediateWithLengthResult {\n  registerA: u8\n  registerB: u8\n  lengthX: i32\n  immediateX: i64\n  \n  constructor(registerA: u8, registerB: u8, lengthX: i32, immediateX: i64) {\n    this.registerA = registerA\n    this.registerB = registerB\n    this.lengthX = lengthX\n    this.immediateX = immediateX\n  }\n}\n\n/**\n * Result class for parseTwoRegistersAndImmediate (simple)\n */\nexport class TwoRegistersAndImmediateResult {\n  registerA: u8\n  registerB: u8\n  immediateX: i64\n  \n  constructor(registerA: u8, registerB: u8, immediateX: i64) {\n    this.registerA = registerA\n    this.registerB = registerB\n    this.immediateX = immediateX\n  }\n}\n\n/**\n * Result class for parseBranchOperands\n */\nexport class BranchOperandsResult {\n  registerA: u8\n  immediateX: i64\n  offset: i64\n  targetAddress: u32\n  \n  constructor(registerA: u8, immediateX: i64, offset: i64, targetAddress: u32) {\n    this.registerA = registerA\n    this.immediateX = immediateX\n    this.offset = offset\n    this.targetAddress = targetAddress\n  }\n}\n\n/**\n * Result class for parseRegisterBranchOperands\n */\nexport class RegisterBranchOperandsResult {\n  registerA: u8\n  registerB: u8\n  offset: i64\n  targetAddress: u32\n  \n  constructor(registerA: u8, registerB: u8, offset: i64, targetAddress: u32) {\n    this.registerA = registerA\n    this.registerB = registerB\n    this.offset = offset\n    this.targetAddress = targetAddress\n  }\n}\n\n/**\n * Result class for parseRegisterAndTwoImmediates (with lengths)\n */\nexport class RegisterAndTwoImmediatesWithLengthsResult {\n  registerA: u8\n  lengthX: i32\n  immediateX: i64\n  lengthY: i32\n  immediateY: i64\n  \n  constructor(registerA: u8, lengthX: i32, immediateX: i64, lengthY: i32, immediateY: i64) {\n    this.registerA = registerA\n    this.lengthX = lengthX\n    this.immediateX = immediateX\n    this.lengthY = lengthY\n    this.immediateY = immediateY\n  }\n}\n\n/**\n * Result class for parseRegisterAndTwoImmediates (simple)\n */\nexport class RegisterAndTwoImmediatesResult {\n  registerA: u8\n  immediateX: i64\n  immediateY: i64\n  \n  constructor(registerA: u8, immediateX: i64, immediateY: i64) {\n    this.registerA = registerA\n    this.immediateX = immediateX\n    this.immediateY = immediateY\n  }\n}\n\n/**\n * Result class for parseTwoRegistersAndTwoImmediates (with lengths)\n */\nexport class TwoRegistersAndTwoImmediatesWithLengthsResult {\n  registerA: u8\n  registerB: u8\n  lengthX: i32\n  immediateX: i64\n  lengthY: i32\n  immediateY: i64\n  \n  constructor(registerA: u8, registerB: u8, lengthX: i32, immediateX: i64, lengthY: i32, immediateY: i64) {\n    this.registerA = registerA\n    this.registerB = registerB\n    this.lengthX = lengthX\n    this.immediateX = immediateX\n    this.lengthY = lengthY\n    this.immediateY = immediateY\n  }\n}\n\n/**\n * Result class for parseTwoRegistersAndTwoImmediates (simple)\n */\nexport class TwoRegistersAndTwoImmediatesResult {\n  registerA: u8\n  registerB: u8\n  immediateX: i64\n  immediateY: i64\n  \n  constructor(registerA: u8, registerB: u8, immediateX: i64, immediateY: i64) {\n    this.registerA = registerA\n    this.registerB = registerB\n    this.immediateX = immediateX\n    this.immediateY = immediateY\n  }\n}\n\n/**\n * Result class for parseTwoImmediates (with lengths)\n */\nexport class TwoImmediatesWithLengthsResult {\n  lengthX: i32\n  immediateX: i64\n  lengthY: i32\n  immediateY: i64\n  \n  constructor(lengthX: i32, immediateX: i64, lengthY: i32, immediateY: i64) {\n    this.lengthX = lengthX\n    this.immediateX = immediateX\n    this.lengthY = lengthY\n    this.immediateY = immediateY\n  }\n}\n\n/**\n * Result class for parseTwoImmediates (simple)\n */\nexport class TwoImmediatesResult {\n  immediateX: i64\n  immediateY: i64\n  \n  constructor(immediateX: i64, immediateY: i64) {\n    this.immediateX = immediateX\n    this.immediateY = immediateY\n  }\n}\n\n/**\n * Result class for parseRegisterAndImmediateUnsigned\n */\nexport class RegisterAndImmediateUnsignedResult {\n  registerA: u8\n  immediateX: u64\n  \n  constructor(registerA: u8, immediateX: u64) {\n    this.registerA = registerA\n    this.immediateX = immediateX\n  }\n}\n\n/**\n * Result class for parseTwoRegistersAndOffset\n */\nexport class TwoRegistersAndOffsetResult {\n  registerA: u8\n  registerB: u8\n  targetAddress: u32\n  \n  constructor(registerA: u8, registerB: u8, targetAddress: u32) {\n    this.registerA = registerA\n    this.registerB = registerB\n    this.targetAddress = targetAddress\n  }\n}\n\n/**\n * Result class for parseOffsetOnly\n */\nexport class OffsetOnlyResult {\n  targetAddress: u32\n  \n  constructor(targetAddress: u32) {\n    this.targetAddress = targetAddress\n  }\n}\n\n/**\n * Result class for parseTwoRegisters\n */\nexport class TwoRegistersResult {\n  registerD: u8\n  registerA: u8\n  \n  constructor(registerD: u8, registerA: u8) {\n    this.registerD = registerD\n    this.registerA = registerA\n  }\n}\n\n/**\n * Result class for parseOneRegisterAndImmediate (with length) - signed immediate\n */\nexport class OneRegisterAndImmediateWithLengthResult {\n  registerA: u8\n  lengthX: i32\n  immediateX: i64\n  \n  constructor(registerA: u8, lengthX: i32, immediateX: i64) {\n    this.registerA = registerA\n    this.lengthX = lengthX\n    this.immediateX = immediateX\n  }\n}\n\n/**\n * Result class for parseOneRegisterAndImmediateUnsigned (with length) - unsigned immediate\n */\nexport class OneRegisterAndImmediateWithLengthUnsignedResult {\n  registerA: u8\n  lengthX: i32\n  immediateX: u64\n  \n  constructor(registerA: u8, lengthX: i32, immediateX: u64) {\n    this.registerA = registerA\n    this.lengthX = lengthX\n    this.immediateX = immediateX\n  }\n}\n\n/**\n * Result class for parseOneRegisterAndImmediate (D and A registers)\n */\nexport class OneRegisterAndImmediateResult {\n  registerD: u8\n  registerA: u8\n  immediateX: i64\n  \n  constructor(registerD: u8, registerA: u8, immediateX: i64) {\n    this.registerD = registerD\n    this.registerA = registerA\n    this.immediateX = immediateX\n  }\n}\n\n/**\n * Base interface for all PVM instruction handlers\n *\n * Gray Paper Reference: pvm.tex section 7.1-7.3\n */\nexport interface PVMInstructionHandler {\n  opcode: i32\n  name: string\n\n  /**\n   * Execute the instruction (mutates context in place)\n   * @returns resultCode (null = continue, otherwise halt/panic/etc)\n   */\n  execute(context: InstructionContext): InstructionResult\n\n  /**\n   * Validate instruction operands\n   */\n  validate(operands: Uint8Array): boolean\n\n  /**\n   * Disassemble instruction to string representation\n   */\n  disassemble(operands: Uint8Array): string\n}\n\n/**\n * Abstract base class for PVM instructions\n * Implements Gray Paper instruction patterns\n */\nexport class BaseInstruction implements PVMInstructionHandler {\n  opcode: i32 = 0\n  name: string = ''\n\n  /**\n   * Get register index from operand byte (Gray Paper pattern)\n   * r_A = min(12, operand_byte mod 16)\n   */\n  getRegisterIndex(operandByte: u8): u8 {\n    return min(12, operandByte & 0x0f) as u8 // Low nibble\n  }\n\n  /**\n   * Get register A from first operand byte (low nibble)\n   * Test vector format: operands[0] = (B << 4) | A\n   *\n   * Gray Paper: Missing operands means invalid instruction  TRAP\n   */\n  getRegisterA(operands: Uint8Array): u8 {\n    return this.getRegisterIndex(operands[0])\n  }\n\n  /**\n   * Get immediate X length from high nibble of first operand byte\n   * Used in branch instructions with variable-length immediates\n   * Gray Paper: l_X = min(4, (operands[0] >> 4) & 0x07)\n   */\n  getImmediateLengthX(operands: Uint8Array): i32 {\n    return min(4, i32((operands[0] >> 4) & 0x07))\n  }\n\n  /**\n   * Get immediate X length from low 3 bits of first operand byte\n   * Used in two-immediate instructions (STORE_IMM_* opcodes 30-33)\n   * Gray Paper pvm.tex 7.4.4 line 288: l_X = min(4, instructions[+1] mod 8)\n   */\n  getImmediateLengthXFromLowBits(operands: Uint8Array): i32 {\n    return min(4, i32(operands[0] & 0x07))\n  }\n\n  /**\n   * Parse one register and two immediate operands according to Gray Paper 7.4.6\n   * Used by opcodes 70-73 (STORE_IMM_IND_U8/U16/U32/U64)\n   *\n   * Gray Paper pvm.tex 7.4.6 lines 360-368:\n   * - r_A = min(12, operands[0] mod 16)\n   * - l_X = min(4, operands[0]/16 mod 8)\n   * - immed_X = sext(l_X, decode[l_X](operands[1:l_X]))\n   * - l_Y = min(4, max(0,  - l_X - 1))\n   * - immed_Y = sext(l_Y, decode[l_Y](operands[1+l_X:l_Y]))\n   *\n   * Where:  = Fskip() = skip distance\n   */\n  /**\n   * Parse \"One Register & One Immediate\" format (Gray Paper Format 1)\n   * Used by opcodes 50-53, 70-73\n   * r_A = min(12, instructions[+1] mod 16)\n   * l_X = min(4, max(0,  - 1))\n   * immed_X = sext{l_X}{decode[l_X]{instructions[+2:l_X]}}\n   */\n  parseRegisterAndOneImmediate(\n    operands: Uint8Array,\n    fskip: i32,\n  ): RegisterAndImmediateResult {\n    // r_A from low 4 bits of operands[0]\n    const registerA = this.getRegisterIndex(operands[0])\n\n    // l_X = min(4, max(0,  - 1))\n    const lengthX = min(4, max(0, fskip - 1))\n\n    // immed_X starts at operands[1]\n    const immediateX = this.getImmediateValue(operands, 1, lengthX)\n\n    return new RegisterAndImmediateResult(registerA, immediateX)\n  }\n\n  /**\n   * Parse \"One Register, One Immediate and One Offset\" format (Gray Paper Format 2)\n   * Used by opcodes 80+\n   * r_A = min(12, instructions[+1] mod 16)\n   * l_X = min(4, floor(instructions[+1]/16) mod 8)\n   * immed_X = sext{l_X}{decode[l_X]{instructions[+2:l_X]}}\n   * l_Y = min(4, max(0,  - l_X - 1))\n   * immed_Y =  + signfunc{l_Y}(decode[l_Y]{instructions[+2+l_X:l_Y]})\n   */\n  parseRegisterAndTwoImmediates(\n    operands: Uint8Array,\n    fskip: i32,\n  ): RegisterAndTwoImmediatesWithLengthsResult {\n    // r_A from low 4 bits of operands[0]\n    const registerA = this.getRegisterIndex(operands[0])\n\n    // l_X = min(4, operands[0]/16 mod 8) - HIGH nibble bits 4-6\n    const lengthX = min(4, i32((operands[0] >> 4) & 0x07))\n\n    // immed_X starts at operands[1]\n    const immediateX = this.getImmediateValue(operands, 1, lengthX)\n\n    // l_Y = min(4, max(0,  - l_X - 1))\n    const lengthY = min(4, max(0, fskip - lengthX - 1))\n\n    // immed_Y starts after immed_X\n    const immediateY = this.getImmediateValue(operands, 1 + lengthX, lengthY)\n\n    return new RegisterAndTwoImmediatesWithLengthsResult(registerA, lengthX, immediateX, lengthY, immediateY)\n  }\n\n  /**\n   * Parse \"Two Registers and Two Immediates\" format (Gray Paper Format 5)\n   * Used by opcode 180 (LOAD_IMM_JUMP_IND)\n   * r_A = min(12, (instructions[+1]) mod 16)\n   * r_B = min(12, instructions[+1]/16)\n   * l_X = min(4, instructions[+2] mod 8)\n   * immed_X = sext{l_X}{decode[l_X]{instructions[+3:l_X]}}\n   * l_Y = min(4, max(0,  - l_X - 2))\n   * immed_Y = sext{l_Y}{decode[l_Y]{instructions[+3+l_X:l_Y]}}\n   */\n  parseTwoRegistersAndTwoImmediates(\n    operands: Uint8Array,\n    fskip: i32,\n  ): TwoRegistersAndTwoImmediatesWithLengthsResult {\n    // r_A = min(12, (instructions[+1]) mod 16)\n    const registerA = this.getRegisterIndex(operands[0])\n\n    // r_B = min(12, instructions[+1]/16)\n    const registerB = this.getRegisterB(operands)\n\n    // l_X = min(4, instructions[+2] mod 8)\n    const lengthX = min(4, i32(operands[1] & 0x07))\n\n    // immed_X = sext{l_X}{decode[l_X]{instructions[+3:l_X]}}\n    const immediateX = this.getImmediateValue(operands, 2, lengthX)\n\n    // l_Y = min(4, max(0,  - l_X - 2))\n    const lengthY = min(4, max(0, fskip - lengthX - 2))\n\n    // immed_Y = sext{l_Y}{decode[l_Y]{instructions[+3+l_X:l_Y]}}\n    const immediateY = this.getImmediateValue(operands, 2 + lengthX, lengthY)\n\n    return new TwoRegistersAndTwoImmediatesWithLengthsResult(registerA, registerB, lengthX, immediateX, lengthY, immediateY)\n  }\n\n  /**\n   * Parse two immediate operands (no register)\n   * Gray Paper pvm.tex 7.4.4 lines 286-291:\n   * - l_X = min(4, instructions[+1] mod 8)\n   * - immed_X = sext(l_X, decode[l_X](instructions[+2:l_X]))\n   * - l_Y = min(4, max(0,  - l_X - 1))\n   * - immed_Y = sext(l_Y, decode[l_Y](instructions[+2+l_X:l_Y]))\n   *\n   * Used by opcodes 30-33 (STORE_IMM_U8/U16/U32/U64)\n   * @param skip - Skip distance (default: 1 for test vectors with all-1s bitmask)\n   */\n  parseTwoImmediates(\n    operands: Uint8Array,\n    fskip: i32,\n  ): TwoImmediatesWithLengthsResult {\n    // FIX: Use low 3 bits instead of high nibble\n    const lengthX = min(4, i32(operands[0] & 0x07)) // mod 8 = low 3 bits\n\n    // immed_X starts at operands[1]\n    const immediateX = this.getImmediateValue(operands, 1, lengthX)\n\n    // l_Y = min(4, max(0,  - l_X - 1))\n    const lengthY = min(4, max(0, fskip - lengthX - 1))\n\n    // immed_Y starts after immed_X\n    const immediateY = this.getImmediateValue(operands, 1 + lengthX, lengthY)\n\n    return new TwoImmediatesWithLengthsResult(lengthX, immediateX, lengthY, immediateY)\n  }\n\n  /**\n   * Parse one register and one immediate according to Gray Paper 7.4.5\n   * Used by opcodes with one register + one immediate pattern\n   *\n   * Gray Paper pvm.tex 7.4.5 lines 329-333:\n   * - r_A = min(12, operands[0] mod 16)\n   * - l_X = min(4, max(0,  - 1))\n   * - immed_X = sext(l_X, decode[l_X](operands[1:l_X]))\n   *\n   * Where:  = Fskip() = skip distance\n   */\n  parseOneRegisterAndImmediate(\n    operands: Uint8Array,\n    fskip: i32,\n  ): OneRegisterAndImmediateWithLengthResult {\n    // r_A from low 4 bits of operands[0]\n    const registerA = this.getRegisterIndex(operands[0])\n\n    // l_X = min(4, max(0,  - 1))\n    const lengthX = min(4, max(0, fskip - 1))\n\n    // immed_X starts at operands[1], sign-extended\n    const immediateX = this.getImmediateValue(operands, 1, lengthX)\n\n    return new OneRegisterAndImmediateWithLengthResult(registerA, lengthX, immediateX)\n  }\n\n  parseOneRegisterAndImmediateUnsigned(\n    operands: Uint8Array,\n    fskip: i32,\n  ): OneRegisterAndImmediateWithLengthUnsignedResult {\n    // r_A from low 4 bits of operands[0]\n    const registerA = this.getRegisterIndex(operands[0])\n\n    // l_X = min(4, max(0,  - 1))\n    const lengthX = min(4, max(0, fskip - 1))\n\n    // immed_X starts at operands[1], unsigned\n    const immediateX = this.getImmediateValueUnsigned(operands, 1, lengthX)\n\n    return new OneRegisterAndImmediateWithLengthUnsignedResult(registerA, lengthX, immediateX)\n  }\n\n  /**\n   * Get immediate X length from high nibble bits 4-6 of first operand byte\n   * Used in one register + two immediate instructions (STORE_IMM_IND_* opcodes 70-73)\n   * Gray Paper pvm.tex 7.4.6 line 365: l_X = min(4, operands[0]/16 mod 8)\n   */\n  getImmediateLengthXFromHighBits(operands: Uint8Array): i32 {\n    return min(4, i32((operands[1] >> 4) & 0x07))\n  }\n\n  /**\n   * Parse two registers and one immediate according to Gray Paper 7.4.9\n   * Used by opcodes 120-299 (Two Registers & One Immediate pattern)\n   *\n   * Operand format (lines 462-469):\n   * - operands[0]: r_A (low 4 bits) + r_B (high 4 bits)\n   * - operands[1:1+l_X]: immed_X (sign-extended)\n   *\n   * Where: l_X = min(4, max(0,  - 1))\n   */\n  parseTwoRegistersAndImmediate(\n    operands: Uint8Array,\n    fskip: i32,\n  ): TwoRegistersAndImmediateWithLengthResult {\n    // r_A from low 4 bits, r_B from high 4 bits\n    const registerA = this.getRegisterIndex(operands[0])\n    const registerB = this.getRegisterB(operands)\n\n    // l_X = min(4, max(0,  - 1))\n    const lengthX = min(4, max(0, fskip - 1))\n\n    // immed_X starts at operands[1], sign-extended\n    const immediateX = this.getImmediateValue(operands, 1, lengthX)\n\n    return new TwoRegistersAndImmediateWithLengthResult(registerA, registerB, lengthX, immediateX)\n  }\n\n  /**\n   * Parse branch instruction operands (One Register, One Immediate, One Offset)\n   * Returns: {registerA, immediateX, offset, targetAddress}\n   * Gray Paper pvm.tex line 394: immed_Y =  + signfunc{l_Y}(decode[l_Y]{instructions[+2+l_X:l_Y]})\n   * \n   * signfunc{n}(a) = { a if a < 2^{8-1}, a - 2^{8} otherwise }\n   */\n  parseBranchOperands(\n    operands: Uint8Array,\n    currentPC: u32,\n  ): BranchOperandsResult {\n    const registerA = this.getRegisterIndex(operands[0])\n    const lengthX = this.getImmediateLengthX(operands)\n    const immediateX = this.getImmediateValue(operands, 1, lengthX)\n\n    // Offset Y starts after immediate X\n    // Gray Paper: l_Y = min(4, max(0,  - l_X - 1))\n    const lengthY = min(4, max(0, i32(operands.length) - lengthX - 1))\n    \n    // Read offset as unsigned first\n    const rawOffset_u64 = this.getImmediateValueUnsigned(operands, 1 + lengthX, lengthY)\n    const rawOffset = i64(rawOffset_u64)\n    \n    // Apply Gray Paper signfunc: signfunc{n}(a) = { a if a < 2^{8-1}, a - 2^{8} otherwise }\n    // This converts unsigned value to signed in range [-2^{8-1}, 2^{8-1}-1]\n    const signBitPosition = i64(8 * lengthY - 1)\n    const signBit = lengthY > 0 ? i64((rawOffset >> signBitPosition) & i64(1)) : i64(0)\n    const offset =\n      signBit === i64(0) ? rawOffset : rawOffset - (i64(1) << i64(8 * lengthY))\n\n    // Calculate target address: immed_Y =  + signfunc{l_Y}(offset)\n    const targetAddress = u32(i32(currentPC) + i32(offset))\n\n    return new BranchOperandsResult(registerA, immediateX, offset, targetAddress)\n  }\n\n  /**\n   * Get immediate value as unsigned 64-bit integer (no sign extension)\n   * Used for unsigned comparisons and operations\n   */\n  getImmediateValueUnsigned(\n    operands: Uint8Array,\n    startIndex: i32,\n    length: i32,\n  ): u64 {\n    // Determine how many bytes to read\n    const bytesToRead = length > 0 ? length : min(4, i32(operands.length) - startIndex)\n    const end = min(i32(operands.length), startIndex + bytesToRead)\n\n    if (end <= startIndex) return u64(0)\n\n    // Read little-endian bytes (no sign extension) as unsigned\n    let value = u64(0)\n    for (let i = startIndex; i < end; i++) {\n      value |= u64(operands[i]) << u64((i - startIndex) * 8)\n    }\n\n    return value\n  }\n  \n  signedCompare(a: i64, b: i64): i32 {\n    const signedA = this.toSigned64(a)\n    const signedB = this.toSigned64(b)\n\n    if (signedA < signedB) return -1\n    if (signedA > signedB) return 1\n    return 0\n  }\n\n  /**\n   * Parse register-to-register branch operands (Two Registers & One Offset)\n   * Returns: {registerA, registerB, targetAddress}\n   * Gray Paper pvm.tex line 541: immed_X =  + signfunc{l_X}(decode[l_X]{getctions[+2:l_X]})\n   * \n   * signfunc{n}(a) = { a if a < 2^{8-1}, a - 2^{8} otherwise }\n   */\n  parseRegisterBranchOperands(\n    operands: Uint8Array,\n    currentPC: u32,\n  ): RegisterBranchOperandsResult {\n    const registerA = this.getRegisterIndex(operands[0])\n    const registerB = this.getRegisterB(operands)\n\n    // Gray Paper: l_X = min(4, max(0,  - 1))\n    // Offset starts at operands[1] (after register byte at +1, so offset is at +2)\n    const lengthX = min(4, max(0, i32(operands.length) - 1))\n    \n    // Read offset as unsigned first\n    const rawOffset_u64 = this.getImmediateValueUnsigned(operands, 1, lengthX)\n    const rawOffset = i64(rawOffset_u64)\n    \n    // Apply Gray Paper signfunc: signfunc{n}(a) = { a if a < 2^{8-1}, a - 2^{8} otherwise }\n    // This converts unsigned value to signed in range [-2^{8-1}, 2^{8-1}-1]\n    const signBitPosition = i64(8 * lengthX - 1)\n    const signBit = lengthX > 0 ? i64((rawOffset >> signBitPosition) & i64(1)) : i64(0)\n    const offset =\n      signBit === i64(0) ? rawOffset : rawOffset - (i64(1) << i64(8 * lengthX))\n\n    // Calculate target address: immed_X =  + signfunc{l_X}(offset)\n    const targetAddress = u32(i32(currentPC) + i32(offset))\n\n    return new RegisterBranchOperandsResult(registerA, registerB, offset, targetAddress)\n  }\n\n  /**\n   * Parse one offset operand according to Gray Paper formula\n   * Used by JUMP instruction (opcode 0x40)\n   *\n   * Gray Paper pvm.tex 7.4.3 lines 308-314:\n   * \\using l_X = \\min(4, \\ell) \\,,\\quad\n   * \\immed_X \\equiv \\imath + \\signfunc{l_X}(\\decode[l_X]{\\instructions\\subrange{\\imath+1}{l_X}})\n   *\n   * @param operands The operand bytes (starting from +1)\n   * @param fskip The skip distance ()\n   * @param currentPC The current program counter ()\n   * @returns The target address (immed_X)\n   */\n  parseOneOffset(\n    operands: Uint8Array,\n    fskip: i32,\n    currentPC: u32,\n  ): u32 {\n    // l_X = min(4, )\n    const lengthX = min(4, fskip)\n\n    // Read the offset bytes starting from operands[0] (which is +1)\n    // Gray Paper: \\signfunc{l_X}(\\decode[l_X]{\\instructions\\subrange{\\imath+1}{l_X}})\n    const rawOffset_u64 = this.getImmediateValueUnsigned(operands, 0, lengthX)\n    const rawOffset = i64(rawOffset_u64)\n\n    // Apply Gray Paper sign function: \\signfunc{l_X}\n    // signfunc{n}(a) = { a if a < 2^{8-1}, a - 2^{8} otherwise }\n    const signBitPosition = i64(8 * lengthX - 1)\n    const signBit = i64((rawOffset >> signBitPosition) & i64(1))\n    const offset =\n      signBit === i64(0) ? rawOffset : rawOffset - (i64(1) << i64(8 * lengthX))\n\n    // Calculate target address: immed_X =  + signfunc{l_X}(offset)\n    const targetAddress = u32(i32(currentPC) + i32(offset))\n\n    return targetAddress\n  }\n\n  /**\n   * Get register B from first operand byte (high nibble)\n   * Test vector format: operands[0] = (B << 4) | A\n   *\n   * Gray Paper: Missing operands means invalid instruction  TRAP\n   */\n  getRegisterB(operands: Uint8Array): u8 {\n    return min(12, (operands[0] >> 4) & 0x0f) as u8\n  }\n\n  /**\n   * Parse \"Two Registers\" format (Gray Paper pvm.tex lines 418-428)\n   * Used by instructions that only need two registers (no immediate)\n   * r_D = min(12, (instructions[+1]) mod 16) - destination (low nibble)\n   * r_A = min(12, instructions[+1]/16) - source (high nibble)\n   */\n  parseTwoRegisters(operands: Uint8Array): TwoRegistersResult {\n    const registerD = this.getRegisterIndex(operands[0]) // r_D from low nibble\n    const registerA = this.getRegisterB(operands) // r_A from high nibble\n    return new TwoRegistersResult(registerD, registerA)\n  }\n\n  /**\n   * Get register D (destination) from second operand byte\n   * Test vector format: operands[1] = D\n   *\n   * Gray Paper: Missing operands means invalid instruction  TRAP\n   */\n  getRegisterD(operands: Uint8Array): u8 {\n    return this.getRegisterIndex(operands[1])\n  }\n\n  /**\n   * Get immediate value as 64-bit i64 with proper sign extension\n   * Gray Paper: Immediate values are little-endian encoded with sign extension\n   * Variable length, sign-extended to 64 bits according to Gray Paper formula\n   */\n  getImmediateValue(\n    operands: Uint8Array,\n    startIndex: i32,\n    length: i32,\n  ): i64 {\n    // If length is 0, return 0 immediately (no bytes to read)\n    if (length === 0) return i64(0)\n    \n    // Determine how many bytes to read\n    const bytesToRead = length\n    const end = min(i32(operands.length), startIndex + bytesToRead)\n\n    if (end <= startIndex) return i64(0)\n\n    // Read little-endian bytes\n    let value = i64(0)\n    for (let i = startIndex; i < end; i++) {\n      value |= i64(operands[i]) << i64((i - startIndex) * 8)\n    }\n\n    // Apply Gray Paper sign extension formula: sext{n}(x)\n    return this.signExtend(value, bytesToRead)\n  }\n\n  setRegisterValue(\n    registers: RegisterState,\n    index: u8,\n    value: u64,\n  ): void {\n    registers[index] = value\n  }\n\n  /**\n   * Get register value (all registers store 64-bit values)\n   */\n  getRegisterValue(\n    registers: RegisterState,\n    index: u8,\n  ): u64 {\n    return registers[index]\n  }\n\n  /**\n   * Get register value as 64-bit u64 (for 64-bit operations)\n   * Gray Paper: 64-bit operations can read from ANY register\n   * For 32-bit registers, zero-extend to 64 bits\n   */\n  getRegisterValueAs64(\n    registers: RegisterState,\n    index: u8,\n  ): u64 {\n    return this.getRegisterValue(registers, index)\n  }\n\n  /**\n   * Get register value masked to 32 bits (for 32-bit operations)\n   * Gray Paper: 32-bit operations can read from ANY register, mask to 32 bits\n   * Returns unsigned 32-bit as u64\n   */\n  getRegisterValueAs32(\n    registers: RegisterState,\n    index: u8,\n  ): u64 {\n    return this.getRegisterValue(registers, index) & u64(0xffffffff)\n  }\n\n  /**\n   * Sign-extend a value to 64 bits according to Gray Paper formula\n   * Gray Paper pvm.tex equation (1): sext{n}(x) = x + floor(x/2^(8-1)) * (2^64 - 2^(8))\n   *\n   * @param value The value to sign-extend (should be masked to appropriate bit width)\n   * @param octets Number of octets (bytes) the original value occupied (1, 2, 3, 4, or 8)\n   * @returns Sign-extended 64-bit unsigned value\n   */\n  signExtend(value: u64, octets: i32): u64 {\n    // Gray Paper formula: sext{n}(x) = x + floor(x/2^(8n-1)) * (2^64 - 2^(8n))\n    // Work with unsigned values for bit manipulation\n    // First, mask the value to the appropriate bit width\n    let maskedValue: u64\n    if (octets === 1) {\n      maskedValue = value & u64(0xff)\n    } else if (octets === 2) {\n      maskedValue = value & u64(0xffff)\n    } else if (octets === 3) {\n      maskedValue = value & u64(0xffffff)\n    } else if (octets === 4) {\n      maskedValue = value & u64(0xffffffff)\n    } else {\n      // For 8 octets, no masking needed (already 64-bit)\n      maskedValue = value\n    }\n    \n    const n = u64(octets)\n    const signBitPosition = u64(8) * n - u64(1)\n    // Cast shift amount to i32 for proper bit shifting in AssemblyScript\n    const signBit = (maskedValue >> i32(signBitPosition)) & u64(1)\n    \n    \n    // Calculate extension mask: 2^64 - 2^(8n) = (0xFFFFFFFFFFFFFFFF << (8*n)) | (value & mask)\n    // For 16-bit (octets=2): mask should be 0xFFFFFFFFFFFF0000\n    // Use bitwise OR with pre-computed masks to avoid overflow\n    let extensionMask: u64\n    if (octets === 1) {\n      extensionMask = u64(0xFFFFFFFFFFFFFF00)\n    } else if (octets === 2) {\n      extensionMask = u64(0xFFFFFFFFFFFF0000)\n    } else if (octets === 3) {\n      extensionMask = u64(0xFFFFFFFFFF000000)\n    } else if (octets === 4) {\n      extensionMask = u64(0xFFFFFFFF00000000)\n    } else {\n      // For 8 octets, no extension needed (already 64-bit)\n      extensionMask = u64(0)\n    }\n\n    // If sign bit is set, apply the extension mask\n    if (signBit !== u64(0)) {\n      return maskedValue | extensionMask\n    } else {\n      return maskedValue\n    }\n  }\n\n  /**\n   * Sign-extend a 32-bit value to 64 bits\n   * Gray Paper: sext{4}{value}\n   */\n  signExtend32(value: u64): u64 {\n    return this.signExtend(value & u64(0xffffffff), 4)\n  }\n\n  /**\n   * Convert a sign-extended value to a signed offset for relative addressing\n   * If the sign-extended value has the high bit set (>= 2^63), interpret as negative\n   * This allows PC + signedOffset to effectively subtract when the offset is negative\n   *\n   * The sign extension already creates the correct two's complement representation,\n   * but we need to convert it from unsigned i64 to signed interpretation.\n   *\n   * @param signExtendedValue The sign-extended value (64-bit i64)\n   * @param originalLength The original length in bytes of the encoded value (for debugging)\n   * @returns Signed offset that can be added to PC (negative if high bit is set)\n   */\n  toSigned64(signExtendedValue: i64): i64 {\n    // Convert unsigned 64-bit value to signed 64-bit interpretation\n    // If MSB is set (>= 2^63), subtract 2^64 to get negative value\n    // Use u64 for the calculation to avoid overflow\n    const threshold = i64(1) << i64(63)\n    if (signExtendedValue >= threshold) {\n      // signExtendedValue - 2^64\n      // Since 2^64 = 0x10000000000000000 doesn't fit in u64, we use:\n      // value - 2^64 = value - 0x8000000000000000 - 0x8000000000000000\n      const value_u64 = u64(signExtendedValue)\n      const result_u64 = value_u64 - u64(0x8000000000000000) - u64(0x8000000000000000)\n      return i64(result_u64)\n    } else {\n      return signExtendedValue\n    }\n  }\n\n  toUnsigned64(value: i64): i64 {\n    // Convert signed back to unsigned\n    // For negative values, add 2^64 to get the unsigned representation\n    // Use u64 arithmetic to avoid overflow: u64 cast gives correct two's complement representation\n    if (value < i64(0)) {\n      return i64(u64(value))\n    }\n    return value\n  }\n\n  /**\n   * Set register value with 64-bit result (for 64-bit operations)\n   * Gray Paper: reg'_D = result mod 2^64\n   * Works with ANY register - truncates to 32 bits for r8-r12\n   */\n  setRegisterValueWith64BitResult(\n    registers: RegisterState,\n    index: u8,\n    value: u64,\n  ): void {\n    this.setRegisterValue(registers, index, value)\n  }\n\n  /**\n   * Set register value with 32-bit sign-extension (for 32-bit operations)\n   * Gray Paper: reg'_D = sext{4}{result mod 2^32}\n   * Works with ANY register - sign-extends to 64 bits for r0-r7\n   */\n  setRegisterValueWith32BitResult(\n    registers: RegisterState,\n    index: u8,\n    value: u64,\n  ): void {\n    // Gray Paper: 32-bit ops sign-extend to 64 bits for ALL registers\n    const value32 = value & u64(0xffffffff) // Mask to 32 bits\n    const extended = this.signExtend32(value32)\n    this.setRegisterValue(registers, index, extended)\n  }\n\n  /**\n   * Default validation - check minimum operand count\n   */\n  validate(operands: Uint8Array): boolean {\n    return operands.length >= 1\n  }\n\n  /**\n   * Default disassembly - show opcode and operands\n   */\n  disassemble(operands: Uint8Array): string {\n    return this.name + ' ' + bytesToHex(operands)\n  }\n\n  /**\n   * Convert little-endian bytes to i64\n   */\n  bytesToBigIntLE(bytes: Uint8Array): u64 {\n    let value = u64(0)\n    for (let i = 0; i < bytes.length; i++) {\n      value |= u64(bytes[i]) << u64(i * 8)\n    }\n    return value\n  }\n\n  /**\n   * Convert i64 to little-endian bytes of specified length\n   */\n  bigIntToBytesLE(value: i64, numBytes: i32): Uint8Array {\n    const bytes = new Uint8Array(numBytes)\n    let val = value\n    for (let i = 0; i < numBytes; i++) {\n      bytes[i] = u8(val & i64(0xff))\n      val = val >> i64(8)\n    }\n    return bytes\n  }\n\n  /**\n   * Validate branch target address according to Gray Paper basic block rules\n   * Used by all branching instructions (JUMP, BRANCH_*, etc.)\n   *\n   * Gray Paper: Branches must target basic block starts\n   * Basic blocks are defined as:\n   * basicblocks  ({0}  {n + 1 + Fskip(n) | n  Nmax(len(c))  k[n] = 1  c[n]  T})  {n | k[n] = 1  c[n]  U}\n   *\n   * Where T is the set of termination instructions (trap, fallthrough, jumps, branches)\n   *\n   * @param targetAddress The address to validate\n   * @param context The instruction context\n   * @returns InstructionResult with PANIC if invalid, null if valid\n   */\n  validateBranchTarget(\n    targetAddress: u32,\n    context: InstructionContext,\n  ): InstructionResult | null {\n    // Check if target address is within valid bounds\n    if (i32(targetAddress) >= context.code.length) {\n      return new InstructionResult(RESULT_CODE_PANIC)\n    }\n\n    // Gray Paper line 124: basicblocks  ({0}  {n + 1 + Fskip(n) | .})  {n | k[n] = 1  c[n]  U}\n    // The intersection requires BOTH conditions:\n    // 1. Target is in {0}  {n + 1 + Fskip(n) | .} (address 0 OR follows termination)\n    // 2. Target is in {n | k[n] = 1  c[n]  U} (valid opcode position)\n    \n    // Check if target is a valid opcode position (bitmask check) - required by intersection\n    // This must be checked even for address 0\n    if (\n      i32(targetAddress) >= context.bitmask.length ||\n      context.bitmask[targetAddress] === 0\n    ) {\n      return new InstructionResult(RESULT_CODE_PANIC)\n    }\n\n    // Check if target is address 0 (always valid basic block start if bitmask[0] = 1)\n    if (targetAddress === 0) {\n      return null // Valid - allow the branch (bitmask already checked above)\n    }\n\n    // Gray Paper: Check if target is a basic block start\n    // Basic blocks are defined as:\n    // basicblocks  ({0}  {n + 1 + Fskip(n) | n  Nmax(len(c))  k[n] = 1  c[n]  T})  {n | k[n] = 1  c[n]  U}\n    //\n    // Where T is the set of termination instructions\n    // This means a valid basic block start is either:\n    // 1. Address 0 (already handled above)\n    // 2. An instruction that follows a termination instruction: n + 1 + Fskip(n)\n\n    // Check if target follows a termination instruction\n    const targetIndex = u32(targetAddress)\n\n    // Look backwards to find if there's a termination instruction that ends just before our target\n    for (let i: i32 = 0; i < i32(targetIndex); i++) {\n      if (context.bitmask[i] === 1) {\n        const opcode = u8(context.code[i])\n        if (isTerminationInstruction(opcode)) {\n          // Calculate where this termination instruction ends using Fskip\n          const skipDistance = this.calculateSkipDistance(i, context.bitmask)\n          const instructionEnd = i + 1 + skipDistance\n\n          // If this termination instruction ends just before our target, it's a valid basic block start\n          if (instructionEnd === targetIndex) {\n            return null // Valid basic block start\n          }\n        }\n      }\n    }\n\n    // If we get here, the target is not a valid basic block start\n    return new InstructionResult(RESULT_CODE_PANIC)\n  }\n\n  /**\n   * Calculate skip distance for an instruction (Gray Paper Fskip function)\n   * Gray Paper: Fskip(i) = min(24, j  N : (k  {1,1,.})[i+1+j] = 1)\n   *\n   * This calculates how many octets (minus 1) to the next instruction's opcode\n   */\n  calculateSkipDistance(\n    instructionIndex: i32,\n    bitmask: Uint8Array,\n  ): i32 {\n    // Gray Paper: Fskip(i) = min(24, j  N : (k  {1,1,.})[i+1+j] = 1)\n    // We need to find the next set bit after instructionIndex + 1\n\n    for (let j = 1; j <= 24; j++) {\n      const nextIndex = instructionIndex + j\n      if (nextIndex >= bitmask.length || bitmask[nextIndex] === 1) {\n        return j - 1\n      }\n    }\n    return 24 // Maximum skip distance\n  }\n\n  /**\n   * Execute method - must be overridden by subclasses\n   * Default implementation returns panic to indicate it must be overridden\n   */\n  execute(context: InstructionContext): InstructionResult {\n    // This should be overridden by all instruction subclasses\n    return new InstructionResult(RESULT_CODE_PANIC)\n  }\n}\n","/**\n * Control Flow Instructions\n *\n * NOP, HALT, ERROR, CALL, RETURN, JUMP, JUMP_IF, JUMP_IF_NOT\n */\n\nimport {\n  HALT_ADDRESS,\n  OPCODE_FALLTHROUGH,\n  OPCODE_JUMP,\n  OPCODE_JUMP_IND,\n  OPCODE_LOAD_IMM_JUMP,\n  OPCODE_LOAD_IMM_JUMP_IND,\n  OPCODE_TRAP,\n  RESULT_CODE_HALT,\n  RESULT_CODE_PANIC,\n} from '../config'\nimport { InstructionContext, InstructionResult } from '../types'\nimport { BaseInstruction } from './base'\n\n/**\n * TRAP instruction (opcode 0x00)\n * Panics the PVM as specified in Gray Paper\n */\nexport class TRAPInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_TRAP\n  name: string = 'TRAP'\n\n  execute(_context: InstructionContext): InstructionResult {\n    return new InstructionResult(RESULT_CODE_PANIC)\n  }\n}\n\n/**\n * FALLTHROUGH instruction (opcode 0x01)\n * No operation as specified in Gray Paper\n */\nexport class FALLTHROUGHInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_FALLTHROUGH\n  name: string = 'FALLTHROUGH'\n\n  execute(_context: InstructionContext): InstructionResult {\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * JUMP instruction (opcode 0x40)\n * Unconditional jump with offset as specified in Gray Paper\n * \n * Gray Paper (pvm.tex line 322):\n * Format: \"One Offset\" (lines 308-314)\n * immed_X   + signfunc{l_X}(decode[l_X]{instructions[+1:l_X]})\n * Mutation: branch(immed_X, )\n */\nexport class JUMPInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_JUMP\n  name: string = 'JUMP'\n\n  execute(context: InstructionContext): InstructionResult {\n    // Gray Paper: Instructions with Arguments of One Offset\n    // immed_X =  + signfunc{l_X}(decode[l_X]{instructions[+1:l_X]})\n    const targetAddress = this.parseOneOffset(\n      context.operands,\n      context.fskip,\n      context.programCounter,\n    )\n\n    // Gray Paper: Static jumps must target basic block starts\n    // Use validateBranchTarget for consistent validation with other branch instructions\n    const validationResult = this.validateBranchTarget(targetAddress, context)\n    if (validationResult !== null) {\n      return validationResult\n    }\n\n    // Mutate context directly\n    context.programCounter = targetAddress\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * JUMP_IND instruction (opcode 0x50)\n * Indirect jump as specified in Gray Paper\n *\n * Gray Paper (pvm.tex line 343):\n * Format: \"One Register & One Immediate\" (lines 326-335)\n * r_A = min(12, instructions[+1] mod 16)\n * l_X = min(4, max(0,  - 1))\n * immed_X  sext{l_X}{decode[l_X]{instructions[+2:l_X]}}\n * Mutation: djump((reg_A + immed_X) mod 2^32)\n *\n * Where djump(a) is defined in equations 211-216:\n * djump(a)  (, ') = {\n *   (halt, )                                 when a = 2^32 - 2^16\n *   (panic, )                                when a = 0  a > len(j)2  a mod 2  0  j_{(a/2)-1}  basicblocks\n *   (continue, j_{(a/2)-1})                   otherwise\n * }\n */\nexport class JUMP_INDInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_JUMP_IND\n  name: string = 'JUMP_IND'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseOneRegisterAndImmediate(context.operands, context.fskip)\n    const registerA: u8 = parseResult.registerA\n    const immediateX = parseResult.immediateX\n    const registerValue = this.getRegisterValueAs64(\n      context.registers,\n      registerA,\n    )\n\n    // Gray Paper djump logic (equation 211-216):\n    // djump(a)  (, ') = {\n    //   (halt, ) when a = 2^32 - 2^16\n    //   (panic, ) otherwhen a = 0  a > len(j)2  a mod 2  0  j_{(a/2) - 1}  basicblocks\n    //   (continue, j_{(a/2) - 1}) otherwise\n    // }\n    // a = (register + immediateX) % 2^32\n    const a = u64((registerValue + immediateX) & u64(0xffffffff))\n\n    // Check for HALT condition: a = 2^32 - 2^16\n    if (a === u64(HALT_ADDRESS)) {\n      return new InstructionResult(RESULT_CODE_HALT)\n    }\n\n    // Check for PANIC conditions:\n    // - a = 0\n    // - a > len(j)  2\n    // - a mod 2  0\n    const maxAddress = u32(context.jumpTable.length) * 2\n    if (a === u64(0) || a > u64(maxAddress) || (a % u64(2)) !== u64(0)) {\n      return new InstructionResult(RESULT_CODE_PANIC)\n    }\n\n    // Calculate jump table index: (a / 2) - 1\n    const index = i32((a / u64(2)) - u64(1))\n\n    // Check if index is valid\n    if (index < 0 || index >= context.jumpTable.length) {\n      return new InstructionResult(RESULT_CODE_PANIC)\n    }\n\n    // Get target from jump table\n    const targetAddress = context.jumpTable[index]\n\n    // Gray Paper: Validate that target is a valid basic block start\n    // This is the same validation as LOAD_IMM_JUMP and other branch instructions\n    // basicblocks = ({0}  {n + 1 + Fskip(n) : n is termination instruction})\n    //                {n : bitmask[n] = 1 and c[n] in valid opcodes}\n    const validationResult = this.validateBranchTarget(targetAddress, context)\n    if (validationResult !== null) {\n      return validationResult\n    }\n\n    // Mutate context directly\n    context.programCounter = targetAddress\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * LOAD_IMM_JUMP instruction (opcode 0x80)\n * Load immediate and jump as specified in Gray Paper\n * \n * Gray Paper (pvm.tex line 404):\n * Format: \"One Register, One Immediate and One Offset\" (lines 385-396)\n * r_A = min(12, instructions[+1] mod 16)\n * l_X = min(4, instructions[+1]/16 mod 8)\n * immed_X = sext{l_X}{decode[l_X]{instructions[+2:l_X]}}\n * l_Y = min(4, max(0,  - l_X - 1))\n * immed_Y =  + signfunc{l_Y}(decode[l_Y]{instructions[+2+l_X:l_Y]})\n * Mutation: branch(immed_Y, ), reg_A' = immed_X\n */\nexport class LOAD_IMM_JUMPInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_LOAD_IMM_JUMP\n  name: string = 'LOAD_IMM_JUMP'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseRegisterAndTwoImmediates(\n        context.operands,\n        context.fskip,\n      )\n    const registerA: u8 = parseResult.registerA\n    const immediateX = parseResult.immediateX\n    const immediateY = parseResult.immediateY\n\n    // Interpret immediateY as a signed offset\n    // If MSB is set in the original value, treat it as negative\n    // This ensures context.programCounter + signedOffset effectively subtracts when needed\n    const signedOffset = this.toSigned64(immediateY)\n    const targetAddress = u32(i32(context.programCounter) + i32(signedOffset))\n\n    // Gray Paper: Static jumps must target basic block starts\n    // Use validateBranchTarget to check if target is in basicblocks\n    // Gray Paper equation 200-204: branch(b, C)  panic if b not in basicblocks\n    // basicblocks = ({0}  {n + 1 + Fskip(n) : n is termination instruction})\n    //                {n : bitmask[n] = 1 and c[n] in valid opcodes}\n    const validationResult = this.validateBranchTarget(targetAddress, context)\n    if (validationResult !== null) {\n      return validationResult\n    }\n\n    // Set register A to immediateX (Gray Paper: reg_A' = immed_X)\n    this.setRegisterValueWith64BitResult(\n      context.registers,\n      registerA,\n      immediateX,\n    )\n\n    // Mutate context directly - set PC to target address\n    context.programCounter = targetAddress\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * LOAD_IMM_JUMP_IND instruction (opcode 0x180)\n * Load immediate and indirect jump as specified in Gray Paper\n * \n * Gray Paper (pvm.tex lines 583-586):\n * Format: \"Two Registers and Two Immediates\" (lines 560-575)\n * r_A = min(12, instructions[+1] mod 16)\n * r_B = min(12, instructions[+1]/16)\n * l_X = min(4, instructions[+2] mod 8)\n * immed_X = sext{l_X}{decode[l_X]{instructions[+3:l_X]}}\n * l_Y = min(4, max(0,  - l_X - 2))\n * immed_Y = sext{l_Y}{decode[l_Y]{instructions[+3+l_X:l_Y]}}\n * Mutation: djump((reg_B + immed_Y) mod 2^32), reg_A' = immed_X\n */\nexport class LOAD_IMM_JUMP_INDInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_LOAD_IMM_JUMP_IND\n  name: string = 'LOAD_IMM_JUMP_IND'\n\n  execute(context: InstructionContext): InstructionResult {\n    // Gray Paper: Instructions with Arguments of Two Registers and Two Immediates\n    // r_A = min(12, (instructions[+1]) mod 16)\n    // r_B = min(12, instructions[+1]/16)\n    // l_X = min(4, instructions[+2] mod 8)\n    // immed_X = sext{l_X}{decode[l_X]{instructions[+3:l_X]}}\n    // l_Y = min(4, max(0,  - l_X - 2))\n    // immed_Y = sext{l_Y}{decode[l_Y]{instructions[+3+l_X:l_Y]}}\n    const parseResult = this.parseTwoRegistersAndTwoImmediates(\n        context.operands,\n        context.fskip,\n      )\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n    const immediateY = parseResult.immediateY\n\n    // Gray Paper: djump((reg_B + immed_Y) mod 2^32)\n    // Read register B value BEFORE potentially overwriting it\n    const registerBValue = this.getRegisterValueAs64(\n      context.registers,\n      registerB,\n    )\n\n    // Gray Paper: reg_A' = immed_X\n    this.setRegisterValueWith64BitResult(\n      context.registers,\n      registerA,\n      immediateX,\n    )\n\n    const a = u64((registerBValue + immediateY) & u64(0xffffffff)) // mod 2^32\n\n    // Gray Paper djump logic (equation 11):\n    // Check for HALT condition: a = 2^32 - 2^16\n    if (a === u64(HALT_ADDRESS)) {\n      return new InstructionResult(RESULT_CODE_HALT)\n    }\n\n    // Check for PANIC conditions:\n    // - a = 0\n    // - a > len(j)  2\n    // - a mod 2  0\n    const maxAddress = u32(context.jumpTable.length) * 2\n    if (a === u64(0) || a > u64(maxAddress) || (a % u64(2)) !== u64(0)) {\n      return new InstructionResult(RESULT_CODE_PANIC)\n    }\n\n    // Calculate jump table index: (a / 2) - 1\n    const index = i32((a / u64(2)) - u64(1))\n\n    // Check if index is valid\n    if (index < 0 || index >= context.jumpTable.length) {\n      return new InstructionResult(RESULT_CODE_PANIC)\n    }\n\n    // Get target from jump table\n    const targetAddress = context.jumpTable[index]\n\n    // Gray Paper: Validate that target is a valid basic block start\n    // This is the same validation as LOAD_IMM_JUMP, JUMP_IND, and other branch instructions\n    // According to Gray Paper equation 11: j[(a/2)-1]  basicblocks  panic\n    // basicblocks = ({0}  {n + 1 + Fskip(n) : n is termination instruction})\n    //                {n : bitmask[n] = 1 and c[n] in valid opcodes}\n    const validationResult = this.validateBranchTarget(targetAddress, context)\n    if (validationResult !== null) {\n      return validationResult\n    }\n\n    context.programCounter = targetAddress\n\n    return new InstructionResult(-1)\n  }\n}\n","/**\n * System Instructions\n *\n * ECALLI - Host call with immediate value\n */\n\nimport { OPCODE_ECALLI, RESULT_CODE_HOST } from '../config'\nimport { InstructionContext, InstructionResult } from '../types'\nimport { BaseInstruction } from './base'\n\n/**\n * ECALLI instruction (opcode 0x0A / 10)\n * Host call with immediate value\n * Dispatches to General functions (0-13) and Accumulate functions (14-26)\n *\n * Gray Paper pvm.tex 7.4.1 line 264:\n *  = host  immed_X\n *\n * Operand format (lines 251-255):\n * - operands[0:l_X]: immed_X (variable-length immediate, sign-extended)\n * Where: l_X = min(4, )\n *\n * Note: No encoding byte - just raw immediate bytes (0-4 bytes)\n */\nexport class ECALLIInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_ECALLI\n  name: string = 'ECALLI'\n\n  execute(context: InstructionContext): InstructionResult {\n    // Gray Paper pvm.tex 7.4.1 line 264:  = host  immed_X\n    // The host function ID is in the immediate operand, not in r0\n    // We do NOT set r0 - the Gray Paper doesn't require it\n\n    return new InstructionResult(RESULT_CODE_HOST)\n  }\n}\n","/**\n * Memory Instructions\n *\n * LOAD_IMM_64, STORE_IMM variants, LOAD/STORE variants\n */\n\nimport {\n  OPCODE_LOAD_I8,\n  OPCODE_LOAD_I16,\n  OPCODE_LOAD_I32,\n  OPCODE_LOAD_IMM,\n  OPCODE_LOAD_IMM_64,\n  OPCODE_LOAD_U8,\n  OPCODE_LOAD_U16,\n  OPCODE_LOAD_U32,\n  OPCODE_LOAD_U64,\n  OPCODE_STORE_IMM_IND_U8,\n  OPCODE_STORE_IMM_IND_U16,\n  OPCODE_STORE_IMM_IND_U32,\n  OPCODE_STORE_IMM_IND_U64,\n  OPCODE_STORE_IMM_U8,\n  OPCODE_STORE_IMM_U16,\n  OPCODE_STORE_IMM_U32,\n  OPCODE_STORE_IMM_U64,\n  OPCODE_STORE_U8,\n  OPCODE_STORE_U16,\n  OPCODE_STORE_U32,\n  OPCODE_STORE_U64,\n  RESULT_CODE_FAULT,\n  RESULT_CODE_PANIC,\n  ZONE_SIZE,\n} from '../config'\nimport { InstructionContext, InstructionResult } from '../types'\nimport { BaseInstruction } from './base'\n\n/**\n * LOAD_IMM_64 instruction (opcode 0x20)\n * Load 64-bit immediate into register as specified in Gray Paper\n *\n * Gray Paper pvm.tex formula:\n * reg'_A = immed_X\n */\nexport class LOAD_IMM_64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_LOAD_IMM_64\n  name: string = 'LOAD_IMM_64'\n\n  execute(context: InstructionContext): InstructionResult {\n    // Gray Paper: Instructions with Arguments of One Register and One Extended Width Immediate\n    // r_A = min(12, instructions[+1] mod 16)\n    // immed_X = decode[8]{instructions[+2:8]} - decode 8 bytes as unsigned (no sign extension)\n    const registerA = this.getRegisterIndex(context.operands[0])\n    \n    // Read 8 bytes (64 bits) as unsigned little-endian\n    // Gray Paper: decode[8] means read 8 bytes without sign extension\n    let immediateX: u64 = u64(0)\n    for (let i = 0; i < 8 && (1 + i) < context.operands.length; i++) {\n      immediateX |= u64(context.operands[1 + i]) << u64(i * 8)\n    }\n\n    this.setRegisterValue(context.registers, registerA, immediateX)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * STORE_IMM_U8 instruction (opcode 0x30)\n * Store 8-bit immediate to memory\n *\n * Gray Paper pvm.tex formula:\n * mem'[immed_X] = immed_Y mod 2^8\n */\nexport class STORE_IMM_U8Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_STORE_IMM_U8\n  name: string = 'STORE_IMM_U8'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoImmediates(context.operands, context.fskip)\n    const immediateX = parseResult.immediateX\n    const immediateY = parseResult.immediateY\n\n    // mem'[immed_X] = immed_Y mod 2^8\n    const value = immediateY & u64(0xff)\n\n    // Cast signed immediate to unsigned address (mask to 32 bits)\n    const address = u64(immediateX) & u64(0xffffffff)\n    if (address < u64(ZONE_SIZE)) {\n      return new InstructionResult(RESULT_CODE_PANIC)\n    }\n\n    const writeResult = context.ram.writeOctets(\n      u32(address),\n      this.bigIntToBytesLE(value, 1),\n    )\n    if (writeResult.hasFault) {\n      return new InstructionResult(RESULT_CODE_FAULT, u32(writeResult.faultAddress))\n    }\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * STORE_IMM_U16 instruction (opcode 0x31)\n * Store 16-bit immediate to memory\n *\n * Gray Paper pvm.tex formula:\n * mem'[immed_X:2] = encode[2](immed_Y mod 2^16)\n */\nexport class STORE_IMM_U16Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_STORE_IMM_U16\n  name: string = 'STORE_IMM_U16'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoImmediates(context.operands, context.fskip)\n    const immediateX = parseResult.immediateX\n    const immediateY = parseResult.immediateY\n\n    // mem'[immed_X:2] = encode[2](immed_Y mod 2^16)\n    const value = immediateY & u64(0xffff)\n\n    const writeResult = context.ram.writeOctets(\n      u32(immediateX),\n      this.bigIntToBytesLE(value, 2),\n    )\n    if (writeResult.hasFault) {\n      return new InstructionResult(RESULT_CODE_FAULT, writeResult.faultAddress)\n    }\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * STORE_IMM_U32 instruction (opcode 0x32)\n * Store 32-bit immediate to memory\n *\n * Gray Paper pvm.tex formula:\n * mem'[immed_X:4] = encode[4](immed_Y mod 2^32)\n */\nexport class STORE_IMM_U32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_STORE_IMM_U32\n  name: string = 'STORE_IMM_U32'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoImmediates(context.operands, context.fskip)\n    const immediateX = parseResult.immediateX\n    const immediateY = parseResult.immediateY\n\n    // mem'[immed_X:4] = encode[4](immed_Y mod 2^32)\n    const value = immediateY & u64(0xffffffff)\n\n    const writeResult = context.ram.writeOctets(\n      u32(immediateX),\n      this.bigIntToBytesLE(value, 4),\n    )\n    if (writeResult.hasFault) {\n      return new InstructionResult(RESULT_CODE_FAULT, writeResult.faultAddress)\n    }\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * STORE_IMM_U64 instruction (opcode 0x33)\n * Store 64-bit immediate to memory\n *\n * Gray Paper pvm.tex formula:\n * mem'[immed_X:8] = encode[8](immed_Y)\n */\nexport class STORE_IMM_U64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_STORE_IMM_U64\n  name: string = 'STORE_IMM_U64'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoImmediates(context.operands, context.fskip)\n    const immediateX = parseResult.immediateX\n    const immediateY = parseResult.immediateY\n\n    // mem'[immed_X:8] = encode[8](immed_Y)\n    // No modulo for U64 - use full 64-bit value\n\n    const writeResult = context.ram.writeOctets(\n      u32(immediateX),\n      this.bigIntToBytesLE(immediateY, 8),\n    )\n    if (writeResult.hasFault) {\n      return new InstructionResult(RESULT_CODE_FAULT, writeResult.faultAddress)\n    }\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * LOAD_IMM instruction (opcode 0x33)\n * Load immediate into register\n *\n * Gray Paper pvm.tex formula:\n * reg'_A = immed_X\n *\n * Gray Paper 7.4.5: One Register and One Immediate\n * - r_A = min(12, operands[0] mod 16)\n * - l_X = min(4, max(0,  - 1))\n * - immed_X = sext(l_X, decode[l_X](operands[1:l_X]))\n * \n * The immediate is sign-extended to i64, then converted to u64 for storage in registers.\n * Registers store unsigned 64-bit values, but immediates are sign-extended per Gray Paper.\n */\nexport class LOAD_IMMInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_LOAD_IMM\n  name: string = 'LOAD_IMM'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseOneRegisterAndImmediate(context.operands, context.fskip)\n    const registerA: u8 = parseResult.registerA\n    // getImmediateValue returns i64 (sign-extended), convert to u64 for register storage\n    // In AssemblyScript, casting i64 to u64 handles two's complement conversion\n    const immediateX: u64 = u64(parseResult.immediateX)\n\n    this.setRegisterValue(context.registers, registerA, immediateX)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * LOAD_U8 instruction (opcode 0x52)\n * Load unsigned 8-bit from memory as specified in Gray Paper\n *\n * Gray Paper pvm.tex formula:\n * reg'_A = decode[1](mem[immed_X:1])\n */\nexport class LOAD_U8Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_LOAD_U8\n  name: string = 'LOAD_U8'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseOneRegisterAndImmediateUnsigned(context.operands, context.fskip)\n    const registerA: u8 = parseResult.registerA\n    const immediateX = parseResult.immediateX\n\n    const readResult = context.ram.readOctets(u32(immediateX), 1)\n    if (readResult.faultAddress !== 0 || readResult.data === null) {\n      return new InstructionResult(RESULT_CODE_FAULT)\n    }\n\n    // Gray Paper: decode[1] reads a single byte - no endianness conversion needed\n    // For single-byte values, bytesToBigIntLE is redundant; direct access is more efficient\n    const value = u64(readResult.data![0])\n    this.setRegisterValueWith64BitResult(context.registers, registerA, value)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * LOAD_I8 instruction (opcode 0x53)\n * Load signed 8-bit from memory as specified in Gray Paper\n *\n * Gray Paper pvm.tex formula:\n * reg'_A = sext[8](decode[1](mem[immed_X:1]))\n */\nexport class LOAD_I8Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_LOAD_I8\n  name: string = 'LOAD_I8'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseOneRegisterAndImmediateUnsigned(context.operands, context.fskip)\n    const registerA: u8 = parseResult.registerA\n    const immediateX = parseResult.immediateX\n\n    const readResult = context.ram.readOctets(u32(immediateX), 1)\n    if (readResult.faultAddress !== 0 || readResult.data === null) {\n      return new InstructionResult(RESULT_CODE_FAULT)\n    }\n\n    const value = this.signExtend(this.bytesToBigIntLE(readResult.data!), 1)\n    this.setRegisterValueWith64BitResult(context.registers, registerA, value)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * LOAD_U16 instruction (opcode 0x54)\n * Load unsigned 16-bit from memory as specified in Gray Paper\n *\n * Gray Paper pvm.tex formula:\n * reg'_A = decode[2](mem[immed_X:2])\n */\nexport class LOAD_U16Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_LOAD_U16\n  name: string = 'LOAD_U16'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseOneRegisterAndImmediateUnsigned(context.operands, context.fskip)\n    const registerA: u8 = parseResult.registerA\n    const immediateX = parseResult.immediateX\n\n    const readResult = context.ram.readOctets(u32(immediateX), 2)\n    if (readResult.faultAddress !== 0 || readResult.data === null) {\n      return new InstructionResult(RESULT_CODE_FAULT)\n    }\n\n    const value = this.bytesToBigIntLE(readResult.data!)\n    this.setRegisterValueWith64BitResult(context.registers, registerA, value)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * LOAD_I16 instruction (opcode 0x55)\n * Load signed 16-bit from memory as specified in Gray Paper\n *\n * Gray Paper pvm.tex formula:\n * reg'_A = sext[16](decode[2](mem[immed_X:2]))\n */\nexport class LOAD_I16Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_LOAD_I16\n  name: string = 'LOAD_I16'\n\n  execute(context: InstructionContext): InstructionResult {\n    // Step 1: Parse operands\n    const parseResult = this.parseOneRegisterAndImmediateUnsigned(context.operands, context.fskip)\n    const registerA: u8 = parseResult.registerA\n    const immediateX = parseResult.immediateX\n\n    // Step 2: Convert address (TypeScript version doesn't check ZONE_SIZE for LOAD_I16)\n    const address = u32(immediateX)\n    \n    // Step 3: Read from memory\n    const readResult = context.ram.readOctets(address, 2)\n    \n    // Step 4: Check for faults\n    if (readResult.faultAddress !== 0) {\n      // Memory fault - return early\n      return new InstructionResult(RESULT_CODE_FAULT)\n    }\n    if (readResult.data === null) {\n      // No data returned - return early\n      return new InstructionResult(RESULT_CODE_FAULT)\n    }\n    \n    // Step 5: Read 16-bit value as little-endian and sign extend\n    const rawValue = this.bytesToBigIntLE(readResult.data!)\n    const value = this.signExtend(rawValue, 2)\n    \n    // Step 6: Update register (this should work with reference)\n    this.setRegisterValue(context.registers, registerA, value)\n\n    // Step 7: Return continue\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * LOAD_U32 instruction (opcode 0x56)\n * Load unsigned 32-bit from memory as specified in Gray Paper\n *\n * Gray Paper pvm.tex formula:\n * reg'_A = decode[4](mem[immed_X:4])\n */\nexport class LOAD_U32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_LOAD_U32\n  name: string = 'LOAD_U32'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseOneRegisterAndImmediateUnsigned(context.operands, context.fskip)\n    const registerA: u8 = parseResult.registerA\n    const immediateX = parseResult.immediateX\n\n    if (immediateX < u64(ZONE_SIZE)) {\n      return new InstructionResult(RESULT_CODE_PANIC)\n    }\n    const readResult = context.ram.readOctets(u32(immediateX), 4)\n    if (readResult.faultAddress !== 0 || readResult.data === null) {\n      return new InstructionResult(RESULT_CODE_FAULT)\n    }\n\n    const value = this.bytesToBigIntLE(readResult.data!)\n    this.setRegisterValueWith64BitResult(context.registers, registerA, value)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * LOAD_I32 instruction (opcode 0x57)\n * Load signed 32-bit from memory as specified in Gray Paper\n *\n * Gray Paper pvm.tex formula:\n * reg'_A = sext[32](decode[4](mem[immed_X:4]))\n */\nexport class LOAD_I32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_LOAD_I32\n  name: string = 'LOAD_I32'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseOneRegisterAndImmediate(context.operands, context.fskip)\n    const registerA: u8 = parseResult.registerA\n    const immediateX = parseResult.immediateX\n\n    // Cast signed immediate to unsigned address (mask to 32 bits)\n    const address = u64(immediateX) & u64(0xffffffff)\n    if (address < u64(ZONE_SIZE)) {\n      return new InstructionResult(RESULT_CODE_PANIC)\n    }\n\n    const readResult = context.ram.readOctets(u32(address), 4)\n    if (readResult.faultAddress !== 0 || readResult.data === null) {\n      return new InstructionResult(RESULT_CODE_FAULT)\n    }\n    const value = this.signExtend(this.bytesToBigIntLE(readResult.data!), 4)\n    this.setRegisterValueWith64BitResult(context.registers, registerA, value)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * LOAD_U64 instruction (opcode 0x58)\n * Load unsigned 64-bit from memory as specified in Gray Paper\n *\n * Gray Paper pvm.tex formula:\n * reg'_A = decode[8](mem[immed_X:8])\n */\nexport class LOAD_U64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_LOAD_U64\n  name: string = 'LOAD_U64'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseOneRegisterAndImmediate(context.operands, context.fskip)\n    const registerA: u8 = parseResult.registerA\n    const immediateX = parseResult.immediateX\n\n    // Cast signed immediate to unsigned address (mask to 32 bits)\n    const address = u64(immediateX) & u64(0xffffffff)\n\n    if (address < u64(ZONE_SIZE)) {\n      return new InstructionResult(RESULT_CODE_PANIC)\n    }\n\n    const readResult = context.ram.readOctets(u32(immediateX), 8)\n    if (readResult.faultAddress !== 0 || readResult.data === null) {\n      return new InstructionResult(RESULT_CODE_FAULT)\n    }\n\n    const value = this.bytesToBigIntLE(readResult.data!)\n    this.setRegisterValueWith64BitResult(context.registers, registerA, value)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * STORE_U8 instruction (opcode 0x59)\n * Store unsigned 8-bit to memory as specified in Gray Paper\n *\n * Gray Paper pvm.tex formula:\n * mem'[immed_X] = reg_A mod 2^8\n */\nexport class STORE_U8Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_STORE_U8\n  name: string = 'STORE_U8'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseOneRegisterAndImmediate(context.operands, context.fskip)\n    const registerA: u8 = parseResult.registerA\n    const immediateX = parseResult.immediateX\n    const value = this.getRegisterValueAs64(context.registers, registerA) & u64(0xff)\n\n    // Cast signed immediate to unsigned address (mask to 32 bits)\n    const address = u64(immediateX) & u64(0xffffffff)\n    if (address < u64(ZONE_SIZE)) {\n      return new InstructionResult(RESULT_CODE_PANIC)\n    }\n\n    const encodedValue = this.bigIntToBytesLE(value, 1)\n    const writeResult = context.ram.writeOctets(u32(address), encodedValue)\n\n    if (writeResult.hasFault) {\n      return new InstructionResult(RESULT_CODE_FAULT, writeResult.faultAddress)\n    }\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * STORE_U16 instruction (opcode 0x5A)\n * Store unsigned 16-bit to memory as specified in Gray Paper\n *\n * Gray Paper pvm.tex formula:\n * mem'[immed_X:2] = encode[2](reg_A mod 2^16)\n */\nexport class STORE_U16Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_STORE_U16\n  name: string = 'STORE_U16'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseOneRegisterAndImmediate(context.operands, context.fskip)\n    const registerA: u8 = parseResult.registerA\n    const immediateX = parseResult.immediateX\n    const value = this.getRegisterValueAs64(context.registers, registerA) & u64(0xffff)\n\n    // Cast signed immediate to unsigned address (mask to 32 bits)\n    const address = u64(immediateX) & u64(0xffffffff)\n    if (address < u64(ZONE_SIZE)) {\n      return new InstructionResult(RESULT_CODE_PANIC)\n    }\n\n    const writeResult = context.ram.writeOctets(\n      u32(address),\n      this.bigIntToBytesLE(value, 2),\n    )\n    if (writeResult.hasFault) {\n      return new InstructionResult(RESULT_CODE_FAULT, writeResult.faultAddress)\n    }\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * STORE_U32 instruction (opcode 0x5B)\n * Store unsigned 32-bit to memory as specified in Gray Paper\n *\n * Gray Paper pvm.tex formula:\n * mem'[immed_X:4] = encode[4](reg_A mod 2^32)\n */\nexport class STORE_U32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_STORE_U32\n  name: string = 'STORE_U32'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseOneRegisterAndImmediate(context.operands, context.fskip)\n    const registerA: u8 = parseResult.registerA\n    const immediateX = parseResult.immediateX\n    const value = this.getRegisterValueAs64(context.registers, registerA) & u64(0xffffffff)\n\n    // Cast signed immediate to unsigned address (mask to 32 bits)\n    const address = u64(immediateX) & u64(0xffffffff)\n    if (address < u64(ZONE_SIZE)) {\n      return new InstructionResult(RESULT_CODE_PANIC)\n    }\n\n    const writeResult = context.ram.writeOctets(\n      u32(address),\n      this.bigIntToBytesLE(value, 4),\n    )\n    if (writeResult.hasFault) {\n      return new InstructionResult(RESULT_CODE_FAULT, writeResult.faultAddress)\n    }\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * STORE_U64 instruction (opcode 0x5C)\n * Store unsigned 64-bit to memory as specified in Gray Paper\n *\n * Gray Paper pvm.tex formula:\n * mem'[immed_X:8] = encode[8](reg_A)\n */\nexport class STORE_U64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_STORE_U64\n  name: string = 'STORE_U64'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseOneRegisterAndImmediate(context.operands, context.fskip)\n    const registerA: u8 = parseResult.registerA\n    const immediateX = parseResult.immediateX\n    const value = this.getRegisterValueAs64(context.registers, registerA)\n\n    // Cast signed immediate to unsigned address (mask to 32 bits)\n    const address = u64(immediateX) & u64(0xffffffff)\n    if (address < u64(ZONE_SIZE)) {\n      return new InstructionResult(RESULT_CODE_PANIC)\n    }\n\n    const writeResult = context.ram.writeOctets(\n      u32(address),\n      this.bigIntToBytesLE(value, 8),\n    )\n    if (writeResult.hasFault) {\n      return new InstructionResult(RESULT_CODE_FAULT, writeResult.faultAddress)\n    }\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * STORE_IMM_IND_U8 instruction (opcode 0x46 / 70)\n * Store 8-bit immediate to memory at register + offset\n *\n * Gray Paper pvm.tex formula:\n * mem'[reg_A + immed_X] = immed_Y mod 2^8\n */\nexport class STORE_IMM_IND_U8Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_STORE_IMM_IND_U8\n  name: string = 'STORE_IMM_IND_U8'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseRegisterAndTwoImmediates(\n        context.operands,\n        context.fskip,\n      )\n    const registerA = parseResult.registerA\n    const immediateX = parseResult.immediateX\n    const immediateY = parseResult.immediateY\n    const registerAValue = this.getRegisterValueAs64(\n      context.registers,\n      registerA,\n    )\n    // Convert signed i64 immediate to u64 for address calculation\n    // Address space is 32-bit, so mask to 32 bits after addition\n    const address = (registerAValue + u64(immediateX)) & u64(0xffffffff)\n\n    // Check memory access - addresses < 2^16 cause PANIC\n    if (address < u64(ZONE_SIZE)) {\n      return new InstructionResult(RESULT_CODE_PANIC)\n    }\n\n    // mem'[reg_A + immed_X] = immed_Y mod 2^8\n    const value = immediateY & u64(0xff)\n\n    const writeResult = context.ram.writeOctets(\n      u32(address),\n      this.bigIntToBytesLE(value, 1),\n    )\n\n    if (writeResult.hasFault) {\n      return new InstructionResult(RESULT_CODE_FAULT, writeResult.faultAddress)\n    }\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * STORE_IMM_IND_U16 instruction (opcode 0x71)\n * Store immediate to register + immediate address as specified in Gray Paper\n *\n * Gray Paper pvm.tex formula:\n * mem'[reg_A + immed_X:2] = encode[2](immed_Y mod 2^16)\n */\nexport class STORE_IMM_IND_U16Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_STORE_IMM_IND_U16\n  name: string = 'STORE_IMM_IND_U16'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseRegisterAndTwoImmediates(\n        context.operands,\n        context.fskip,\n      )\n    const registerA = parseResult.registerA\n    const immediateX = parseResult.immediateX\n    const immediateY = parseResult.immediateY\n\n    const registerAValue = this.getRegisterValueAs64(\n      context.registers,\n      registerA,\n    )\n    // Convert signed i64 immediate to u64 for address calculation\n    // Address space is 32-bit, so mask to 32 bits after addition\n    const address = (registerAValue + u64(immediateX)) & u64(0xffffffff)\n\n    // Check memory access - addresses < 2^16 cause PANIC\n    if (address < u64(ZONE_SIZE)) {\n      return new InstructionResult(RESULT_CODE_PANIC)\n    }\n\n    // mem'[reg_A + immed_X] = immed_Y mod 2^16\n    const value = immediateY & u64(0xffff)\n\n    const writeResult = context.ram.writeOctets(\n      u32(address),\n      this.bigIntToBytesLE(value, 2),\n    )\n    if (writeResult.hasFault) {\n      return new InstructionResult(RESULT_CODE_FAULT, writeResult.faultAddress)\n    }\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * STORE_IMM_IND_U32 instruction (opcode 0x72)\n * Store immediate to register + immediate address as specified in Gray Paper\n *\n * Gray Paper pvm.tex formula:\n * mem'[reg_A + immed_X:4] = encode[4](immed_Y mod 2^32)\n */\nexport class STORE_IMM_IND_U32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_STORE_IMM_IND_U32\n  name: string = 'STORE_IMM_IND_U32'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseRegisterAndTwoImmediates(\n        context.operands,\n        context.fskip,\n      )\n    const registerA = parseResult.registerA\n    const immediateX = parseResult.immediateX\n    const immediateY = parseResult.immediateY\n\n    const registerAValue = this.getRegisterValueAs64(\n      context.registers,\n      registerA,\n    )\n    const address = (registerAValue + u64(immediateX)) & u64(0xffffffff)\n\n    // Check memory access - addresses < 2^16 cause PANIC\n    if (address < u64(ZONE_SIZE)) {\n      return new InstructionResult(RESULT_CODE_PANIC)\n    }\n\n    // mem'[reg_A + immed_X] = immed_Y mod 2^32\n    const value = immediateY & u64(0xffffffff)\n\n    const writeResult = context.ram.writeOctets(\n      u32(address),\n      this.bigIntToBytesLE(value, 4),\n    )\n    if (writeResult.hasFault) {\n      return new InstructionResult(RESULT_CODE_FAULT, u32(writeResult.faultAddress))\n    }\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * STORE_IMM_IND_U64 instruction (opcode 0x73)\n * Store immediate to register + immediate address as specified in Gray Paper\n *\n * Gray Paper pvm.tex formula:\n * mem'[reg_A + immed_X:8] = encode[8](immed_Y)\n */\nexport class STORE_IMM_IND_U64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_STORE_IMM_IND_U64\n  name: string = 'STORE_IMM_IND_U64'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseRegisterAndTwoImmediates(\n        context.operands,\n        context.fskip,\n      )\n    const registerA = parseResult.registerA\n    const immediateX = parseResult.immediateX\n    const immediateY = parseResult.immediateY\n\n    const registerAValue = this.getRegisterValueAs64(\n      context.registers,\n      registerA,\n    )\n    // Convert signed i64 immediate to u64 for address calculation\n    // Address space is 32-bit, so mask to 32 bits after addition\n    const address = (registerAValue + u64(immediateX)) & u64(0xffffffff)\n\n    // Check memory access - addresses < 2^16 cause PANIC\n    if (address < u64(ZONE_SIZE)) {\n      return new InstructionResult(RESULT_CODE_PANIC)\n    }\n\n    // mem'[reg_A + immed_X] = immed_Y mod 2^64\n    const value = immediateY & u64(0xffffffffffffffff)\n\n    const bytes = this.bigIntToBytesLE(value, 8)\n    const writeResult = context.ram.writeOctets(u32(address), bytes)\n    if (writeResult.hasFault) {\n      return new InstructionResult(RESULT_CODE_FAULT, u32(writeResult.faultAddress))\n    }\n\n    return new InstructionResult(-1)\n  }\n}\n\n","/**\n * Indirect Memory Instructions\n *\n * STORE_IND and LOAD_IND variants - Store/Load to/from register + immediate address\n */\n\nimport {\n  OPCODE_LOAD_IND_I8,\n  OPCODE_LOAD_IND_I16,\n  OPCODE_LOAD_IND_I32,\n  OPCODE_LOAD_IND_U8,\n  OPCODE_LOAD_IND_U16,\n  OPCODE_LOAD_IND_U32,\n  OPCODE_LOAD_IND_U64,\n  OPCODE_STORE_IND_U8,\n  OPCODE_STORE_IND_U16,\n  OPCODE_STORE_IND_U32,\n  OPCODE_STORE_IND_U64,\n  RESULT_CODE_FAULT,\n  RESULT_CODE_PANIC,\n  ZONE_SIZE,\n} from '../config'\nimport { InstructionContext, InstructionResult } from '../types'\nimport { BaseInstruction } from './base'\n\n/**\n * STORE_IND_U8 instruction (opcode 0x120)\n * Store to register + immediate address as specified in Gray Paper\n *\n * Gray Paper pvm.tex formula:\n * mem'[reg_B + immed_X] = reg_A mod 2^8\n */\nexport class STORE_IND_U8Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_STORE_IND_U8\n  name: string = 'STORE_IND_U8'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegistersAndImmediate(\n        context.operands,\n        context.fskip,\n      )\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n\n    const registerAValue = this.getRegisterValueAs64(\n      context.registers,\n      registerA,\n    )\n    const registerBValue = this.getRegisterValueAs64(\n      context.registers,\n      registerB,\n    )\n    // Gray Paper: Address space is 32-bit, so truncate to 32 bits (mod 2^32)\n    // This matches JUMP_IND behavior: (reg_A + immed_X) mod 2^32\n    const address = u64((registerBValue + immediateX) & u64(0xffffffff))\n\n    // Check memory access - addresses < 2^16 cause PANIC\n    if (address < u64(ZONE_SIZE)) {\n      return new InstructionResult(RESULT_CODE_PANIC)\n    }\n\n    // Write 8-bit value to memory\n    const byteValue = registerAValue & u64(0xff)\n    const encodedByteValue = this.bigIntToBytesLE(byteValue, 1)\n\n    const writeResult = context.ram.writeOctets(u32(address), encodedByteValue)\n\n    if (writeResult.hasFault) {\n      return new InstructionResult(RESULT_CODE_FAULT, writeResult.faultAddress)\n    }\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * STORE_IND_U16 instruction (opcode 0x121)\n * Store to register + immediate address as specified in Gray Paper\n *\n * Gray Paper pvm.tex formula:\n * mem'[reg_B + immed_X:2] = encode[2](reg_A mod 2^16)\n */\nexport class STORE_IND_U16Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_STORE_IND_U16\n  name: string = 'STORE_IND_U16'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegistersAndImmediate(\n        context.operands,\n        context.fskip,\n      )\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n\n    const registerAValue = this.getRegisterValueAs64(\n      context.registers,\n      registerA,\n    )\n    const registerBValue = this.getRegisterValueAs64(\n      context.registers,\n      registerB,\n    )\n    // Gray Paper: Address space is 32-bit, so truncate to 32 bits (mod 2^32)\n    // This matches JUMP_IND behavior: (reg_B + immed_X) mod 2^32\n    const address = u64((registerBValue + immediateX) & u64(0xffffffff))\n\n    // Check memory access - addresses < 2^16 cause PANIC\n    if (address < u64(ZONE_SIZE)) {\n      return new InstructionResult(RESULT_CODE_PANIC)\n    }\n\n    const value = registerAValue & u64(0xffff)\n    const encodedValue = this.bigIntToBytesLE(value, 2)\n    const writeResult = context.ram.writeOctets(u32(address), encodedValue)\n\n    if (writeResult.hasFault) {\n      return new InstructionResult(RESULT_CODE_FAULT, writeResult.faultAddress)\n    }\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * STORE_IND_U32 instruction (opcode 0x122)\n * Store to register + immediate address as specified in Gray Paper\n *\n * Gray Paper pvm.tex formula:\n * mem'[reg_B + immed_X:4] = encode[4](reg_A mod 2^32)\n */\nexport class STORE_IND_U32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_STORE_IND_U32\n  name: string = 'STORE_IND_U32'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegistersAndImmediate(\n        context.operands,\n        context.fskip,\n      )\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n    const registerAValue = this.getRegisterValueAs64(\n      context.registers,\n      registerA,\n    )\n    const registerBValue = this.getRegisterValueAs64(\n      context.registers,\n      registerB,\n    )\n    // Gray Paper: Address space is 32-bit, so truncate to 32 bits (mod 2^32)\n    // This matches JUMP_IND behavior: (reg_A + immed_X) mod 2^32\n    const address = u64((registerBValue + immediateX) & u64(0xffffffff))\n\n    // Check memory access - addresses < 2^16 cause PANIC\n    if (address < u64(ZONE_SIZE)) {\n      return new InstructionResult(RESULT_CODE_PANIC)\n    }\n\n    // Write 32-bit value to memory (little-endian)\n    const value = registerAValue & u64(0xffffffff)\n    const encodedValue = this.bigIntToBytesLE(value, 4)\n    const writeResult = context.ram.writeOctets(u32(address), encodedValue)\n\n    if (writeResult.hasFault) {\n      return new InstructionResult(RESULT_CODE_FAULT, writeResult.faultAddress)\n    }\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * STORE_IND_U64 instruction (opcode 0x123)\n * Store to register + immediate address as specified in Gray Paper\n *\n * Gray Paper pvm.tex formula:\n * mem'[reg_B + immed_X:8] = encode[8](reg_A)\n */\nexport class STORE_IND_U64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_STORE_IND_U64\n  name: string = 'STORE_IND_U64'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegistersAndImmediate(\n        context.operands,\n        context.fskip,\n      )\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n\n    const registerBValue = this.getRegisterValueAs64(\n      context.registers,\n      registerB,\n    )\n    const registerAValue = this.getRegisterValueAs64(\n      context.registers,\n      registerA,\n    )\n    // Gray Paper: Address space is 32-bit, so truncate to 32 bits (mod 2^32)\n    // This matches JUMP_IND behavior: (reg_B + immed_X) mod 2^32\n    const address = u64((registerBValue + immediateX) & u64(0xffffffff))\n\n    // Check memory access - addresses < 2^16 cause PANIC\n    if (address < u64(ZONE_SIZE)) {\n      return new InstructionResult(RESULT_CODE_PANIC)\n    }\n\n    const value = registerAValue & u64(0xffffffffffffffff)\n    // Write 64-bit value to memory (little-endian)\n    // Gray Paper: memwr[reg_B + immed_X:8] = encode[8]{reg_A}\n    const encodedValue = this.bigIntToBytesLE(value, 8)\n\n    const writeResult = context.ram.writeOctets(u32(address), encodedValue)\n    if (writeResult.hasFault) {\n      return new InstructionResult(RESULT_CODE_FAULT, writeResult.faultAddress)\n    }\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * LOAD_IND_U8 instruction (opcode 0x124)\n * Load from register + immediate address as specified in Gray Paper\n *\n * Gray Paper pvm.tex formula:\n * reg'_A = decode[1](mem[reg_B + immed_X:1])\n */\nexport class LOAD_IND_U8Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_LOAD_IND_U8\n  name: string = 'LOAD_IND_U8'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegistersAndImmediate(\n        context.operands,\n        context.fskip,\n      )\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n\n    const registerBValue = this.getRegisterValueAs64(\n      context.registers,\n      registerB,\n    )\n    // Gray Paper: Address space is 32-bit, so truncate to 32 bits (mod 2^32)\n    // This matches JUMP_IND behavior: (reg_A + immed_X) mod 2^32\n    const address = u64((registerBValue + immediateX) & u64(0xffffffff))\n\n    if (address < u64(ZONE_SIZE)) {\n      return new InstructionResult(RESULT_CODE_PANIC)\n    }\n\n    // Load 8-bit unsigned value from memory\n    const readResult = context.ram.readOctets(u32(address), 1)\n    if (readResult.faultAddress !== 0 || readResult.data === null) {\n      return new InstructionResult(RESULT_CODE_FAULT)\n    }\n\n    const byteValue = readResult.data![0]\n    const value = u64(byteValue)\n    this.setRegisterValueWith64BitResult(context.registers, registerA, value)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * LOAD_IND_I8 instruction (opcode 0x125)\n * Load from register + immediate address as specified in Gray Paper\n *\n * Gray Paper pvm.tex line 484:\n * reg'_A = unsigned{signedn{1}{memr_{\\reg_B + \\immed_X}}}\n * \n * signedn{1}(x) = signfunc{1}(x) = x if x < 2^7, else x - 2^8\n * unsigned{} converts signed value back to unsigned 64-bit\n */\nexport class LOAD_IND_I8Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_LOAD_IND_I8\n  name: string = 'LOAD_IND_I8'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegistersAndImmediate(\n        context.operands,\n        context.fskip,\n      )\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n\n    const registerBValue = this.getRegisterValueAs64(\n      context.registers,\n      registerB,\n    )\n    // Gray Paper: Address space is 32-bit, so truncate to 32 bits (mod 2^32)\n    // This matches JUMP_IND behavior: (reg_A + immed_X) mod 2^32\n    const address = u64((registerBValue + immediateX) & u64(0xffffffff))\n\n    if (address < u64(ZONE_SIZE)) {\n      return new InstructionResult(RESULT_CODE_PANIC)\n    }\n\n    // Load 8-bit value from memory\n    const readResult = context.ram.readOctets(u32(address), 1)\n    if (readResult.faultAddress !== 0 || readResult.data === null) {\n      return new InstructionResult(RESULT_CODE_FAULT)\n    }\n\n    // Gray Paper: reg'_A = unsigned{signedn{1}{memr_{\\reg_B + \\immed_X}}}\n    // signedn{1}(x) = signfunc{1}(x) = x if x < 2^7, else x - 2^8\n    const decodedValue = u64(readResult.data![0]) & u64(0xff)\n    const signedValue = decodedValue < u64(0x80) ? i64(decodedValue) : i64(decodedValue) - i64(0x100)\n    \n    // Gray Paper: unsigned{} converts signed value back to unsigned 64-bit\n    // unsigned{} = signedValue < 0 ? signedValue + 2^64 : signedValue\n    // In AssemblyScript, casting i64 to u64 automatically handles two's complement conversion\n    const unsignedValue = u64(signedValue)\n    \n    this.setRegisterValueWith64BitResult(context.registers, registerA, unsignedValue)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * LOAD_IND_U16 instruction (opcode 0x126)\n * Load from register + immediate address as specified in Gray Paper\n *\n * Gray Paper pvm.tex formula:\n * reg'_A = decode[2](mem[reg_B + immed_X:2])\n */\nexport class LOAD_IND_U16Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_LOAD_IND_U16\n  name: string = 'LOAD_IND_U16'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegistersAndImmediate(\n        context.operands,\n        context.fskip,\n      )\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n\n    const registerBValue = this.getRegisterValueAs64(\n      context.registers,\n      registerB,\n    )\n    // Gray Paper: Address space is 32-bit, so truncate to 32 bits (mod 2^32)\n    // This matches JUMP_IND behavior: (reg_A + immed_X) mod 2^32\n    const address = u64((registerBValue + immediateX) & u64(0xffffffff))\n\n    if (address < u64(ZONE_SIZE)) {\n      return new InstructionResult(RESULT_CODE_PANIC)\n    }\n\n    // Load 16-bit unsigned value from memory (little-endian)\n    const readResult = context.ram.readOctets(u32(address), 2)\n    if (readResult.faultAddress !== 0 || readResult.data === null) {\n      return new InstructionResult(RESULT_CODE_FAULT)\n    }\n\n    const value = this.bytesToBigIntLE(readResult.data!)\n    this.setRegisterValueWith64BitResult(context.registers, registerA, value)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * LOAD_IND_I16 instruction (opcode 0x127)\n * Load from register + immediate address as specified in Gray Paper\n *\n * Gray Paper pvm.tex line 486:\n * reg'_A = unsigned{signedn{2}{decode[2](mem[reg_B + immed_X:2])}}\n * \n * signedn{2}(x) = signfunc{2}(x) = x if x < 2^15, else x - 2^16\n * unsigned{} converts signed value back to unsigned 64-bit\n * TODO: verify against pvm.tex\n */\nexport class LOAD_IND_I16Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_LOAD_IND_I16\n  name: string = 'LOAD_IND_I16'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegistersAndImmediate(\n        context.operands,\n        context.fskip,\n      )\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n    const registerBValue = this.getRegisterValueAs64(\n      context.registers,\n      registerB,\n    )\n    // Gray Paper: Address space is 32-bit, so truncate to 32 bits (mod 2^32)\n    // This matches JUMP_IND behavior: (reg_A + immed_X) mod 2^32\n    const address = u64((registerBValue + immediateX) & u64(0xffffffff))\n\n    if (address < u64(ZONE_SIZE)) {\n      return new InstructionResult(RESULT_CODE_PANIC)\n    }\n\n    // Load 16-bit value from memory (little-endian)\n    const readResult = context.ram.readOctets(u32(address), 2)\n    if (readResult.faultAddress !== 0 || readResult.data === null) {\n      return new InstructionResult(RESULT_CODE_FAULT)\n    }\n    \n    // Gray Paper: decode[2](mem[.]) - decode 2 bytes as little-endian\n    const decodedValue = this.bytesToBigIntLE(readResult.data!) & u64(0xffff)\n    \n    // Gray Paper: reg'_A = unsigned{signedn{2}{decode[2](mem[reg_B + immed_X:2])}}\n    // signedn{2}(x) = signfunc{2}(x) = x if x < 2^15, else x - 2^16\n    const signedValue = decodedValue < u64(0x8000) ? i64(decodedValue) : i64(decodedValue) - i64(0x10000)\n    \n    // Gray Paper: unsigned{} converts signed value back to unsigned 64-bit\n    // unsigned{} = signedValue < 0 ? signedValue + 2^64 : signedValue\n    // In AssemblyScript, casting i64 to u64 automatically handles two's complement conversion\n    const unsignedValue = u64(signedValue)\n    \n    this.setRegisterValueWith64BitResult(context.registers, registerA, unsignedValue)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * LOAD_IND_U32 instruction (opcode 0x128)\n * Load from register + immediate address as specified in Gray Paper\n *\n * Gray Paper pvm.tex formula:\n * reg'_A = decode[4](mem[reg_B + immed_X:4])\n */\nexport class LOAD_IND_U32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_LOAD_IND_U32\n  name: string = 'LOAD_IND_U32'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegistersAndImmediate(\n        context.operands,\n        context.fskip,\n      )\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n\n    const registerBValue = this.getRegisterValueAs64(\n      context.registers,\n      registerB,\n    )\n    // Gray Paper: Address space is 32-bit, so truncate to 32 bits (mod 2^32)\n    // This matches JUMP_IND behavior: (reg_A + immed_X) mod 2^32\n    const address = u64((registerBValue + immediateX) & u64(0xffffffff))\n\n    if (address < u64(ZONE_SIZE)) {\n      return new InstructionResult(RESULT_CODE_PANIC)\n    }\n\n    // Load 32-bit unsigned value from memory (little-endian)\n    const readResult = context.ram.readOctets(u32(address), 4)\n    if (readResult.faultAddress !== 0 || readResult.data === null) {\n      return new InstructionResult(RESULT_CODE_FAULT)\n    }\n    const value = this.bytesToBigIntLE(readResult.data!)\n    this.setRegisterValueWith64BitResult(context.registers, registerA, value)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * LOAD_IND_I32 instruction (opcode 0x129)\n * Load from register + immediate address as specified in Gray Paper\n *\n * Gray Paper pvm.tex line 488:\n * reg'_A = unsigned{signedn{4}{decode[4](mem[reg_B + immed_X:4])}}\n * \n * signedn{4}(x) = signfunc{4}(x) = x if x < 2^31, else x - 2^32\n * unsigned{} converts signed value back to unsigned 64-bit\n */\nexport class LOAD_IND_I32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_LOAD_IND_I32\n  name: string = 'LOAD_IND_I32'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegistersAndImmediate(\n        context.operands,\n        context.fskip,\n      )\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n    const registerBValue = this.getRegisterValueAs64(\n      context.registers,\n      registerB,\n    )\n    // Gray Paper: Address space is 32-bit, so truncate to 32 bits (mod 2^32)\n    // This matches JUMP_IND behavior: (reg_A + immed_X) mod 2^32\n    const address = u64((registerBValue + immediateX) & u64(0xffffffff))\n\n    if (address < u64(ZONE_SIZE)) {\n      return new InstructionResult(RESULT_CODE_PANIC)\n    }\n\n    // Load 32-bit value from memory (little-endian)\n    const readResult = context.ram.readOctets(u32(address), 4)\n    if (readResult.faultAddress !== 0 || readResult.data === null) {\n      return new InstructionResult(RESULT_CODE_FAULT)\n    }\n    \n    // Gray Paper: decode[4](mem[.]) - decode 4 bytes as little-endian\n    const decodedValue = this.bytesToBigIntLE(readResult.data!) & u64(0xffffffff)\n    \n    // Gray Paper: reg'_A = unsigned{signedn{4}{decode[4](mem[reg_B + immed_X:4])}}\n    // signedn{4}(x) = signfunc{4}(x) = x if x < 2^31, else x - 2^32\n    const signedValue = decodedValue < u64(0x80000000) ? i64(decodedValue) : i64(decodedValue) - i64(0x100000000)\n    \n    // Gray Paper: unsigned{} converts signed value back to unsigned 64-bit\n    // unsigned{} = signedValue < 0 ? signedValue + 2^64 : signedValue\n    // In AssemblyScript, casting i64 to u64 automatically handles two's complement conversion\n    const unsignedValue = u64(signedValue)\n    \n    this.setRegisterValueWith64BitResult(context.registers, registerA, unsignedValue)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * LOAD_IND_U64 instruction (opcode 0x12A)\n * Load from register + immediate address as specified in Gray Paper\n *\n * Gray Paper pvm.tex formula:\n * reg'_A = decode[8](mem[reg_B + immed_X:8])\n */\nexport class LOAD_IND_U64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_LOAD_IND_U64\n  name: string = 'LOAD_IND_U64'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegistersAndImmediate(\n        context.operands,\n        context.fskip,\n      )\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n    const registerBValue = this.getRegisterValueAs64(\n      context.registers,\n      registerB,\n    )\n    // Gray Paper: Address space is 32-bit, so truncate to 32 bits (mod 2^32)\n    // This matches JUMP_IND behavior: (reg_A + immed_X) mod 2^32\n    const address = u64((registerBValue + immediateX) & u64(0xffffffff))\n\n    if (address < u64(ZONE_SIZE)) {\n      return new InstructionResult(RESULT_CODE_PANIC)\n    }\n\n    // Load 64-bit unsigned value from memory (little-endian)\n    const readResult = context.ram.readOctets(u32(address), 8)\n    if (readResult.faultAddress !== 0 || readResult.data === null) {\n      return new InstructionResult(RESULT_CODE_FAULT)\n    }\n    const value = this.bytesToBigIntLE(readResult.data!)\n    this.setRegisterValueWith64BitResult(context.registers, registerA, value)\n\n    return new InstructionResult(-1)\n  }\n}\n","/**\n * Arithmetic Instructions\n *\n * ADD_IMM and MUL_IMM variants - Add/Multiply with immediate values\n */\n\nimport { OPCODE_ADD_IMM_32, OPCODE_ADD_IMM_64, OPCODE_MUL_IMM_32, OPCODE_MUL_IMM_64 } from '../config'\nimport { InstructionContext, InstructionResult } from '../types'\nimport { BaseInstruction } from './base'\n\n/**\n * ADD_IMM_32 instruction (opcode 0x83 / 131)\n * Add immediate to 32-bit register\n *\n * Gray Paper pvm.tex 7.4.9 line 490:\n * reg'_A = sext{4}{(\\reg_B + \\immed_X) \\bmod 2^{32}}\n *\n * Where:\n * - immed_X = sext{l_X}{decode[l_X]{instructions[+2:l_X]}} (line 469)\n * - l_X = min(4, max(0,  - 1)) (line 468)\n * -  = Fskip() (skip distance)\n *\n * Operand format (lines 462-469):\n * - operands[0]: r_A (low 4 bits) + r_B (high 4 bits)\n * - operands[1:1+l_X]: immed_X (sign-extended)\n */\nexport class ADD_IMM_32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_ADD_IMM_32\n  name: string = 'ADD_IMM_32'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegistersAndImmediate(context.operands, context.fskip)\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n\n    const registerValue = this.getRegisterValueAs32(context.registers, registerB)\n\n    // Gray Paper: reg'_A = sext{4}{(\\reg_B + \\immed_X) \\bmod 2^{32}}\n    const addition = (registerValue + immediateX) & i64(0xffffffff) // mod 2^32\n    const result = addition // setRegisterValueWith32BitResult will sign-extend\n\n    this.setRegisterValueWith32BitResult(context.registers, registerA, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * MUL_IMM_32 instruction (opcode 0x12F / 135)\n * Multiply 32-bit register by immediate\n *\n * Gray Paper pvm.tex 7.4.9 line 494:\n * reg'_A = sext{4}((reg_B  immed_X) mod 2^32)\n *\n * Operand format (lines 462-469):\n * - operands[0]: r_A (low 4 bits) + r_B (high 4 bits)\n * - operands[1:1+l_X]: immed_X (sign-extended)\n * Where: l_X = min(4, max(0,  - 1))\n */\nexport class MUL_IMM_32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_MUL_IMM_32\n  name: string = 'MUL_IMM_32'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegistersAndImmediate(context.operands, context.fskip)\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n\n    const registerValue = this.getRegisterValueAs32(context.registers, registerB)\n\n    // Gray Paper: reg'_A = sext{4}((reg_B  immed_X) mod 2^32)\n    const multiplication = (registerValue * immediateX) & i64(0xffffffff) // mod 2^32\n    const result = multiplication // setRegisterValueWith32BitResult will sign-extend\n\n    this.setRegisterValueWith32BitResult(context.registers, registerA, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * ADD_IMM_64 instruction (opcode 0x13D / 149)\n * Add immediate to 64-bit register\n *\n * Gray Paper pvm.tex 7.4.9 line 514:\n * reg'_A = (reg_B + immed_X) mod 2^64\n *\n * Operand format (lines 462-469):\n * - operands[0]: r_A (low 4 bits) + r_B (high 4 bits)\n * - operands[1:1+l_X]: immed_X (sign-extended)\n * Where: l_X = min(4, max(0,  - 1))\n * Note: For 64-bit instructions, immediate is typically 8 bytes\n */\nexport class ADD_IMM_64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_ADD_IMM_64\n  name: string = 'ADD_IMM_64'\n\n  execute(context: InstructionContext): InstructionResult {\n\n    const parseResult = this.parseTwoRegistersAndImmediate(context.operands, context.fskip)\n    const registerA: u8 = parseResult.registerA\n    const registerB: u8 = parseResult.registerB\n    const immediateX = parseResult.immediateX\n\n    const registerValue = this.getRegisterValueAs64(context.registers, registerB)\n\n    const addition = registerValue + immediateX\n    const result = addition & i64(0xffffffffffffffff) // mod 2^64\n\n    this.setRegisterValueWith64BitResult(context.registers, registerA, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * MUL_IMM_64 instruction (opcode 0x13E / 150)\n * Multiply 64-bit register by immediate\n *\n * Gray Paper pvm.tex 7.4.9 line 515:\n * reg'_A = (reg_B  immed_X) mod 2^64\n *\n * Operand format (lines 462-469):\n * - operands[0]: r_A (low 4 bits) + r_B (high 4 bits)\n * - operands[1:1+l_X]: immed_X (sign-extended)\n * Where: l_X = min(4, max(0,  - 1))\n * Note: For 64-bit instructions, immediate is typically 8 bytes\n */\nexport class MUL_IMM_64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_MUL_IMM_64\n  name: string = 'MUL_IMM_64'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegistersAndImmediate(context.operands, context.fskip)\n    const registerD: u8 = parseResult.registerA // registerA is the destination\n    const registerB: u8 = parseResult.registerB // registerB is the source\n    const immediateX = parseResult.immediateX\n\n    const registerValue = this.getRegisterValueAs64(context.registers, registerB)\n    const result = registerValue * immediateX\n\n    this.setRegisterValueWith64BitResult(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n","import { OPCODE_AND_IMM, OPCODE_OR_IMM, OPCODE_XOR_IMM } from '../config'\nimport { InstructionContext, InstructionResult } from '../types'\nimport { BaseInstruction } from './base'\n\nexport class AND_IMMInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_AND_IMM\n  name: string = 'AND_IMM'\n  \n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegistersAndImmediate(context.operands, context.fskip)\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n    \n    const registerValue = this.getRegisterValueAs64(context.registers, registerB)\n    const result = registerValue & immediateX\n\n    this.setRegisterValueWith64BitResult(context.registers, registerA, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\nexport class XOR_IMMInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_XOR_IMM\n  name: string = 'XOR_IMM'\n  \n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegistersAndImmediate(context.operands, context.fskip)\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n    \n    const registerValue = this.getRegisterValueAs64(context.registers, registerB)\n    const result = registerValue ^ immediateX\n\n    this.setRegisterValueWith64BitResult(context.registers, registerA, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\nexport class OR_IMMInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_OR_IMM\n  name: string = 'OR_IMM'\n  \n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegistersAndImmediate(context.operands, context.fskip)\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n    \n    const registerValue = this.getRegisterValueAs64(context.registers, registerB)\n    const result = registerValue | immediateX\n\n    this.setRegisterValueWith64BitResult(context.registers, registerA, result)\n\n    return new InstructionResult(-1)\n  }\n}\n","import {\n  OPCODE_SET_GT_S_IMM,\n  OPCODE_SET_GT_U_IMM,\n  OPCODE_SET_LT_S_IMM,\n  OPCODE_SET_LT_U_IMM,\n} from '../config'\nimport { InstructionContext, InstructionResult } from '../types'\nimport { BaseInstruction } from './base'\n\nexport class SET_LT_U_IMMInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_SET_LT_U_IMM\n  name: string = 'SET_LT_U_IMM'\n\n  execute(context: InstructionContext): InstructionResult {\n    // Gray Paper pvm.tex line 495: set_lt_u_imm: reg'_A = reg_B < immed_X\n    // Format: Two Registers & One Immediate (lines 459-471)\n    // l_X = min(4, max(0,  - 1)) where  = fskip\n    // immed_X = sext{l_X}{decode[l_X]{instructions[+2:l_X]}}\n    // The immediate is sign-extended according to Gray Paper, but comparison is unsigned\n    const parseResult = this.parseTwoRegistersAndImmediate(\n        context.operands,\n        context.fskip,\n      )\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n    const registerValue = this.getRegisterValueAs64(\n      context.registers,\n      registerB,\n    )\n    // Unsigned comparison: reg'_A = reg_B < immed_X\n    const result = u64(registerValue) < u64(immediateX) ? i64(1) : i64(0)\n\n    this.setRegisterValueWith64BitResult(context.registers, registerA, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\nexport class SET_LT_S_IMMInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_SET_LT_S_IMM\n  name: string = 'SET_LT_S_IMM'\n\n  execute(context: InstructionContext): InstructionResult {\n    // Gray Paper pvm.tex line 496: set_lt_s_imm: reg'_A = signed(reg_B) < signed(immed_X)\n    // Format: Two Registers & One Immediate (lines 459-471)\n    // l_X = min(4, max(0,  - 1)) where  = fskip\n    // immed_X = sext{l_X}{decode[l_X]{instructions[+2:l_X]}}\n    const parseResult = this.parseTwoRegistersAndImmediate(\n        context.operands,\n        context.fskip,\n      )\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n    const registerValue = this.getRegisterValueAs64(\n      context.registers,\n      registerB,\n    )\n\n    // Signed comparison: reg'_A = signed(reg_B) < signed(immed_X)\n    const result = this.signedCompare(registerValue, immediateX) < 0 ? i64(1) : i64(0)\n\n    this.setRegisterValueWith64BitResult(context.registers, registerA, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\nexport class SET_GT_U_IMMInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_SET_GT_U_IMM\n  name: string = 'SET_GT_U_IMM'\n\n  execute(context: InstructionContext): InstructionResult {\n    // Gray Paper pvm.tex: set_gt_u_imm: reg'_A = reg_B > immed_X\n    // Format: Two Registers & One Immediate (lines 459-471)\n    // l_X = min(4, max(0,  - 1)) where  = fskip\n    // immed_X = sext{l_X}{decode[l_X]{instructions[+2:l_X]}}\n    // The immediate is sign-extended according to Gray Paper, but comparison is unsigned\n    const parseResult = this.parseTwoRegistersAndImmediate(\n        context.operands,\n        context.fskip,\n      )\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n    const registerValue = this.getRegisterValueAs64(\n      context.registers,\n      registerB,\n    )\n    // Unsigned comparison: reg'_A = reg_B > immed_X\n    const result = u64(registerValue) > u64(immediateX) ? i64(1) : i64(0)\n\n    this.setRegisterValueWith64BitResult(context.registers, registerA, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\nexport class SET_GT_S_IMMInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_SET_GT_S_IMM\n  name: string = 'SET_GT_S_IMM'\n\n  execute(context: InstructionContext): InstructionResult {\n    // Gray Paper pvm.tex: set_gt_s_imm: reg'_A = signed(reg_B) > signed(immed_X)\n    // Format: Two Registers & One Immediate (lines 459-471)\n    // l_X = min(4, max(0,  - 1)) where  = fskip\n    // immed_X = sext{l_X}{decode[l_X]{instructions[+2:l_X]}}\n    const parseResult = this.parseTwoRegistersAndImmediate(\n        context.operands,\n        context.fskip,\n      )\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n    const registerValue = this.getRegisterValueAs64(\n      context.registers,\n      registerB,\n    )\n\n    // Signed comparison: reg'_A = signed(reg_B) > signed(immed_X)\n    const result = this.signedCompare(registerValue, immediateX) > 0 ? i64(1) : i64(0)\n\n    this.setRegisterValueWith64BitResult(context.registers, registerA, result)\n\n    return new InstructionResult(-1)\n  }\n}\n","import { OPCODE_CMOV_IZ_IMM, OPCODE_CMOV_NZ_IMM } from '../config'\nimport { InstructionContext, InstructionResult } from '../types'\nimport { BaseInstruction } from './base'\n\nexport class CMOV_IZ_IMMInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_CMOV_IZ_IMM\n  name: string = 'CMOV_IZ_IMM'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegistersAndImmediate(\n        context.operands,\n        context.fskip,\n      )\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n    const registerBValue = this.getRegisterValue(context.registers, registerB)\n\n    // Gray Paper: reg'_A = { immed_X when reg_B = 0, reg_A otherwise }\n    const result =\n      registerBValue === i64(0)\n        ? immediateX\n        : this.getRegisterValue(context.registers, registerA)\n\n    this.setRegisterValue(context.registers, registerA, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\nexport class CMOV_NZ_IMMInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_CMOV_NZ_IMM\n  name: string = 'CMOV_NZ_IMM'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegistersAndImmediate(\n        context.operands,\n        context.fskip,\n      )\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n    const registerBValue = this.getRegisterValue(context.registers, registerB)\n\n    // Gray Paper: reg'_A = { immed_X when reg_B  0, reg_A otherwise }\n    const result =\n      registerBValue !== i64(0)\n        ? immediateX\n        : this.getRegisterValue(context.registers, registerA)\n\n    this.setRegisterValue(context.registers, registerA, result)\n\n    return new InstructionResult(-1)\n  }\n}\n","import {\n  OPCODE_NEG_ADD_IMM_32,\n  OPCODE_SHAR_R_IMM_32,\n  OPCODE_SHLO_L_IMM_32,\n  OPCODE_SHLO_R_IMM_32,\n} from '../config'\nimport { InstructionContext, InstructionResult } from '../types'\nimport { BaseInstruction } from './base'\n\n/**\n * SHLO_L_IMM_32 instruction (opcode 0x8A)\n * Gray Paper formula: reg'_A = sext{4}{(reg_B  2^(immed_X mod 32)) mod 2^32}\n */\nexport class SHLO_L_IMM_32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_SHLO_L_IMM_32\n  name: string = 'SHLO_L_IMM_32'\n\n  execute(context: InstructionContext): InstructionResult {\n    // Gray Paper formula: reg'_A = sext{4}{(reg_B  2^(immed_X mod 32)) mod 2^32}\n    const parseResult = this.parseTwoRegistersAndImmediate(context.operands, context.fskip)\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n    const registerValue = this.getRegisterValueAs32(context.registers, registerB)\n\n    // Ensure shift amount is within 32-bit range\n    const immediate32 = u64(immediateX) & u64(0xffffffff) // Convert to 32-bit number\n    const shiftAmount = immediate32 % u64(32)\n    const shifted = u64(registerValue) << shiftAmount\n    const result = shifted & u64(0xffffffff) // Mask to 32 bits\n\n    this.setRegisterValueWith32BitResult(context.registers, registerA, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * SHLO_R_IMM_32 instruction (opcode 0x8B)\n * Gray Paper formula: reg'_A = sext{4}{floor(reg_B mod 2^32 / 2^(immed_X mod 32))}\n */\nexport class SHLO_R_IMM_32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_SHLO_R_IMM_32\n  name: string = 'SHLO_R_IMM_32'\n\n  execute(context: InstructionContext): InstructionResult {\n    // Gray Paper formula: reg'_A = sext{4}{floor(reg_B mod 2^32 / 2^(immed_X mod 32))}\n    const parseResult = this.parseTwoRegistersAndImmediate(context.operands, context.fskip)\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n    const registerValue = this.getRegisterValueAs32(context.registers, registerB)\n\n    // Ensure shift amount is within 32-bit range\n    const immediate32 = u64(immediateX) & u64(0xffffffff) // Convert to 32-bit number\n    const shiftAmount = immediate32 % u64(32)\n    const shifted = u64(registerValue) >> shiftAmount // Right shift\n    const result = shifted & u64(0xffffffff) // Mask to 32 bits\n\n    this.setRegisterValueWith32BitResult(context.registers, registerA, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * SHAR_R_IMM_32 instruction (opcode 0x8C)\n * Gray Paper formula: reg'_A = unsigned{floor(signed_4(reg_B mod 2^32) / 2^(immed_X mod 32))}\n */\nexport class SHAR_R_IMM_32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_SHAR_R_IMM_32\n  name: string = 'SHAR_R_IMM_32'\n\n  execute(context: InstructionContext): InstructionResult {\n    // Gray Paper formula: reg'_A = unsigned{floor(signed_4(reg_B mod 2^32) / 2^(immed_X mod 32))}\n    const parseResult = this.parseTwoRegistersAndImmediate(context.operands, context.fskip)\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n    const registerValue = this.getRegisterValueAs32(context.registers, registerB)\n\n    // Arithmetic shift (signed)\n    const immediate32 = u64(immediateX) & u64(0xffffffff) // Convert to 32-bit number\n    const shiftAmount = immediate32 % u64(32)\n\n    // Convert to signed 32-bit, perform arithmetic right shift, then back to unsigned\n    const signedValue_u64 = this.signExtend(registerValue, 4) // Convert to signed 32-bit (returns u64)\n    const signedValue_i64 = i64(signedValue_u64) // Cast to i64 for arithmetic right shift\n    const shifted = signedValue_i64 >> i64(shiftAmount) // Arithmetic right shift\n    const result = u64(shifted) & u64(0xffffffff) // Convert back to unsigned 32-bit\n\n    this.setRegisterValueWith32BitResult(context.registers, registerA, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * NEG_ADD_IMM_32 instruction (opcode 0x8D)\n * Gray Paper formula: reg'_A = sext{4}{(immed_X + 2^32 - reg_B) mod 2^32}\n */\nexport class NEG_ADD_IMM_32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_NEG_ADD_IMM_32\n  name: string = 'NEG_ADD_IMM_32'\n\n  execute(context: InstructionContext): InstructionResult {\n    // Use the standard two-register-and-immediate format\n    const parseResult = this.parseTwoRegistersAndImmediate(context.operands, context.fskip)\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n    const registerValue = this.getRegisterValueAs32(context.registers, registerB)\n\n    // Gray Paper formula: reg'_A = (immed_X + 2^32 - reg_B) mod 2^32\n    const immediate32 = u64(immediateX) & u64(0xffffffff)\n    const result = (immediate32 + u64(0x100000000) - u64(registerValue)) & u64(0xffffffff)\n\n    this.setRegisterValueWith32BitResult(context.registers, registerA, result)\n\n    return new InstructionResult(-1)\n  }\n}\n","import {\n  OPCODE_SHAR_R_IMM_ALT_32,\n  OPCODE_SHLO_L_IMM_ALT_32,\n  OPCODE_SHLO_R_IMM_ALT_32,\n} from '../config'\nimport { InstructionContext, InstructionResult } from '../types'\nimport { BaseInstruction } from './base'\n\nexport class SHLO_L_IMM_ALT_32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_SHLO_L_IMM_ALT_32\n  name: string = 'SHLO_L_IMM_ALT_32'\n\n  execute(context: InstructionContext): InstructionResult {\n    // Gray Paper: reg'_A = sext{4}{(immed_X  2^(reg_B mod 32)) mod 2^32}\n    // ALT: immediate << register (not register << immediate!)\n    const parseResult = this.parseTwoRegistersAndImmediate(context.operands, context.fskip)\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n    const shiftAmount =\n      u64(this.getRegisterValueAs32(context.registers, registerB)) % u64(32)\n\n    // Gray Paper: (immed_X  2^(reg_B mod 32)) mod 2^32\n    // Convert immediate to 32-bit unsigned, perform left shift, then mask to 32 bits\n    const immediate32 = u64(immediateX) & u64(0xffffffff) // Convert to 32-bit unsigned\n    const shifted = immediate32 << shiftAmount // Left shift and mask to 32 bits\n    const result = shifted // Result is already 32-bit\n\n    this.setRegisterValueWith32BitResult(context.registers, registerA, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\nexport class SHLO_R_IMM_ALT_32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_SHLO_R_IMM_ALT_32\n  name: string = 'SHLO_R_IMM_ALT_32'\n\n  execute(context: InstructionContext): InstructionResult {\n    // Gray Paper: reg'_A = sext{4}{floor((immed_X mod 2^32) / 2^(reg_B mod 32))}\n    // ALT: immediate >> register (not register >> immediate!)\n    const parseResult = this.parseTwoRegistersAndImmediate(context.operands, context.fskip)\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n    const shiftAmount =\n      u64(this.getRegisterValueAs32(context.registers, registerB)) % u64(32)\n\n    // Gray Paper: floor((immed_X mod 2^32) / 2^(reg_B mod 32))\n    // Convert immediate to 32-bit unsigned, perform right shift\n    const immediate32 = u64(immediateX) & u64(0xffffffff) // Convert to 32-bit unsigned\n    const shifted = immediate32 >> shiftAmount // Unsigned right shift\n    const result = shifted & u64(0xffffffff) // Mask to 32 bits\n\n    this.setRegisterValueWith32BitResult(context.registers, registerA, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\nexport class SHAR_R_IMM_ALT_32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_SHAR_R_IMM_ALT_32\n  name: string = 'SHAR_R_IMM_ALT_32'\n\n  execute(context: InstructionContext): InstructionResult {\n    // Gray Paper: reg'_A = unsigned{floor(signed_32(immed_X mod 2^32) / 2^(reg_B mod 32))}\n    // ALT: immediate >> register (not register >> immediate!) with arithmetic shift\n    const parseResult = this.parseTwoRegistersAndImmediate(context.operands, context.fskip)\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n    const shiftAmount =\n      u64(this.getRegisterValueAs32(context.registers, registerB)) % u64(32)\n\n    // Gray Paper: unsigned{floor(signed_32(immed_X mod 2^32) / 2^(reg_B mod 32))}\n    // Convert immediate to 32-bit signed, perform arithmetic right shift, then convert back to unsigned\n    const immediate32 = u64(immediateX) & u64(0xffffffff) // Convert to 32-bit unsigned\n    const signed32_u64 = this.signExtend(immediate32, 4) // Convert to signed 32-bit (returns u64)\n    const signed32_i64 = i64(signed32_u64) // Cast to i64 for arithmetic right shift\n    const shifted = signed32_i64 >> i64(shiftAmount) // Arithmetic right shift\n    const result = u64(shifted) // Convert back to unsigned\n\n    this.setRegisterValueWith32BitResult(context.registers, registerA, result)\n\n    return new InstructionResult(-1)\n  }\n}\n","import {\n  OPCODE_NEG_ADD_IMM_64,\n  OPCODE_SHAR_R_IMM_64,\n  OPCODE_SHLO_L_IMM_64,\n  OPCODE_SHLO_R_IMM_64,\n} from '../config'\nimport { InstructionContext, InstructionResult } from '../types'\nimport { BaseInstruction } from './base'\n\n/**\n * SHLO_L_IMM_64 instruction (opcode 0x151)\n * Logical left shift by immediate (64-bit) as specified in Gray Paper\n * Gray Paper formula: reg'_A = sext{8}{(reg_B  2^{immed_X mod 64}) mod 2^64}\n */\nexport class SHLO_L_IMM_64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_SHLO_L_IMM_64\n  name: string = 'SHLO_L_IMM_64'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegistersAndImmediate(context.operands, context.fskip)\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n    const registerValue = this.getRegisterValueAs64(context.registers, registerB)\n\n    // Gray Paper: reg'_A = sext{8}{(reg_B  2^{immed_X mod 64}) mod 2^64}\n    // Apply mod 2^64 BEFORE sext{8} (sext{8} is a no-op for 64-bit values, but we still need to mask)\n    const shiftAmount = u64(immediateX) % u64(64)\n    const multiplied = u64(registerValue) << shiftAmount\n    const mod64 = multiplied & u64(0xffffffffffffffff) // mod 2^64\n    const shift = this.signExtend(mod64, 8) // sext{8} (no-op for 64-bit values)\n\n    this.setRegisterValueWith64BitResult(context.registers, registerA, shift)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * SHLO_R_IMM_64 instruction (opcode 0x152)\n * Logical right shift by immediate (64-bit) as specified in Gray Paper\n * Gray Paper formula: reg'_A = sext{8}{floor{reg_B  2^{immed_X mod 64}}}\n */\nexport class SHLO_R_IMM_64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_SHLO_R_IMM_64\n  name: string = 'SHLO_R_IMM_64'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegistersAndImmediate(context.operands, context.fskip)\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n    const registerValue = this.getRegisterValueAs64(context.registers, registerB)\n\n    // Ensure shift amount is within 64-bit range\n    const shiftAmount = u64(immediateX) % u64(64)\n    const result = u64(registerValue) >> shiftAmount\n\n    const shift = this.signExtend(result, 8)\n\n    this.setRegisterValueWith64BitResult(context.registers, registerA, shift)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * SHAR_R_IMM_64 instruction (opcode 0x153)\n * Arithmetic right shift by immediate (64-bit) as specified in Gray Paper\n * Gray Paper formula: reg'_A = unsigned{floor{signed{reg_B}  2^{immed_X mod 64}}}\n */\nexport class SHAR_R_IMM_64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_SHAR_R_IMM_64\n  name: string = 'SHAR_R_IMM_64'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegistersAndImmediate(context.operands, context.fskip)\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n    const registerBValue = this.getRegisterValueAs64(context.registers, registerB)\n\n    // Convert to signed for arithmetic shift\n    const signedValue = this.toSigned64(registerBValue)\n    const shiftAmount = u64(immediateX) % u64(64)\n    const shiftedValue = signedValue >> i64(shiftAmount)\n    const result = this.toUnsigned64(shiftedValue)\n\n    this.setRegisterValueWith64BitResult(context.registers, registerA, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * NEG_ADD_IMM_64 instruction (opcode 0x154)\n * Negate and add immediate (64-bit) as specified in Gray Paper\n * Gray Paper formula: reg'_A = (immed_X + 2^64 - reg_B) mod 2^64\n */\nexport class NEG_ADD_IMM_64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_NEG_ADD_IMM_64\n  name: string = 'NEG_ADD_IMM_64'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegistersAndImmediate(context.operands, context.fskip)\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n    const registerBValue = this.getRegisterValueAs64(context.registers, registerB)\n\n    // Negate the register value and add immediate\n    // (immed_X + 2^64 - reg_B) mod 2^64\n    const result = (u64(immediateX) - u64(registerBValue)) & u64(0xffffffffffffffff)\n\n    this.setRegisterValueWith64BitResult(context.registers, registerA, result)\n\n    return new InstructionResult(-1)\n  }\n}\n","import {\n  OPCODE_SHAR_R_IMM_ALT_64,\n  OPCODE_SHLO_L_IMM_ALT_64,\n  OPCODE_SHLO_R_IMM_ALT_64,\n} from '../config'\nimport { InstructionContext, InstructionResult } from '../types'\nimport { BaseInstruction } from './base'\n\nexport class SHLO_L_IMM_ALT_64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_SHLO_L_IMM_ALT_64\n  name: string = 'SHLO_L_IMM_ALT_64'\n\n  execute(context: InstructionContext): InstructionResult {\n    // Gray Paper: reg'_A = (immed_X  2^(reg_B mod 64)) mod 2^64\n    // ALT: immediate << register (not register << immediate!)\n    const parseResult = this.parseTwoRegistersAndImmediate(context.operands, context.fskip)\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n\n    const registerBValue = this.getRegisterValueAs64(context.registers, registerB)\n    const shiftAmount = u64(registerBValue) % u64(64)\n\n    // ALT: shift the immediate value by the register amount\n    const result = u64(immediateX) << shiftAmount\n\n    this.setRegisterValueWith64BitResult(context.registers, registerA, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\nexport class SHLO_R_IMM_ALT_64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_SHLO_R_IMM_ALT_64\n  name: string = 'SHLO_R_IMM_ALT_64'\n\n  execute(context: InstructionContext): InstructionResult {\n    // Gray Paper: reg'_A = floor(immed_X / 2^(reg_B mod 64))\n    // ALT: immediate >> register (not register >> immediate!)\n    const parseResult = this.parseTwoRegistersAndImmediate(context.operands, context.fskip)\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n\n    const registerBValue = this.getRegisterValueAs64(context.registers, registerB)\n    const shiftAmount = u64(registerBValue) % u64(64)\n\n    // ALT: shift the immediate value by the register amount (unsigned)\n    const result = u64(immediateX) >> shiftAmount\n\n    this.setRegisterValueWith64BitResult(context.registers, registerA, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\nexport class SHAR_R_IMM_ALT_64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_SHAR_R_IMM_ALT_64\n  name: string = 'SHAR_R_IMM_ALT_64'\n\n  execute(context: InstructionContext): InstructionResult {\n    // Gray Paper: reg'_A = unsigned{floor(signed_64(immed_X) / 2^(reg_B mod 64))}\n    // ALT: immediate >> register (not register >> immediate!) with arithmetic shift\n    const parseResult = this.parseTwoRegistersAndImmediate(context.operands, context.fskip)\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n\n    const registerBValue = this.getRegisterValueAs64(context.registers, registerB)\n    const shiftAmount = u64(registerBValue) % u64(64)\n\n    // ALT: arithmetic shift the immediate value by the register amount\n    const signedImmediate = this.toSigned64(immediateX)\n    const shiftedValue = signedImmediate >> i64(shiftAmount)\n    const result = this.toUnsigned64(shiftedValue)\n\n    this.setRegisterValueWith64BitResult(context.registers, registerA, result)\n\n    return new InstructionResult(-1)\n  }\n}\n","import {\n  OPCODE_ROT_R_32_IMM,\n  OPCODE_ROT_R_32_IMM_ALT,\n  OPCODE_ROT_R_64_IMM,\n  OPCODE_ROT_R_64_IMM_ALT,\n} from '../config'\nimport { InstructionContext, InstructionResult } from '../types'\nimport { BaseInstruction } from './base'\n\nexport class ROT_R_64_IMMInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_ROT_R_64_IMM\n  name: string = 'ROT_R_64_IMM'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegistersAndImmediate(context.operands, context.fskip)\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n    const registerValue = this.getRegisterValue(context.registers, registerB)\n\n    // Ensure rotation amount is within 64-bit range\n    const rotationAmount = u64(immediateX) % u64(64)\n    const result = this.rotateRight64(registerValue, rotationAmount)\n\n    this.setRegisterValue(context.registers, registerA, result)\n\n    return new InstructionResult(-1)\n  }\n\n  rotateRight64(value: u64, amount: u64): u64 {\n    // Handle negative rotation amounts\n    let normalizedAmount = amount\n    if (i64(amount) < i64(0)) {\n      normalizedAmount = u64(64) + amount\n    }\n\n    // Normalize amount to 0-63 range\n    normalizedAmount = normalizedAmount % u64(64)\n\n    if (normalizedAmount === u64(0)) return value\n\n    // Perform right rotation\n    const mask = u64(0xffffffffffffffff)\n    const rightPart = value >> normalizedAmount\n    const leftPart = (value << (u64(64) - normalizedAmount)) & mask\n    return (rightPart | leftPart) & mask\n  }\n}\n\nexport class ROT_R_64_IMM_ALTInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_ROT_R_64_IMM_ALT\n  name: string = 'ROT_R_64_IMM_ALT'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegistersAndImmediate(context.operands, context.fskip)\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n    // Gray Paper: rotates immediateX by registerB\n    const immediateValue = u64(immediateX)\n    const registerBValue = this.getRegisterValue(context.registers, registerB)\n\n    // Alternative rotation implementation: rotate immediate by register value\n    const rotationAmount = i32(registerBValue % u64(64))\n    const result = this.rotateRight64(immediateValue, u64(rotationAmount))\n\n    this.setRegisterValue(context.registers, registerA, result)\n\n    return new InstructionResult(-1)\n  }\n\n  rotateRight64(value: u64, amount: u64): u64 {\n    // Handle negative rotation amounts\n    let normalizedAmount = amount\n    if (i64(amount) < i64(0)) {\n      normalizedAmount = u64(64) + amount\n    }\n\n    // Normalize amount to 0-63 range\n    normalizedAmount = normalizedAmount % u64(64)\n\n    if (normalizedAmount === u64(0)) return value\n\n    // Perform right rotation\n    const mask = u64(0xffffffffffffffff)\n    const rightPart = value >> normalizedAmount\n    const leftPart = (value << (u64(64) - normalizedAmount)) & mask\n    return (rightPart | leftPart) & mask\n  }\n}\n\nexport class ROT_R_32_IMMInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_ROT_R_32_IMM\n  name: string = 'ROT_R_32_IMM'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegistersAndImmediate(context.operands, context.fskip)\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n    const registerValue =\n      this.getRegisterValue(context.registers, registerB) & u64(0xffffffff)\n\n    // Ensure rotation amount is within 32-bit range\n    const rotationAmount = i32(u64(immediateX) % u64(32))\n    const result = this.rotateRight32(registerValue, rotationAmount)\n\n    // Gray Paper: reg'_A = sext{4}{x} - sign-extend 32-bit result to 64 bits\n    this.setRegisterValueWith32BitResult(context.registers, registerA, result)\n\n    return new InstructionResult(-1)\n  }\n\n  rotateRight32(value: u64, amount: i32): u64 {\n    // Handle negative rotation amounts\n    let normalizedAmount = amount\n    if (amount < 0) {\n      normalizedAmount = 32 + amount\n    }\n\n    // Normalize amount to 0-31 range\n    normalizedAmount = normalizedAmount % 32\n\n    if (normalizedAmount === 0) return value\n\n    // Perform right rotation\n    const mask = u64(0xffffffff)\n    const rightPart = value >> u64(normalizedAmount)\n    const leftPart = (value << u64(32 - normalizedAmount)) & mask\n    return (rightPart | leftPart) & mask\n  }\n}\n\nexport class ROT_R_32_IMM_ALTInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_ROT_R_32_IMM_ALT\n  name: string = 'ROT_R_32_IMM_ALT'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegistersAndImmediate(context.operands, context.fskip)\n    const registerA = parseResult.registerA\n    const registerB = parseResult.registerB\n    const immediateX = parseResult.immediateX\n    // Gray Paper: rotates immediateX by registerB (32-bit)\n    const immediateValue = u64(immediateX) & u64(0xffffffff)\n    const registerBValue =\n      this.getRegisterValue(context.registers, registerB) & u64(0xffffffff)\n\n    // Alternative rotation implementation: rotate immediate by register value\n    const rotationAmount = i32(registerBValue % u64(32))\n    const result = this.rotateRight32(immediateValue, rotationAmount)\n\n    // Gray Paper: reg'_A = sext{4}{x} - sign-extend 32-bit result to 64 bits\n    this.setRegisterValueWith32BitResult(context.registers, registerA, result)\n\n    return new InstructionResult(-1)\n  }\n\n  rotateRight32(value: u64, amount: i32): u64 {\n    // Handle negative rotation amounts\n    let normalizedAmount = amount\n    if (amount < 0) {\n      normalizedAmount = 32 + amount\n    }\n\n    // Normalize amount to 0-31 range\n    normalizedAmount = normalizedAmount % 32\n\n    if (normalizedAmount === 0) return value\n\n    // Perform right rotation\n    const mask = u64(0xffffffff)\n    const rightPart = value >> u64(normalizedAmount)\n    const leftPart = (value << u64(32 - normalizedAmount)) & mask\n    return (rightPart | leftPart) & mask\n  }\n}\n","/**\n * Branching Instructions\n *\n * BRANCH_*_IMM variants - Branch if condition with immediate\n */\n\nimport {\n  OPCODE_BRANCH_EQ,\n  OPCODE_BRANCH_EQ_IMM,\n  OPCODE_BRANCH_GE_S,\n  OPCODE_BRANCH_GE_S_IMM,\n  OPCODE_BRANCH_GE_U,\n  OPCODE_BRANCH_GE_U_IMM,\n  OPCODE_BRANCH_GT_S_IMM,\n  OPCODE_BRANCH_GT_U_IMM,\n  OPCODE_BRANCH_LE_S_IMM,\n  OPCODE_BRANCH_LE_U_IMM,\n  OPCODE_BRANCH_LT_S,\n  OPCODE_BRANCH_LT_S_IMM,\n  OPCODE_BRANCH_LT_U,\n  OPCODE_BRANCH_LT_U_IMM,\n  OPCODE_BRANCH_NE,\n  OPCODE_BRANCH_NE_IMM,\n} from '../config'\nimport { InstructionContext, InstructionResult } from '../types'\nimport { BaseInstruction } from './base'\n\n/**\n * BRANCH_EQ_IMM instruction (opcode 0x81)\n * Branch if register equals immediate as specified in Gray Paper\n * \n * Gray Paper (pvm.tex line 405):\n * Format: \"One Register, One Immediate and One Offset\" (lines 385-396)\n * immed_Y =  + signfunc{l_Y}(decode[l_Y]{instructions[+2+l_X:l_Y]})\n * Mutation: branch(immed_Y, reg_A = immed_X)\n */\nexport class BRANCH_EQ_IMMInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_BRANCH_EQ_IMM\n  name: string = 'BRANCH_EQ_IMM'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseBranchOperands(context.operands, context.programCounter)\n    const registerA: u8 = parseResult.registerA\n    const immediateX = parseResult.immediateX\n    const targetAddress = parseResult.targetAddress\n    const registerValue = this.getRegisterValueAs64(\n      context.registers,\n      registerA,\n    )\n\n    // Branch if register equals immediate\n    if (registerValue === immediateX) {\n      // Gray Paper: Branches must target basic block starts\n      const validationResult = this.validateBranchTarget(targetAddress, context)\n      if (validationResult) {\n        return validationResult\n      }\n\n      context.programCounter = targetAddress\n    }\n    // else: not branching - PVM will advance PC normally\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * BRANCH_NE_IMM instruction (opcode 0x82)\n * Branch if register not equals immediate as specified in Gray Paper\n * \n * Gray Paper (pvm.tex line 406):\n * Format: \"One Register, One Immediate and One Offset\" (lines 385-396)\n * immed_Y =  + signfunc{l_Y}(decode[l_Y]{instructions[+2+l_X:l_Y]})\n * Mutation: branch(immed_Y, reg_A  immed_X)\n */\nexport class BRANCH_NE_IMMInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_BRANCH_NE_IMM\n  name: string = 'BRANCH_NE_IMM'\n\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseBranchOperands(context.operands, context.programCounter)\n    const registerA: u8 = parseResult.registerA\n    const immediateX = parseResult.immediateX\n    const targetAddress = parseResult.targetAddress\n    const registerValue = this.getRegisterValueAs64(\n      context.registers,\n      registerA,\n    )\n\n    // Branch if register not equals immediate\n    if (registerValue !== immediateX) {\n      // Gray Paper: Branches must target basic block starts\n      const validationResult = this.validateBranchTarget(targetAddress, context)\n      if (validationResult) {\n        return validationResult\n      }\n\n      context.programCounter = targetAddress\n    }\n    // else: not branching - PVM will advance PC normally\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * BRANCH_LT_U_IMM instruction (opcode 0x83)\n * Branch if register less than immediate (unsigned) as specified in Gray Paper\n * \n * Gray Paper (pvm.tex line 407):\n * Format: \"One Register, One Immediate and One Offset\" (lines 385-396)\n * immed_Y =  + signfunc{l_Y}(decode[l_Y]{instructions[+2+l_X:l_Y]})\n * Mutation: branch(immed_Y, reg_A < immed_X)\n */\nexport class BRANCH_LT_U_IMMInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_BRANCH_LT_U_IMM\n  name: string = 'BRANCH_LT_U_IMM'\n\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseBranchOperands(context.operands, context.programCounter)\n    const registerA: u8 = parseResult.registerA\n    const immediateX = parseResult.immediateX\n    const targetAddress = parseResult.targetAddress\n    const registerValue = this.getRegisterValueAs64(\n      context.registers,\n      registerA,\n    )\n\n    // Branch if register less than immediate (unsigned)\n    if (u64(registerValue) < u64(immediateX)) {\n      // Gray Paper: Branches must target basic block starts\n      const validationResult = this.validateBranchTarget(targetAddress, context)\n      if (validationResult) {\n        return validationResult\n      }\n\n      context.programCounter = targetAddress\n    }\n    // else: not branching - PVM will advance PC normally\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * BRANCH_LE_U_IMM instruction (opcode 0x84)\n * Branch if register less or equal immediate (unsigned) as specified in Gray Paper\n * \n * Gray Paper (pvm.tex line 408):\n * Format: \"One Register, One Immediate and One Offset\" (lines 385-396)\n * immed_Y =  + signfunc{l_Y}(decode[l_Y]{instructions[+2+l_X:l_Y]})\n * Mutation: branch(immed_Y, reg_A  immed_X)\n */\nexport class BRANCH_LE_U_IMMInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_BRANCH_LE_U_IMM\n  name: string = 'BRANCH_LE_U_IMM'\n\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseBranchOperands(context.operands, context.programCounter)\n    const registerA: u8 = parseResult.registerA\n    const immediateX = parseResult.immediateX\n    const targetAddress = parseResult.targetAddress\n    const registerValue = this.getRegisterValueAs64(\n      context.registers,\n      registerA,\n    )\n\n    // Branch if register less or equal immediate (unsigned)\n    if (u64(registerValue) <= u64(immediateX)) {\n      // Gray Paper: Branches must target basic block starts\n      const validationResult = this.validateBranchTarget(targetAddress, context)\n      if (validationResult) { \n\n        return validationResult\n      }\n\n      context.programCounter = targetAddress\n    }\n    // else: not branching - PVM will advance PC normally\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * BRANCH_GE_U_IMM instruction (opcode 0x85)\n * Branch if register greater or equal immediate (unsigned) as specified in Gray Paper\n * \n * Gray Paper (pvm.tex line 409):\n * Format: \"One Register, One Immediate and One Offset\" (lines 385-396)\n * immed_Y =  + signfunc{l_Y}(decode[l_Y]{instructions[+2+l_X:l_Y]})\n * Mutation: branch(immed_Y, reg_A  immed_X)\n */\nexport class BRANCH_GE_U_IMMInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_BRANCH_GE_U_IMM\n  name: string = 'BRANCH_GE_U_IMM'\n\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseBranchOperands(context.operands, context.programCounter)\n    const registerA: u8 = parseResult.registerA\n    const immediateX = parseResult.immediateX\n    const targetAddress = parseResult.targetAddress\n    const registerValue = this.getRegisterValueAs64(\n      context.registers,\n      registerA,\n    )\n\n    // Branch if register greater or equal immediate (unsigned)\n    if (u64(registerValue) >= u64(immediateX)) {\n      // Gray Paper: Branches must target basic block starts\n      const validationResult = this.validateBranchTarget(targetAddress, context)\n      if (validationResult) {\n\n        return validationResult\n      }\n\n      context.programCounter = targetAddress\n    }\n    // else: not branching - PVM will advance PC normally\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * BRANCH_GT_U_IMM instruction (opcode 0x86)\n * Branch if register greater than immediate (unsigned) as specified in Gray Paper\n * \n * Gray Paper (pvm.tex line 410):\n * Format: \"One Register, One Immediate and One Offset\" (lines 385-396)\n * immed_Y =  + signfunc{l_Y}(decode[l_Y]{instructions[+2+l_X:l_Y]})\n * Mutation: branch(immed_Y, reg_A > immed_X)\n */\nexport class BRANCH_GT_U_IMMInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_BRANCH_GT_U_IMM\n  name: string = 'BRANCH_GT_U_IMM'\n\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseBranchOperands(context.operands, context.programCounter)\n    const registerA: u8 = parseResult.registerA\n    const immediateX = parseResult.immediateX\n    const targetAddress = parseResult.targetAddress\n    const registerValue = this.getRegisterValueAs64(\n      context.registers,\n      registerA,\n    )\n\n    // Branch if register greater than immediate (unsigned)\n    if (u64(registerValue) > u64(immediateX)) {\n      // Gray Paper: Branches must target basic block starts\n      const validationResult = this.validateBranchTarget(targetAddress, context)\n      if (validationResult) {\n\n        return validationResult\n      }\n\n      context.programCounter = targetAddress\n    }\n    // else: not branching - PVM will advance PC normally\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * BRANCH_LT_S_IMM instruction (opcode 0x87)\n * Branch if register less than immediate (signed) as specified in Gray Paper\n * \n * Gray Paper (pvm.tex line 411):\n * Format: \"One Register, One Immediate and One Offset\" (lines 385-396)\n * immed_Y =  + signfunc{l_Y}(decode[l_Y]{instructions[+2+l_X:l_Y]})\n * Mutation: branch(immed_Y, signed(reg_A) < signed(immed_X))\n */\nexport class BRANCH_LT_S_IMMInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_BRANCH_LT_S_IMM\n  name: string = 'BRANCH_LT_S_IMM'\n\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseBranchOperands(context.operands, context.programCounter)\n    const registerA: u8 = parseResult.registerA\n    const immediateX = parseResult.immediateX\n    const targetAddress = parseResult.targetAddress\n    const registerValue = this.getRegisterValueAs64(\n      context.registers,\n      registerA,\n    )\n\n    // Branch if register less than immediate (signed)\n    if (this.signedCompare(registerValue, immediateX) < 0) {\n      // Gray Paper: Branches must target basic block starts\n      const validationResult = this.validateBranchTarget(targetAddress, context)\n      if (validationResult) {\n          \n        return validationResult\n      }\n\n      context.programCounter = targetAddress\n    }\n    // else: not branching - PVM will advance PC normally\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * BRANCH_LE_S_IMM instruction (opcode 0x88)\n * Branch if register less or equal immediate (signed) as specified in Gray Paper\n * \n * Gray Paper (pvm.tex line 412):\n * Format: \"One Register, One Immediate and One Offset\" (lines 385-396)\n * immed_Y =  + signfunc{l_Y}(decode[l_Y]{instructions[+2+l_X:l_Y]})\n * Mutation: branch(immed_Y, signed(reg_A)  signed(immed_X))\n */\nexport class BRANCH_LE_S_IMMInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_BRANCH_LE_S_IMM\n  name: string = 'BRANCH_LE_S_IMM'\n\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseBranchOperands(context.operands, context.programCounter)\n    const registerA: u8 = parseResult.registerA\n    const immediateX = parseResult.immediateX\n    const targetAddress = parseResult.targetAddress\n    const registerValue = this.getRegisterValueAs64(\n      context.registers,\n      registerA,\n    )\n\n    // Branch if register less or equal immediate (signed)\n    if (this.signedCompare(registerValue, immediateX) <= 0) {\n      // Gray Paper: Branches must target basic block starts\n      const validationResult = this.validateBranchTarget(targetAddress, context)\n      if (validationResult) {\n\n        return validationResult\n      }\n\n      context.programCounter = targetAddress\n    }\n    // else: not branching - PVM will advance PC normally\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * BRANCH_GE_S_IMM instruction (opcode 0x89)\n * Branch if register greater or equal immediate (signed) as specified in Gray Paper\n * \n * Gray Paper (pvm.tex line 413):\n * Format: \"One Register, One Immediate and One Offset\" (lines 385-396)\n * immed_Y =  + signfunc{l_Y}(decode[l_Y]{instructions[+2+l_X:l_Y]})\n * Mutation: branch(immed_Y, signed(reg_A)  signed(immed_X))\n */\nexport class BRANCH_GE_S_IMMInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_BRANCH_GE_S_IMM\n  name: string = 'BRANCH_GE_S_IMM'\n\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseBranchOperands(context.operands, context.programCounter)\n    const registerA: u8 = parseResult.registerA\n    const immediateX = parseResult.immediateX\n    const targetAddress = parseResult.targetAddress\n    const registerValue = this.getRegisterValueAs64(\n      context.registers,\n      registerA,\n    )\n\n    // Branch if register greater or equal immediate (signed)\n    if (this.signedCompare(registerValue, immediateX) >= 0) {\n      // Gray Paper: Branches must target basic block starts\n      const validationResult = this.validateBranchTarget(targetAddress, context)\n      if (validationResult) {\n\n        return validationResult\n      }\n\n      context.programCounter = targetAddress\n    }\n    // else: not branching - PVM will advance PC normally\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * BRANCH_GT_S_IMM instruction (opcode 0x8A / 0x90)\n * Branch if register greater than immediate (signed) as specified in Gray Paper\n * \n * Gray Paper (pvm.tex line 414):\n * Format: \"One Register, One Immediate and One Offset\" (lines 385-396)\n * immed_Y =  + signfunc{l_Y}(decode[l_Y]{instructions[+2+l_X:l_Y]})\n * Mutation: branch(immed_Y, signed(reg_A) > signed(immed_X))\n */\nexport class BRANCH_GT_S_IMMInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_BRANCH_GT_S_IMM\n  name: string = 'BRANCH_GT_S_IMM'\n\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseBranchOperands(context.operands, context.programCounter)\n    const registerA: u8 = parseResult.registerA\n    const immediateX = parseResult.immediateX\n    const targetAddress = parseResult.targetAddress\n    const registerValue = this.getRegisterValueAs64(\n      context.registers,\n      registerA,\n    )\n\n    // Branch if register greater than immediate (signed)\n    if (this.signedCompare(registerValue, immediateX) > 0) {\n      // Gray Paper: Branches must target basic block starts\n      const validationResult = this.validateBranchTarget(targetAddress, context)\n      if (validationResult) {\n\n        return validationResult\n      }\n\n      context.programCounter = targetAddress\n    }\n    // else: not branching - PVM will advance PC normally\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * Register-based Branch Instructions\n *\n * BRANCH_* variants - Branch if condition between two registers\n */\n\n/**\n * BRANCH_EQ instruction (opcode 0x170)\n * Branch if two registers are equal as specified in Gray Paper\n * \n * Gray Paper (pvm.tex line 551):\n * Format: \"Two Registers & One Offset\" (lines 531-543)\n * immed_X   + signfunc{l_X}(decode[l_X]{instructions[+2:l_X]})\n * Mutation: branch(immed_X, reg_A = reg_B)\n */\nexport class BRANCH_EQInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_BRANCH_EQ\n  name: string = 'BRANCH_EQ'\n\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseRegisterBranchOperands(context.operands, context.programCounter)\n    const registerA: u8 = parseResult.registerA\n    const registerB: u8 = parseResult.registerB\n    const targetAddress = parseResult.targetAddress\n    const registerValueA = this.getRegisterValueAs64(\n      context.registers,\n      registerA,\n    )\n    const registerValueB = this.getRegisterValueAs64(\n      context.registers,\n      registerB,\n    )\n\n    // Branch if two registers are equal\n    if (registerValueA === registerValueB) {\n      // Gray Paper: Branches must target basic block starts\n      const validationResult = this.validateBranchTarget(targetAddress, context)\n      if (validationResult) {\n\n        return validationResult\n      }\n\n      context.programCounter = targetAddress\n    }\n    // else: not branching - PVM will advance PC normally\n\n    return new InstructionResult(-1)\n  }\n\n}\n\n/**\n * BRANCH_NE instruction (opcode 0x171)\n * Branch if two registers are not equal as specified in Gray Paper\n * \n * Gray Paper (pvm.tex line 552):\n * Format: \"Two Registers & One Offset\" (lines 531-543)\n * immed_X   + signfunc{l_X}(decode[l_X]{instructions[+2:l_X]})\n * Mutation: branch(immed_X, reg_A  reg_B)\n */\nexport class BRANCH_NEInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_BRANCH_NE\n  name: string = 'BRANCH_NE'\n\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseRegisterBranchOperands(context.operands, context.programCounter)\n    const registerA: u8 = parseResult.registerA\n    const registerB: u8 = parseResult.registerB\n    const targetAddress = parseResult.targetAddress\n    const registerValueA = this.getRegisterValueAs64(\n      context.registers,\n      registerA,\n    )\n    const registerValueB = this.getRegisterValueAs64(\n      context.registers,\n      registerB,\n    )\n\n    // Branch if two registers are not equal\n    if (registerValueA !== registerValueB) {\n      // Gray Paper: Branches must target basic block starts\n      const validationResult = this.validateBranchTarget(targetAddress, context)\n      if (validationResult) {\n        return validationResult\n      }\n\n      context.programCounter = targetAddress\n    }\n    // else: not branching - PVM will advance PC normally\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * BRANCH_LT_U instruction (opcode 0x172)\n * Branch if register A less than register B (unsigned) as specified in Gray Paper\n * \n * Gray Paper (pvm.tex line 553):\n * Format: \"Two Registers & One Offset\" (lines 531-543)\n * immed_X   + signfunc{l_X}(decode[l_X]{instructions[+2:l_X]})\n * Mutation: branch(immed_X, reg_A < reg_B)\n */\nexport class BRANCH_LT_UInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_BRANCH_LT_U\n  name: string = 'BRANCH_LT_U'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseRegisterBranchOperands(context.operands, context.programCounter)\n    const registerA: u8 = parseResult.registerA\n    const registerB: u8 = parseResult.registerB\n    const targetAddress = parseResult.targetAddress\n    const registerValueA = this.getRegisterValueAs64(\n      context.registers,\n      registerA,\n    )\n    const registerValueB = this.getRegisterValueAs64(\n      context.registers,\n      registerB,\n    )\n    // Branch if register A less than register B (unsigned)\n    if (registerValueA < registerValueB) {\n      // Gray Paper: Branches must target basic block starts\n      const validationResult = this.validateBranchTarget(targetAddress, context)\n      if (validationResult) {\n\n        return validationResult\n      }\n\n      context.programCounter = targetAddress\n    }\n    // else: not branching - PVM will advance PC normally\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * BRANCH_LT_S instruction (opcode 0x173)\n * Branch if register A less than register B (signed) as specified in Gray Paper\n * \n * Gray Paper (pvm.tex line 554):\n * Format: \"Two Registers & One Offset\" (lines 531-543)\n * immed_X   + signfunc{l_X}(decode[l_X]{instructions[+2:l_X]})\n * Mutation: branch(immed_X, signed(reg_A) < signed(reg_B))\n */\nexport class BRANCH_LT_SInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_BRANCH_LT_S\n  name: string = 'BRANCH_LT_S'\n\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseRegisterBranchOperands(context.operands, context.programCounter)\n    const registerA: u8 = parseResult.registerA\n    const registerB: u8 = parseResult.registerB\n    const targetAddress = parseResult.targetAddress\n    const registerValueA = this.getRegisterValueAs64(\n      context.registers,\n      registerA,\n    )\n    const registerValueB = this.getRegisterValueAs64(\n      context.registers,\n      registerB,\n    )\n    // Branch if register A less than register B (signed)\n    if (this.signedCompare(registerValueA, registerValueB) < 0) {\n      // Gray Paper: Branches must target basic block starts\n      const validationResult = this.validateBranchTarget(targetAddress, context)\n      if (validationResult) {\n\n        return validationResult\n      }\n\n      context.programCounter = targetAddress\n    }\n    // else: not branching - PVM will advance PC normally\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * BRANCH_GE_U instruction (opcode 0x174)\n * Branch if register A greater or equal register B (unsigned) as specified in Gray Paper\n * \n * Gray Paper (pvm.tex line 555):\n * Format: \"Two Registers & One Offset\" (lines 531-543)\n * immed_X   + signfunc{l_X}(decode[l_X]{instructions[+2:l_X]})\n * Mutation: branch(immed_X, reg_A  reg_B)\n */\nexport class BRANCH_GE_UInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_BRANCH_GE_U\n  name: string = 'BRANCH_GE_U'\n\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseRegisterBranchOperands(context.operands, context.programCounter)\n    const registerA: u8 = parseResult.registerA\n    const registerB: u8 = parseResult.registerB\n    const targetAddress = parseResult.targetAddress\n    const registerValueA = this.getRegisterValueAs64(\n      context.registers,\n      registerA,\n    )\n    const registerValueB = this.getRegisterValueAs64(\n      context.registers,\n      registerB,\n    )\n    // Branch if register A greater or equal register B (unsigned)\n    if (registerValueA >= registerValueB) {\n      // Gray Paper: Branches must target basic block starts\n      const validationResult = this.validateBranchTarget(targetAddress, context)\n      if (validationResult) {\n\n        return validationResult\n      }\n\n      context.programCounter = targetAddress\n    }\n    // else: not branching - PVM will advance PC normally\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * BRANCH_GE_S instruction (opcode 0x175)\n * Branch if register A greater or equal register B (signed) as specified in Gray Paper\n * \n * Gray Paper (pvm.tex line 556):\n * Format: \"Two Registers & One Offset\" (lines 531-543)\n * immed_X   + signfunc{l_X}(decode[l_X]{instructions[+2:l_X]})\n * Mutation: branch(immed_X, signed(reg_A)  signed(reg_B))\n */\nexport class BRANCH_GE_SInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_BRANCH_GE_S\n  name: string = 'BRANCH_GE_S'\n\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseRegisterBranchOperands(context.operands, context.programCounter)\n    const registerA: u8 = parseResult.registerA\n    const registerB: u8 = parseResult.registerB\n    const targetAddress = parseResult.targetAddress\n    const registerValueA = this.getRegisterValueAs64(\n      context.registers,\n      registerA,\n    )\n    const registerValueB = this.getRegisterValueAs64(\n      context.registers,\n      registerB,\n    )\n    // Branch if register A greater or equal register B (signed)\n    if (this.signedCompare(registerValueA, registerValueB) >= 0) {\n      // Gray Paper: Branches must target basic block starts\n      const validationResult = this.validateBranchTarget(targetAddress, context)\n      if (validationResult) {\n\n        return validationResult\n      }\n\n      context.programCounter = targetAddress\n    }\n    // else: not branching - PVM will advance PC normally\n\n    return new InstructionResult(-1)\n  }\n}\n","import { OPCODE_ADD_32, OPCODE_DIV_S_32, OPCODE_DIV_U_32, OPCODE_MUL_32, OPCODE_REM_S_32, OPCODE_REM_U_32, OPCODE_SUB_32 } from '../config'\nimport { InstructionContext, InstructionResult } from '../types'\nimport { BaseInstruction } from './base'\n\n/**\n * ADD_32 instruction (opcode 0xBE / 190)\n * Gray Paper formula: reg'_D = sext{4}{(reg_A + reg_B) mod 2^32}\n */\nexport class ADD_32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_ADD_32\n  name: string = 'ADD_32'\n\n  /**\n   * Gray Paper: Instructions with 2 registers + immediate = 11 bytes\n   * (1 opcode + 2 registers + 8 immediate)\n   */\n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands) // From operands[1]\n    const registerA = this.getRegisterA(context.operands) // From operands[0] low nibble\n    const registerB = this.getRegisterB(context.operands) // From operands[0] high nibble\n\n    const valueA = this.getRegisterValueAs32(context.registers, registerA)\n    const valueB = this.getRegisterValueAs32(context.registers, registerB)\n\n    // Gray Paper formula: reg'_D = sext{4}{(reg_A + reg_B) mod 2^32}\n    // Step 1: (reg_A + reg_B) mod 2^32\n    const sum = (valueA + valueB) & u64(0xffffffff)\n    \n    // Use setRegisterValueWith32BitResult which will mask and sign-extend\n    // This matches the Gray Paper formula: sext{4}{sum mod 2^32}\n    this.setRegisterValueWith32BitResult(context.registers, registerD, sum)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * SUB_32 instruction (opcode 0xBF / 191)\n * Gray Paper formula: reg'_D = sext{4}{(reg_A + 2^32 - (reg_B mod 2^32)) mod 2^32}\n */\nexport class SUB_32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_SUB_32\n  name: string = 'SUB_32'\n\n  execute(context: InstructionContext): InstructionResult {\n    // Extract operands from code starting at programCounter + 1\n    const pc = i32(context.programCounter)\n    const operands = context.code.slice(pc + 1, pc + 3)\n    \n    const registerD = this.getRegisterD(operands)\n    const registerA = this.getRegisterIndex(operands[0])\n    const registerB = this.getRegisterB(operands)\n    const valueA = this.getRegisterValueAs32(context.registers, registerA)\n    const valueB = this.getRegisterValueAs32(context.registers, registerB)\n    const result = (valueA - valueB + i64(0x100000000)) & i64(0xffffffff) // Handle underflow\n\n    this.setRegisterValueWith32BitResult(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * MUL_32 instruction (opcode 0xC0 / 192)\n * Gray Paper formula: reg'_D = sext{4}{(reg_A  reg_B) mod 2^32}\n */\nexport class MUL_32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_MUL_32\n  name: string = 'MUL_32'\n\n  execute(context: InstructionContext): InstructionResult {\n    // Extract operands from code starting at programCounter + 1\n    const pc = i32(context.programCounter)\n    const operands = context.code.slice(pc + 1, pc + 3)\n    \n    const registerD = this.getRegisterD(operands)\n    const registerA = this.getRegisterIndex(operands[0])\n    const registerB = this.getRegisterB(operands)\n    const valueA = this.getRegisterValueAs32(context.registers, registerA)\n    const valueB = this.getRegisterValueAs32(context.registers, registerB)\n    const result = (valueA * valueB) & i64(0xffffffff)\n\n    this.setRegisterValueWith32BitResult(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * DIV_U_32 instruction (opcode 0xC1 / 193)\n * Gray Paper formula: reg'_D = {2^64 - 1 when reg_B mod 2^32 = 0, sext{4}{floor((reg_A mod 2^32)  (reg_B mod 2^32))} otherwise}\n */\nexport class DIV_U_32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_DIV_U_32\n  name: string = 'DIV_U_32'\n\n  execute(context: InstructionContext): InstructionResult {\n    // Extract operands from code starting at programCounter + 1\n    const pc = i32(context.programCounter)\n    const operands = context.code.slice(pc + 1, pc + 3)\n    \n    const registerD = this.getRegisterD(operands)\n    const registerA = this.getRegisterIndex(operands[0])\n    const registerB = this.getRegisterB(operands)\n\n    // Gray Paper: reg'_D = sext{4}{floor((reg_A mod 2^32) / (reg_B mod 2^32))}\n    const valueA = this.getRegisterValueAs32(context.registers, registerA)\n    const valueB = this.getRegisterValueAs32(context.registers, registerB)\n\n    // Gray Paper: Handle division by zero - result = 2^64 - 1\n    // Use u64 to avoid overflow: 0xFFFFFFFFFFFFFFFF\n    let result: i64\n    if (valueB === i64(0)) {\n      result = i64(u64(0xFFFFFFFFFFFFFFFF)) // 2^64 - 1\n    } else {\n      // Unsigned division with sign-extension of result\n      result = valueA / valueB\n    }\n\n    this.setRegisterValueWith32BitResult(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * DIV_S_32 instruction (opcode 0xC2 / 194)\n * Gray Paper formula: reg'_D = {2^64 - 1 when b = 0, unsigned{a} when a = -2^31  b = -1, unsigned{rtz(a  b)} otherwise}\n * where a = signed_4(reg_A mod 2^32), b = signed_4(reg_B mod 2^32)\n */\nexport class DIV_S_32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_DIV_S_32\n  name: string = 'DIV_S_32'\n\n  execute(context: InstructionContext): InstructionResult {\n    // Extract operands from code starting at programCounter + 1\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueA = this.getRegisterValueAs32(context.registers, registerA)\n    const valueB = this.getRegisterValueAs32(context.registers, registerB)\n\n    // Convert to signed values (check if negative in 32-bit context)\n    // Gray Paper: signed_4(x) means interpret 32-bit value as signed\n    const isNegativeA = (valueA & u64(0x80000000)) !== u64(0)\n    const isNegativeB = (valueB & u64(0x80000000)) !== u64(0)\n\n    // Convert to signed: if MSB is set, subtract 2^32 to get negative value\n    // Use u64 for the calculation to avoid overflow, then convert to i64\n    const signedA_u64 = isNegativeA ? valueA - u64(0x100000000) : valueA\n    const signedB_u64 = isNegativeB ? valueB - u64(0x100000000) : valueB\n    const signedA = i64(signedA_u64)\n    const signedB = i64(signedB_u64)\n\n    // Gray Paper: handle special cases\n    let result: i64\n    if (signedB === i64(0)) {\n      // Division by zero: result = 2^64 - 1\n      // Use u64 to avoid overflow: 0xFFFFFFFFFFFFFFFF\n      result = i64(u64(0xFFFFFFFFFFFFFFFF))\n    } else if (valueA === i64(0x80000000) && valueB === i64(0xffffffff)) {\n      // Gray Paper: unsigned{a} when a = -2^31  b = -1\n      // Check using 32-bit values: 0x80000000 = -2^31, 0xffffffff = -1\n      result = valueA\n    } else {\n      // Gray Paper: unsigned{rtz(a  b)} - round towards zero, result as unsigned\n      const signedResult = signedA / signedB\n      result = i64(signedResult) < i64(0) ? signedResult + (i64(1) << i64(32)) : signedResult\n      // Ensure result is within 32-bit range\n      result = result & i64(0xffffffff)\n    }\n\n    this.setRegisterValueWith32BitResult(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * REM_U_32 instruction (opcode 0xC3 / 195)\n * Gray Paper formula: reg'_D = {sext{4}{reg_A mod 2^32} when reg_B mod 2^32 = 0, sext{4}{(reg_A mod 2^32) mod (reg_B mod 2^32)} otherwise}\n */\nexport class REM_U_32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_REM_U_32\n  name: string = 'REM_U_32'\n\n  execute(context: InstructionContext): InstructionResult {\n\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueA = this.getRegisterValueAs32(context.registers, registerA)\n    const valueB = this.getRegisterValueAs32(context.registers, registerB)\n\n    // Gray Paper: when B = 0, result = sext(4, A mod 2^32)\n    const result = valueB === u64(0) ? valueA : valueA % valueB\n\n    this.setRegisterValueWith32BitResult(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * REM_S_32 instruction (opcode 0xC4 / 196)\n * Gray Paper formula: reg'_D = {0 when a = -2^31  b = -1, unsigned{smod(a, b)} otherwise}\n * where a = signed_4(reg_A mod 2^32), b = signed_4(reg_B mod 2^32)\n */\nexport class REM_S_32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_REM_S_32\n  name: string = 'REM_S_32'\n\n  execute(context: InstructionContext): InstructionResult {\n    // Extract operands from code starting at programCounter + 1\n    const pc = i32(context.programCounter)\n    const operands = context.code.slice(pc + 1, pc + 3)\n    \n    const registerD = this.getRegisterD(operands)\n    const registerA = this.getRegisterIndex(operands[0])\n    const registerB = this.getRegisterB(operands)\n    const valueA = this.getRegisterValueAs32(context.registers, registerA)\n    const valueB = this.getRegisterValueAs32(context.registers, registerB)\n\n    // Convert to signed values (signExtend32 returns u64, but represents sign-extended value)\n    const signedA_u64 = this.signExtend32(valueA)\n    const signedB_u64 = this.signExtend32(valueB)\n    const signedA = i64(signedA_u64)\n    const signedB = i64(signedB_u64)\n\n    // Gray Paper: reg'_D = {0 when a = -2^31  b = -1, unsigned{smod(a, b)} otherwise}\n    let result: i64\n    if (signedA === -(i64(1) << i64(31)) && signedB === i64(-1)) {\n      // Special overflow case: result = 0\n      result = i64(0)\n    } else if (signedB === i64(0)) {\n      // Gray Paper: smod(a, b) = a when b = 0\n      // Convert signed value a to unsigned\n      result = signedA < i64(0) ? signedA + (i64(1) << i64(32)) : signedA\n    } else {\n      // Gray Paper: smod(a, b) = sgn(a)  (|a| mod |b|)\n      // Check if valueA is negative in 32-bit context (MSB set)\n      const isNegativeA = (valueA & i64(0x80000000)) !== i64(0)\n      const isNegativeB = (valueB & i64(0x80000000)) !== i64(0)\n\n      const absA = isNegativeA ? i64(0x100000000) - valueA : valueA\n      const absB = isNegativeB ? i64(0x100000000) - valueB : valueB\n      const signA = isNegativeA ? i64(-1) : i64(1)\n      const modResult = absA % absB\n      const signedResult = signA * modResult\n      // Gray Paper: unsigned{smod(a, b)} - convert signed result to unsigned\n      result = signedResult < i64(0) ? signedResult + (i64(1) << i64(32)) : signedResult\n    }\n    \n    this.setRegisterValueWith32BitResult(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n","import {\n  OPCODE_SHAR_R_32,\n  OPCODE_SHLO_L_32,\n  OPCODE_SHLO_R_32,\n} from '../config'\nimport { InstructionContext, InstructionResult } from '../types'\nimport { BaseInstruction } from './base'\n\n/**\n * SHLO_L_32 instruction (opcode 0x7A)\n * Gray Paper formula: reg'_D = sext{4}{(reg_A  2^(reg_B mod 32)) mod 2^32}\n */\nexport class SHLO_L_32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_SHLO_L_32\n  name: string = 'SHLO_L_32'\n\n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueA = this.getRegisterValueAs32(context.registers, registerA)\n    const valueB = this.getRegisterValueAs32(context.registers, registerB)\n    const shiftAmount = valueB % u64(32)\n    const result = valueA << shiftAmount\n\n    this.setRegisterValueWith32BitResult(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * SHLO_R_32 instruction (opcode 0x7B)\n * Gray Paper formula: reg'_D = sext{4}{floor((reg_A mod 2^32)  2^(reg_B mod 32))}\n */\nexport class SHLO_R_32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_SHLO_R_32\n  name: string = 'SHLO_R_32'\n\n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueA = this.getRegisterValueAs32(context.registers, registerA)\n    const valueB = this.getRegisterValueAs32(context.registers, registerB)\n    const shiftAmount = valueB % u64(32)\n    const result = valueA >> shiftAmount // Unsigned right shift\n\n    this.setRegisterValueWith32BitResult(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * SHAR_R_32 instruction (opcode 0x7C)\n * Gray Paper formula: reg'_D = unsigned{floor(signed_4(reg_A mod 2^32)  2^(reg_B mod 32))}\n */\nexport class SHAR_R_32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_SHAR_R_32\n  name: string = 'SHAR_R_32'\n\n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueA = this.getRegisterValueAs32(context.registers, registerA)\n    const valueB = this.getRegisterValueAs32(context.registers, registerB)\n    const shiftAmount = valueB % u64(32)\n\n    // Convert to signed for arithmetic shift\n    // If valueA > 2^31 - 1, it's negative in signed 32-bit representation\n    const signedValue = valueA > u64(0x7fffffff) ? i64(valueA) - i64(0x100000000) : i64(valueA)\n    const shiftedValue = signedValue >> i64(shiftAmount)\n    const result = shiftedValue < i64(0) ? u64(shiftedValue + i64(0x100000000)) : u64(shiftedValue)\n\n    this.setRegisterValueWith32BitResult(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n","import { OPCODE_ADD_64, OPCODE_DIV_S_64, OPCODE_DIV_U_64, OPCODE_MUL_64, OPCODE_REM_S_64, OPCODE_REM_U_64, OPCODE_SUB_64 } from '../config'\nimport { InstructionContext, InstructionResult } from '../types'\nimport { BaseInstruction } from './base'\n\nexport class ADD_64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_ADD_64\n  name: string = 'ADD_64'\n  \n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueA = this.getRegisterValueAs64(context.registers, registerA)\n    const valueB = this.getRegisterValueAs64(context.registers, registerB)\n    const result = valueA + valueB\n\n    this.setRegisterValueWith64BitResult(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\nexport class SUB_64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_SUB_64\n  name: string = 'SUB_64'\n  \n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueA = this.getRegisterValueAs64(context.registers, registerA)\n    const valueB = this.getRegisterValueAs64(context.registers, registerB)\n    const result = valueA - valueB\n\n    this.setRegisterValueWith64BitResult(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\nexport class MUL_64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_MUL_64\n  name: string = 'MUL_64'\n  \n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueA = this.getRegisterValueAs64(context.registers, registerA)\n    const valueB = this.getRegisterValueAs64(context.registers, registerB)\n    const result = valueA * valueB\n\n    this.setRegisterValueWith64BitResult(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\nexport class DIV_U_64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_DIV_U_64\n  name: string = 'DIV_U_64'\n  \n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueA = this.getRegisterValueAs64(context.registers, registerA)\n    const valueB = this.getRegisterValueAs64(context.registers, registerB)\n\n    // Gray Paper: division by zero results in 2^64 - 1\n    // Use u64 to avoid overflow: 0xFFFFFFFFFFFFFFFF\n    const result = valueB === i64(0) ? i64(u64(0xFFFFFFFFFFFFFFFF)) : valueA / valueB\n\n    this.setRegisterValue(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\nexport class DIV_S_64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_DIV_S_64\n  name: string = 'DIV_S_64'\n  \n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueA = this.getRegisterValueAs64(context.registers, registerA)\n    const valueB = this.getRegisterValueAs64(context.registers, registerB)\n\n    // Convert to signed values\n    const signedA = this.toSigned64(valueA)\n    const signedB = this.toSigned64(valueB)\n\n    // Gray Paper: handle special cases\n    let result: i64\n    if (signedB === i64(0)) {\n      // Division by zero: result = 2^64 - 1\n      // Use u64 to avoid overflow: 0xFFFFFFFFFFFFFFFF\n      result = i64(u64(0xFFFFFFFFFFFFFFFF))\n    } else if (signedA === -(i64(1) << i64(63)) && signedB === i64(-1)) {\n      // Overflow case: result = unsigned(a) = valueA\n      result = valueA\n    } else {\n      // Normal division: round towards zero\n      // Gray Paper: unsigned{rtz(a  b)} - convert signed result to unsigned\n      const signedResult = signedA / signedB\n      // Convert negative result to unsigned: add 2^64\n      // Use u64 arithmetic to avoid overflow: signedResult + 2^64 = signedResult + 0xFFFFFFFFFFFFFFFF + 1\n      if (signedResult < i64(0)) {\n        // For negative values, we need to add 2^64 to get the unsigned representation\n        // Since we can't do i64 + 2^64 directly, we use u64 arithmetic\n        // u64(signedResult) when signedResult is negative gives a large positive (two's complement)\n        // But we want signedResult + 2^64, which is: u64(signedResult) (already includes the 2^64 offset)\n        // Actually, in two's complement, a negative i64 value when viewed as u64 IS the unsigned representation\n        // So we can just cast: u64(signedResult) is correct\n        result = i64(u64(signedResult))\n      } else {\n        result = signedResult\n      }\n    }\n\n    this.setRegisterValue(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\nexport class REM_U_64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_REM_U_64\n  name: string = 'REM_U_64'\n  \n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueA = this.getRegisterValueAs64(context.registers, registerA)\n    const valueB = this.getRegisterValueAs64(context.registers, registerB)\n\n    // Gray Paper: when B = 0, result = A\n    const result = valueB === i64(0) ? valueA : valueA % valueB\n\n    this.setRegisterValue(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\nexport class REM_S_64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_REM_S_64\n  name: string = 'REM_S_64'\n  \n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueA = this.getRegisterValueAs64(context.registers, registerA)\n    const valueB = this.getRegisterValueAs64(context.registers, registerB)\n\n    // Convert to signed values using toSigned64 helper\n    const signedA = this.toSigned64(valueA)\n    const signedB = this.toSigned64(valueB)\n\n    // Gray Paper: smod(a, b) = a when b = 0, or 0 when a = -2^63 and b = -1\n    let result: i64\n    if (signedA === -(i64(1) << i64(63)) && signedB === i64(-1)) {\n      // Special overflow case: result = 0\n      result = i64(0)\n    } else if (signedB === i64(0)) {\n      // Division by zero: result = a (signed modulo definition)\n      result = valueA\n    } else {\n      // Normal case: sgn(a) * (|a| mod |b|)\n      const absA = signedA < i64(0) ? -signedA : signedA\n      const absB = signedB < i64(0) ? -signedB : signedB\n      const sign = signedA < i64(0) ? i64(-1) : i64(1)\n      const signedResult = sign * (absA % absB)\n      // Convert signed result to unsigned using two's complement\n      // Casting negative i64 to u64 automatically adds 2^64\n      result = i64(u64(signedResult))\n    }\n\n    this.setRegisterValue(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n","import {\n  OPCODE_SHAR_R_64,\n  OPCODE_SHLO_L_64,\n  OPCODE_SHLO_R_64,\n} from '../config'\nimport { InstructionContext, InstructionResult } from '../types'\nimport { BaseInstruction } from './base'\n\n/**\n * SHLO_L_64 instruction (opcode 0xCF)\n * Gray Paper formula: reg'_D = (reg_A  2^(reg_B mod 64)) mod 2^64\n */\nexport class SHLO_L_64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_SHLO_L_64\n  name: string = 'SHLO_L_64'\n\n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueA = this.getRegisterValueAs64(context.registers, registerA)\n    const valueB = this.getRegisterValueAs64(context.registers, registerB)\n    const shiftAmount = valueB % u64(64)\n    const result = valueA << shiftAmount\n\n    this.setRegisterValue(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * SHLO_R_64 instruction (opcode 0xD0)\n * Gray Paper formula: reg'_D = floor(reg_A  2^(reg_B mod 64))\n */\nexport class SHLO_R_64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_SHLO_R_64\n  name: string = 'SHLO_R_64'\n\n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueA = this.getRegisterValueAs64(context.registers, registerA)\n    const valueB = this.getRegisterValueAs64(context.registers, registerB)\n    const shiftAmount = valueB % u64(64)\n    const result = valueA >> shiftAmount\n\n    this.setRegisterValueWith64BitResult(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * SHAR_R_64 instruction (opcode 0xD1)\n * Gray Paper formula: reg'_D = unsigned{floor(signed(reg_A)  2^(reg_B mod 64))}\n */\nexport class SHAR_R_64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_SHAR_R_64\n  name: string = 'SHAR_R_64'\n\n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueA = this.getRegisterValueAs64(context.registers, registerA)\n    const valueB = this.getRegisterValueAs64(context.registers, registerB)\n    const shiftAmount = valueB % u64(64)\n\n    // Convert to signed for arithmetic shift\n    const signedValue = this.toSigned64(valueA)\n    const shiftedValue = signedValue >> i64(shiftAmount)\n    const result = u64(this.toUnsigned64(shiftedValue))\n\n    this.setRegisterValueWith64BitResult(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n","import { OPCODE_AND, OPCODE_OR, OPCODE_XOR } from '../config'\nimport { InstructionContext, InstructionResult } from '../types'\nimport { BaseInstruction } from './base'\n\nexport class ANDInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_AND\n  name: string = 'AND'\n\n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands) // From operands[1]\n    const registerA = this.getRegisterA(context.operands) // From operands[0] low nibble\n    const registerB = this.getRegisterB(context.operands) // From operands[0] high nibble\n    const valueA = this.getRegisterValueAs64(context.registers, registerA)\n    const valueB = this.getRegisterValueAs64(context.registers, registerB)\n    const result = valueA & valueB\n\n    this.setRegisterValueWith64BitResult(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n\n  disassemble(operands: Uint8Array): string {\n    const registerD = this.getRegisterD(operands)\n    const registerA = this.getRegisterIndex(operands[0])\n    const registerB = this.getRegisterB(operands)\n    return this.name + ' r' + registerD.toString() + ' r' + registerA.toString() + ' r' + registerB.toString()\n  }\n}\n\n/**\n * XOR instruction (opcode 0xD3 / 211)\n * Bitwise XOR of two registers\n *\n * Gray Paper pvm.tex 7.4.10 line 211:\n * i  Nmax{64} : bits{reg'_D}_i = bits{reg_A}_i  bits{reg_B}_i\n *\n * Operand format (lines 591-603):\n * - operands[0]: r_D\n * - operands[1]: r_A (low 4 bits) + r_B (high 4 bits)\n */\nexport class XORInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_XOR\n  name: string = 'XOR'\n\n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands) // From operands[1]\n    const registerA = this.getRegisterA(context.operands) // From operands[0] low nibble\n    const registerB = this.getRegisterB(context.operands) // From operands[0] high nibble\n    const valueA = this.getRegisterValueAs64(context.registers, registerA)\n    const valueB = this.getRegisterValueAs64(context.registers, registerB)\n    const result = valueA ^ valueB\n\n    this.setRegisterValueWith64BitResult(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * OR instruction (opcode 0xD4 / 212)\n * Bitwise OR of two registers\n *\n * Gray Paper pvm.tex 7.4.10 line 212:\n * i  Nmax{64} : bits{reg'_D}_i = bits{reg_A}_i  bits{reg_B}_i\n *\n * Operand format (lines 590-603): \"Three Registers\" format\n * - operands[0]: r_A (low 4 bits) + r_B (high 4 bits)\n * - operands[1]: r_D\n */\nexport class ORInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_OR\n  name: string = 'OR'\n\n  execute(context: InstructionContext): InstructionResult {\n    // Extract operands from code starting at programCounter + 1\n    // Format for three-register instructions: operands[0] = (B << 4) | A, operands[1] = D\n    const pc = i32(context.programCounter)\n    const operands = context.code.slice(pc + 1, pc + 3) // Get operand bytes\n    \n    // Gray Paper: Three Registers format\n    // r_A = min(12, (instructions[+1]) mod 16) - from low nibble of operands[0]\n    // r_B = min(12, instructions[+1]/16) - from high nibble of operands[0]\n    // r_D = min(12, instructions[+2]) - from operands[1]\n    const registerD = this.getRegisterD(operands)\n    const registerA = this.getRegisterIndex(operands[0])\n    const registerB = this.getRegisterB(operands)\n    const valueA = this.getRegisterValueAs64(context.registers, registerA)\n    const valueB = this.getRegisterValueAs64(context.registers, registerB)\n    \n    // Gray Paper: i  Nmax{64} : bits{reg'_D}_i = bits{reg_A}_i  bits{reg_B}_i\n    const result = valueA | valueB\n\n    this.setRegisterValueWith64BitResult(context.registers, registerD, result)\n    return new InstructionResult(-1)\n  }\n}\n","import {\n  OPCODE_MUL_UPPER_S_S,\n  OPCODE_MUL_UPPER_S_U,\n  OPCODE_MUL_UPPER_U_U,\n} from '../config'\nimport { InstructionContext, InstructionResult } from '../types'\nimport { BaseInstruction } from './base'\n\nexport class MUL_UPPER_S_SInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_MUL_UPPER_S_S\n  name: string = 'MUL_UPPER_S_S'\n\n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueA = this.getRegisterValue(context.registers, registerA)\n    const valueB = this.getRegisterValue(context.registers, registerB)\n\n    // Gray Paper: reg'_D = unsigned(floor((signed(reg_A) * signed(reg_B)) / 2^64))\n    // Convert to signed 64-bit values\n    const signedA = i64(valueA)\n    const signedB = i64(valueB)\n\n    // Split into 32-bit parts with proper sign extension\n    // For signed numbers: value = (sign-extended high 32 bits) * 2^32 + (low 32 bits)\n    const aLo = u64(signedA) & u64(0xffffffff)\n    const aHiSigned = i64(signedA >> 32)  // Arithmetic right shift preserves sign\n    const bLo = u64(signedB) & u64(0xffffffff)\n    const bHiSigned = i64(signedB >> 32)  // Arithmetic right shift preserves sign\n\n    // For signed multiplication, we need to handle the cross terms correctly\n    // aHi * bLo and aLo * bHi need to account for sign\n    // Convert to signed 32-bit for proper sign handling\n    const aHi32 = i32(aHiSigned)\n    const bHi32 = i32(bHiSigned)\n    \n    // Compute cross terms as signed multiplications, then convert to unsigned\n    // aHi * bLo: if aHi is negative (0xFFFFFFFF = -1), this should be negative\n    const aHi_bLo_signed = i64(aHi32) * i64(bLo)\n    const aLo_bHi_signed = i64(aLo) * i64(bHi32)\n    \n    // Convert to unsigned for bit manipulation (two's complement)\n    const aHi_bLo = u64(aHi_bLo_signed)\n    const aLo_bHi = u64(aLo_bHi_signed)\n\n    // Low 32x32 multiplication (always unsigned)\n    const aLo_bLo = aLo * bLo\n    const carryFromLow = aLo_bLo >> 32\n    \n    // Split cross terms into high and low 32-bit parts\n    const aHi_bLo_hi = aHi_bLo >> 32\n    const aHi_bLo_lo = aHi_bLo & u64(0xffffffff)\n    const aLo_bHi_hi = aLo_bHi >> 32\n    const aLo_bHi_lo = aLo_bHi & u64(0xffffffff)\n    \n    // Add low parts with carry (all unsigned now, but may be negative in signed interpretation)\n    const lowSum = aHi_bLo_lo + aLo_bHi_lo + carryFromLow\n    const lowSumCarry = lowSum >> 32\n    \n    // Add high parts with carry\n    // For signed arithmetic, we need to interpret the high parts as signed\n    // aHi_bLo_hi and aLo_bHi_hi are the high 32 bits of signed products,\n    // so they should be interpreted as signed when >= 2^31\n    // Convert unsigned high 32 bits to signed: if >= 0x80000000, it's negative\n    const aHi_bLo_hi_signed = i64(aHi_bLo_hi >= u64(0x80000000) ? aHi_bLo_hi - u64(0x100000000) : aHi_bLo_hi)\n    const aLo_bHi_hi_signed = i64(aLo_bHi_hi >= u64(0x80000000) ? aLo_bHi_hi - u64(0x100000000) : aLo_bHi_hi)\n    \n    // Compute middle term sum as signed\n    // lowSumCarry is always positive (0 or 1), so convert to signed\n    const middleSumSigned = aHi_bLo_hi_signed + aLo_bHi_hi_signed + i64(lowSumCarry)\n    \n    // High 32x32 multiplication (signed)\n    const signedAHi = aHiSigned\n    const signedBHi = bHiSigned\n    \n    // Upper 64 bits of signed product: aHi*bHi (signed) + middleSumSigned (signed)\n    const upperBits = signedAHi * signedBHi + middleSumSigned\n\n    // Convert back to unsigned representation\n    const result = u64(upperBits)\n\n    this.setRegisterValue(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\nexport class MUL_UPPER_U_UInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_MUL_UPPER_U_U\n  name: string = 'MUL_UPPER_U_U'\n\n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueA = this.getRegisterValue(context.registers, registerA)\n    const valueB = this.getRegisterValue(context.registers, registerB)\n\n    // Gray Paper: reg'_D = floor((reg_A * reg_B) / 2^64)\n    // Split into 32-bit parts: value = hi * 2^32 + lo\n    const aLo = valueA & u64(0xffffffff)\n    const aHi = valueA >> 32\n    const bLo = valueB & u64(0xffffffff)\n    const bHi = valueB >> 32\n\n    // Compute 128-bit product: (aHi*2^32 + aLo) * (bHi*2^32 + bLo)\n    // = aHi*bHi*2^64 + (aHi*bLo + aLo*bHi)*2^32 + aLo*bLo\n    // Upper 64 bits = aHi*bHi + ((aHi*bLo + aLo*bHi + (aLo*bLo >> 32)) >> 32)\n    \n    // To avoid overflow in the intermediate sum, compute in parts:\n    // 1. Compute aLo * bLo and extract the carry (high 32 bits)\n    const aLo_bLo = aLo * bLo\n    const carryFromLow = aLo_bLo >> 32\n    \n    // 2. Compute aHi * bLo and aLo * bHi, split into high and low 32-bit parts\n    const aHi_bLo = aHi * bLo\n    const aLo_bHi = aLo * bHi\n    \n    // Extract high and low 32-bit parts of each product\n    const aHi_bLo_hi = aHi_bLo >> 32\n    const aHi_bLo_lo = aHi_bLo & u64(0xffffffff)\n    const aLo_bHi_hi = aLo_bHi >> 32\n    const aLo_bHi_lo = aLo_bHi & u64(0xffffffff)\n\n    // 3. Add the low parts together with carryFromLow (this sum fits in 34 bits, safe in u64)\n    const lowSum = aHi_bLo_lo + aLo_bHi_lo + carryFromLow\n    const lowSumCarry = lowSum >> 32\n\n    // 4. Add the high parts together with the carry from low sum (fits in u64)\n    const middleHigh = aHi_bLo_hi + aLo_bHi_hi + lowSumCarry\n    \n    // 5. Final result: aHi*bHi + middleHigh\n    const result = aHi * bHi + middleHigh\n\n    this.setRegisterValue(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\nexport class MUL_UPPER_S_UInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_MUL_UPPER_S_U\n  name: string = 'MUL_UPPER_S_U'\n\n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueA = this.getRegisterValue(context.registers, registerA)\n    const valueB = this.getRegisterValue(context.registers, registerB)\n\n    // Gray Paper: reg'_D = unsigned(floor((signed(reg_A) * reg_B) / 2^64))\n    // Convert first operand to signed, keep second as unsigned\n    const signedA = i64(valueA)\n    const unsignedB = valueB\n\n    // Split into 32-bit parts\n    const aLo = u64(signedA) & u64(0xffffffff)\n    // Extract high 32 bits and sign-extend to 64 bits\n    const aHiSigned = i64(signedA >> 32)  // High 32 bits as signed (sign-extended)\n    const aHi = u64(aHiSigned)  // For unsigned operations, but we'll convert back to signed when needed\n    const bLo = unsignedB & u64(0xffffffff)\n    const bHi = unsignedB >> 32\n\n    // Compute 128-bit product: (aHi*2^32 + aLo) * (bHi*2^32 + bLo)\n    // For signed-unsigned multiplication:\n    // - aHi is signed (sign-extended 32-bit value)\n    // - aLo is unsigned (low 32 bits)\n    // - bHi and bLo are both unsigned\n    \n    // Low 32x32 multiplication (unsigned)\n    const aLo_bLo = aLo * bLo\n    const carryFromLow = aLo_bLo >> 32\n    \n    // Cross terms: aHi*bLo (signed * unsigned = signed) and aLo*bHi (unsigned * unsigned = unsigned)\n    // We need to compute aHi*bLo as signed multiplication\n    const aHi_bLo_signed = aHiSigned * i64(bLo)\n    const aLo_bHi = aLo * bHi\n    \n    // Split aHi_bLo into high and low 32-bit parts (treating as signed)\n    const aHi_bLo_hi_signed = i64(aHi_bLo_signed >> 32)\n    const aHi_bLo_lo = u64(aHi_bLo_signed) & u64(0xffffffff)\n\n    // Split aLo_bHi into high and low 32-bit parts (unsigned)\n    const aLo_bHi_hi = aLo_bHi >> 32\n    const aLo_bHi_lo = aLo_bHi & u64(0xffffffff)\n    \n    // Add low parts with carry\n    const lowSum = aHi_bLo_lo + aLo_bHi_lo + carryFromLow\n    const lowSumCarry = lowSum >> 32\n    \n    // Add high parts with carry\n    // aHi_bLo_hi is signed, aLo_bHi_hi is unsigned, lowSumCarry is unsigned (0 or 1)\n    const middleHigh = aHi_bLo_hi_signed + i64(aLo_bHi_hi) + i64(lowSumCarry)\n\n    // High 32x32 multiplication: aHi (signed) * bHi (unsigned) = signed\n    const signedAHi = aHiSigned\n    const unsignedBHi = bHi\n\n    // Upper 64 bits of signed-unsigned product\n    const upperBits = signedAHi * i64(unsignedBHi) + middleHigh\n\n    // Convert back to unsigned representation\n    const result = u64(upperBits)\n\n    this.setRegisterValue(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n","import { OPCODE_SET_LT_S, OPCODE_SET_LT_U } from '../config'\nimport { InstructionContext, InstructionResult } from '../types'\nimport { BaseInstruction } from './base'\n\nexport class SET_LT_UInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_SET_LT_U\n  name: string = 'SET_LT_U'\n\n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueA = this.getRegisterValueAs64(context.registers, registerA)\n    const valueB = this.getRegisterValueAs64(context.registers, registerB)\n    const result = valueA < valueB ? i64(1) : i64(0)\n\n    this.setRegisterValueWith64BitResult(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n\n  disassemble(operands: Uint8Array): string {\n    const registerD = this.getRegisterD(operands)\n    const registerA = this.getRegisterA(operands)\n    const registerB = this.getRegisterB(operands)\n    return this.name + ' r' + registerD.toString() + ' r' + registerA.toString() + ' r' + registerB.toString()\n  }\n}\n\nexport class SET_LT_SInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_SET_LT_S\n  name: string = 'SET_LT_S'\n\n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueA = this.getRegisterValueAs64(context.registers, registerA)\n    const valueB = this.getRegisterValueAs64(context.registers, registerB)\n\n    // Use signedCompare helper for proper signed comparison\n    const result = this.signedCompare(valueA, valueB) < 0 ? i64(1) : i64(0)\n\n    this.setRegisterValueWith64BitResult(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n\n  disassemble(operands: Uint8Array): string {\n    const registerD = this.getRegisterD(operands)\n    const registerA = this.getRegisterA(operands)\n    const registerB = this.getRegisterB(operands)\n    return this.name + ' r' + registerD.toString() + ' r' + registerA.toString() + ' r' + registerB.toString()\n  }\n}\n","import { OPCODE_CMOV_IZ, OPCODE_CMOV_NZ } from '../config'\nimport { InstructionContext, InstructionResult } from '../types'\nimport { BaseInstruction } from './base'\n\nexport class CMOV_IZInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_CMOV_IZ\n  name: string = 'CMOV_IZ'\n\n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueB = this.getRegisterValue(context.registers, registerB)\n\n    // Gray Paper: reg'_D = { reg_A when reg_B = 0, reg_D otherwise }\n    const result =\n      valueB === i64(0)\n        ? this.getRegisterValue(context.registers, registerA)\n        : this.getRegisterValue(context.registers, registerD)\n\n    this.setRegisterValue(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n\n  disassemble(operands: Uint8Array): string {\n    const registerD = this.getRegisterD(operands)\n    const registerA = this.getRegisterA(operands)\n    const registerB = this.getRegisterB(operands)\n    return this.name + ' r' + registerD.toString() + ' r' + registerA.toString() + ' r' + registerB.toString()\n  }\n}\n\nexport class CMOV_NZInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_CMOV_NZ\n  name: string = 'CMOV_NZ'\n\n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueB = this.getRegisterValue(context.registers, registerB)\n\n    // Gray Paper: reg'_D = { reg_A when reg_B  0, reg_D otherwise }\n    const result =\n      valueB !== i64(0)\n        ? this.getRegisterValue(context.registers, registerA)\n        : this.getRegisterValue(context.registers, registerD)\n\n    this.setRegisterValue(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n\n  disassemble(operands: Uint8Array): string {\n    const registerD = this.getRegisterD(operands)\n    const registerA = this.getRegisterA(operands)\n    const registerB = this.getRegisterB(operands)\n    return this.name + ' r' + registerD.toString() + ' r' + registerA.toString() + ' r' + registerB.toString()\n  }\n}\n","import {\n  OPCODE_ROT_L_32,\n  OPCODE_ROT_L_64,\n  OPCODE_ROT_R_32,\n  OPCODE_ROT_R_64,\n} from '../config'\nimport { InstructionContext, InstructionResult } from '../types'\nimport { BaseInstruction } from './base'\n\nexport class ROT_L_64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_ROT_L_64\n  name: string = 'ROT_L_64'\n\n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueA = this.getRegisterValue(context.registers, registerA)\n    const rotationAmount = i32(\n      this.getRegisterValue(context.registers, registerB) % u64(64),\n    )\n    const result = this.rotateLeft64(valueA, rotationAmount)\n\n    this.setRegisterValue(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n\n  rotateLeft64(value: u64, amount: i32): u64 {\n    // Handle negative rotation amounts\n    let normalizedAmount = amount\n    if (amount < 0) {\n      normalizedAmount = 64 + amount\n    }\n\n    // Normalize amount to 0-63 range\n    normalizedAmount = normalizedAmount % 64\n\n    if (normalizedAmount === 0) return value\n\n    // Perform left rotation\n    const mask = u64(0xffffffffffffffff)\n    const leftPart = (value << u64(normalizedAmount)) & mask\n    const rightPart = value >> u64(64 - normalizedAmount)\n    return (leftPart | rightPart) & mask\n  }\n}\n\n/**\n * ROT_L_32 instruction (opcode 0xDD / 221)\n * Gray Paper pvm.tex line 678:\n * reg'_D = sext{4}{x} where x  Nbits{32}, i  Nmax{32} : bitsfunc{4}(x)_{(i + reg_B) mod 32} = bitsfunc{4}(reg_A)_i\n *\n * Rotates the lower 32 bits of reg_A left by reg_B positions, then sign-extends to 64 bits.\n */\nexport class ROT_L_32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_ROT_L_32\n  name: string = 'ROT_L_32'\n\n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueA =\n      this.getRegisterValue(context.registers, registerA) & u64(0xffffffff)\n    const rotationAmount = i32(\n      this.getRegisterValue(context.registers, registerB) % u64(32),\n    )\n    const result = this.rotateLeft32(valueA, rotationAmount)\n\n    // Gray Paper: reg'_D = sext{4}{x} - sign-extend 32-bit result to 64 bits\n    this.setRegisterValueWith32BitResult(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n\n  rotateLeft32(value: u64, amount: i32): u64 {\n    // Handle negative rotation amounts\n    let normalizedAmount = amount\n    if (amount < 0) {\n      normalizedAmount = 32 + amount\n    }\n\n    // Normalize amount to 0-31 range\n    normalizedAmount = normalizedAmount % 32\n\n    if (normalizedAmount === 0) return value\n\n    // Perform left rotation\n    const mask = u64(0xffffffff)\n    const leftPart = (value << u64(normalizedAmount)) & mask\n    const rightPart = value >> u64(32 - normalizedAmount)\n    return (leftPart | rightPart) & mask\n  }\n}\n\nexport class ROT_R_64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_ROT_R_64\n  name: string = 'ROT_R_64'\n\n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueA = this.getRegisterValue(context.registers, registerA)\n    const rotationAmount = i32(\n      this.getRegisterValue(context.registers, registerB) % u64(64),\n    )\n    const result = this.rotateRight64(valueA, rotationAmount)\n\n    this.setRegisterValue(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n\n  rotateRight64(value: u64, amount: i32): u64 {\n    // Handle negative rotation amounts\n    let normalizedAmount = amount\n    if (amount < 0) {\n      normalizedAmount = 64 + amount\n    }\n\n    // Normalize amount to 0-63 range\n    normalizedAmount = normalizedAmount % 64\n\n    if (normalizedAmount === 0) return value\n\n    // Perform right rotation\n    const mask = u64(0xffffffffffffffff)\n    const rightPart = value >> u64(normalizedAmount)\n    const leftPart = (value << u64(64 - normalizedAmount)) & mask\n    return (rightPart | leftPart) & mask\n  }\n}\n\n/**\n * ROT_R_32 instruction (opcode 0xDF / 223)\n * Gray Paper pvm.tex line 680:\n * reg'_D = sext{4}{x} where x  Nbits{32}, i  Nmax{32} : bitsfunc{4}(x)_i = bitsfunc{4}(reg_A)_{(i + reg_B) mod 32}\n *\n * Rotates the lower 32 bits of reg_A right by reg_B positions, then sign-extends to 64 bits.\n */\nexport class ROT_R_32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_ROT_R_32\n  name: string = 'ROT_R_32'\n\n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueA =\n      this.getRegisterValue(context.registers, registerA) & u64(0xffffffff)\n    const rotationAmount = i32(\n      this.getRegisterValue(context.registers, registerB) % u64(32),\n    )\n    const result = this.rotateRight32(valueA, rotationAmount)\n\n    // Gray Paper: reg'_D = sext{4}{x} - sign-extend 32-bit result to 64 bits\n    this.setRegisterValueWith32BitResult(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n\n  rotateRight32(value: u64, amount: i32): u64 {\n    // Handle negative rotation amounts\n    let normalizedAmount = amount\n    if (amount < 0) {\n      normalizedAmount = 32 + amount\n    }\n\n    // Normalize amount to 0-31 range\n    normalizedAmount = normalizedAmount % 32\n\n    if (normalizedAmount === 0) return value\n\n    // Perform right rotation\n    const mask = u64(0xffffffff)\n    const rightPart = value >> u64(normalizedAmount)\n    const leftPart = (value << u64(32 - normalizedAmount)) & mask\n    return (rightPart | leftPart) & mask\n  }\n}\n","import { OPCODE_AND_INV, OPCODE_OR_INV, OPCODE_XNOR } from '../config'\nimport { InstructionContext, InstructionResult } from '../types'\nimport { BaseInstruction } from './base'\n\nexport class AND_INVInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_AND_INV\n  name: string = 'AND_INV'\n  \n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands) // From operands[1]\n    const registerA = this.getRegisterA(context.operands) // From operands[0] low nibble\n    const registerB = this.getRegisterB(context.operands) // From operands[0] high nibble\n    const valueA = this.getRegisterValueAs64(context.registers, registerA)\n    const valueB = this.getRegisterValueAs64(context.registers, registerB)\n    const result = valueA & ~valueB\n\n    this.setRegisterValueWith64BitResult(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\nexport class OR_INVInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_OR_INV\n  name: string = 'OR_INV'\n\n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands) // From operands[1]\n    const registerA = this.getRegisterA(context.operands) // From operands[0] low nibble\n    const registerB = this.getRegisterB(context.operands) // From operands[0] high nibble\n    const valueA = this.getRegisterValueAs64(context.registers, registerA)\n    const valueB = this.getRegisterValueAs64(context.registers, registerB)\n    const result = valueA | ~valueB\n\n    this.setRegisterValueWith64BitResult(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\nexport class XNORInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_XNOR\n  name: string = 'XNOR'\n\n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands) // From operands[1]\n    const registerA = this.getRegisterA(context.operands) // From operands[0] low nibble\n    const registerB = this.getRegisterB(context.operands) // From operands[0] high nibble\n    const valueA = this.getRegisterValueAs64(context.registers, registerA)\n    const valueB = this.getRegisterValueAs64(context.registers, registerB)\n    const result = ~(valueA ^ valueB)\n\n    this.setRegisterValueWith64BitResult(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n","import {\n  OPCODE_MAX,\n  OPCODE_MAX_U,\n  OPCODE_MIN,\n  OPCODE_MIN_U,\n} from '../config'\nimport { InstructionContext, InstructionResult } from '../types'\nimport { BaseInstruction } from './base'\n\nexport class MINInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_MIN\n  name: string = 'MIN'\n\n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueA = this.getRegisterValue(context.registers, registerA)\n    const valueB = this.getRegisterValue(context.registers, registerB)\n\n    // Convert to signed values for comparison\n    const signedA = this.toSigned64(valueA)\n    const signedB = this.toSigned64(valueB)\n    const result = i64(signedA) < i64(signedB) ? valueA : valueB\n\n    this.setRegisterValue(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\nexport class MIN_UInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_MIN_U\n  name: string = 'MIN_U'\n\n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueA = this.getRegisterValue(context.registers, registerA)\n    const valueB = this.getRegisterValue(context.registers, registerB)\n    const result = valueA < valueB ? valueA : valueB\n\n    this.setRegisterValue(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\nexport class MAXInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_MAX\n  name: string = 'MAX'\n\n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueA = this.getRegisterValue(context.registers, registerA)\n    const valueB = this.getRegisterValue(context.registers, registerB)\n\n    // Convert to signed values for comparison\n    const signedA = this.toSigned64(valueA)\n    const signedB = this.toSigned64(valueB)\n    const result = i64(signedA) > i64(signedB) ? valueA : valueB\n\n    this.setRegisterValue(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\nexport class MAX_UInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_MAX_U\n  name: string = 'MAX_U'\n\n  execute(context: InstructionContext): InstructionResult {\n    const registerD = this.getRegisterD(context.operands)\n    const registerA = this.getRegisterA(context.operands)\n    const registerB = this.getRegisterB(context.operands)\n    const valueA = this.getRegisterValue(context.registers, registerA)\n    const valueB = this.getRegisterValue(context.registers, registerB)\n    const result = valueA > valueB ? valueA : valueB\n\n    this.setRegisterValue(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n","/**\n * Register Operations Instructions\n *\n * MOVE_REG, SBRK, and bit manipulation instructions\n */\n\nimport { alignToPage } from '../alignment-helpers'\nimport {\n  MAX_MEMORY_ADDRESS,\n  OPCODE_COUNT_SET_BITS_32,\n  OPCODE_COUNT_SET_BITS_64,\n  OPCODE_LEADING_ZERO_BITS_32,\n  OPCODE_LEADING_ZERO_BITS_64,\n  OPCODE_MOVE_REG,\n  OPCODE_REVERSE_BYTES,\n  OPCODE_SBRK,\n  OPCODE_SIGN_EXTEND_8,\n  OPCODE_SIGN_EXTEND_16,\n  OPCODE_TRAILING_ZERO_BITS_32,\n  OPCODE_TRAILING_ZERO_BITS_64,\n  OPCODE_ZERO_EXTEND_16,\n  PAGE_SIZE,\n} from '../config'\nimport { InstructionContext, InstructionResult } from '../types'\nimport { BaseInstruction } from './base'\n\n/**\n * MOVE_REG instruction (opcode 0x100)\n * Move register value as specified in Gray Paper\n * Gray Paper formula: reg'_D = reg_A\n */\nexport class MOVE_REGInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_MOVE_REG\n  name: string = 'MOVE_REG'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegisters(context.operands)\n    const registerD = parseResult.registerD\n    const registerA = parseResult.registerA\n    const value = this.getRegisterValue(context.registers, registerA)\n\n    this.setRegisterValue(context.registers, registerD, value)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * SBRK instruction (opcode 0x101)\n * Allocate memory as specified in Gray Paper\n * Gray Paper formula: reg'_D  min(x  pvmreg): x  h  Nrange{x}{reg_A}  readable{memory}  Nrange{x}{reg_A}  writable{memory'}\n *\n * Implementation follows Go reference from jam-test-vectors/traces/README.md\n */\nexport class SBRKInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_SBRK\n  name: string = 'SBRK'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegisters(context.operands)\n    const registerD = parseResult.registerD\n    const registerA = parseResult.registerA\n    const valueA = this.getRegisterValue(context.registers, registerA)\n\n    const ram = context.ram\n    const currentHeapPointer = u64(ram.currentHeapPointer)\n\n    // Go implementation: if valueA == 0, return current heap pointer\n    if (valueA === u64(0)) {\n      this.setRegisterValue(context.registers, registerD, currentHeapPointer)\n      return new InstructionResult(-1)\n    }\n\n    // Record current heap pointer to return (before allocation)\n    const result = currentHeapPointer\n\n    const nextPageBoundary = alignToPage(ram.currentHeapPointer)\n    const newHeapPointer: u32 = ram.currentHeapPointer + u32(valueA)\n\n    if (newHeapPointer > MAX_MEMORY_ADDRESS) {\n      this.setRegisterValue(context.registers, registerD, u64(0))\n      return new InstructionResult(-1)\n    }\n\n    // If new heap pointer exceeds next page boundary, allocate pages\n    if (newHeapPointer > nextPageBoundary) {\n      const finalBoundary = alignToPage(newHeapPointer)\n      const idxStart = nextPageBoundary / PAGE_SIZE\n      const idxEnd = finalBoundary / PAGE_SIZE\n      const pageCount = idxEnd - idxStart\n\n      ram.allocatePages(idxStart, pageCount)\n    }\n\n    // Advance the heap\n    ram.currentHeapPointer = newHeapPointer\n\n    // Return the previous heap pointer (before allocation)\n    this.setRegisterValue(context.registers, registerD, result)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * COUNT_SET_BITS_64 instruction (opcode 0x102)\n * Count set bits in 64-bit register as specified in Gray Paper\n * Gray Paper formula: reg'_D = (i=0 to 63) bitsfunc{8}(reg_A)[i]\n */\nexport class COUNT_SET_BITS_64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_COUNT_SET_BITS_64\n  name: string = 'COUNT_SET_BITS_64'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegisters(context.operands)\n    const registerD = parseResult.registerD\n    const registerA = parseResult.registerA\n    const value = this.getRegisterValue(context.registers, registerA)\n\n    // Count set bits using bit manipulation\n    let count: u64 = u64(0)\n    let temp = value\n    while (temp !== u64(0)) {\n      count += temp & u64(1)\n      temp = temp >> u64(1)\n    }\n\n    this.setRegisterValue(context.registers, registerD, count)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * COUNT_SET_BITS_32 instruction (opcode 0x103)\n * Count set bits in 32-bit register as specified in Gray Paper\n * Gray Paper formula: reg'_D = (i=0 to 31) bitsfunc{4}(reg_A mod 2^32)[i]\n */\nexport class COUNT_SET_BITS_32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_COUNT_SET_BITS_32\n  name: string = 'COUNT_SET_BITS_32'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegisters(context.operands)\n    const registerD = parseResult.registerD\n    const registerA = parseResult.registerA\n    const value = this.getRegisterValue(context.registers, registerA) & u64(0xffffffff)\n\n    // Count set bits using bit manipulation\n    let count: u64 = u64(0)\n    let temp = value\n    while (temp !== u64(0)) {\n      count += temp & u64(1)\n      temp = temp >> u64(1)\n    }\n\n    this.setRegisterValue(context.registers, registerD, count)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * LEADING_ZERO_BITS_64 instruction (opcode 0x104)\n * Count leading zero bits in 64-bit register as specified in Gray Paper\n * Gray Paper formula: reg'_D = max(n  Nmax{65}) where (i=0 to i<n) revbitsfunc{8}(reg_A)[i] = 0\n */\nexport class LEADING_ZERO_BITS_64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_LEADING_ZERO_BITS_64\n  name: string = 'LEADING_ZERO_BITS_64'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegisters(context.operands)\n    const registerD = parseResult.registerD\n    const registerA = parseResult.registerA\n    const value = this.getRegisterValue(context.registers, registerA)\n\n    // Count leading zeros\n    let count: u64 = u64(0)\n    const temp = value\n    for (let i: i32 = 63; i >= 0; i--) {\n      if ((temp & (u64(1) << u64(i))) === u64(0)) {\n        count++\n      } else {\n        break\n      }\n    }\n\n    this.setRegisterValue(context.registers, registerD, count)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * LEADING_ZERO_BITS_32 instruction (opcode 0x105)\n * Count leading zero bits in 32-bit register as specified in Gray Paper\n * Gray Paper formula: reg'_D = max(n  Nmax{33}) where (i=0 to i<n) revbitsfunc{4}(reg_A mod 2^32)[i] = 0\n */\nexport class LEADING_ZERO_BITS_32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_LEADING_ZERO_BITS_32\n  name: string = 'LEADING_ZERO_BITS_32'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegisters(context.operands)\n    const registerD = parseResult.registerD\n    const registerA = parseResult.registerA\n    const value = this.getRegisterValue(context.registers, registerA) & u64(0xffffffff)\n\n    // Count leading zeros\n    let count: u64 = u64(0)\n    const temp = value\n    for (let i: i32 = 31; i >= 0; i--) {\n      if ((temp & (u64(1) << u64(i))) === u64(0)) {\n        count++\n      } else {\n        break\n      }\n    }\n\n    this.setRegisterValue(context.registers, registerD, count)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * TRAILING_ZERO_BITS_64 instruction (opcode 0x106)\n * Count trailing zero bits in 64-bit register as specified in Gray Paper\n * Gray Paper formula: reg'_D = max(n  Nmax{65}) where (i=0 to i<n) bitsfunc{8}(reg_A)[i] = 0\n */\nexport class TRAILING_ZERO_BITS_64Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_TRAILING_ZERO_BITS_64\n  name: string = 'TRAILING_ZERO_BITS_64'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegisters(context.operands)\n    const registerD = parseResult.registerD\n    const registerA = parseResult.registerA\n    const value = this.getRegisterValue(context.registers, registerA)\n\n    // Count trailing zeros\n    let count: u64 = u64(0)\n    const temp = value\n    for (let i: i32 = 0; i < 64; i++) {\n      if ((temp & (u64(1) << u64(i))) === u64(0)) {\n        count++\n      } else {\n        break\n      }\n    }\n\n    this.setRegisterValue(context.registers, registerD, count)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * TRAILING_ZERO_BITS_32 instruction (opcode 0x107)\n * Count trailing zero bits in 32-bit register as specified in Gray Paper\n * Gray Paper formula: reg'_D = max(n  Nmax{33}) where (i=0 to i<n) bitsfunc{4}(reg_A mod 2^32)[i] = 0\n */\nexport class TRAILING_ZERO_BITS_32Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_TRAILING_ZERO_BITS_32\n  name: string = 'TRAILING_ZERO_BITS_32'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegisters(context.operands)\n    const registerD = parseResult.registerD\n    const registerA = parseResult.registerA\n    const value = this.getRegisterValue(context.registers, registerA) & u64(0xffffffff)\n\n    // Count trailing zeros\n    let count: u64 = u64(0)\n    const temp = value\n    for (let i: i32 = 0; i < 32; i++) {\n      if ((temp & (u64(1) << u64(i))) === u64(0)) {\n        count++\n      } else {\n        break\n      }\n    }\n\n    this.setRegisterValue(context.registers, registerD, count)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * SIGN_EXTEND_8 instruction (opcode 0x108)\n * Sign extend 8-bit value as specified in Gray Paper\n * Gray Paper formula: reg'_D = unsigned{signedn{1}{reg_A mod 2^8}}\n */\nexport class SIGN_EXTEND_8Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_SIGN_EXTEND_8\n  name: string = 'SIGN_EXTEND_8'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegisters(context.operands)\n    const registerD = parseResult.registerD\n    const registerA = parseResult.registerA\n    const value = this.getRegisterValue(context.registers, registerA) & u64(0xff)\n\n    // Gray Paper: reg'_D = unsigned{signedn{1}{reg_A mod 2^8}}\n    // signedn{1}(x) = signfunc{1}(x) = x if x < 128, else x - 256\n    // unsigned{} converts signed value back to unsigned 64-bit\n    // This is equivalent to bitwise sign extension\n    const signBit = value & u64(0x80)\n    const extendedValue = signBit !== u64(0) ? value | u64(0xffffffffffffff00) : value\n\n    this.setRegisterValue(context.registers, registerD, extendedValue)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * SIGN_EXTEND_16 instruction (opcode 0x109)\n * Sign extend 16-bit value as specified in Gray Paper\n * Gray Paper formula: reg'_D = unsigned{signedn{2}{reg_A mod 2^16}}\n */\nexport class SIGN_EXTEND_16Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_SIGN_EXTEND_16\n  name: string = 'SIGN_EXTEND_16'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegisters(context.operands)\n    const registerD = parseResult.registerD\n    const registerA = parseResult.registerA\n    const value = this.getRegisterValue(context.registers, registerA) & u64(0xffff)\n\n    // Gray Paper: reg'_D = unsigned{signedn{2}{reg_A mod 2^16}}\n    // signedn{2}(x) = signfunc{2}(x) = x if x < 0x8000, else x - 0x10000\n    // unsigned{} converts signed value back to unsigned 64-bit\n    const signedValue = value < u64(0x8000) ? i64(value) : i64(value) - i64(0x10000)\n    const extendedValue = signedValue < i64(0) ? u64(signedValue) : u64(signedValue)\n\n    this.setRegisterValue(context.registers, registerD, extendedValue)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * ZERO_EXTEND_16 instruction (opcode 0x10A)\n * Zero extend 16-bit value as specified in Gray Paper\n * Gray Paper formula: reg'_D = reg_A mod 2^16\n */\nexport class ZERO_EXTEND_16Instruction extends BaseInstruction {\n  opcode: i32 = OPCODE_ZERO_EXTEND_16\n  name: string = 'ZERO_EXTEND_16'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegisters(context.operands)\n    const registerD = parseResult.registerD\n    const registerA = parseResult.registerA\n    const value = this.getRegisterValue(context.registers, registerA) & u64(0xffff)\n\n    this.setRegisterValue(context.registers, registerD, value)\n\n    return new InstructionResult(-1)\n  }\n}\n\n/**\n * REVERSE_BYTES instruction (opcode 0x10B)\n * Reverse byte order as specified in Gray Paper\n * Gray Paper pvm.tex line 452: i  N_8 : encode[8]{reg'_D}[i] = encode[8]{reg_A}[7-i]\n */\nexport class REVERSE_BYTESInstruction extends BaseInstruction {\n  opcode: i32 = OPCODE_REVERSE_BYTES\n  name: string = 'REVERSE_BYTES'\n\n  execute(context: InstructionContext): InstructionResult {\n    const parseResult = this.parseTwoRegisters(context.operands)\n    const registerD = parseResult.registerD\n    const registerA = parseResult.registerA\n    const value = this.getRegisterValue(context.registers, registerA)\n\n    // Reverse byte order (8 bytes)\n    let reversed: u64 = u64(0)\n    for (let i: i32 = 0; i < 8; i++) {\n      const byte = (value >> u64(i * 8)) & u64(0xff)\n      reversed = reversed | (byte << u64((7 - i) * 8))\n    }\n\n    this.setRegisterValue(context.registers, registerD, reversed)\n\n    return new InstructionResult(-1)\n  }\n}\n","/**\n * Polkadot Virtual Machine (PVM) Implementation\n *\n * Simplified Gray Paper compliant implementation\n * Gray Paper Reference: pvm.tex\n */\n\nimport { alignToZone } from './alignment-helpers'\nimport {\n  decodeBlob,\n  decodeProgramFromPreimage,\n  decodeImplicationsPair,\n  decodeAccumulateArgs,\n  encodeImplicationsPair,\n  PartialState,\n  CompleteServiceAccount,\n  decodeVariableSequence,\n  AccumulateInput,\n  decodeAccumulateInput,\n  WorkPackage,\n} from './codec'\nimport { ImplicationsPair } from './codec'\nimport {\n  ARGS_SEGMENT_START,\n  DEFAULT_GAS_LIMIT,\n  HALT_ADDRESS,\n  INIT_INPUT_SIZE,\n  PAGE_SIZE,\n  RESULT_CODE_HALT,\n  RESULT_CODE_HOST,\n  RESULT_CODE_OOG,\n  RESULT_CODE_PANIC,\n  STACK_SEGMENT_END,\n  ZONE_SIZE,\n  GENERAL_FUNCTIONS,\n} from './config'\nimport { FetchHostFunction } from './host-functions/general/fetch'\nimport { LookupHostFunction } from './host-functions/general/lookup'\nimport { ReadHostFunction } from './host-functions/general/read'\nimport { WriteHostFunction } from './host-functions/general/write'\nimport { InfoHostFunction } from './host-functions/general/info'\nimport { LogHostFunction } from './host-functions/general/log'\nimport { AccumulateHostFunctionRegistry } from './host-functions/accumulate/registry'\nimport { AccumulateHostFunctionContext, ACCUMULATE_ERROR_WHAT } from './host-functions/accumulate/base'\nimport { BlessHostFunction } from './host-functions/accumulate/bless'\nimport { AssignHostFunction } from './host-functions/accumulate/assign'\nimport { DesignateHostFunction } from './host-functions/accumulate/designate'\nimport { CheckpointHostFunction } from './host-functions/accumulate/checkpoint'\nimport { NewHostFunction } from './host-functions/accumulate/new'\nimport { UpgradeHostFunction } from './host-functions/accumulate/upgrade'\nimport { TransferHostFunction } from './host-functions/accumulate/transfer'\nimport { EjectHostFunction } from './host-functions/accumulate/eject'\nimport { QueryHostFunction } from './host-functions/accumulate/query'\nimport { SolicitHostFunction } from './host-functions/accumulate/solicit'\nimport { ForgetHostFunction } from './host-functions/accumulate/forget'\nimport { YieldHostFunction } from './host-functions/accumulate/yield'\nimport { ProvideHostFunction } from './host-functions/accumulate/provide'\nimport { HostFunctionRegistry } from './host-functions/general/registry'\nimport { HostFunctionContext, HostFunctionParams, ReadParams, WriteParams, LookupParams, InfoParams, LogParams, FetchParams, RefineInvocationContext } from './host-functions/general/base'\nimport { ServiceAccount } from './pbnj-types-compat'\nimport { InstructionRegistry } from './instructions/registry'\nimport { PVMParser } from './parser'\nimport { InstructionContext, RegisterState, RAM, ExecutionResult, RunProgramResult } from './types'\n\n/**\n * PVM Instruction structure\n */\nexport class PVMInstruction {\n  opcode: i32\n  operands: Uint8Array\n  fskip: i32\n  pc: u32\n\n  constructor(opcode: i32, operands: Uint8Array, fskip: i32, pc: u32) {\n    this.opcode = opcode\n    this.operands = operands\n    this.fskip = fskip\n    this.pc = pc\n  }\n}\n\n/**\n * PVM State Structure\n */\nexport class PVMState {\n  resultCode: u8 = RESULT_CODE_HALT\n  programCounter: u32 = 0\n  registerState: RegisterState\n  ram: RAM // Initialized in constructor - no field initializer to avoid wasteful object creation\n  gasCounter: u32 = u32(DEFAULT_GAS_LIMIT)\n  jumpTable: u32[] = []\n  code: Uint8Array = new Uint8Array(0)\n  bitmask: Uint8Array = new Uint8Array(0)\n  faultAddress: u32 = 0 // Fault address (0 means no fault)\n  hasFaultAddress: bool = false // Whether faultAddress is valid\n  hostCallId: u32 = 0 // 0 means no host call\n\n  constructor(\n    registerState: RegisterState,\n    ram: RAM,\n    programCounter: u32,\n    gasCounter: u32,\n  ) {\n    // Enforce non-null invariants - all parameters must be provided\n    // Initialize dynamic objects in constructor to avoid wasteful field initializers\n    this.registerState = registerState\n    this.ram = ram\n    this.programCounter = programCounter\n    this.gasCounter = gasCounter\n  }\n}\n\n/**\n * Marshalling invocation result\n */\nexport class MarshallingInvocationResult {\n  gasConsumed: u32\n  result: ExecutionResult\n  context: any\n\n  constructor(gasConsumed: u32, result: ExecutionResult, context: any) {\n    this.gasConsumed = gasConsumed\n    this.result = result\n    this.context = context\n  }\n}\n\n/**\n * Accumulation invocation result\n */\nexport class AccumulateInvocationResult {\n  gasConsumed: u32\n  result: ExecutionResult\n  encodedContext: Uint8Array\n\n  constructor(gasConsumed: u32, result: ExecutionResult, encodedContext: Uint8Array) {\n    this.gasConsumed = gasConsumed\n    this.result = result\n    this.encodedContext = encodedContext\n  }\n}\n\n/**\n * PVM implementation\n *\n * Gray Paper  function: Executes instructions until a halting condition\n */\nexport class PVM {\n  public state: PVMState\n  registry: InstructionRegistry\n  hostFunctionRegistry: HostFunctionRegistry\n  accumulateHostFunctionRegistry: AccumulateHostFunctionRegistry\n  accumulationContext: ImplicationsPair | null = null\n  timeslot: u64 = u64(0) // Current timeslot for accumulation\n  entropyAccumulator: Uint8Array | null = null // Entropy accumulator for FETCH host function\n  accumulateInputs: Array<AccumulateInput> | null = null // Accumulate inputs for FETCH host function (selectors 14, 15)\n  refineContext: RefineInvocationContext | null = null // Refine context (m, e) for refine invocation\n  // Refine invocation parameters (needed by host functions)\n  refineWorkPackage: WorkPackage | null = null // Work package for FETCH host function\n  refineAuthorizerTrace: Uint8Array | null = null // Authorizer trace for FETCH host function\n  refineImportSegments: Array<Array<Uint8Array>> | null = null // Import segments for FETCH host function\n  refineExportSegmentOffset: u32 = 0 // Export segment offset for EXPORT host function\n  refineServiceAccount: CompleteServiceAccount | null = null // Service account for HISTORICAL_LOOKUP host function\n  refineLookupAnchorTimeslot: u64 = u64(0) // Lookup anchor timeslot for HISTORICAL_LOOKUP host function\n  \n  // Config parameters (set during setupAccumulateInvocation)\n  configNumCores: i32 = 341\n  configPreimageExpungePeriod: u32 = 19200\n  configEpochDuration: u32 = 600\n  configMaxBlockGas: u64 = u64(3500000000)\n  configMaxRefineGas: u64 = u64(5000000000)\n  configMaxTicketsPerExtrinsic: u16 = 16\n  configTicketsPerValidator: u16 = 2\n  configSlotDuration: u16 = 6\n  configRotationPeriod: u16 = 10\n  configNumValidators: u16 = 1023\n  configNumEcPiecesPerSegment: u32 = 6\n  configContestDuration: u32 = 500\n  configMaxLookupAnchorage: u32 = 14400\n  configEcPieceSize: u32 = 684\n  \n  // JAM version (for version-aware encoding)\n  jamVersionMajor: u8 = 0\n  jamVersionMinor: u8 = 7\n  jamVersionPatch: u8 = 2\n\n  constructor(\n    registerState: RegisterState,\n    ram: RAM,\n    programCounter: u32,\n    gasCounter: u32,\n    hostFunctionRegistry: HostFunctionRegistry,\n  ) {\n    // Initialize instruction registry (singleton)\n    this.registry = new InstructionRegistry()\n\n    // Initialize host function registry (optional)\n    this.hostFunctionRegistry = hostFunctionRegistry\n\n    // Initialize accumulation host function registry\n    this.accumulateHostFunctionRegistry = new AccumulateHostFunctionRegistry()\n\n    // Initialize state\n    this.state = new PVMState(registerState, ram, programCounter, gasCounter)\n  }\n\n\n  /**\n   * Invoke PVM execution with specific parameters\n   * This is used by the INVOKE host function to execute a PVM machine\n   * with custom gas limit and register state\n   */\n  public invoke(\n    gasLimit: u32,\n    registers: RegisterState,\n    code: Uint8Array,\n    bitmask: Uint8Array,\n    jumpTable: u32[],\n  ): void {\n    this.reset()\n    // Set invocation parameters\n    this.state.gasCounter = gasLimit\n    this.state.registerState = registers\n    this.state.code = code\n    this.state.bitmask = bitmask\n    this.state.jumpTable = jumpTable\n\n    // Execute until termination\n    this.run(null)\n  }\n\n  /**\n   * Y - Standard initialization function\n   * Gray Paper equation 753-760: Y(blob, blob)  (blob, registers, ram)?\n   *\n   * Decodes program blob and argument data to yield program code, registers, and RAM.\n   * Returns null if the conditions cannot be satisfied with unique values.\n   *\n   * @param programBlob - Program blob containing code, output, writable, and init data\n   * @param argumentData - Argument data blob (max Cpvminitinputsize)\n   * @returns Code blob or null if invalid\n   */\n  public initializeProgram(\n    programBlob: Uint8Array,\n    argumentData: Uint8Array,\n  ): Uint8Array | null {\n    // Try to decode as standard program format first (Gray Paper Y function)\n    // Note: decodeProgramFromPreimage internally calls decodeServiceCodeFromPreimage\n    // to extract metadata and codeBlob, then decodes the codeBlob as Y function format\n    const result = decodeProgramFromPreimage(programBlob)\n    if (!result) {\n      abort(\n        `initializeProgram: Failed to decode program from preimage: programBlob length=${programBlob.length}`\n      )\n      unreachable()\n    }\n\n    const code = result!.code\n    const roData = result!.roData\n    const rwData = result!.rwData\n    const stackSize = result!.stackSize\n    const heapZeroPaddingSize = result!.heapZeroPaddingSize\n\n    // Gray Paper equation 767: Validate condition\n    // 5*Cpvminitzonesize + rnq(len(o)) + rnq(len(w) + z*Cpvmpagesize) + rnq(s) + Cpvminitinputsize <= 2^32\n\n    const alignedReadOnlyDataLength = alignToZone(i32(roData.length))\n    const alignedHeapLength = alignToZone(\n      i32(rwData.length + heapZeroPaddingSize * PAGE_SIZE),\n    )\n    const alignedStackSize = alignToZone(i32(stackSize))\n\n    const total: u32 =\n      u32(5 * ZONE_SIZE +\n      alignedReadOnlyDataLength +\n      alignedHeapLength +\n      alignedStackSize +\n      INIT_INPUT_SIZE)\n\n    // Gray Paper equation 767: total must be <= 2^32\n    // Use u32.MAX_VALUE (2^32 - 1) for comparison since 2^32 cannot be represented as u32\n    // If total > u32.MAX_VALUE, then total >= 2^32, which violates the condition\n    const MAX_U32: u32 = 0xFFFFFFFF // 2^32 - 1 = 4294967295\n    if (total > MAX_U32) {\n      abort(\n        `initializeProgram: Gray Paper equation 767 condition violated: total=${total} > 2^32 (${MAX_U32 + 1}), roDataLength=${roData.length}, rwDataLength=${rwData.length}, heapZeroPaddingSize=${heapZeroPaddingSize}, stackSize=${stackSize}, alignedReadOnlyDataLength=${alignedReadOnlyDataLength}, alignedHeapLength=${alignedHeapLength}, alignedStackSize=${alignedStackSize}`\n      )\n      unreachable()\n    }\n\n    // Initialize registers according to Gray Paper equation 803-811\n    this.initializeRegisters(u32(argumentData.length))\n\n    // Set up memory sections according to Gray Paper memory layout\n    this.initializeMemoryLayout(\n      argumentData,\n      roData,\n      rwData,\n      stackSize,\n      heapZeroPaddingSize,\n    )\n\n    // The code field from decodeProgramFromPreimage is the instruction data blob in deblob format\n    // Decode it as deblob format to get bitmask and jump table\n    const decodedBlob = decodeBlob(code)\n    if (!decodedBlob) {\n      abort(\n        `initializeProgram: Failed to decode code as deblob format: code length=${code.length}`\n      )\n      unreachable()\n    }\n    // Set decoded program state so run() can use it\n    this.state.code = decodedBlob!.code\n    this.state.bitmask = decodedBlob!.bitmask\n    this.state.jumpTable = decodedBlob!.jumpTable\n\n    return code\n  }\n\n  /**\n   * Initialize PVM registers according to Gray Paper equation 803-811\n   * Reference: https://graypaper.fluffylabs.dev/#/579bd12/2c7c012cb101\n   *\n   * All registers are initialized to 0 in constructor, then specific ones are set here:\n   * - r0: HALT address (2^32 - 2^16)\n   * - r1: Stack segment end address (2^32 - 2*Cpvminitzonesize - Cpvminitinputsize)\n   * - r7: Arguments segment start address (2^32 - Cpvminitzonesize - Cpvminitinputsize)\n   * - r8: Argument data length\n   * - r2-r6, r9-r12: Remain 0\n   *\n   * @param argumentDataLength - Length of argument data (a) in bytes\n   */\n  initializeRegisters(argumentDataLength: u32): void {\n    // r0: HALT address - jumping to this address causes the PVM to halt gracefully\n    // Gray Paper equation 803: registers[0] = 2^32 - 2^16\n    // This is equivalent to the HALT_ADDRESS constant (0xffff0000)\n    this.state.registerState[0] = u64(HALT_ADDRESS)\n\n    // r1: Stack segment end address (exclusive)\n    // Gray Paper equation 803: registers[1] = 2^32 - 2*Cpvminitzonesize - Cpvminitinputsize\n    // This is equivalent to the STACK_SEGMENT_END constant (0xfefe0000)\n    // Represents the end address of the stack region (exclusive boundary)\n    this.state.registerState[1] = u64(STACK_SEGMENT_END)\n\n    // r7: Arguments segment start address\n    // Gray Paper equation 803: registers[7] = 2^32 - Cpvminitzonesize - Cpvminitinputsize\n    // This is equivalent to the ARGS_SEGMENT_START constant (0xfeff0000)\n    // Represents the start address of the arguments/output region\n    this.state.registerState[7] = u64(ARGS_SEGMENT_START)\n\n    // r8: Argument data length\n    // Gray Paper equation 803: registers[8] = len(argumentData)\n    // Stores the length of the argument data in bytes\n    this.state.registerState[8] = u64(argumentDataLength)\n\n    // Registers r2-r6 and r9-r12 remain 0 (already initialized in constructor)\n  }\n\n  /**\n   * Initialize memory layout according to Gray Paper equation 770-802\n   *\n   * Gray Paper equation 766: Alignment functions\n   * - rnp(x  )  Cpvmpagesize * ceil(x / Cpvmpagesize) - page alignment\n   * - rnq(x  )  Cpvminitzonesize * ceil(x / Cpvminitzonesize) - zone alignment\n   *\n   * @param argumentData - Argument data (a)\n   * @param readOnlyData - Read-only data section (o)\n   * @param readWriteData - Read-write data section (w) -> initial heap data\n   * @param stackSize - Stack size (s)\n   * @param heapZeroPaddingSize - Heap zero padding size (z) (in number of pages)\n   */\n  initializeMemoryLayout(\n    argumentData: Uint8Array,\n    readOnlyData: Uint8Array,\n    readWriteData: Uint8Array,\n    stackSize: u32,\n    heapZeroPaddingSize: u32,\n  ): void {\n    // This sets up address boundaries, allocates contiguous arrays, and sets data\n    this.state.ram.initializeMemoryLayout(\n      argumentData,\n      readOnlyData,\n      readWriteData,\n      stackSize,\n      heapZeroPaddingSize,\n    )\n  }\n\n  runProgram(): RunProgramResult {\n    const initialGas = this.state.gasCounter\n    this.run(null)\n\n    // After execution, extract final state\n    const finalGasCounter = this.state.gasCounter\n    const finalResultCode = this.state.resultCode\n    const finalRegisters = this.state.registerState\n    const finalMemory = this.state.ram\n\n    // Gray Paper equation 834: Calculate gas consumed\n    // u = gascounter - max(gascounter', 0)\n    const gasConsumed = initialGas - (finalGasCounter > 0 ? finalGasCounter : 0)\n\n    const result = this.extractResultFromExecution(\n      finalResultCode,\n      finalRegisters,\n      finalMemory,\n    )\n\n    return new RunProgramResult(gasConsumed, result)\n  }\n\n  /**\n   * R function - Extract result from execution based on termination condition\n   *\n   * Gray Paper equation 829-835 (pvm.tex):\n   * R(gascounter, _H(.))  (gas, result, context)\n   *\n   * Where result is determined by:\n   * - Gray Paper equation 829: If  = oog: return (u, oog, x')\n   * - Gray Paper equation 831: If  = halt AND Nrange{registers'[7]}{registers'[8]}  readable{mem'}:\n   *   return (u, mem'[registers'[7].registers'[7]+registers'[8]], x')\n   * - Gray Paper equation 832: If  = halt AND range not readable: return (u, [], x')\n   * - Gray Paper equation 833: Otherwise: return (u, panic, x')\n   *\n   * Where:\n   * -  = resultCode (termination condition: halt, panic, or oog)\n   * - u = gas consumed (calculated in executeMarshallingInvocation)\n   * - registers'[7] = start offset of result range (arguments segment start)\n   * - registers'[8] = length of result range (argument data length)\n   * - mem' = final memory state after execution\n   * - Nrange{a}{b} = range from address a to a+b (inclusive start, exclusive end)\n   * - readable{mem'} = set of readable memory addresses\n   *\n   * @param resultCode - Termination condition (HALT, PANIC, or OOG)\n   * @param finalRegisters - Final register state after execution\n   * @param finalMemory - Final memory state after execution\n   * @returns Result blob, 'PANIC', or 'OOG'\n   */\n  extractResultFromExecution(\n    resultCode: u8,\n    finalRegisters: RegisterState,\n    finalMemory: RAM,\n  ): ExecutionResult {\n    // Gray Paper equation 829: If  = oog: return (u, oog, x')\n    if (resultCode === RESULT_CODE_OOG) {\n      return ExecutionResult.fromOOG()\n    }\n\n    // Gray Paper equation 830-832: Handle HALT case\n    if (resultCode === RESULT_CODE_HALT) {\n      // Extract result range from registers\n      // registers'[7] = arguments segment start address\n      // registers'[8] = argument data length\n      const startOffset = finalRegisters[7]\n      const length = finalRegisters[8]\n\n      // Empty range is trivially readable - return empty blob\n      if (length === u64(0)) {\n        return ExecutionResult.fromData(new Uint8Array(0))\n      }\n\n      // Gray Paper equation 831-832: Check if Nrange{registers'[7]}{registers'[8]}  readable{mem'}\n      // Nrange{registers'[7]}{registers'[8]} means range from startOffset to startOffset+length\n\n      // Gray Paper equation 831: If  = halt AND Nrange{registers'[7]}{registers'[8]}  readable{mem'}\n      // return (u, mem'[registers'[7].registers'[7]+registers'[8]], x')\n      const readResult = finalMemory.readOctets(u32(startOffset), u32(length))\n\n      // If readOctets returns a fault, this is an inconsistency (range was readable but read failed)\n      // Gray Paper equation 832: If  = halt AND range not readable: return (u, [], x')\n      if (readResult.faultAddress !== 0) {\n        return ExecutionResult.fromData(new Uint8Array(0))\n      }\n\n      // If memoryResult is null, also treat as error (should not happen if range is readable)\n      if (readResult.data === null) {\n        return ExecutionResult.fromPanic()\n      }\n\n      return ExecutionResult.fromData(readResult.data!)\n    }\n\n    // Gray Paper equation 833: Otherwise: return (u, panic, x')\n    // This covers PANIC and any other unexpected result codes\n    return ExecutionResult.fromPanic()\n  }\n\n  /**\n   * Execute a single instruction step (Gray Paper )\n   * Returns the result code and whether execution should continue\n   */\n  public step(instruction: PVMInstruction): i32 {\n    // Check for halt conditions\n    if (this.state.gasCounter === 0) {\n      this.state.resultCode = RESULT_CODE_OOG\n      return i32(RESULT_CODE_OOG)\n    }\n\n    // Consume 1 gas for each instruction\n    this.state.gasCounter -= 1\n\n    // Execute instruction () - gas consumption handled by instruction itself\n    const resultCode = this.executeInstruction(instruction)\n\n    // -1 = continue, >= 0 = halt with that result code\n    if (resultCode === -1) {\n      // Continue execution\n      return -1\n    }\n\n    // Check if it's a HOST result code\n    if (resultCode === i32(RESULT_CODE_HOST)) {\n      // Extract host call ID from instruction operands (Gray Paper: immed_X from ECALLI)\n      // Gray Paper pvm.tex 7.4.1:  = host  immed_X, where immed_X is the immediate operand\n      // Gray Paper pvm.tex line 251-255: If l_X=0 (no operand bytes), immed_X defaults to 0\n      // This happens when fskip=0, meaning operands array is empty\n      let hostCallId: u64 = 0\n      if (instruction.operands.length > 0) {\n        hostCallId = u64(instruction.operands[0])\n      }\n      this.state.hostCallId = u32(hostCallId)\n      \n      if (this.state.gasCounter === 0) {\n        this.state.resultCode = RESULT_CODE_OOG\n        return i32(RESULT_CODE_OOG)\n      }\n\n      // Handle HOST calls according to pvm_invocations.tex\n      // If in accumulation context, route to accumulation host functions\n      if (this.accumulationContext !== null) {\n        return this.handleAccumulationHostCall(hostCallId, instruction)\n      }\n\n      // Otherwise, return HOST result code to indicate host call needed (general functions)\n      return i32(RESULT_CODE_HOST)\n    }\n\n    // Return the result code (halt/panic/oog/etc)\n    return resultCode\n  }\n\n  /**\n   * Handle HOST calls during accumulation invocation\n   * \n   * Gray Paper pvm_invocations.tex equation 187-211:\n   * Routes host calls to appropriate handlers based on function ID\n   * - General functions: gas, fetch, read, write, lookup, info\n   * - Accumulation-specific functions: bless (14), assign (15), designate (16), checkpoint (17), \n   *   new (18), upgrade (19), transfer (20), eject (21), query (22), solicit (23), forget (24), \n   *   yield (25), provide (26)\n   * \n   * Similar to TypeScript createAccumulateContextMutator and handleAccumulateHostFunction\n   * \n   * @param hostCallId - Host function ID\n   * @param instruction - Current instruction (for PC advancement)\n   * @returns Result code (-1 = continue, >= 0 = halt)\n   */\n  private handleAccumulationHostCall(hostCallId: u64, instruction: PVMInstruction): i32 {\n    // Gray Paper: Apply base gas cost (10 gas for all host functions)\n    const gasCost: u32 = 10\n    if (this.state.gasCounter < gasCost) {\n      this.state.resultCode = RESULT_CODE_OOG\n      return i32(RESULT_CODE_OOG)\n    }\n    \n    // Deduct base gas cost before calling host function\n    this.state.gasCounter -= gasCost\n    \n    // Try accumulate host functions first (14-26)\n    // Gray Paper: Accumulation-specific functions are in range 14-26\n    if (hostCallId >= u64(14) && hostCallId <= u64(26)) {\n      const result = this.handleAccumulateHostFunction(hostCallId, instruction)\n      \n      // If result code is 255 (sentinel for null), continue execution\n      if (result === -1) {\n        // Advance PC by instruction length (host function handled it)\n        const instructionLength = u32(1 + instruction.fskip)\n        this.state.programCounter += instructionLength\n        return -1 // Continue\n      }\n      \n      // Otherwise, halt with the result code\n      this.state.resultCode = u8(result)\n      return result\n    }\n    \n    // General host functions available in accumulate context (0-5)\n    // Also include log (100) - JIP-1 debug/monitoring function\n    if ((hostCallId >= u64(0) && hostCallId <= u64(5)) || hostCallId === u64(100)) {\n      const result = this.handleGeneralHostFunction(hostCallId, instruction)\n      \n      // If result code is -1 (continue), advance PC\n      if (result === -1) {\n        // Advance PC by instruction length (host function handled it)\n        const instructionLength = u32(1 + instruction.fskip)\n        this.state.programCounter += instructionLength\n        return -1 // Continue\n      }\n      \n      // Otherwise, halt with the result code\n      this.state.resultCode = u8(result)\n      return result\n    }\n    \n    // Gray Paper pvm_invocations.tex lines 206-210:\n    // Unknown host function in accumulation context:\n    // - Gas already deducted (10 gas above)\n    // - Set registers[7] = WHAT (name unknown)\n    // - Continue execution\n    this.state.registerState[7] = ACCUMULATE_ERROR_WHAT\n    \n    // Advance PC by instruction length\n    const instructionLength = u32(1 + instruction.fskip)\n    this.state.programCounter += instructionLength\n    return -1 // Continue execution\n  }\n\n  /**\n   * Handle accumulation-specific host function (similar to TypeScript handleAccumulateHostFunction)\n   * \n   * Gray Paper: Functions 14-26 (bless, assign, designate, checkpoint, new, upgrade, transfer, eject, query, solicit, forget, yield, provide)\n   * \n   * @param hostCallId - Host function ID (should be 14-26)\n   * @param instruction - Current instruction (for PC advancement)\n   * @returns Result code (-1 = continue, >= 0 = halt)\n   */\n  private handleAccumulateHostFunction(hostCallId: u64, instruction: PVMInstruction): i32 {\n    // NOTE: AssemblyScript doesn't support runtime polymorphism, so we use explicit dispatch\n    \n    // Create accumulation host function context\n    if (!this.accumulationContext) {\n      this.state.resultCode = RESULT_CODE_PANIC\n      return i32(RESULT_CODE_PANIC)\n    }\n    \n    const context = new AccumulateHostFunctionContext(\n      this.state.gasCounter,\n      this.state.registerState,\n      this.state.ram,\n      this.accumulationContext!,\n      this.timeslot,\n      u64(this.configPreimageExpungePeriod),\n      u32(this.configNumCores), // Pass numCores from config\n      u32(this.configNumValidators), // Pass numValidators from config\n      this.jamVersionMajor, // Pass JAM version for version-aware behavior\n      this.jamVersionMinor,\n      this.jamVersionPatch,\n    )\n    \n    let resultCode: u8 = 255\n    \n    switch (u32(hostCallId)) {\n      case u32(14): {\n        // BLESS\n        const handler = this.accumulateHostFunctionRegistry.get(hostCallId)\n        if (handler === null) { this.state.resultCode = RESULT_CODE_PANIC; return i32(RESULT_CODE_PANIC) }\n        const bless = changetype<BlessHostFunction>(handler)\n        const result = bless.execute(context)\n        resultCode = result.resultCode\n        break\n      }\n      case u32(15): {\n        // ASSIGN\n        const handler = this.accumulateHostFunctionRegistry.get(hostCallId)\n        if (handler === null) { this.state.resultCode = RESULT_CODE_PANIC; return i32(RESULT_CODE_PANIC) }\n        const assign = changetype<AssignHostFunction>(handler)\n        const result = assign.execute(context)\n        resultCode = result.resultCode\n        break\n      }\n      case u32(16): {\n        // DESIGNATE\n        const handler = this.accumulateHostFunctionRegistry.get(hostCallId)\n        if (handler === null) { this.state.resultCode = RESULT_CODE_PANIC; return i32(RESULT_CODE_PANIC) }\n        const designate = changetype<DesignateHostFunction>(handler)\n        const result = designate.execute(context)\n        resultCode = result.resultCode\n        break\n      }\n      case u32(17): {\n        // CHECKPOINT\n        const handler = this.accumulateHostFunctionRegistry.get(hostCallId)\n        if (handler === null) { this.state.resultCode = RESULT_CODE_PANIC; return i32(RESULT_CODE_PANIC) }\n        const checkpoint = changetype<CheckpointHostFunction>(handler)\n        const result = checkpoint.execute(context)\n        resultCode = result.resultCode\n        break\n      }\n      case u32(18): {\n        // NEW\n        const handler = this.accumulateHostFunctionRegistry.get(hostCallId)\n        if (handler === null) { this.state.resultCode = RESULT_CODE_PANIC; return i32(RESULT_CODE_PANIC) }\n        const newFn = changetype<NewHostFunction>(handler)\n        const result = newFn.execute(context)\n        resultCode = result.resultCode\n        break\n      }\n      case u32(19): {\n        // UPGRADE\n        const handler = this.accumulateHostFunctionRegistry.get(hostCallId)\n        if (handler === null) { this.state.resultCode = RESULT_CODE_PANIC; return i32(RESULT_CODE_PANIC) }\n        const upgrade = changetype<UpgradeHostFunction>(handler)\n        const result = upgrade.execute(context)\n        resultCode = result.resultCode\n        break\n      }\n      case u32(20): {\n        // TRANSFER\n        const handler = this.accumulateHostFunctionRegistry.get(hostCallId)\n        if (handler === null) { this.state.resultCode = RESULT_CODE_PANIC; return i32(RESULT_CODE_PANIC) }\n        const transfer = changetype<TransferHostFunction>(handler)\n        const result = transfer.execute(context)\n        resultCode = result.resultCode\n        // Gray Paper: On success, TRANSFER deducts gasLimit (additionalGasCost) from gas counter\n        if (result.additionalGasCost > u64(0)) {\n          if (u64(context.gasCounter) < result.additionalGasCost) {\n            // OOG - not enough gas for additional cost\n            this.state.gasCounter = 0\n            this.state.resultCode = RESULT_CODE_OOG\n            return i32(RESULT_CODE_OOG)\n          }\n          context.gasCounter -= u32(result.additionalGasCost)\n        }\n        break\n      }\n      case u32(21): {\n        // EJECT\n        const handler = this.accumulateHostFunctionRegistry.get(hostCallId)\n        if (handler === null) { this.state.resultCode = RESULT_CODE_PANIC; return i32(RESULT_CODE_PANIC) }\n        const eject = changetype<EjectHostFunction>(handler)\n        const result = eject.execute(context)\n        resultCode = result.resultCode\n        break\n      }\n      case u32(22): {\n        // QUERY\n        const handler = this.accumulateHostFunctionRegistry.get(hostCallId)\n        if (handler === null) { this.state.resultCode = RESULT_CODE_PANIC; return i32(RESULT_CODE_PANIC) }\n        const query = changetype<QueryHostFunction>(handler)\n        const result = query.execute(context)\n        resultCode = result.resultCode\n        break\n      }\n      case u32(23): {\n        // SOLICIT\n        const handler = this.accumulateHostFunctionRegistry.get(hostCallId)\n        if (handler === null) { this.state.resultCode = RESULT_CODE_PANIC; return i32(RESULT_CODE_PANIC) }\n        const solicit = changetype<SolicitHostFunction>(handler)\n        const result = solicit.execute(context)\n        resultCode = result.resultCode\n        break\n      }\n      case u32(24): {\n        // FORGET\n        const handler = this.accumulateHostFunctionRegistry.get(hostCallId)\n        if (handler === null) { this.state.resultCode = RESULT_CODE_PANIC; return i32(RESULT_CODE_PANIC) }\n        const forget = changetype<ForgetHostFunction>(handler)\n        const result = forget.execute(context)\n        resultCode = result.resultCode\n        break\n      }\n      case u32(25): {\n        // YIELD\n        const handler = this.accumulateHostFunctionRegistry.get(hostCallId)\n        if (handler === null) { this.state.resultCode = RESULT_CODE_PANIC; return i32(RESULT_CODE_PANIC) }\n        const yieldFn = changetype<YieldHostFunction>(handler)\n        const result = yieldFn.execute(context)\n        resultCode = result.resultCode\n        break\n      }\n      case u32(26): {\n        // PROVIDE\n        const handler = this.accumulateHostFunctionRegistry.get(hostCallId)\n        if (handler === null) { this.state.resultCode = RESULT_CODE_PANIC; return i32(RESULT_CODE_PANIC) }\n        const provide = changetype<ProvideHostFunction>(handler)\n        const result = provide.execute(context)\n        resultCode = result.resultCode\n        break\n      }\n      default: {\n        // Gray Paper: Unknown accumulation host function\n        // - Set registers[7] = WHAT (name unknown)\n        // - Continue execution\n        this.state.registerState[7] = ACCUMULATE_ERROR_WHAT\n        return -1 // Continue execution\n      }\n    }\n    \n    // Update gas counter from context\n    this.state.gasCounter = context.gasCounter\n    \n    // If result code is 255 (sentinel for null), continue execution\n    if (resultCode === u8(255)) {\n      return -1 // Continue\n    }\n    \n    // Otherwise, return the result code\n    return i32(resultCode)\n  }\n\n  /**\n   * Handle general host function (similar to TypeScript handleGeneralHostFunction)\n   * \n   * Gray Paper: gas (0), fetch (1), read (3), write (4), lookup (2), info (5), log (100)\n   * \n   * @param hostCallId - Host function ID\n   * @param instruction - Current instruction (for PC advancement)\n   * @returns Result code (-1 = continue, >= 0 = halt)\n   */\n  private handleGeneralHostFunction(hostCallId: u64, instruction: PVMInstruction): i32 {\n    // NOTE: AssemblyScript doesn't support runtime polymorphism, so we use explicit dispatch\n    // like TypeScript does in typescript-pvm-executor.ts handleGeneralHostFunction\n    \n    // Create host function context once (shared for all cases that need it)\n    const hostContext = new HostFunctionContext(\n      this.state.gasCounter,\n      this.state.registerState,\n      this.state.ram,\n    )\n    \n    switch (u32(hostCallId)) {\n      case u32(0): {\n        // GAS - inline implementation (Gray Paper: set registers[7] = gasCounter)\n        this.state.registerState[7] = u64(this.state.gasCounter)\n        return -1 // Continue\n      }\n      case u32(1): {\n        // FETCH\n        const handler = this.hostFunctionRegistry.get(hostCallId)\n        if (handler === null) {\n          this.state.resultCode = RESULT_CODE_PANIC\n          return i32(RESULT_CODE_PANIC)\n        }\n    const params = this.buildGeneralHostFunctionParams(hostCallId)\n        const fetch = changetype<FetchHostFunction>(handler)\n        const result = fetch.execute(hostContext, params)\n    this.state.gasCounter = hostContext.gasCounter\n        return result.resultCode === u8(255) ? -1 : i32(result.resultCode)\n      }\n      case u32(2): {\n        // LOOKUP\n        const handler = this.hostFunctionRegistry.get(hostCallId)\n        if (handler === null) {\n          this.state.resultCode = RESULT_CODE_PANIC\n          return i32(RESULT_CODE_PANIC)\n        }\n        const params = this.buildGeneralHostFunctionParams(hostCallId)\n        const lookup = changetype<LookupHostFunction>(handler)\n        const result = lookup.execute(hostContext, params)\n        this.state.gasCounter = hostContext.gasCounter\n        return result.resultCode === u8(255) ? -1 : i32(result.resultCode)\n      }\n      case u32(3): {\n        // READ\n        const handler = this.hostFunctionRegistry.get(hostCallId)\n        if (handler === null) {\n          this.state.resultCode = RESULT_CODE_PANIC\n          return i32(RESULT_CODE_PANIC)\n        }\n        const params = this.buildGeneralHostFunctionParams(hostCallId)\n        const read = changetype<ReadHostFunction>(handler)\n        const result = read.execute(hostContext, params)\n        this.state.gasCounter = hostContext.gasCounter\n        return result.resultCode === u8(255) ? -1 : i32(result.resultCode)\n      }\n      case u32(4): {\n        // WRITE\n        const handler = this.hostFunctionRegistry.get(hostCallId)\n        if (handler === null) {\n          this.state.resultCode = RESULT_CODE_PANIC\n          return i32(RESULT_CODE_PANIC)\n        }\n        const params = this.buildGeneralHostFunctionParams(hostCallId)\n        const write = changetype<WriteHostFunction>(handler)\n        const result = write.execute(hostContext, params)\n        this.state.gasCounter = hostContext.gasCounter\n        return result.resultCode === u8(255) ? -1 : i32(result.resultCode)\n      }\n      case u32(5): {\n        // INFO\n        const handler = this.hostFunctionRegistry.get(hostCallId)\n        if (handler === null) {\n          this.state.resultCode = RESULT_CODE_PANIC\n          return i32(RESULT_CODE_PANIC)\n        }\n        const params = this.buildGeneralHostFunctionParams(hostCallId)\n        const info = changetype<InfoHostFunction>(handler)\n        const result = info.execute(hostContext, params)\n        this.state.gasCounter = hostContext.gasCounter\n        return result.resultCode === u8(255) ? -1 : i32(result.resultCode)\n      }\n      case u32(100): {\n        // LOG (JIP-1)\n        const handler = this.hostFunctionRegistry.get(hostCallId)\n        if (handler === null) {\n          this.state.resultCode = RESULT_CODE_PANIC\n          return i32(RESULT_CODE_PANIC)\n        }\n        const params = this.buildGeneralHostFunctionParams(hostCallId)\n        const log = changetype<LogHostFunction>(handler)\n        const result = log.execute(hostContext, params)\n        this.state.gasCounter = hostContext.gasCounter\n        return result.resultCode === u8(255) ? -1 : i32(result.resultCode)\n      }\n      default: {\n        // Gray Paper: Unknown general host function\n        // - Set registers[7] = WHAT (name unknown)\n        // - Continue execution\n        this.state.registerState[7] = ACCUMULATE_ERROR_WHAT\n        return -1 // Continue execution\n      }\n    }\n  }\n\n  /**\n   * Build params for general host functions (similar to TypeScript handleGeneralHostFunction)\n   * Gray Paper: gas (0), fetch (1), read (3), write (4), lookup (2), info (5), log (100)\n   */\n  private buildGeneralHostFunctionParams(hostCallId: u64): HostFunctionParams | null {\n    if (!this.accumulationContext) {\n      return null\n    }\n\n    const imX = this.accumulationContext!.regular\n\n    switch (u32(hostCallId)) {\n      case u32(0): {\n        // gas - no params needed\n        return null\n      }\n      case u32(1): {\n        // fetch - FetchParams with timeslot and accumulateInputs\n        const fetchParams = new FetchParams(this.timeslot, u64(0))\n        fetchParams.accumulateInputs = this.accumulateInputs\n        return fetchParams\n      }\n      case u32(2): {\n        // lookup - LookupParams with service ID and accounts Map\n        const accountsMap = this.buildAccountsMap(imX.state)\n        return new LookupParams(u64(imX.id), accountsMap)\n      }\n      case u32(3): {\n        // read - ReadParams with service account and accounts\n        const serviceAccount = this.findServiceAccount(imX.state, u32(imX.id))\n        const accountsMap = this.buildAccountsMap(imX.state)\n        return new ReadParams(u64(imX.id), serviceAccount, accountsMap)\n      }\n      case u32(4): {\n        // write - WriteParams with service ID and service account\n        const serviceAccount = this.findServiceAccount(imX.state, u32(imX.id))\n        if (!serviceAccount) {\n          return null\n        }\n        return new WriteParams(u64(imX.id), serviceAccount)\n      }\n      case u32(5): {\n        // info - InfoParams with service ID and accounts Map\n        const accountsMap = this.buildAccountsMap(imX.state)\n        return new InfoParams(u64(imX.id), accountsMap)\n      }\n      case u32(100): {\n        // log (JIP-1) - LogParams (no properties needed)\n        return new LogParams()\n      }\n      default: {\n        return null\n      }\n    }\n  }\n\n  /**\n   * Build accounts Map from PartialState accounts array\n   */\n  private buildAccountsMap(state: PartialState): Map<u64, CompleteServiceAccount> {\n    const accountsMap = new Map<u64, CompleteServiceAccount>()\n    for (let i = 0; i < state.accounts.length; i++) {\n      const entry = state.accounts[i]\n      accountsMap.set(u64(entry.serviceId), entry.account)\n    }\n    return accountsMap\n  }\n\n  /**\n   * Find service account in partial state by service ID\n   */\n  private findServiceAccount(state: PartialState, serviceId: u32): CompleteServiceAccount | null {\n    // Search through accounts array to find matching serviceId\n    for (let i = 0; i < state.accounts.length; i++) {\n      if (state.accounts[i].serviceId === u32(serviceId)) {\n        return state.accounts[i].account\n      }\n    }\n    return null\n  }\n\n  /**\n   * Extract result from memory - placeholder implementation\n   */\n  extractResultFromMemory(): Uint8Array | null {\n    const start = this.state.registerState[7]\n    const length = this.state.registerState[8]\n    const readResult = this.state.ram.readOctets(u32(start), u32(length))\n    if (readResult.faultAddress !== 0) {\n      return null\n    }\n    if (readResult.data === null) {\n      return null\n    }\n    return readResult.data\n  }\n\n  /**\n   * Skip function Fskip(i) - determines distance to next instruction\n   *\n   * Gray Paper Equation 7.1:\n   * Fskip(i) = min(24, j  N : (k  {1,1,.})_{i+1+j} = 1)\n   *\n   * @param instructionIndex - Index of instruction opcode in instruction data\n   * @param opcodeBitmask - Bitmask indicating valid instruction boundaries\n   * @returns Number of octets minus 1 to next instruction's opcode\n   */\n  skip(instructionIndex: i32, opcodeBitmask: Uint8Array): i32 {\n    // Append bitmask with sequence of set bits for final instruction\n    const extendedBitmask = new Uint8Array(opcodeBitmask.length + 25)\n    extendedBitmask.set(opcodeBitmask)\n    extendedBitmask.fill(1, opcodeBitmask.length)\n\n    // Find next set bit starting from i+1\n    for (let j: i32 = 1; j <= 24; j++) {\n      const bitIndex = instructionIndex + j\n      if (\n        bitIndex < extendedBitmask.length &&\n        extendedBitmask[bitIndex] === 1\n      ) {\n        return j - 1\n      }\n    }\n\n    return 24 // Maximum skip distance\n  }\n\n\n  /**\n   * Execute program until termination (Gray Paper  function)\n   *\n   * Uses step() function to execute instructions one by one\n   * \n   * @param codeBlob - Optional code blob to decode. If provided, decodes and sets state before running.\n   */\n  public run(codeBlob: Uint8Array | null): void {\n    // If program blob provided, decode it first\n    if (codeBlob) {\n      const decoded = decodeBlob(codeBlob)\n      if (!decoded) {\n        this.state.resultCode = RESULT_CODE_PANIC\n        return\n      }\n      this.state.code = decoded.code\n      this.state.bitmask = decoded.bitmask\n      this.state.jumpTable = decoded.jumpTable\n    }\n    \n    // Ensure code and bitmask are set (should be set by runBlob or previous decode)\n    // If codeBlob was null, we expect state to already be set\n    if (this.state.code.length === 0 || this.state.bitmask.length === 0) {\n      this.state.resultCode = RESULT_CODE_PANIC\n      return\n    }\n    \n    // Gray Paper pvm.tex equation:   c  [0, 0, . . . ]\n    // Append 16 zeros to ensure no out-of-bounds access and trap behavior\n    // This implements the infinite sequence of zeros as specified in the Gray Paper\n    const extendedCode = new Uint8Array(this.state.code.length + 16)\n    extendedCode.set(this.state.code)\n    // Zeros are already initialized by Uint8Array constructor\n\n    // Extend bitmask to cover the padded zeros (all 1s = valid opcode positions)\n    // Gray Paper: \"appends k with a sequence of set bits in order to ensure a well-defined result\"\n    // Use 25 to match skip function's maximum distance (24 + 1 for safety)\n    const extendedBitmask = new Uint8Array(this.state.bitmask.length + 25)\n    extendedBitmask.set(this.state.bitmask)\n    extendedBitmask.fill(1, this.state.bitmask.length) // Fill remaining positions with 1s\n\n    this.state.code = extendedCode\n    this.state.bitmask = extendedBitmask\n\n    let resultCode: i32 = -1 // -1 means continue\n    while (resultCode === -1) {\n      const instructionIndex = this.state.programCounter\n\n      // Bounds check: instruction pointer must be within valid code range\n      if (instructionIndex < 0 || u32(instructionIndex) >= u32(extendedCode.length)) {\n        this.state.resultCode = RESULT_CODE_PANIC\n        return\n      }\n\n      const opcode = extendedCode[instructionIndex]\n\n      // Calculate Fskip(i) according to Gray Paper specification:\n      // Fskip(i) = min(24, j  N : (k  {1,1,.})_{i+1+j} = 1)\n      const fskip = this.skip(instructionIndex, extendedBitmask)\n      const instructionLength = 1 + fskip\n\n      // Extract operands from extended code (with zero padding)\n      const operands = extendedCode.slice(\n        instructionIndex + 1,\n        instructionIndex + instructionLength,\n      )\n\n      const instruction = new PVMInstruction(\n        opcode,\n        operands,\n        fskip,\n        this.state.programCounter,\n      )\n\n      resultCode = this.step(instruction)\n    }\n\n    // Convert i32 result code to u8 (resultCode >= 0 means halt with that code)\n    this.state.resultCode = resultCode >= 0 ? u8(resultCode) : RESULT_CODE_PANIC\n  }\n\n  /**\n   * Execute single instruction (Gray Paper )\n   * Instructions mutate the context in place\n   */\n  executeInstruction(instruction: PVMInstruction): i32 {\n    const handler = this.registry.getHandler(instruction.opcode)\n\n    if (!handler) {\n      return RESULT_CODE_PANIC\n    }\n\n    // Save PC before execution\n    const pcBefore = this.state.programCounter\n\n    // Create execution context (mutable)\n    const context = new InstructionContext(\n      this.state.code,\n      this.state.bitmask,\n      this.state.registerState,\n      this.state.programCounter,\n      this.state.gasCounter,\n      instruction.operands,\n      instruction.fskip,\n      this.state.jumpTable,\n      this.state.ram,\n    )\n\n    // Execute instruction (mutates context)\n    const result = handler.execute(context)\n\n    // Check result code BEFORE advancing PC\n    // -1 = continue, >= 0 = halt with that result code\n    if (result.resultCode !== -1) {\n      // Instruction returned a terminal result - don't advance PC\n      // If there's a fault address, store it in state\n      if (result.hasFaultAddress) {\n        this.state.faultAddress = result.faultAddress\n        this.state.hasFaultAddress = true\n      } else {\n        this.state.faultAddress = 0\n        this.state.hasFaultAddress = false\n      }\n      return u8(result.resultCode)\n    }\n\n    // Check if instruction modified PC (branches/jumps)\n    if (context.programCounter !== pcBefore) {\n      // Instruction modified PC (branch/jump) - already updated above\n      // Return -1 to continue execution (will be converted to null in TS)\n      this.state.programCounter = context.programCounter\n    } else {\n      // Normal flow - advance PC by instruction length (in bytes)\n      // Instruction length = 1 (opcode) + Fskip() according to Gray Paper\n      const instructionLength = 1 + instruction.fskip\n      this.state.programCounter += instructionLength\n    }\n\n    // Return -1 to continue execution\n    return -1\n  }\n\n  /**\n   * Reset to initial state\n   * Preserves the existing RAM instance but resets its state\n   * Resets all properties in-place for better performance\n   */\n  public reset(): void {\n    // Reset result code\n    this.state.resultCode = RESULT_CODE_HALT\n    \n    // Reset program counter\n    this.state.programCounter = 0\n    \n    // Reset all registers to zero (preserve registerState array)\n    for (let i = 0; i < 13; i++) {\n      this.state.registerState[i] = u64(0)\n    }\n    \n    // Reset RAM state (preserves RAM instance but clears its memory)\n    this.state.ram.reset()\n    \n    // Reset gas counter\n    this.state.gasCounter = u32(DEFAULT_GAS_LIMIT)\n    \n    // Reset jump table (clear array)\n    this.state.jumpTable = []\n    \n    // Reset code and bitmask (clear arrays)\n    this.state.code = new Uint8Array(0)\n    this.state.bitmask = new Uint8Array(0)\n    \n    // Reset fault address\n    this.state.faultAddress = 0\n    this.state.hasFaultAddress = false\n    \n    // Reset host call ID\n    this.state.hostCallId = 0\n  }\n\n  /**\n   * Get current state\n   */\n  public getState(): PVMState {\n    // Create a new PVMState with copied values\n    const newState = new PVMState(\n      this.state.registerState,\n      this.state.ram,\n      this.state.programCounter,\n      this.state.gasCounter,\n    )\n    newState.resultCode = this.state.resultCode\n    newState.jumpTable = this.state.jumpTable.slice()\n    newState.code = this.state.code.slice()\n    newState.bitmask = this.state.bitmask.slice()\n    newState.faultAddress = this.state.faultAddress\n    newState.hasFaultAddress = this.state.hasFaultAddress\n    newState.hostCallId = this.state.hostCallId\n    return newState\n  }\n\n\n  public accumulateInvocation(\n    gasLimit: u32,\n    program: Uint8Array,\n    args: Uint8Array,\n    context: Uint8Array,\n    numCores: i32,\n    numValidators: i32,\n    authQueueSize: i32,\n    entropyAccumulator: Uint8Array,\n    encodedWorkItems: Uint8Array,\n    configNumCores: i32 = 341,\n    configPreimageExpungePeriod: u32 = 19200,\n    configEpochDuration: u32 = 600,\n    configMaxBlockGas: u64 = u64(3500000000),\n    configTicketsPerValidator: u16 = 2,\n    configSlotDuration: u16 = 6,\n    configRotationPeriod: u16 = 10,\n    configNumValidators: u16 = 1023,\n  ): AccumulateInvocationResult {\n    const initialGas = gasLimit\n    \n    // Set up accumulation invocation (decodes context, initializes program, sets up state, extracts timeslot)\n    // setupAccumulateInvocation already decodes args and sets this.timeslot according to Gray Paper\n    this.setupAccumulateInvocation(\n      gasLimit,\n      program,\n      args,\n      context,\n      numCores,\n      numValidators,\n      authQueueSize,\n      entropyAccumulator,\n      encodedWorkItems,\n      configNumCores,\n      configPreimageExpungePeriod,\n      configEpochDuration,\n      configMaxBlockGas,\n      configTicketsPerValidator,\n      configSlotDuration,\n      configRotationPeriod,\n      configNumValidators,\n    )\n\n    // Gray Paper: Call core  function (_H) with context mutator\n    // The core  function (this.run) handles all PVM execution logic\n    // Pass null because setupAccumulateInvocation already set up state.code, state.bitmask, etc.\n    this.run(null) // null means use existing state.code (set by setupAccumulateInvocation)\n    \n    // After execution, extract final state\n    const finalGasCounter = this.state.gasCounter\n    const finalResultCode = this.state.resultCode\n    const finalRegisters = this.state.registerState\n    const finalMemory = this.state.ram\n\n    // Gray Paper equation 834: Calculate gas consumed\n    // u = gascounter - max(gascounter', 0)\n    const gasConsumed = initialGas - (finalGasCounter > 0 ? finalGasCounter : 0)\n\n    // Gray Paper equation 829-835: R function - extract result based on termination\n    const result = this.extractResultFromExecution(\n      finalResultCode,\n      finalRegisters,\n      finalMemory,\n    )\n    \n    // Encode final context (ImplicationsPair) - use the updated accumulationContext\n    if (!this.accumulationContext) {\n      abort(\n        `accumulateInvocation: accumulationContext is null after execution`\n      )\n      unreachable()\n    }\n    \n    const encodedContext = encodeImplicationsPair(\n      this.accumulationContext!,\n      numCores,\n      numValidators,\n      authQueueSize,\n    )\n    \n    // Clear accumulation context after execution\n    this.accumulationContext = null\n    \n    return new AccumulateInvocationResult(gasConsumed, result, encodedContext)\n  }\n\n  /**\n   * Set up accumulation invocation without executing\n   * This allows step-by-step execution after setup\n   */\n  public setupAccumulateInvocation(\n    gasLimit: u32,\n    program: Uint8Array,\n    args: Uint8Array,\n    context: Uint8Array,\n    numCores: i32,\n    numValidators: i32,\n    authQueueSize: i32,\n    entropyAccumulator: Uint8Array,\n    encodedWorkItems: Uint8Array,\n    configNumCores: i32 = 341,\n    configPreimageExpungePeriod: u32 = 19200,\n    configEpochDuration: u32 = 600,\n    configMaxBlockGas: u64 = u64(3500000000),\n    configMaxRefineGas: u64 = u64(5000000000),\n    configMaxTicketsPerExtrinsic: u16 = 16,\n    configTicketsPerValidator: u16 = 2,\n    configSlotDuration: u16 = 6,\n    configRotationPeriod: u16 = 10,\n    configNumValidators: u16 = 1023,\n    configNumEcPiecesPerSegment: u32 = 6,\n    configContestDuration: u32 = 500,\n    configMaxLookupAnchorage: u32 = 14400,\n    configEcPieceSize: u32 = 684,\n    jamVersionMajor: u8 = 0,\n    jamVersionMinor: u8 = 7,\n    jamVersionPatch: u8 = 2,\n  ): void {\n    // CRITICAL: Reset PVM state completely before each accumulation invocation\n    // This ensures no state leaks between invocations\n    this.reset()\n    \n    // Also clear accumulation-specific state\n    this.accumulationContext = null\n    this.entropyAccumulator = null\n    this.accumulateInputs = null\n    this.timeslot = u64(0)\n    \n    // Store config parameters\n    this.configNumCores = configNumCores\n    this.configPreimageExpungePeriod = configPreimageExpungePeriod\n    this.configEpochDuration = configEpochDuration\n    this.configMaxBlockGas = configMaxBlockGas\n    this.configMaxRefineGas = configMaxRefineGas\n    this.configMaxTicketsPerExtrinsic = configMaxTicketsPerExtrinsic\n    this.configTicketsPerValidator = configTicketsPerValidator\n    this.configSlotDuration = configSlotDuration\n    this.configRotationPeriod = configRotationPeriod\n    this.configNumValidators = configNumValidators\n    this.configNumEcPiecesPerSegment = configNumEcPiecesPerSegment\n    this.configContestDuration = configContestDuration\n    this.configMaxLookupAnchorage = configMaxLookupAnchorage\n    this.configEcPieceSize = configEcPieceSize\n    this.jamVersionMajor = jamVersionMajor\n    this.jamVersionMinor = jamVersionMinor\n    this.jamVersionPatch = jamVersionPatch\n    this.state.gasCounter = gasLimit\n    this.state.programCounter = 5 // initial PC for accumulate invocation\n    \n    // Decode accumulation context (ImplicationsPair)\n    const contextResult = decodeImplicationsPair(context, numCores, numValidators, authQueueSize)\n    if (!contextResult) {\n      abort(\n        `setupAccumulateInvocation: decodeImplicationsPair failed: context length=${context.length}, numCores=${numCores}, numValidators=${numValidators}, authQueueSize=${authQueueSize}`\n      )\n      unreachable()\n    }\n    \n    // Store accumulation context for HOST call handling\n    this.accumulationContext = contextResult!.value\n    \n    // Decode arguments to extract timeslot according to Gray Paper\n    // Gray Paper: encode(timeslot, serviceid, len(inputs))\n    const argsResult = decodeAccumulateArgs(args)\n    if (!argsResult) {\n      abort(\n        `setupAccumulateInvocation: Failed to decode arguments: args length=${args.length}`\n      )\n      unreachable()\n    }\n    \n    // Extract timeslot from decoded arguments\n    // argsResult is guaranteed to be non-null after the check above\n    this.timeslot = argsResult!.value.timeslot\n    \n    // Store entropy accumulator for FETCH host function\n    this.entropyAccumulator = entropyAccumulator\n    \n    // Decode and store accumulate inputs for FETCH host function (selectors 14 and 15)\n    // encodedWorkItems is now actually encoded AccumulateInputs\n    // Gray Paper pvm_invocations.tex lines 359-360:\n    // - Selector 14: encode{var{i}} - sequence of AccumulateInputs\n    // - Selector 15: encode{i[registers[11]]} - single AccumulateInput\n    // Should always be present (even if empty, it's encoded as length prefix 0 = 0x00)\n    if (encodedWorkItems.length === 0) {\n      // Truly empty (no data at all) - this shouldn't happen if we always encode\n      // But handle it gracefully by setting empty array\n      this.accumulateInputs = new Array<AccumulateInput>()\n    } else {\n      const inputsResult = decodeVariableSequence<AccumulateInput>(\n        encodedWorkItems,\n        (data: Uint8Array) => decodeAccumulateInput(data),\n      )\n      if (inputsResult) {\n        this.accumulateInputs = inputsResult.value\n        // accumulateInputs is now an array (possibly empty, but never null)\n      } else {\n        // Decoding failed - this is a problem\n        abort(\n          `setupAccumulateInvocation: decodeVariableSequence failed for encodedAccumulateInputs.length=${encodedWorkItems.length}`\n        )\n        unreachable()\n      }\n    }\n    \n    // Set PVM instance on FetchHostFunction so it can access config values\n    const fetchHandler = this.hostFunctionRegistry.get(GENERAL_FUNCTIONS.FETCH)\n    if (fetchHandler) {\n      const fetchHostFunction = fetchHandler as FetchHostFunction\n      fetchHostFunction.setPvmInstance(this)\n    }\n    \n    // Initialize program (decodes preimage and sets up memory/registers)\n    const codeBlob = this.initializeProgram(program, args)\n    if (!codeBlob) {\n      abort(\n        `setupAccumulateInvocation: initializeProgram failed: program length=${program.length}, args length=${args.length}`\n      )\n      unreachable()\n    }\n    \n    // Verify that state.code and state.bitmask were set by initializeProgram\n    if (this.state.code.length === 0 || this.state.bitmask.length === 0) {\n      abort(\n        `setupAccumulateInvocation: initializeProgram succeeded but state not set: code.length=${this.state.code.length}, bitmask.length=${this.state.bitmask.length}`\n      )\n      unreachable()\n    }\n    \n    // Don't call run() - caller will step through manually\n  }\n\n  /**\n   * Set accumulate inputs for FETCH host function\n   * This is called from the WASM executor to provide accumulate inputs for selectors 14 and 15\n   */\n  public setAccumulateInputs(inputs: Array<AccumulateInput> | null): void {\n    this.accumulateInputs = inputs\n  }\n\n  /**\n   * Set up refine invocation without executing\n   * Gray Paper equation 78-89: _R(coreIndex, workItemIndex, workPackage, authorizerTrace, importSegments, exportSegmentOffset)\n   * \n   * This sets up the refine context and initializes the program for step-by-step execution.\n   * Host functions will access the refine context through this.refineContext.\n   * \n   * @param gasLimit - Gas limit for execution (from work item refgaslimit)\n   * @param program - Service code blob (preimage format)\n   * @param args - Encoded refine arguments: encode{c, i, w.serviceindex, var{w.payload}, blake{p}}\n   * @param workPackage - Work package (for FETCH host function)\n   * @param authorizerTrace - Authorizer trace (for FETCH host function)\n   * @param importSegments - Import segments (for FETCH host function)\n   * @param exportSegmentOffset - Export segment offset (for EXPORT host function)\n   * @param serviceAccount - Service account (for HISTORICAL_LOOKUP host function)\n   * @param lookupAnchorTimeslot - Lookup anchor timeslot (for HISTORICAL_LOOKUP host function)\n   */\n  public setupRefineInvocation(\n    gasLimit: u32,\n    program: Uint8Array,\n    args: Uint8Array,\n    workPackage: WorkPackage | null,\n    authorizerTrace: Uint8Array | null,\n    importSegments: Array<Array<Uint8Array>> | null,\n    exportSegmentOffset: u32,\n    serviceAccount: CompleteServiceAccount | null,\n    lookupAnchorTimeslot: u64,\n  ): void {\n    // CRITICAL: Reset PVM state completely before each refine invocation\n    // This ensures no state leaks between invocations\n    this.reset()\n    \n    // Clear refine-specific state\n    this.refineContext = null\n    this.refineWorkPackage = null\n    this.refineAuthorizerTrace = null\n    this.refineImportSegments = null\n    this.refineExportSegmentOffset = 0\n    this.refineServiceAccount = null\n    this.refineLookupAnchorTimeslot = u64(0)\n    this.accumulationContext = null\n    this.entropyAccumulator = null\n    this.accumulateInputs = null\n    this.timeslot = u64(0)\n    \n    // Store refine invocation parameters for host functions\n    this.refineWorkPackage = workPackage\n    this.refineAuthorizerTrace = authorizerTrace\n    this.refineImportSegments = importSegments\n    this.refineExportSegmentOffset = exportSegmentOffset\n    this.refineServiceAccount = serviceAccount\n    this.refineLookupAnchorTimeslot = lookupAnchorTimeslot\n    \n    // Initialize refine context (Gray Paper: (, ) - empty machines dict and empty export segments)\n    this.refineContext = new RefineInvocationContext()\n    \n    // Set gas and program counter\n    // Gray Paper equation 86: Initial PC = 0 (not 5 like accumulate)\n    this.state.gasCounter = gasLimit\n    this.state.programCounter = 0\n    \n    // Initialize program using Gray Paper Y function\n    // This decodes the preimage blob and sets up code, bitmask, and jumpTable\n    const codeBlob = this.initializeProgram(program, args)\n    \n    if (!codeBlob) {\n      abort(\n        `setupRefineInvocation: initializeProgram failed: program length=${program.length}, args length=${args.length}`\n      )\n      unreachable()\n    }\n    \n    // Verify that state.code and state.bitmask were set by initializeProgram\n    if (this.state.code.length === 0 || this.state.bitmask.length === 0) {\n      abort(\n        `setupRefineInvocation: initializeProgram succeeded but state not set: code.length=${this.state.code.length}, bitmask.length=${this.state.bitmask.length}`\n      )\n      unreachable()\n    }\n    \n    // Don't call run() - caller will step through manually\n  }\n\n  /**\n   * Reset PVM with program, registers, and gas\n   * \n   * Resets the PVM state and sets up a new program execution context.\n   * Uses preimage format for program decoding (Gray Paper Y function).\n   * \n   * @param programBlob - Program blob in preimage format to decode\n   * @param registers - Initial register values (13 x 8 bytes = 104 bytes, little-endian)\n   * @param gas - Initial gas amount\n   */\n  public resetGeneric(programBlob: Uint8Array, registers: Uint8Array, gas: u32): void {\n    // First reset the PVM state\n    this.reset()\n    \n    // Use initializeProgram (Gray Paper Y function) to decode the program\n    // Pass empty argument data for now (WASM wrapper doesn't use marshalling invocation)\n    const argumentData = new Uint8Array(0)\n    const codeBlob = this.initializeProgram(programBlob, argumentData)\n    \n    if (!codeBlob) {\n      this.state.resultCode = RESULT_CODE_PANIC\n      return\n    }\n    \n    // Decode the code blob to get code, bitmask, and jumpTable\n    const decoded = decodeBlob(codeBlob)\n    if (!decoded) {\n      this.state.resultCode = RESULT_CODE_PANIC\n      return\n    }\n    \n    // Set decoded program state\n    this.state.code = decoded.code\n    this.state.bitmask = decoded.bitmask\n    this.state.jumpTable = decoded.jumpTable\n    \n    // Decode registers from Uint8Array (13 registers x 8 bytes each, little-endian)\n    if (registers.length === 13 * 8) {\n      for (let i: i32 = 0; i < 13; i++) {\n        const offset = i * 8\n        // Read little-endian u64\n        let value: u64 = u64(0)\n        value |= u64(registers[offset])\n        value |= u64(registers[offset + 1]) << 8\n        value |= u64(registers[offset + 2]) << 16\n        value |= u64(registers[offset + 3]) << 24\n        value |= u64(registers[offset + 4]) << 32\n        value |= u64(registers[offset + 5]) << 40\n        value |= u64(registers[offset + 6]) << 48\n        value |= u64(registers[offset + 7]) << 56\n        this.state.registerState[i] = value\n      }\n    }\n    \n    // Set gas and program counter\n    this.state.gasCounter = gas\n    this.state.programCounter = 0\n  }\n\n  /**\n   * Get parser instance\n   * \n   * Returns a PVMParser instance for parsing program blobs.\n   * Used by WASM wrapper to parse programs before execution.\n   * \n   * @returns PVMParser instance\n   */\n  public getParser(): PVMParser {\n    return new PVMParser()\n  }\n}\n","import { AssignHostFunction } from './assign'\nimport { BaseAccumulateHostFunction } from './base'\nimport { BlessHostFunction } from './bless'\nimport { CheckpointHostFunction } from './checkpoint'\nimport { DesignateHostFunction } from './designate'\nimport { EjectHostFunction } from './eject'\nimport { ForgetHostFunction } from './forget'\nimport { NewHostFunction } from './new'\nimport { ProvideHostFunction } from './provide'\nimport { QueryHostFunction } from './query'\nimport { SolicitHostFunction } from './solicit'\nimport { TransferHostFunction } from './transfer'\nimport { UpgradeHostFunction } from './upgrade'\nimport { YieldHostFunction } from './yield'\n\n/**\n * Registry for managing all accumulation host functions\n *\n * Similar to the general host function registry, this maintains a mapping of\n * function IDs to their corresponding implementations for accumulation operations.\n */\nexport class AccumulateHostFunctionRegistry {\n  handlers: Map<u64, BaseAccumulateHostFunction> = new Map()\n\n  constructor() {\n    this.registerAccumulateHostFunctions()\n  }\n\n  registerAccumulateHostFunctions(): void {\n    this.register(new AssignHostFunction())\n    this.register(new BlessHostFunction())\n    this.register(new CheckpointHostFunction())\n    this.register(new DesignateHostFunction())\n    this.register(new EjectHostFunction())\n    this.register(new ForgetHostFunction())\n    this.register(new NewHostFunction())\n    this.register(new ProvideHostFunction())\n    this.register(new QueryHostFunction())\n    this.register(new SolicitHostFunction())\n    this.register(new TransferHostFunction())\n    this.register(new UpgradeHostFunction())\n    this.register(new YieldHostFunction())\n  }\n\n  register(hostFunction: BaseAccumulateHostFunction): void {\n    this.handlers.set(hostFunction.functionId, hostFunction)\n  }\n\n  get(functionId: u64): BaseAccumulateHostFunction | null {\n    if (this.handlers.has(functionId)) {\n      return this.handlers.get(functionId)!\n    }\n    return null\n  }\n}\n","import { RESULT_CODE_PANIC } from '../../config'\nimport {\n  ACCUMULATE_ERROR_CORE,\n  ACCUMULATE_ERROR_HUH,\n  ACCUMULATE_ERROR_OOB,\n  AccumulateHostFunctionContext,\n  BaseAccumulateHostFunction,\n  HostFunctionResult,\n} from './base'\n\n/**\n * ASSIGN accumulation host function (_A)\n *\n * Assigns core to service account\n *\n * Gray Paper Specification:\n * - Function ID: 15 (assign)\n * - Gas Cost: 10\n * - Parameters: registers[7-9] = c, o, a\n *   - c: core index\n *   - o: auth queue offset in memory\n *   - a: service account ID to assign\n * - Returns: registers[7] = OK or error code\n *\n * Gray Paper Logic:\n * 1. Read auth queue from memory (80 entries * 32 bytes each)\n * 2. Check if core index is valid (< 341)\n * 3. Check if current service is the assigner for this core\n * 4. Check if service account ID is valid\n * 5. Update auth queue and assigner for the core\n */\nexport class AssignHostFunction extends BaseAccumulateHostFunction {\n  functionId: u64 = u64(15) // ASSIGN function ID\n  name: string = 'assign'\n  gasCost: u64 = u64(10)\n\n  // Gray Paper constants\n  C_AUTH_QUEUE_SIZE: u64 = u64(80) // Cauthqueuesize\n\n  execute(context: AccumulateHostFunctionContext): HostFunctionResult {\n    const registers = context.registers\n    const ram = context.ram\n    const implications = context.implications\n    const numCores = context.numCores // Get from config via context\n    \n    // Extract parameters from registers\n    const coreIndex = u64(registers[7])\n    const authQueueOffset = u64(registers[8])\n    const serviceIdToAssign = u64(registers[9])\n\n    // Read auth queue from memory (80 entries * 32 bytes each)\n    const authQueueLength = this.C_AUTH_QUEUE_SIZE * u64(32)\n    const readResult1 = ram.readOctets(\n      u32(authQueueOffset),\n      u32(authQueueLength),\n    )\n    const authQueueData = readResult1.data\n    const faultAddress = readResult1.faultAddress\n    // Note: jamduna sets OOB on memory faults before PANIC to indicate why it failed\n    // According to GP, registers[7] should be unchanged, but we set OOB to match jamduna behavior\n    if (faultAddress !== 0 || authQueueData === null) {\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_OOB)\n      return new HostFunctionResult(RESULT_CODE_PANIC)\n    }\n\n    // Parse auth queue (32 bytes per entry)\n    const authQueue: Uint8Array[] = []\n    for (let i: i32 = 0; i < i32(this.C_AUTH_QUEUE_SIZE); i++) {\n      const entry = authQueueData.slice(i * 32, (i + 1) * 32)\n      authQueue.push(entry)\n    }\n\n    // Check if core index is valid\n    // Gray Paper: c >= Ccorecount\n    if (coreIndex >= u64(numCores)) {\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_CORE)\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Get the current implications context\n    const imX = implications.regular\n\n    // Check if current service is the assigner for this core\n    // Gray Paper: imX.id !== imX.state.assigners[c]\n    const coreIndexI32 = i32(coreIndex)\n    if (coreIndexI32 >= imX.state.assigners.length) {\n      // Extend assigners array if needed\n      while (imX.state.assigners.length <= coreIndexI32) {\n        imX.state.assigners.push(u32(0))\n      }\n    }\n    if (imX.id !== u64(imX.state.assigners[coreIndexI32])) {\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_HUH)\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Note: TypeScript version only checks for negative service IDs\n    // Service ID 0 is a valid service ID in JAM\n\n    // Update auth queue and assigner for the core\n    // Gray Paper: imX.state.authqueue[c] = q, imX.state.assigners[c] = a\n    // Extend authqueue array if needed\n    if (coreIndexI32 >= imX.state.authqueue.length) {\n      while (imX.state.authqueue.length <= coreIndexI32) {\n        imX.state.authqueue.push([] as Uint8Array[])\n      }\n    }\n    imX.state.authqueue[coreIndexI32] = authQueue\n    imX.state.assigners[coreIndexI32] = u32(serviceIdToAssign)\n\n    // Set success result\n    this.setAccumulateSuccess(registers)\n    return new HostFunctionResult(255) // continue execution\n  }\n}\n","import { RESULT_CODE_PANIC } from '../../config'\nimport { AlwaysAccerEntry } from '../../codec'\nimport {\n  ACCUMULATE_ERROR_WHO,\n  AccumulateHostFunctionContext,\n  BaseAccumulateHostFunction,\n  HostFunctionResult,\n} from './base'\n\n/**\n * BLESS accumulation host function (_B)\n *\n * Empowers service with manager, assigners, delegator, registrar, and always accessors\n *\n * Gray Paper Specification:\n * - Function ID: 14 (bless)\n * - Gas Cost: 10\n * - Parameters: registers[7-12] = m, a, v, r, o, n\n *   - m: manager service ID\n *   - a: assigners array offset in memory\n *   - v: delegator service ID\n *   - r: registrar service ID\n *   - o: always accessors array offset in memory\n *   - n: number of always accessors\n * - Returns: registers[7] = OK or error code\n *\n * Gray Paper Logic:\n * 1. Read assigners array from memory (341 cores * 4 bytes each)\n * 2. Read always accessors array from memory (n entries * 12 bytes each)\n * 3. Validate service IDs are valid\n * 4. Update state with new privileges\n */\nexport class BlessHostFunction extends BaseAccumulateHostFunction {\n  functionId: u64 = u64(14) // BLESS function ID\n  name: string = 'bless'\n  gasCost: u64 = u64(10)\n\n  execute(context: AccumulateHostFunctionContext): HostFunctionResult {\n    const registers = context.registers\n    const ram = context.ram\n    const implications = context.implications\n    const numCores = context.numCores // Get from config via context\n    \n    // Extract parameters from registers\n    const managerServiceId = u64(registers[7])\n    const assignersOffset = u64(registers[8])\n    const delegatorServiceId = u64(registers[9])\n    const registrarServiceId = u64(registers[10])\n    const alwaysAccessorsOffset = u64(registers[11])\n    const numberOfAlwaysAccessors = u64(registers[12])\n\n    // Read assigners array from memory (Ccorecount * 4 bytes each)\n    // Gray Paper pvm_invocations.tex lines 696-699:\n    // a = decode[4]{memory[a:4*Ccorecount]} when Nrange(a,4*Ccorecount)  readable(memory), error otherwise\n    const assignersLength = u64(numCores) * u64(4)\n    const readResult_assigners = ram.readOctets(\n      u32(assignersOffset),\n      u32(assignersLength),\n    )\n    // Gray Paper: PANIC but registers[7] should remain UNCHANGED\n    // Do NOT call setAccumulateError - just return PANIC\n    if (readResult_assigners.faultAddress !== 0 || readResult_assigners.data === null) {\n      return new HostFunctionResult(RESULT_CODE_PANIC)\n    }\n    const assignersData = readResult_assigners.data!\n\n    // Read always accessors array from memory (n entries * 12 bytes each)\n    const accessorsLength = numberOfAlwaysAccessors * u64(12)\n    const readResult_accessors = ram.readOctets(\n      u32(alwaysAccessorsOffset),\n      u32(accessorsLength),\n    )\n    // Gray Paper: PANIC but registers[7] should remain UNCHANGED\n    if (readResult_accessors.faultAddress !== 0 || readResult_accessors.data === null) {\n      return new HostFunctionResult(RESULT_CODE_PANIC)\n    }\n    const accessorsData = readResult_accessors.data!\n\n    // Parse assigners array (4 bytes per core ID, little-endian)\n    const assigners: u32[] = []\n    for (let i: i32 = 0; i < i32(numCores); i++) {\n      const offset = i * 4\n      // Read 4 bytes as little-endian u32\n      let coreId: u32 = u32(0)\n      coreId |= u32(assignersData[offset])\n      coreId |= u32(assignersData[offset + 1]) << 8\n      coreId |= u32(assignersData[offset + 2]) << 16\n      coreId |= u32(assignersData[offset + 3]) << 24\n      assigners.push(coreId)\n    }\n\n    // Parse always accessors array (12 bytes per accessor: 4 bytes service ID + 8 bytes gas, little-endian)\n    const alwaysAccessors: Array<AlwaysAccerEntry> = []\n    for (let i: i32 = 0; i < i32(numberOfAlwaysAccessors); i++) {\n      const offset = i * 12\n      // Read service ID (4 bytes, little-endian)\n      let serviceId: u32 = u32(0)\n      serviceId |= u32(accessorsData[offset])\n      serviceId |= u32(accessorsData[offset + 1]) << 8\n      serviceId |= u32(accessorsData[offset + 2]) << 16\n      serviceId |= u32(accessorsData[offset + 3]) << 24\n      // Read gas (8 bytes, little-endian)\n      let gas: u64 = u64(0)\n      gas |= u64(accessorsData[offset + 4])\n      gas |= u64(accessorsData[offset + 5]) << 8\n      gas |= u64(accessorsData[offset + 6]) << 16\n      gas |= u64(accessorsData[offset + 7]) << 24\n      gas |= u64(accessorsData[offset + 8]) << 32\n      gas |= u64(accessorsData[offset + 9]) << 40\n      gas |= u64(accessorsData[offset + 10]) << 48\n      gas |= u64(accessorsData[offset + 11]) << 56\n      alwaysAccessors.push(new AlwaysAccerEntry(serviceId, gas))\n    }\n\n    // Validate service IDs\n    // Gray Paper line 706: (m, v, r) not in serviceid^3  return WHO\n    // serviceid  Nbits{32} (Gray Paper definitions.tex line 15, accounts.tex line 7)\n    // So each service ID must be: 0  id < 2^32\n    const MAX_SERVICE_ID: u64 = u64(4294967296) // 2^32\n    const isValidServiceId = (id: u64): bool => {\n      return id < MAX_SERVICE_ID\n    }\n\n    if (\n      !isValidServiceId(managerServiceId) ||\n      !isValidServiceId(delegatorServiceId) ||\n      !isValidServiceId(registrarServiceId)\n    ) {\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_WHO)\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Update state with new privileges\n    // Gray Paper: imX.state = {manager: m, assigners: a, delegator: v, registrar: r, alwaysaccers: z}\n    const imX = implications.regular\n    imX.state.manager = u32(managerServiceId)\n    imX.state.assigners = assigners\n    imX.state.delegator = u32(delegatorServiceId)\n    imX.state.registrar = u32(registrarServiceId)\n    imX.state.alwaysaccers = alwaysAccessors\n\n    // Set success result\n    this.setAccumulateSuccess(registers)\n    return new HostFunctionResult(255) // continue execution\n  }\n}\n","import {\n  AccumulateHostFunctionContext,\n  BaseAccumulateHostFunction,\n  HostFunctionResult,\n  Implications,\n} from './base'\nimport {\n  PartialState,\n  AccountEntry,\n  CompleteServiceAccount,\n  AlwaysAccerEntry,\n  DeferredTransfer,\n  ProvisionEntry,\n  CshEntry,\n  RawCshKeyvals,\n} from '../../codec'\n\nexport class CheckpointHostFunction extends BaseAccumulateHostFunction {\n  functionId: u64 = u64(17) // CHECKPOINT function ID\n  name: string = 'checkpoint'\n  gasCost: u64 = u64(10)\n\n  execute(context: AccumulateHostFunctionContext): HostFunctionResult {\n    // Gray Paper line 748-753: _C (checkpoint)\n    // imY' = imX (copy regular dimension to exceptional dimension)\n    // registers'_7 = gascounter' (set registers[7] to gas counter after decrement)\n    const registers = context.registers\n    const implications = context.implications\n    const gasCounter = context.gasCounter\n    const imX = implications.regular\n\n    // Gray Paper line 752: imY' = imX\n    // Deep copy imX to imY to create the checkpoint\n    // This creates a rollback point for exceptional termination (OOG or panic)\n    // NOTE: We MUST do a deep copy, not a reference copy, because:\n    // 1. After checkpoint, execution continues and modifies imX (regular dimension)\n    // 2. If imY was just a reference to imX, those modifications would also affect imY\n    // 3. When rolling back to imY on panic/OOG, we'd get the modified state instead of the checkpoint\n    const checkpointState = new Implications()\n    checkpointState.id = imX.id\n    checkpointState.state = this.deepCopyPartialState(imX.state)\n    checkpointState.nextfreeid = imX.nextfreeid\n    checkpointState.xfers = this.deepCopyXfers(imX.xfers)\n    checkpointState.yield = imX.yield !== null ? this.copyUint8Array(imX.yield!) : null\n    checkpointState.provisions = this.deepCopyProvisions(imX.provisions)\n\n    // Set the exceptional dimension to the checkpoint\n    implications.exceptional = checkpointState\n\n    // Gray Paper line 753: registers'_7 = gascounter'\n    // Note: gasCounter passed here is already gascounter' (after gas cost deduction by the executor)\n    // So we should return gasCounter directly, not gasCounter - gasCost\n    this.setAccumulateSuccess(registers, gasCounter)\n\n    return new HostFunctionResult(255) // continue execution\n  }\n\n  /**\n   * Deep copy a Uint8Array\n   */\n  private copyUint8Array(arr: Uint8Array): Uint8Array {\n    const copy = new Uint8Array(arr.length)\n    copy.set(arr)\n    return copy\n  }\n\n  /**\n   * Deep copy PartialState including all nested structures\n   * Gray Paper: Must create a complete snapshot for rollback capability\n   */\n  private deepCopyPartialState(state: PartialState): PartialState {\n    const copy = new PartialState()\n    \n    // Deep copy accounts array with nested ServiceAccount structures\n    copy.accounts = new Array<AccountEntry>(state.accounts.length)\n    for (let i = 0; i < state.accounts.length; i++) {\n      const entry = state.accounts[i]\n      copy.accounts[i] = new AccountEntry(entry.serviceId, this.deepCopyServiceAccount(entry.account))\n    }\n    \n    // Deep copy stagingset\n    copy.stagingset = new Array<Uint8Array>(state.stagingset.length)\n    for (let i = 0; i < state.stagingset.length; i++) {\n      copy.stagingset[i] = this.copyUint8Array(state.stagingset[i])\n    }\n    \n    // Deep copy authqueue (array of arrays)\n    copy.authqueue = new Array<Array<Uint8Array>>(state.authqueue.length)\n    for (let i = 0; i < state.authqueue.length; i++) {\n      const innerArray = state.authqueue[i]\n      copy.authqueue[i] = new Array<Uint8Array>(innerArray.length)\n      for (let j = 0; j < innerArray.length; j++) {\n        copy.authqueue[i][j] = this.copyUint8Array(innerArray[j])\n      }\n    }\n    \n    // Copy primitive fields\n    copy.manager = state.manager\n    copy.delegator = state.delegator\n    copy.registrar = state.registrar\n    \n    // Deep copy assigners\n    copy.assigners = new Array<u32>(state.assigners.length)\n    for (let i = 0; i < state.assigners.length; i++) {\n      copy.assigners[i] = state.assigners[i]\n    }\n    \n    // Deep copy alwaysaccers\n    copy.alwaysaccers = new Array<AlwaysAccerEntry>(state.alwaysaccers.length)\n    for (let i = 0; i < state.alwaysaccers.length; i++) {\n      const entry = state.alwaysaccers[i]\n      copy.alwaysaccers[i] = new AlwaysAccerEntry(entry.serviceId, entry.gas)\n    }\n    \n    return copy\n  }\n\n  /**\n   * Deep copy ServiceAccount including rawCshKeyvals\n   */\n  private deepCopyServiceAccount(account: CompleteServiceAccount): CompleteServiceAccount {\n    const copy = new CompleteServiceAccount()\n    copy.codehash = this.copyUint8Array(account.codehash)\n    copy.balance = account.balance\n    copy.minaccgas = account.minaccgas\n    copy.minmemogas = account.minmemogas\n    copy.octets = account.octets\n    copy.gratis = account.gratis\n    copy.items = account.items\n    copy.created = account.created\n    copy.lastacc = account.lastacc\n    copy.parent = account.parent\n    \n    // Deep copy rawCshKeyvals\n    copy.rawCshKeyvals = new RawCshKeyvals()\n    const keys = account.rawCshKeyvals.keys()\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i]\n      const value = account.rawCshKeyvals.get(key)\n      if (value !== null) {\n        copy.rawCshKeyvals.set(this.copyUint8Array(key), this.copyUint8Array(value))\n      }\n    }\n    \n    return copy\n  }\n\n  /**\n   * Deep copy deferred transfers array\n   */\n  private deepCopyXfers(xfers: Array<DeferredTransfer>): Array<DeferredTransfer> {\n    const copy = new Array<DeferredTransfer>(xfers.length)\n    for (let i = 0; i < xfers.length; i++) {\n      const xfer = xfers[i]\n      const xferCopy = new DeferredTransfer()\n      xferCopy.source = xfer.source\n      xferCopy.dest = xfer.dest\n      xferCopy.amount = xfer.amount\n      xferCopy.memo = this.copyUint8Array(xfer.memo)\n      xferCopy.gasLimit = xfer.gasLimit\n      copy[i] = xferCopy\n    }\n    return copy\n  }\n\n  /**\n   * Deep copy provisions array\n   */\n  private deepCopyProvisions(provisions: Array<ProvisionEntry>): Array<ProvisionEntry> {\n    const copy = new Array<ProvisionEntry>(provisions.length)\n    for (let i = 0; i < provisions.length; i++) {\n      const entry = provisions[i]\n      copy[i] = new ProvisionEntry(entry.serviceId, this.copyUint8Array(entry.blob))\n    }\n    return copy\n  }\n}\n","import { RESULT_CODE_PANIC } from '../../config'\nimport {\n  ACCUMULATE_ERROR_HUH,\n  AccumulateHostFunctionContext,\n  BaseAccumulateHostFunction,\n  HostFunctionResult,\n} from './base'\n\n/**\n * DESIGNATE accumulation host function (_D)\n *\n * Designates validators (only delegator can do this)\n *\n * Gray Paper Specification:\n * - Function ID: 16 (designate)\n * - Gas Cost: 10\n * - Parameters: registers[7] = o\n *   - o: validators array offset in memory\n * - Returns: registers[7] = OK or error code\n *\n * Gray Paper Logic:\n * 1. Read validators array from memory (336 bytes per validator, up to Cvalcount validators)\n * 2. Check if current service is the delegator (imX.id === imX.state.ps_delegator)\n * 3. Update staging set with new validators\n * 4. Return OK on success, HUH if not delegator, PANIC on error\n */\nexport class DesignateHostFunction extends BaseAccumulateHostFunction {\n  functionId: u64 = u64(16) // DESIGNATE function ID\n  name: string = 'designate'\n  gasCost: u64 = u64(10)\n\n  // Gray Paper constants\n  VALIDATOR_SIZE: i32 = 336 // bytes per validator\n\n  execute(context: AccumulateHostFunctionContext): HostFunctionResult {\n    const registers = context.registers\n    const ram = context.ram\n    const implications = context.implications\n    const numValidators = context.numValidators // Get from config via context\n    \n    // Get the current implications context\n    const imX = implications.regular\n\n    // Extract parameters from registers\n    const validatorsOffset = u64(registers[7])\n\n    // Read validators array from memory (336 bytes per validator, up to Cvalcount validators)\n    // Gray Paper: sequence[Cvalcount]{valkey} where Cvalcount comes from config\n    // Gray Paper: v = sequence{memory[o+336i:336] for i in valindex} when readable, error otherwise\n    const totalSize = this.VALIDATOR_SIZE * i32(numValidators)\n\n    const readResult_validators = ram.readOctets(\n      u32(validatorsOffset),\n      u32(totalSize),\n    )\n    \n    // Gray Paper: (panic, registers_7, stagingset) when v = error\n    // Check memory read FIRST (before delegator check) per Gray Paper order\n    // DO NOT modify registers[7] - it must remain unchanged on panic\n    if (readResult_validators.faultAddress !== 0 || readResult_validators.data === null) {\n      return new HostFunctionResult(RESULT_CODE_PANIC)\n    }\n    const validatorsData = readResult_validators.data!\n\n    // Gray Paper: (continue, HUH, stagingset) otherwhen imX_id  (imX_state)_ps_delegator\n    // Check delegator AFTER successful memory read per Gray Paper order\n    if (imX.id !== u64(imX.state.delegator)) {\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_HUH)\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Parse validators array (336 bytes per validator)\n    // Note: For AssemblyScript, we store raw validator data as Uint8Array\n    // Full implementation would decode ValidatorPublicKeys structure\n    const validators: Uint8Array[] = []\n    for (let i: i32 = 0; i < i32(numValidators); i++) {\n      const validatorData = validatorsData.slice(\n        i * this.VALIDATOR_SIZE,\n        (i + 1) * this.VALIDATOR_SIZE,\n      )\n      // Note: Would decode ValidatorPublicKeys here if codec available\n      // For now, store raw bytes\n      validators.push(validatorData)\n    }\n\n    // Update staging set with new validators\n    // Gray Paper: (imX'.state).ps_stagingset = v\n    imX.state.stagingset = validators\n\n    // Set success result\n    this.setAccumulateSuccess(registers)\n    return new HostFunctionResult(255) // continue execution\n  }\n}\n","import { encodeFixedLength, getRequestValue, decodeRequestTimeslots } from '../../codec'\nimport { RESULT_CODE_PANIC } from '../../config'\nimport {\n  ACCUMULATE_ERROR_HUH,\n  ACCUMULATE_ERROR_WHO,\n  AccumulateHostFunctionContext,\n  BaseAccumulateHostFunction,\n  HostFunctionResult,\n} from './base'\n\n/**\n * EJECT accumulation host function (_J)\n *\n * Ejects/removes service account\n *\n * Gray Paper Specification:\n * - Function ID: 21 (eject)\n * - Gas Cost: 10\n * - Parameters: registers[7-8] = d, o\n *   - d: service account ID to eject\n *   - o: hash offset in memory (32 bytes)\n * - Returns: registers[7] = OK or error code\n *\n * Gray Paper Logic:\n * 1. Read hash from memory at offset o (32 bytes)\n * 2. Get service account d from accounts dictionary\n * 3. Check if service account exists and is not the current service\n * 4. Verify the hash matches the service's code hash\n * 5. Check if the service has exactly 2 items and the request exists\n * 6. Check if the ejection period has expired (y < t - Cexpungeperiod)\n * 7. Remove the service account and transfer its balance to current service\n */\nexport class EjectHostFunction extends BaseAccumulateHostFunction {\n  functionId: u64 = u64(21) // EJECT function ID\n  name: string = 'eject'\n  gasCost: u64 = u64(10)\n\n  execute(context: AccumulateHostFunctionContext): HostFunctionResult {\n    const registers = context.registers\n    const ram = context.ram\n    const implications = context.implications\n    const timeslot = context.timeslot\n    const expungePeriod = context.expungePeriod\n    // Extract parameters from registers\n    const serviceIdToEject = u64(registers[7])\n    const hashOffset = u64(registers[8])\n\n    // Read hash from memory (32 bytes)\n    // Gray Paper line 851-854: h = memory[o:32] when Nrange(o,32)  readable(memory), error otherwise\n    const readResult_hash = ram.readOctets(u32(hashOffset), u32(32))\n    // Gray Paper line 862: panic when h = error, registers[7] unchanged\n    if (readResult_hash.faultAddress !== 0) {\n      return new HostFunctionResult(RESULT_CODE_PANIC)\n    }\n    if (readResult_hash.data === null) {\n      return new HostFunctionResult(RESULT_CODE_PANIC)\n    }\n    const hashData = readResult_hash.data!\n\n    // Get the current implications context\n    const imX = implications.regular\n\n    // Get service account d from accounts dictionary\n    // Gray Paper: d  imX.id  d  keys(imX.state.ps_accounts)\n    if (serviceIdToEject === imX.id) {\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_WHO)\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    const accountEntry = this.findAccountEntry(imX.state.accounts, serviceIdToEject)\n    if (accountEntry === null) {\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_WHO)\n      return new HostFunctionResult(255) // continue execution\n    }\n    const serviceAccount = accountEntry.account\n\n    // Verify the hash matches the service's code hash\n    // Gray Paper: d.sa_codehash  encode[32]{imX.id}\n    // Use encodeFixedLength for proper Gray Paper encoding\n    const expectedCodeHash = encodeFixedLength(imX.id, 32)\n    const serviceCodeHash = serviceAccount.codehash\n    if (!this.arraysEqual(serviceCodeHash, expectedCodeHash)) {\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_WHO)\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Calculate length: max(81, d.sa_octets) - 81\n    const octetsI32 = i32(serviceAccount.octets)\n    const l = max(81, octetsI32) - 81\n\n    // Check if the service has exactly 2 items and the request exists\n    // Gray Paper: d.sa_items  2  (h, l)  d.sa_requests\n    if (serviceAccount.items !== 2) {\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_HUH)\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Get request using rawCshKeyvals helper\n    const requestValue = getRequestValue(serviceAccount, u32(serviceIdToEject), hashData, u64(l))\n    if (requestValue === null) {\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_HUH)\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Decode the request timeslots\n    const timeslots = decodeRequestTimeslots(requestValue)\n    if (timeslots === null) {\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_HUH)\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Check if the ejection period has expired\n    // Gray Paper: d.sa_requests[h, l] = [x, y], y < t - Cexpungeperiod\n    // For test vectors, Cexpungeperiod = 32 (as per README)\n    // For production, Cexpungeperiod = 19200 (Gray Paper constant)\n    if (timeslots.length < 2 || u64(timeslots[1]) >= timeslot - expungePeriod) {\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_HUH)\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Transfer balance to current service and remove the ejected service\n    // Gray Paper: imX'.state.ps_accounts = imX.state.ps_accounts \\ {d}  {imX.id: s'}\n    // where s' = imX.self except s'.sa_balance = imX.self.sa_balance + d.sa_balance\n    const currentAccountEntry = this.findAccountEntry(imX.state.accounts, imX.id)\n    \n    if (currentAccountEntry === null) {\n      // Current service account not found - this should not happen but handle gracefully\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_WHO)\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Transfer balance: s'.sa_balance = imX.self.sa_balance + d.sa_balance\n    currentAccountEntry.account.balance += serviceAccount.balance\n\n    // Remove the ejected service account\n    for (let i = 0; i < imX.state.accounts.length; i++) {\n      if (u64(imX.state.accounts[i].serviceId) === serviceIdToEject) {\n        imX.state.accounts.splice(i, 1)\n        break\n      }\n    }\n\n    // Set success result\n    this.setAccumulateSuccess(registers)\n    return new HostFunctionResult(255) // continue execution\n  }\n\n  arraysEqual(a: Uint8Array, b: Uint8Array): bool {\n    if (a.length !== b.length) return false\n    for (let i: i32 = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false\n    }\n    return true\n  }\n}\n","import { RESULT_CODE_PANIC } from '../../config'\nimport {\n  getRequestValue,\n  setRequestValue,\n  deleteRequestValue,\n  deletePreimageValue,\n  decodeRequestTimeslots,\n  encodeRequestTimeslots,\n} from '../../codec'\nimport {\n  ACCUMULATE_ERROR_HUH,\n  AccumulateHostFunctionContext,\n  BaseAccumulateHostFunction,\n  HostFunctionResult,\n} from './base'\n\n/**\n * FORGET accumulation host function (_F)\n *\n * Forgets preimage request\n *\n * Gray Paper Specification:\n * - Function ID: 24 (forget)\n * - Gas Cost: 10\n * - Parameters: registers[7-8] = o, z\n *   - o: hash offset in memory (32 bytes)\n *   - z: size of the preimage\n * - Returns: registers[7] = OK or error code\n *\n * Gray Paper Logic:\n * 1. Read hash from memory at offset o (32 bytes)\n * 2. Get current service account from imX.self\n * 3. Check request status in sa_requests[h, z]:\n *    - [] (empty): Remove request and preimage completely\n *    - [x, y] where y < t - Cexpungeperiod: Remove request and preimage completely\n *    - [x]: Update to [x, t] (mark as unavailable)\n *    - [x, y, w] where y < t - Cexpungeperiod: Update to [w, t] (mark as unavailable again)\n *    - Otherwise: Error HUH (cannot forget)\n */\nexport class ForgetHostFunction extends BaseAccumulateHostFunction {\n  functionId: u64 = u64(24) // FORGET function ID (Gray Paper: 24)\n  name: string = 'forget'\n  gasCost: u64 = u64(10)\n\n  execute(context: AccumulateHostFunctionContext): HostFunctionResult {\n    const registers = context.registers\n    const ram = context.ram\n    const implications = context.implications\n    const timeslot = context.timeslot\n    const expungePeriod = context.expungePeriod\n    // Gray Paper line 204: _F receives H_timeslot (block header's timeslot)\n    // This is the current block's timeslot passed from the Accumulate invocation\n\n    // Extract parameters from registers\n    const hashOffset = u64(registers[7])\n    const preimageLength = u64(registers[8])\n\n    // Read hash from memory (32 bytes)\n    // Gray Paper line 924-927: h = memory[o:32] when Nrange(o,32)  readable(memory), error otherwise\n    const readResult_hash = ram.readOctets(u32(hashOffset), u32(32))\n    // Gray Paper line 941: panic when h = error, registers[7] unchanged\n    if (readResult_hash.faultAddress !== 0) {\n      return new HostFunctionResult(RESULT_CODE_PANIC)\n    }\n    if (readResult_hash.data === null) {\n      return new HostFunctionResult(RESULT_CODE_PANIC)\n    }\n    const hashData = readResult_hash.data!\n\n    // Get the current implications context\n    const imX = implications.regular\n\n    // Get current service account (imX.self)\n    // Gray Paper line 928-939: a = imX.self except modifications based on request state\n    const accountEntry = this.findAccountEntry(imX.state.accounts, imX.id)\n    if (accountEntry === null) {\n      // Gray Paper line 942: HUH when a = error\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_HUH)\n      return new HostFunctionResult(255) // continue execution\n    }\n    const serviceAccount = accountEntry.account\n\n    // Get request using rawCshKeyvals helper\n    const requestValue = getRequestValue(serviceAccount, u32(imX.id), hashData, preimageLength)\n    if (requestValue === null) {\n      // Gray Paper line 942: HUH when a = error (request doesn't exist)\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_HUH)\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Decode the request timeslots\n    const timeslots = decodeRequestTimeslots(requestValue)\n    if (timeslots === null) {\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_HUH)\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Apply Gray Paper logic for different request states (line 935-938)\n    if (timeslots.length === 0) {\n      // Case 1 (line 935): [] (empty) - Remove request and preimage completely\n      deleteRequestValue(serviceAccount, u32(imX.id), hashData, preimageLength)\n      deletePreimageValue(serviceAccount, u32(imX.id), hashData)\n      // Gray Paper: Update items and octets when removing a request\n      // items -= 2 for each removed request (h, z)\n      // octets -= (81 + z) for each removed request\n      if (serviceAccount.items >= u32(2)) {\n        serviceAccount.items -= u32(2)\n      } else {\n        serviceAccount.items = u32(0)\n      }\n      const octetsDelta = u64(81) + preimageLength\n      if (serviceAccount.octets >= octetsDelta) {\n        serviceAccount.octets -= octetsDelta\n      } else {\n        serviceAccount.octets = u64(0)\n      }\n    } else if (timeslots.length === 2) {\n      // Case 2 (line 935): [x, y] where y < t - Cexpungeperiod - Remove request and preimage completely\n      const y = u64(timeslots[1])\n      // Use y + expungePeriod < timeslot to avoid unsigned underflow when timeslot < expungePeriod\n      if (y + expungePeriod < timeslot) {\n        // Remove request and preimage completely\n        deleteRequestValue(serviceAccount, u32(imX.id), hashData, preimageLength)\n        deletePreimageValue(serviceAccount, u32(imX.id), hashData)\n        // Gray Paper: Update items and octets when removing a request\n        if (serviceAccount.items >= u32(2)) {\n          serviceAccount.items -= u32(2)\n        } else {\n          serviceAccount.items = u32(0)\n        }\n        const octetsDelta2 = u64(81) + preimageLength\n        if (serviceAccount.octets >= octetsDelta2) {\n          serviceAccount.octets -= octetsDelta2\n        } else {\n          serviceAccount.octets = u64(0)\n        }\n      } else {\n        // Gray Paper line 938: otherwise  error (HUH)\n        this.setAccumulateError(registers, ACCUMULATE_ERROR_HUH)\n        return new HostFunctionResult(255) // continue execution\n      }\n    } else if (timeslots.length === 1) {\n      // Case 3 (line 936): [x] - Update to [x, t] (mark as unavailable)\n      const x = timeslots[0]\n      const newTimeslots: u32[] = [x, u32(timeslot)]\n      setRequestValue(serviceAccount, u32(imX.id), hashData, preimageLength, encodeRequestTimeslots(newTimeslots))\n    } else if (timeslots.length === 3) {\n      // Case 4 (line 937): [x, y, w] where y < t - Cexpungeperiod - Update to [w, t]\n      const y = u64(timeslots[1])\n      const w = timeslots[2]\n      // Use y + expungePeriod < timeslot to avoid unsigned underflow when timeslot < expungePeriod\n      if (y + expungePeriod < timeslot) {\n        // Update to [w, t] (mark as unavailable again)\n        const newTimeslots2: u32[] = [w, u32(timeslot)]\n        setRequestValue(serviceAccount, u32(imX.id), hashData, preimageLength, encodeRequestTimeslots(newTimeslots2))\n      } else {\n        // Gray Paper line 938: otherwise  error (HUH)\n        this.setAccumulateError(registers, ACCUMULATE_ERROR_HUH)\n        return new HostFunctionResult(255) // continue execution\n      }\n    } else {\n      // Gray Paper line 938: otherwise  error (HUH)\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_HUH)\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Set success result\n    // Gray Paper line 943: OK when otherwise\n    this.setAccumulateSuccess(registers)\n    return new HostFunctionResult(255) // continue execution\n  }\n}\n","import { RESULT_CODE_PANIC } from '../../config'\nimport { CompleteServiceAccount, AccountEntry, setRequestValue, encodeRequestTimeslots } from '../../codec'\nimport {\n  ACCUMULATE_ERROR_CASH,\n  ACCUMULATE_ERROR_FULL,\n  ACCUMULATE_ERROR_HUH,\n  AccumulateHostFunctionContext,\n  BaseAccumulateHostFunction,\n  HostFunctionResult,\n  ServiceAccount,\n} from './base'\n\n/**\n * NEW accumulation host function (_N)\n *\n * Creates a new service account\n *\n * Gray Paper Specification:\n * - Function ID: 18 (new)\n * - Gas Cost: 10\n * - Parameters: registers[7-12] = o, l, minAccGas, minMemoGas, gratis, desiredId\n *   - o: code hash offset in memory\n *   - l: code hash length (should be 32)\n *   - minAccGas: minimum accumulation gas\n *   - minMemoGas: minimum memory gas\n *   - gratis: gratis flag (0 = paid, 1 = free)\n *   - desiredId: desired service ID (if gratis = 0)\n * - Returns: registers[7] = new service ID or error code\n *\n * Gray Paper Logic:\n * 1. Read code hash from memory (32 bytes)\n * 2. Check if current service is registrar (if gratis = 0)\n * 3. Check if current service has sufficient balance\n * 4. Create new service account with specified parameters\n * 5. Deduct minimum balance from current service\n * 6. Return new service ID\n */\nexport class NewHostFunction extends BaseAccumulateHostFunction {\n  functionId: u64 = u64(18) // NEW function ID\n  name: string = 'new'\n  gasCost: u64 = u64(10)\n\n  execute(context: AccumulateHostFunctionContext): HostFunctionResult {\n    const registers = context.registers\n    const ram = context.ram\n    const implications = context.implications\n    const timeslot = context.timeslot\n    // Gray Paper line 204: _F receives H_timeslot (block header's timeslot)\n    // This is the current block's timeslot passed from the Accumulate invocation\n\n    // Extract parameters from registers\n    // Gray Paper: (o, l, minaccgas, minmemogas, gratis, desiredid) = registers[7:6]\n    // o = code hash offset\n    // l = expected code length (NOT the hash length - hash is always 32 bytes)\n    const codeHashOffset = u64(registers[7])\n    const expectedCodeLength = u64(registers[8])  // Expected length of the code preimage\n    const minAccGas = u64(registers[9])\n    const minMemoGas = u64(registers[10])\n    const gratis = u64(registers[11])\n    const desiredId = u64(registers[12])\n\n    // Gray Paper: l must be a valid 32-bit number\n    // Gray Paper line 763: l  N_bits32, otherwise codehash = error  PANIC\n    // On PANIC, registers_7 remains unchanged - do NOT set error\n    if (expectedCodeLength > u64(0xFFFFFFFF)) {\n      return new HostFunctionResult(RESULT_CODE_PANIC)\n    }\n\n    // Gray Paper: codehash = memory[o:32] - ALWAYS read 32 bytes for the hash\n    // The hash is a blake2b hash which is always 32 bytes\n    const readResult_codeHash = ram.readOctets(\n      u32(codeHashOffset),\n      u32(32),  // Always read 32 bytes for the code hash\n    )\n    // Gray Paper: PANIC but registers_7 should remain UNCHANGED\n    // Do NOT call setAccumulateError - just return PANIC\n    if (readResult_codeHash.faultAddress !== 0 || readResult_codeHash.data === null) {\n      return new HostFunctionResult(RESULT_CODE_PANIC)\n    }\n    const codeHashData = readResult_codeHash.data!\n\n    // Get the current implications context\n    const imX = implications.regular\n\n    // Get current service account\n    const currentAccountEntry = this.findAccountEntry(imX.state.accounts, imX.id)\n    if (currentAccountEntry === null) {\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_HUH)\n      return new HostFunctionResult(255) // continue execution\n    }\n    const currentService = currentAccountEntry.account\n\n    // Gray Paper line 787: HUH when gratis != 0 AND service is not the manager\n    // Only the manager can create services with gratis (free deposit allowance)\n    if (gratis !== u64(0) && imX.id !== imX.state.manager) {\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_HUH)\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Calculate minimum balance required for the new service\n    // Gray Paper accounts.tex equation (deposits):\n    //   minbalance = max(0, Cbasedeposit + Citemdeposit * items + Cbytedeposit * octets - gratis)\n    // For a new service with one request entry (codehash, expectedCodeLength):\n    //   items = 2 * len(requests) + len(storage) = 2 * 1 + 0 = 2\n    //   octets = sum((81 + z) for (h, z) in keys(requests)) = 81 + expectedCodeLength\n    const C_BASE_DEPOSIT: u64 = u64(100)\n    const C_ITEM_DEPOSIT: u64 = u64(10)\n    const C_BYTE_DEPOSIT: u64 = u64(1)\n\n    const newServiceItems: u64 = u64(2) // 2 * 1 request + 0 storage\n    const newServiceOctets: u64 = u64(81) + expectedCodeLength // 81 + expected code length\n\n    // Gray Paper: minbalance = max(0, Cbasedeposit + Citemdeposit * items + Cbytedeposit * octets - gratis)\n    const minBalanceBeforeGratis: u64 =\n      C_BASE_DEPOSIT +\n      C_ITEM_DEPOSIT * newServiceItems +\n      C_BYTE_DEPOSIT * newServiceOctets\n    const minBalance: u64 =\n      minBalanceBeforeGratis > gratis ? minBalanceBeforeGratis - gratis : u64(0)\n\n    // Check if current service has sufficient balance\n    // Gray Paper line 786: CASH when s.balance < self.minbalance\n    // where s = imX_self exc s_sa_balance = (imX_self)_sa_balance - a_sa_minbalance\n    // So we check: (imX_self)_sa_balance - a_sa_minbalance < (imX_self)_sa_minbalance\n    \n    // First check for underflow (would result in negative balance)\n    if (currentService.balance < minBalance) {\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_CASH)\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Calculate balance after deduction\n    const balanceAfterDeduction = currentService.balance - minBalance\n\n    // Gray Paper line 786: Check if remaining balance is at least current service's minbalance\n    // Calculate current service's minbalance from its storage footprint\n    const currentServiceMinBalanceBeforeGratis: u64 =\n      C_BASE_DEPOSIT +\n      C_ITEM_DEPOSIT * u64(currentService.items) +\n      C_BYTE_DEPOSIT * currentService.octets\n    const currentServiceMinBalance: u64 =\n      currentServiceMinBalanceBeforeGratis > currentService.gratis\n        ? currentServiceMinBalanceBeforeGratis - currentService.gratis\n        : u64(0)\n\n    if (balanceAfterDeduction < currentServiceMinBalance) {\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_CASH)\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Determine new service ID\n    // Gray Paper lines 788-792:\n    // - If registrar and desiredId < Cminpublicindex: use desiredId, keep nextfreeid unchanged\n    // - Otherwise: use imX.nextfreeid directly, then update nextfreeid to i*\n    let newServiceId: u64\n    let updateNextFreeId = false\n    const C_MIN_PUBLIC_INDEX: u64 = u64(65536) // 2^16\n\n    if (gratis === u64(0) && imX.id === imX.state.registrar && desiredId < C_MIN_PUBLIC_INDEX) {\n      // Registrar creating reserved service with specific ID\n      // Gray Paper line 788: check if desired ID is already taken\n      if (this.hasAccountEntry(imX.state.accounts, desiredId)) {\n        this.setAccumulateError(registers, ACCUMULATE_ERROR_FULL)\n        return new HostFunctionResult(255) // continue execution\n      }\n      newServiceId = desiredId\n      // nextfreeid stays unchanged for registrar with reserved ID\n    } else {\n      // Non-registrar OR registrar with public ID - use imX.nextfreeid directly\n      // Gray Paper line 790: returns imX.nextfreeid as the new service ID\n      newServiceId = u64(imX.nextfreeid)\n      updateNextFreeId = true\n    }\n\n    // Create new service account\n    // Gray Paper line 770: sa_requests = {(c, l): []}\n    // where c = codehash and l = expectedCodeLength (expected code length)\n    const newServiceAccount = new CompleteServiceAccount()\n    newServiceAccount.codehash = codeHashData\n    newServiceAccount.balance = minBalance\n    newServiceAccount.minaccgas = minAccGas\n    newServiceAccount.minmemogas = minMemoGas\n    // Use already-calculated items and octets for consistency\n    newServiceAccount.octets = newServiceOctets\n    newServiceAccount.gratis = gratis\n    newServiceAccount.items = u32(newServiceItems)\n    newServiceAccount.created = u32(timeslot)\n    newServiceAccount.lastacc = 0\n    newServiceAccount.parent = u32(imX.id)\n    // Gray Paper line 770: Initial request for code: requests[(codeHashData, expectedCodeLength)] = []\n    // Using rawCshKeyvals helper - empty timeslots array\n    const emptyTimeslots: u32[] = []\n    setRequestValue(newServiceAccount, u32(newServiceId), codeHashData, expectedCodeLength, encodeRequestTimeslots(emptyTimeslots))\n\n    // Deduct balance from current service\n    currentService.balance -= minBalance\n\n    // Add new service to accounts\n    this.setAccountEntry(imX.state.accounts, newServiceId, newServiceAccount)\n\n    // Update next free ID only for non-registrar cases\n    // Gray Paper line 791: i* = check(Cminpublicindex + (imX.nextfreeid - Cminpublicindex + 42) mod ...)\n    if (updateNextFreeId) {\n      imX.nextfreeid = u32(this.getNextFreeId(u64(imX.nextfreeid), imX.state.accounts))\n    }\n\n    // Set success result with new service ID\n    this.setAccumulateSuccess(registers, newServiceId)\n    return new HostFunctionResult(255) // continue execution\n  }\n\n  /**\n   * Get next free ID according to Gray Paper specification\n   *\n   * Gray Paper line 791: i* = check(Cminpublicindex + (im_nextfreeid - Cminpublicindex + 42) mod (2^32 - Cminpublicindex - 2^8))\n   *\n   * The check function (Gray Paper line 252-255) ensures the ID is not already in use:\n   * - If ID is available, return it\n   * - Otherwise, recursively check the next candidate (increment by 1, wrapped)\n   */\n  getNextFreeId(\n    currentId: u64,\n    accounts: Array<AccountEntry>,\n  ): u64 {\n    const C_MIN_PUBLIC_INDEX: u64 = u64(65536) // 2^16 = Cminpublicindex\n    const MODULUS: u64 = u64(4294967296) - C_MIN_PUBLIC_INDEX - u64(256) // 2^32 - Cminpublicindex - 2^8\n\n    // Gray Paper line 791: Calculate candidate ID\n    // i* = Cminpublicindex + (im_nextfreeid - Cminpublicindex + 42) mod (2^32 - Cminpublicindex - 2^8)\n    const candidateId =\n      C_MIN_PUBLIC_INDEX + ((currentId - C_MIN_PUBLIC_INDEX + u64(42)) % MODULUS)\n\n    // Gray Paper line 252-255: Apply check function to ensure ID is available\n    // Note: This uses v0.7.1+ formula (no version parameter needed for post-creation update)\n    return this.checkServiceIdV071(candidateId, accounts)\n  }\n\n  /**\n   * Check function from Gray Paper line 252-255\n   * Version-aware: uses different formulas for v0.7.0 and v0.7.1+\n   *\n   * @param id - Candidate service ID to check\n   * @param accounts - Array of existing service accounts\n   * @param jamVersionMajor - JAM version major\n   * @param jamVersionMinor - JAM version minor\n   * @param jamVersionPatch - JAM version patch\n   */\n  checkServiceId(\n    id: u64,\n    accounts: Array<AccountEntry>,\n    jamVersionMajor: u8,\n    jamVersionMinor: u8,\n    jamVersionPatch: u8,\n  ): u64 {\n    // Check if version is <= 0.7.0\n    const isV070OrEarlier = \n      jamVersionMajor < 0 ||\n      (jamVersionMajor == 0 && jamVersionMinor < 7) ||\n      (jamVersionMajor == 0 && jamVersionMinor == 7 && jamVersionPatch <= 0)\n    \n    if (isV070OrEarlier) {\n      return this.checkServiceIdV070(id, accounts)\n    }\n    return this.checkServiceIdV071(id, accounts)\n  }\n\n  /**\n   * Check function for v0.7.0 and earlier\n   * v0.7.0: check((i - 2^8 + 1) mod (2^32 - 2^9) + 2^8)\n   */\n  checkServiceIdV070(\n    id: u64,\n    accounts: Array<AccountEntry>,\n  ): u64 {\n    const OFFSET: u64 = u64(256) // 2^8\n    const MODULUS: u64 = u64(4294967296) - u64(512) // 2^32 - 512\n\n    // If ID is not in accounts, return it\n    if (!this.hasAccountEntry(accounts, id)) {\n      return id\n    }\n\n    // Otherwise, recursively check the next candidate\n    // v0.7.0: (i - 2^8 + 1) mod (2^32 - 512) + 2^8\n    const nextCandidate = OFFSET + ((id - OFFSET + u64(1)) % MODULUS)\n\n    return this.checkServiceIdV070(nextCandidate, accounts)\n  }\n\n  /**\n   * Check function for v0.7.1 and later\n   * v0.7.1+: check((i - Cminpublicindex + 1) mod (2^32 - 2^8 - Cminpublicindex) + Cminpublicindex)\n   */\n  checkServiceIdV071(\n    id: u64,\n    accounts: Array<AccountEntry>,\n  ): u64 {\n    const C_MIN_PUBLIC_INDEX: u64 = u64(65536) // 2^16 = Cminpublicindex\n    const MODULUS: u64 = u64(4294967296) - u64(256) - C_MIN_PUBLIC_INDEX // 2^32 - 2^8 - Cminpublicindex\n\n    // If ID is not in accounts, return it\n    if (!this.hasAccountEntry(accounts, id)) {\n      return id\n    }\n\n    // Otherwise, recursively check the next candidate\n    // (i - Cminpublicindex + 1) mod (2^32 - 2^8 - Cminpublicindex) + Cminpublicindex\n    const nextCandidate =\n      C_MIN_PUBLIC_INDEX + ((id - C_MIN_PUBLIC_INDEX + u64(1)) % MODULUS)\n\n    return this.checkServiceIdV071(nextCandidate, accounts)\n  }\n}\n","import { blake2b256 } from '../../crypto'\nimport { RESULT_CODE_PANIC } from '../../config'\nimport { getRequestValue } from '../../codec'\nimport {\n  ACCUMULATE_ERROR_HUH,\n  ACCUMULATE_ERROR_WHO,\n  AccumulateHostFunctionContext,\n  BaseAccumulateHostFunction,\n  HostFunctionResult,\n} from './base'\n\n/**\n * PROVIDE accumulation host function (_)\n *\n * Provides preimage data\n *\n * Gray Paper Specification:\n * - Function ID: 26 (provide)\n * - Gas Cost: 10\n * - Parameters: registers[7-9] = s, o, z\n *   - s: service account ID (or 2^64-1 for current service)\n *   - o: preimage data offset in memory\n *   - z: preimage data length\n * - Returns: registers[7] = OK or error code\n *\n * Gray Paper Logic:\n * 1. Determine target service ID (current service if s = 2^64-1)\n * 2. Read preimage data from memory\n * 3. Check if service account exists\n * 4. Check if there's a matching request for this hash and size\n * 5. Check if the preimage hasn't already been provided\n * 6. Add the preimage to provisions\n */\nexport class ProvideHostFunction extends BaseAccumulateHostFunction {\n  functionId: u64 = u64(26) // PROVIDE function ID (Gray Paper line 965)\n  name: string = 'provide'\n  gasCost: u64 = u64(10)\n\n  execute(context: AccumulateHostFunctionContext): HostFunctionResult {\n    const registers = context.registers\n    const ram = context.ram\n    const implications = context.implications\n    // Gray Paper line 204: _F receives H_timeslot (block header's timeslot)\n    // This is the current block's timeslot passed from the Accumulate invocation\n\n    // Extract parameters from registers\n    const targetServiceId = u64(registers[7])\n    const preimageOffset = u64(registers[8])\n    const preimageLength = u64(registers[9])\n\n    // Determine target service ID\n    // Gray Paper: s = imX.id when registers[7] = 2^64-1, otherwise registers[7]\n    const MAX_U64: u64 = u64(0xffffffffffffffff) // 2^64 - 1\n    const serviceId =\n      targetServiceId === MAX_U64 ? implications.regular.id : targetServiceId\n\n    // Read preimage data from memory\n    const readResult_preimage = ram.readOctets(\n      u32(preimageOffset),\n      u32(preimageLength),\n    )\n    if (readResult_preimage.faultAddress !== 0) {\n      return new HostFunctionResult(RESULT_CODE_PANIC)\n    }\n    if (readResult_preimage.data === null) {\n      return new HostFunctionResult(RESULT_CODE_PANIC)\n    }\n    const preimageData = readResult_preimage.data!\n\n    // Get the current implications context\n    const imX = implications.regular\n\n    // Check if service account exists\n    const accountEntry = this.findAccountEntry(imX.state.accounts, serviceId)\n    if (accountEntry === null) {\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_WHO)\n      return new HostFunctionResult(255) // continue execution\n    }\n    const serviceAccount = accountEntry.account\n\n    // Check if there's a matching request for this hash and size\n    // Gray Paper line 985: a.sa_requests[(blake(i), z)]  []\n    // Compute blake2b hash of the preimage data\n    const preimageHash = blake2b256(preimageData)\n    const requestValue = getRequestValue(serviceAccount, u32(serviceId), preimageHash, preimageLength)\n    if (requestValue === null) {\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_HUH)\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Check if the preimage hasn't already been provided\n    // Gray Paper: (s, i)  imX.provisions\n    const existingProvision = this.findProvisionEntry(imX.provisions, serviceId)\n    if (\n      existingProvision !== null &&\n      this.arraysEqual(existingProvision.blob, preimageData)\n    ) {\n      // Gray Paper line 942: HUH when a = error (preimage already provided)\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_HUH)\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Add the preimage to provisions\n    // Gray Paper: imX.provisions  {(s, i)}\n    this.setProvisionEntry(imX.provisions, serviceId, preimageData)\n\n    // Set success result\n    this.setAccumulateSuccess(registers)\n    return new HostFunctionResult(255) // continue execution\n  }\n\n  arraysEqual(a: Uint8Array, b: Uint8Array): bool {\n    if (a.length !== b.length) return false\n    for (let i: i32 = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false\n    }\n    return true\n  }\n}\n","import { RESULT_CODE_PANIC } from '../../config'\nimport { getRequestValue, decodeRequestTimeslots } from '../../codec'\nimport {\n  ACCUMULATE_ERROR_NONE,\n  AccumulateHostFunctionContext,\n  BaseAccumulateHostFunction,\n  HostFunctionResult,\n} from './base'\n\n/**\n * QUERY accumulation host function (_Q)\n *\n * Queries preimage request status\n *\n * Gray Paper Specification:\n * - Function ID: 22 (query)\n * - Gas Cost: 10\n * - Parameters: registers[7-8] = o, z\n *   - o: hash offset in memory (32 bytes)\n *   - z: size of the preimage\n * - Returns: registers[7-8] = status and additional data\n *\n * Gray Paper Logic:\n * 1. Read hash from memory (32 bytes)\n * 2. Look up request status in current service's requests\n * 3. Return encoded status:\n *    - NONE: request doesn't exist\n *    - 0: request exists but is empty []\n *    - 1 + 2^32 * x: request has one entry [x]\n *    - 2 + 2^32 * x, y: request has two entries [x, y]\n *    - 3 + 2^32 * x, y + 2^32 * z: request has three entries [x, y, z]\n */\nexport class QueryHostFunction extends BaseAccumulateHostFunction {\n  functionId: u64 = u64(22) // QUERY function ID (Gray Paper: query = 22)\n  name: string = 'query'\n  gasCost: u64 = u64(10)\n\n  execute(context: AccumulateHostFunctionContext): HostFunctionResult {\n    const registers = context.registers\n    const ram = context.ram\n    const implications = context.implications\n    // Gray Paper line 204: _F receives H_timeslot (block header's timeslot)\n    // This is the current block's timeslot passed from the Accumulate invocation\n\n    // Extract parameters from registers\n    const preimageOffset = u64(registers[7])\n    const preimageLength = u64(registers[8])\n\n    // Read hash from memory (32 bytes)\n    // Gray Paper: h = memory[o:32] - always reads 32 bytes (hash size)\n    const readResult_hash = ram.readOctets(u32(preimageOffset), 32)\n    if (readResult_hash.faultAddress !== 0) {\n      return new HostFunctionResult(RESULT_CODE_PANIC)\n    }\n    if (readResult_hash.data === null) {\n      return new HostFunctionResult(RESULT_CODE_PANIC)\n    }\n    const hashData = readResult_hash.data!\n\n    // Get the current implications context\n    const imX = implications.regular\n\n    // Get current service account\n    const accountEntry = this.findAccountEntry(imX.state.accounts, imX.id)\n    if (accountEntry === null) {\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_NONE)\n      registers[8] = u64(0)\n      return new HostFunctionResult(255) // continue execution\n    }\n    const serviceAccount = accountEntry.account\n\n    // Look up request using rawCshKeyvals helper\n    const requestValue = getRequestValue(serviceAccount, u32(imX.id), hashData, preimageLength)\n\n    if (requestValue === null) {\n      // Request doesn't exist\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_NONE)\n      registers[8] = u64(0)\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Decode the request timeslots\n    const timeslots = decodeRequestTimeslots(requestValue)\n    if (timeslots === null) {\n      // Invalid request value\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_NONE)\n      registers[8] = u64(0)\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Return encoded status based on request length\n    const TWO_TO_32: u64 = u64(4294967296) // 2^32\n    if (timeslots.length === 0) {\n      // Empty request []\n      registers[7] = u64(0)\n      registers[8] = u64(0)\n    } else if (timeslots.length === 1) {\n      // Single entry [x]\n      const x = u64(timeslots[0])\n      registers[7] = u64(1) + TWO_TO_32 * x\n      registers[8] = u64(0)\n    } else if (timeslots.length === 2) {\n      // Two entries [x, y]\n      const x = u64(timeslots[0])\n      const y = u64(timeslots[1])\n      registers[7] = u64(2) + TWO_TO_32 * x\n      registers[8] = y\n    } else if (timeslots.length === 3) {\n      // Three entries [x, y, z]\n      const x = u64(timeslots[0])\n      const y = u64(timeslots[1])\n      const z = u64(timeslots[2])\n      registers[7] = u64(3) + TWO_TO_32 * x\n      registers[8] = y + TWO_TO_32 * z\n    } else {\n      // Invalid request state\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_NONE)\n      registers[8] = u64(0)\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    return new HostFunctionResult(255) // continue execution\n  }\n}\n","import { RESULT_CODE_PANIC } from '../../config'\nimport { DeferredTransfer } from '../../codec'\nimport {\n  ACCUMULATE_ERROR_WHO,\n  ACCUMULATE_ERROR_LOW,\n  ACCUMULATE_ERROR_CASH,\n  ACCUMULATE_ERROR_HUH,\n  ACCUMULATE_ERROR_OK,\n  AccumulateHostFunctionContext,\n  BaseAccumulateHostFunction,\n  HostFunctionResult,\n} from './base'\n\n/**\n * TRANSFER accumulation host function (_T)\n *\n * Transfers tokens between service accounts\n *\n * Gray Paper Specification:\n * - Function ID: 20 (transfer)\n * - Gas Cost: 10 + l (gasLimit) on success, 10 on error\n * - Parameters: registers[7-10] = dest, amount, l, o\n *   - dest: destination service account ID\n *   - amount: transfer amount\n *   - l: gas limit for the transfer\n *   - o: memo offset in memory\n * - Returns: registers[7] = OK or error code\n *\n * Gray Paper Logic:\n * 1. Read memo from memory (128 bytes)\n * 2. Check if destination service exists\n * 3. Check if gas limit is sufficient for destination\n * 4. Check if sender has sufficient balance\n * 5. Create deferred transfer entry\n * 6. Deduct amount from sender's balance\n */\nexport class TransferHostFunction extends BaseAccumulateHostFunction {\n  functionId: u64 = u64(20) // TRANSFER function ID\n  name: string = 'transfer'\n  gasCost: u64 = u64(10) // Base cost, actual cost is 10 + gasLimit on success\n\n  execute(context: AccumulateHostFunctionContext): HostFunctionResult {\n    const registers = context.registers\n    const ram = context.ram\n    const implications = context.implications\n    \n    // Extract parameters from registers\n    // Gray Paper pvm_invocations.tex line 818: [dest, amount, l, o] = registers[7:4]\n    const destinationServiceId = u64(registers[7])\n    const amount = u64(registers[8])\n    const gasLimit = u64(registers[9])\n    const memoOffset = u64(registers[10])\n\n    // Read memo from memory (128 bytes - Gray Paper Cmemosize)\n    // Gray Paper pvm_invocations.tex lines 820-832:\n    // t = error when Nrange(o, Cmemosize) not readable\n    // c = panic when t = error\n    // registers'_7 = registers_7 (unchanged) when c = panic\n    const C_MEMO_SIZE: u32 = 128\n    const readResult_memo = ram.readOctets(u32(memoOffset), C_MEMO_SIZE)\n    if (readResult_memo.faultAddress !== 0 || readResult_memo.data === null) {\n      // Gray Paper line 832: c = panic when t = error\n      // Gray Paper line 839: registers'_7 = registers_7 (unchanged) when c = panic\n      // DO NOT modify registers[7] - it must remain unchanged on panic\n      return new HostFunctionResult(RESULT_CODE_PANIC)\n    }\n    const memoData = readResult_memo.data!\n\n    // Get the current implications context\n    const imX = implications.regular\n\n    // Get current service account\n    const currentAccountEntry = this.findAccountEntry(imX.state.accounts, imX.id)\n    if (currentAccountEntry === null) {\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_HUH)\n      return new HostFunctionResult(255) // continue execution\n    }\n    const currentService = currentAccountEntry.account\n\n    // Check if destination service exists\n    const destAccountEntry = this.findAccountEntry(imX.state.accounts, destinationServiceId)\n    if (destAccountEntry === null) {\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_WHO)\n      return new HostFunctionResult(255) // continue execution\n    }\n    const destService = destAccountEntry.account\n\n    // Check if gas limit is sufficient for destination\n    // Gray Paper: l < destService.sa_minmemogas\n    if (gasLimit < destService.minmemogas) {\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_LOW)\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Check if sender has sufficient balance after transfer\n    // Gray Paper line 830: b = (imX_self)_sa_balance - amount\n    // Gray Paper line 835: CASH when b < (imX_self)_sa_minbalance\n    // Gray Paper accounts.tex: sa_minbalance = max(0, Cbasedeposit + Citemdeposit * items + Cbytedeposit * octets - gratis)\n    if (currentService.balance < amount) {\n      // Would result in negative balance - insufficient funds\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_CASH)\n      return new HostFunctionResult(255) // continue execution\n    }\n    const balanceAfterTransfer = currentService.balance - amount\n\n    // Calculate minbalance according to Gray Paper accounts.tex\n    const C_BASEDEPOSIT: u64 = u64(100)\n    const C_ITEMDEPOSIT: u64 = u64(10)\n    const C_BYTEDEPOSIT: u64 = u64(1)\n    const baseDeposit = C_BASEDEPOSIT\n    const itemDeposit = C_ITEMDEPOSIT * u64(currentService.items)\n    const byteDeposit = C_BYTEDEPOSIT * currentService.octets\n    const totalDeposit = baseDeposit + itemDeposit + byteDeposit\n    const minbalance = totalDeposit > currentService.gratis\n      ? totalDeposit - currentService.gratis\n      : u64(0)\n\n    if (balanceAfterTransfer < minbalance) {\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_CASH)\n      return new HostFunctionResult(255) // continue execution\n    }\n\n    // Create deferred transfer entry\n    // Gray Paper: t = {source: imX.id, dest, amount, memo, gas: l}\n    const deferredTransfer = new DeferredTransfer()\n    deferredTransfer.source = u32(imX.id)\n    deferredTransfer.dest = u32(destinationServiceId)\n    deferredTransfer.amount = amount\n    deferredTransfer.memo = memoData\n    deferredTransfer.gasLimit = gasLimit\n\n    // Add transfer to xfers list\n    imX.xfers.push(deferredTransfer)\n\n    // Deduct amount from sender's balance\n    currentService.balance = balanceAfterTransfer\n\n    // Set success result\n    this.setAccumulateSuccess(registers, ACCUMULATE_ERROR_OK)\n\n    // Gray Paper: On success, gas cost is 10 + l (where l = gasLimit)\n    // Return with additionalGasCost to deduct gasLimit from gas counter\n    return new HostFunctionResult(255, gasLimit) // continue execution, deduct gasLimit\n  }\n}\n","import { RESULT_CODE_PANIC } from '../../config'\nimport {\n  ACCUMULATE_ERROR_HUH,\n  AccumulateHostFunctionContext,\n  BaseAccumulateHostFunction,\n  HostFunctionResult,\n} from './base'\n\n/**\n * UPGRADE accumulation host function (_U)\n *\n * Upgrades service code hash and gas limits\n *\n * Gray Paper Specification:\n * - Function ID: 19 (upgrade)\n * - Gas Cost: 10\n * - Parameters: registers[7-9] = o, g, m\n *   - o: code hash offset in memory (32 bytes)\n *   - g: new minimum accumulation gas\n *   - m: new minimum memory gas\n * - Returns: registers[7] = OK or error code\n *\n * Gray Paper Logic:\n * 1. Read code hash from memory (32 bytes)\n * 2. Update current service's code hash\n * 3. Update minimum accumulation gas\n * 4. Update minimum memory gas\n */\nexport class UpgradeHostFunction extends BaseAccumulateHostFunction {\n  functionId: u64 = u64(19) // UPGRADE function ID\n  name: string = 'upgrade'\n  gasCost: u64 = u64(10)\n\n  execute(context: AccumulateHostFunctionContext): HostFunctionResult {\n    const registers = context.registers\n    const ram = context.ram\n    const implications = context.implications\n    // Extract parameters from registers\n    const codeHashOffset = u64(registers[7])\n    const newMinimumAccumulationGas = u64(registers[8])\n    const newMinimumMemoryGas = u64(registers[9])\n\n    // Read code hash from memory (32 bytes)\n    const readResult_codeHash = ram.readOctets(u32(codeHashOffset), u32(32))\n    // Gray Paper line 808: (panic, registers_7, ...) when c = error\n    // Gray Paper: registers'_7 = registers_7 (unchanged) when c = panic\n    // DO NOT modify registers[7] - it must remain unchanged on panic\n    if (readResult_codeHash.faultAddress !== 0 || readResult_codeHash.data === null) {\n      return new HostFunctionResult(RESULT_CODE_PANIC)\n    }\n    const codeHashData = readResult_codeHash.data!\n\n    // Get the current implications context\n    const imX = implications.regular\n\n    // Get current service account\n    const accountEntry = this.findAccountEntry(imX.state.accounts, imX.id)\n    if (accountEntry === null) {\n      this.setAccumulateError(registers, ACCUMULATE_ERROR_HUH)\n      return new HostFunctionResult(255) // continue execution\n    }\n    const serviceAccount = accountEntry.account\n\n    // Update service account with new code hash and gas limits\n    // Gray Paper: imX.self.codehash = c, imX.self.minaccgas = g, imX.self.minmemogas = m\n    serviceAccount.codehash = codeHashData\n    serviceAccount.minaccgas = newMinimumAccumulationGas\n    serviceAccount.minmemogas = newMinimumMemoryGas\n\n    this.setAccountEntry(imX.state.accounts, imX.id, serviceAccount)\n\n    // Set success result\n    this.setAccumulateSuccess(registers)\n    return new HostFunctionResult(255) // continue execution\n  }\n}\n","import { RESULT_CODE_PANIC } from '../../config'\nimport {\n  AccumulateHostFunctionContext,\n  BaseAccumulateHostFunction,\n  HostFunctionResult,\n} from './base'\n\n/**\n * YIELD accumulation host function (_)\n *\n * Yields accumulation trie result\n *\n * Gray Paper Specification:\n * - Function ID: 25 (yield)\n * - Gas Cost: 10\n * - Parameters: registers[7] = o\n *   - o: hash offset in memory (32 bytes)\n * - Returns: registers[7] = OK or error code\n *\n * Gray Paper Logic:\n * 1. Read hash from memory (32 bytes)\n * 2. Set the yield hash in the accumulation context\n * 3. This hash represents the result of the accumulation trie\n * 4. The hash will be used by the system to verify the accumulation result\n */\nexport class YieldHostFunction extends BaseAccumulateHostFunction {\n  functionId: u64 = u64(25)\n  name: string = 'yield'\n\n  execute(context: AccumulateHostFunctionContext): HostFunctionResult {\n    const registers = context.registers\n    const ram = context.ram\n    const implications = context.implications\n    // Extract parameters from registers\n    const hashOffset = u64(registers[7])\n\n    // Read hash from memory (32 bytes)\n    // Gray Paper pvm_invocations.tex lines 953-956:\n    // h = memory[o:32] when Nrange(o,32)  readable(memory), error otherwise\n    const readResult_hash = ram.readOctets(u32(hashOffset), u32(32))\n    // Gray Paper line 958: (panic, registers_7, ...) when h = error\n    // Gray Paper: registers'_7 = registers_7 (unchanged) when c = panic\n    if (readResult_hash.faultAddress !== 0 || readResult_hash.data === null) {\n      // DO NOT modify registers[7] - it must remain unchanged on panic\n      return new HostFunctionResult(RESULT_CODE_PANIC)\n    }\n    const hashData = readResult_hash.data!\n\n    // Get the current implications context\n    const imX = implications.regular\n\n    // Set the yield hash in the accumulation context\n    imX.yield = hashData\n    // Note: This would require extending the Implications class with a yield field\n    // For now, this is a placeholder implementation\n\n    // Set success result\n    this.setAccumulateSuccess(registers)\n    return new HostFunctionResult(255) // continue execution\n  }\n}\n","/**\n * PVM Codec Implementation (AssemblyScript)\n *\n * Implements Gray Paper codec functions for decoding program blobs\n * Gray Paper Reference: pvm.tex, serialization.tex\n */\n\nimport { blake2b256 } from './crypto'\n\n/**\n * Decoding result structure\n */\nexport class DecodingResult<T> {\n  value: T\n  consumed: i32\n\n  constructor(value: T, consumed: i32) {\n    this.value = value\n    this.consumed = consumed\n  }\n}\n\n/**\n * Service code decoding result\n */\nexport class ServiceCodeResult {\n  metadata: Uint8Array\n  codeBlob: Uint8Array\n\n  constructor(metadata: Uint8Array, codeBlob: Uint8Array) {\n    this.metadata = metadata\n    this.codeBlob = codeBlob\n  }\n}\n\n/**\n * Decoded blob structure\n */\nexport class DecodedBlob {\n  code: Uint8Array\n  bitmask: Uint8Array\n  jumpTable: u32[]\n  elementSize: i32\n  headerSize: i32\n\n  constructor(\n    code: Uint8Array,\n    bitmask: Uint8Array,\n    jumpTable: u32[],\n    elementSize: i32,\n    headerSize: i32,\n  ) {\n    this.code = code\n    this.bitmask = bitmask\n    this.jumpTable = jumpTable\n    this.elementSize = elementSize\n    this.headerSize = headerSize\n  }\n}\n\n/**\n * Decoded program structure (Y function format)\n */\nexport class DecodedProgram {\n  metadata: Uint8Array\n  roDataLength: u32\n  rwDataLength: u32\n  heapZeroPaddingSize: u32\n  stackSize: u32\n  roData: Uint8Array\n  rwData: Uint8Array\n  codeSize: u32\n  code: Uint8Array\n\n  constructor(\n    metadata: Uint8Array,\n    roDataLength: u32,\n    rwDataLength: u32,\n    heapZeroPaddingSize: u32,\n    stackSize: u32,\n    roData: Uint8Array,\n    rwData: Uint8Array,\n    codeSize: u32,\n    code: Uint8Array,\n  ) {\n    this.metadata = metadata\n    this.roDataLength = roDataLength\n    this.rwDataLength = rwDataLength\n    this.heapZeroPaddingSize = heapZeroPaddingSize\n    this.stackSize = stackSize\n    this.roData = roData\n    this.rwData = rwData\n    this.codeSize = codeSize\n    this.code = code\n  }\n}\n\n/**\n * Decoded accumulate arguments structure\n */\nexport class DecodedAccumulateArgs {\n  timeslot: u64\n  serviceId: u64\n  inputLength: u64\n\n  constructor(timeslot: u64, serviceId: u64, inputLength: u64) {\n    this.timeslot = timeslot\n    this.serviceId = serviceId\n    this.inputLength = inputLength\n  }\n}\n\n/**\n * Decode natural number according to Gray Paper specification.\n *\n * Gray Paper Equation 30-38: Variable-length encoding for natural numbers\n */\nexport function decodeNatural(\n  data: Uint8Array,\n): DecodingResult<u64> | null {\n  if (data.length === 0) {\n    return null\n  }\n\n  const first = data[0]\n\n  // Gray Paper Case 1: prefix = 0  x = 0\n  if (first === 0) {\n    return new DecodingResult<u64>(u64(0), 1)\n  }\n\n  // Gray Paper Case 3: prefix = 255  large number encoding\n  if (first === 0xff) {\n    if (data.length < 9) {\n      return null\n    }\n\n    // decode[8]{x} - 8-byte little-endian decoding\n    let value: u64 = u64(0)\n    for (let i: i32 = 0; i < 8; i++) {\n      value |= u64(data[1 + i]) << u64(i32(i * 8))\n    }\n\n    return new DecodingResult<u64>(value, 9)\n  }\n\n  // Special case for single-byte values (1-127): direct decoding\n  if (first >= 1 && first <= 127) {\n    return new DecodingResult<u64>(u64(first), 1)\n  }\n\n  // Gray Paper Case 2: Variable-length encoding\n  // Determine l by finding which range the prefix falls into\n  let l: i32 = 0\n  for (let testL: i32 = 1; testL <= 8; testL++) {\n    const minPrefix: u64 = u64(256) - (u64(1) << u64(8 - testL)) // 2^8-2^(8-l)\n    const maxPrefix: u64 =\n      minPrefix +\n      (((u64(1) << u64(7 * (testL + 1))) - u64(1)) >> u64(8 * testL))\n\n    if (u64(first) >= minPrefix && u64(first) <= maxPrefix) {\n      l = testL\n      break\n    }\n  }\n\n  if (l === 0) {\n    return null\n  }\n\n  if (data.length < 1 + l) {\n    return null\n  }\n\n  // Extract high bits from prefix: (prefix - (2^8-2^(8-l))) * 2^(8l)\n  const prefixBase: u64 = u64(256) - (u64(1) << u64(8 - l)) // 2^8-2^(8-l)\n  const highBits: u64 = (u64(first) - prefixBase) << u64(8 * l)\n\n  // Extract low bits from suffix: little-endian l-byte value\n  let lowBits: u64 = u64(0)\n  for (let i: i32 = 0; i < l; i++) {\n    lowBits |= u64(data[1 + i]) << u64(i32(i * 8))\n  }\n\n  const value: u64 = highBits | lowBits\n  return new DecodingResult<u64>(value, 1 + l)\n}\n\n/**\n * Decode PVM program blob according to Gray Paper pvm.tex deblob function\n *\n * Format: p = encode(len(j))  encode[1](z)  encode(len(c))  encode[z](j)  encode(c)  encode(k)\n */\nexport function decodeBlob(\n  programBlob: Uint8Array,\n): DecodedBlob | null {\n  let offset: i32 = 0\n\n  // 1. Decode len(j) - jump table length\n  const jumpTableLengthResult = decodeNatural(programBlob.slice(offset))\n  if (!jumpTableLengthResult) {\n    return null\n  }\n  const jumpTableLength = i32(jumpTableLengthResult.value)\n  offset += jumpTableLengthResult.consumed\n\n  // 2. Decode z - element size (1 byte)\n  if (offset >= programBlob.length) {\n    return null\n  }\n  const elementSize = programBlob[offset]\n  offset += 1\n\n  // 3. Decode len(c) - code length\n  const codeLengthResult = decodeNatural(programBlob.slice(offset))\n  if (!codeLengthResult) {\n    return null\n  }\n  const codeLength = i32(codeLengthResult.value)\n  offset += codeLengthResult.consumed\n\n  const headerSize = offset\n\n  // 4. Decode jump table data\n  const jumpTableSize = jumpTableLength * elementSize\n  if (offset + jumpTableSize > programBlob.length) {\n    return null\n  }\n\n  const jumpTable = new Array<u32>(jumpTableLength)\n  for (let i: i32 = 0; i < jumpTableLength; i++) {\n    const elementStart = offset + i * elementSize\n    const elementBytes = programBlob.slice(\n      elementStart,\n      elementStart + elementSize,\n    )\n    // Decode as little-endian\n    let value: u32 = 0\n    for (let j: i32 = 0; j < i32(elementSize); j++) {\n      value |= u32(elementBytes[j]) << u32(j * 8)\n    }\n    jumpTable[i] = value\n  }\n  offset += jumpTableSize\n\n  // 5. Extract code data\n  if (offset + codeLength > programBlob.length) {\n    return null\n  }\n  const code = programBlob.slice(offset, offset + codeLength)\n  offset += codeLength\n\n  // 6. Extract bitmask according to Gray Paper specification\n  if (offset >= programBlob.length) {\n    return null\n  }\n\n  const remainingBytes = programBlob.length - offset\n  const bitmask = new Uint8Array(codeLength)\n\n  // Extract packed bitmask bytes and expand them\n  let bitIndex: i32 = 0\n  let byteIndex: i32 = 0\n\n  while (bitIndex < codeLength && byteIndex < remainingBytes) {\n    const packedByte = programBlob[offset + byteIndex]\n\n    // Extract up to 8 bits from this packed byte\n    for (let i: i32 = 0; i < 8 && bitIndex < i32(codeLength); i++) {\n      bitmask[bitIndex] = u8((u32(packedByte) >> u32(i)) & u32(1))\n      bitIndex++\n    }\n    byteIndex++\n  }\n\n  if (bitIndex < codeLength) {\n    return null\n  }\n\n  return new DecodedBlob(code, bitmask, jumpTable, elementSize, headerSize)\n}\n\n/**\n * Decode service code from preimage blob according to Gray Paper accounts.tex\n *\n * Format: encode(len(m)) || encode(m) || encode(code_blob)\n */\nexport function decodeServiceCodeFromPreimage(\n  preimageBlob: Uint8Array,\n): DecodingResult<ServiceCodeResult> | null {\n  let offset: i32 = 0\n\n  // 1. Decode metadata length\n  const metadataLengthResult = decodeNatural(preimageBlob.slice(offset))\n  if (!metadataLengthResult) {\n    return null\n  }\n  const metadataLength = i32(metadataLengthResult.value)\n  offset += metadataLengthResult.consumed\n\n  // 2. Extract metadata blob\n  if (offset + metadataLength > preimageBlob.length) {\n    return null\n  }\n  const metadata = preimageBlob.slice(offset, offset + metadataLength)\n  offset += metadataLength\n\n  // 3. Remaining data is the code blob\n  const codeBlob = preimageBlob.slice(offset)\n\n  return new DecodingResult<ServiceCodeResult>(\n    new ServiceCodeResult(metadata, codeBlob),\n    preimageBlob.length,\n  )\n}\n\n/**\n * Decode program according to Gray Paper Y function specification\n *\n * Format: E(|o|) || E(|w|) || E(z) || E(s) || o || w || E(|c|) || c\n */\n// Helper function to read little-endian unsigned numbers\nfunction readLE(programBlob: Uint8Array, offset: i32, bytes: i32): u32 {\n  if (offset + bytes > programBlob.length) {\n    return u32(0xFFFFFFFF) // Sentinel value for error\n  }\n  let value: u32 = 0\n  for (let i: i32 = 0; i < bytes; i++) {\n    value |= u32(programBlob[offset + i]) << u32(i * 8)\n  }\n  return value\n}\n\nexport function decodeProgram(\n  programBlob: Uint8Array,\n): DecodedProgram | null {\n  let offset: i32 = 0\n\n  // 1. Decode E(|o|) - read-only data length (3 bytes, little-endian)\n  const roDataLengthResult = readLE(programBlob, offset, 3)\n  if (roDataLengthResult === u32(0xFFFFFFFF)) {\n    return null\n  }\n  const roDataLength = roDataLengthResult\n  offset += 3\n\n  // 2. Decode E(|w|) - read-write data length (3 bytes, little-endian)\n  const rwDataLengthResult = readLE(programBlob, offset, 3)\n  if (rwDataLengthResult === u32(0xFFFFFFFF)) {\n    return null\n  }\n  const rwDataLength = rwDataLengthResult\n  offset += 3\n\n  // 3. Decode E(z) - heap zero padding size (2 bytes, little-endian)\n  const heapZeroPaddingSizeResult = readLE(programBlob, offset, 2)\n  if (heapZeroPaddingSizeResult === u32(0xFFFFFFFF)) {\n    return null\n  }\n  const heapZeroPaddingSize = heapZeroPaddingSizeResult\n  offset += 2\n\n  // 4. Decode E(s) - stack size (3 bytes, little-endian)\n  const stackSizeResult = readLE(programBlob, offset, 3)\n  if (stackSizeResult === u32(0xFFFFFFFF)) {\n    return null\n  }\n  const stackSize = stackSizeResult\n  offset += 3\n\n  // 5. Extract read-only data section (o)\n  if (offset + roDataLength > programBlob.length) {\n    return null\n  }\n  const roData = programBlob.slice(offset, offset + roDataLength)\n  offset += roDataLength\n\n  // 6. Extract read-write data section (w)\n  if (offset + rwDataLength > programBlob.length) {\n    return null\n  }\n  const rwData = programBlob.slice(offset, offset + rwDataLength)\n  offset += rwDataLength\n\n  // 7. Decode E(|c|) - instruction data length (4 bytes, little-endian)\n  const codeSizeResult = readLE(programBlob, offset, 4)\n  if (codeSizeResult === u32(0xFFFFFFFF)) {\n    return null\n  }\n  const codeSize = codeSizeResult\n  offset += 4\n\n  // 8. Extract instruction data (c)\n  if (offset + codeSize > programBlob.length) {\n    return null\n  }\n  const code = programBlob.slice(offset, offset + codeSize)\n  offset += codeSize\n\n  return new DecodedProgram(\n    new Uint8Array(0), // metadata (not used in decodeProgram)\n    roDataLength,\n    rwDataLength,\n    heapZeroPaddingSize,\n    stackSize,\n    roData,\n    rwData,\n    codeSize,\n    code,\n  )\n}\n\n/**\n * Decode service code from preimage blob as Y function format\n *\n * After extracting metadata, the code blob c should be in Y function format\n */\nexport function decodeProgramFromPreimage(\n  preimageBlob: Uint8Array,\n): DecodedProgram | null {\n  // First, extract metadata\n  const preimageResult = decodeServiceCodeFromPreimage(preimageBlob)\n  if (!preimageResult) {\n    return null\n  }\n\n  // Then decode the code blob as Y function format\n  const programResult = decodeProgram(preimageResult.value.codeBlob)\n  if (!programResult) {\n    return null\n  }\n\n  // Combine metadata and program results\n  return new DecodedProgram(\n    preimageResult.value.metadata,\n    programResult.roDataLength,\n    programResult.rwDataLength,\n    programResult.heapZeroPaddingSize,\n    programResult.stackSize,\n    programResult.roData,\n    programResult.rwData,\n    programResult.codeSize,\n    programResult.code,\n  )\n}\n\n/**\n * Service Account structure (AssemblyScript compatible)\n */\nexport class ServiceAccountData {\n  codehash: Uint8Array // 32 bytes\n  balance: u64\n  minaccgas: u64\n  minmemogas: u64\n  octets: u64\n  gratis: u64\n  items: u32\n  created: u32\n  lastacc: u32\n  parent: u32\n\n  constructor(\n    codehash: Uint8Array,\n    balance: u64,\n    minaccgas: u64,\n    minmemogas: u64,\n    octets: u64,\n    gratis: u64,\n    items: u32,\n    created: u32,\n    lastacc: u32,\n    parent: u32\n  ) {\n    this.codehash = codehash\n    this.balance = balance\n    this.minaccgas = minaccgas\n    this.minmemogas = minmemogas\n    this.octets = octets\n    this.gratis = gratis\n    this.items = items\n    this.created = created\n    this.lastacc = lastacc\n    this.parent = parent\n  }\n}\n\n/**\n * Encode natural number (simplified for 0 only)\n * Full implementation would handle variable-length encoding\n */\nfunction encodeNaturalZero(): Uint8Array {\n  const result = new Uint8Array(1)\n  result[0] = 0\n  return result\n}\n\n/**\n * Concatenate multiple byte arrays\n */\nfunction concatBytes(arrays: Uint8Array[]): Uint8Array {\n  let totalLength = 0\n  for (let i = 0; i < arrays.length; i++) {\n    totalLength += arrays[i].length\n  }\n\n  const result = new Uint8Array(totalLength)\n  let offset = 0\n  for (let i = 0; i < arrays.length; i++) {\n    const arr = arrays[i]\n    for (let j = 0; j < arr.length; j++) {\n      result[offset + j] = arr[j]\n    }\n    offset += arr.length\n  }\n\n  return result\n}\n\n/**\n * Encode service account according to Gray Paper specification\n * \n * Gray Paper merklization.tex equation C(255, s):\n *  s, sa  accounts: C(255, s)  encode{\n *   0,\n *   sa_codehash,\n *   encode[8]{sa_balance, sa_minaccgas, sa_minmemogas, sa_octets, sa_gratis},\n *   encode[4]{sa_items, sa_created, sa_lastacc, sa_parent}\n * }\n * \n * @param account - Service account to encode\n * @param major - JAM version major (default: 0)\n * @param minor - JAM version minor (default: 7)\n * @param patch - JAM version patch (default: 2)\n * @returns Encoded octet sequence\n */\nexport function encodeServiceAccount(\n  account: ServiceAccountData,\n  major: i32 = 0,\n  minor: i32 = 7,\n  patch: i32 = 2,\n): Uint8Array {\n  const parts: Uint8Array[] = []\n\n  // Gray Paper: 0 (placeholder discriminator)\n  // Include discriminator for JAM version > 0.7.0 (v0.7.1+)\n  // Fuzzer test vectors (v0.7.0) omit this discriminator byte\n  const includeDiscriminator =\n    major > 0 ||\n    (major === 0 && minor > 7) ||\n    (major === 0 && minor === 7 && patch > 0)\n\n  if (includeDiscriminator) {\n    parts.push(encodeNaturalZero())\n  }\n\n  // Gray Paper: sa_codehash (32-byte hash)\n  parts.push(account.codehash)\n\n  // Gray Paper: encode[8]{sa_balance, sa_minaccgas, sa_minmemogas, sa_octets, sa_gratis}\n  // 5  8-byte fields = 40 bytes total\n  const accountBytes = new Uint8Array(40)\n  const view = new DataView(accountBytes.buffer)\n\n  // Balance (8 bytes, little-endian)\n  view.setUint64(0, account.balance, true)\n\n  // MinAccGas (8 bytes, little-endian)\n  view.setUint64(8, account.minaccgas, true)\n\n  // MinMemoGas (8 bytes, little-endian)\n  view.setUint64(16, account.minmemogas, true)\n\n  // Octets (8 bytes, little-endian)\n  view.setUint64(24, account.octets, true)\n\n  // Gratis (8 bytes, little-endian)\n  view.setUint64(32, account.gratis, true)\n\n  parts.push(accountBytes)\n\n  // Gray Paper: encode[4]{sa_items, sa_created, sa_lastacc, sa_parent}\n  // 4  4-byte fields = 16 bytes total\n  const metadataBytes = new Uint8Array(16)\n  const metadataView = new DataView(metadataBytes.buffer)\n\n  // Items (4 bytes, little-endian)\n  metadataView.setUint32(0, account.items, true)\n\n  // Created (4 bytes, little-endian)\n  metadataView.setUint32(4, account.created, true)\n\n  // LastAcc (4 bytes, little-endian)\n  metadataView.setUint32(8, account.lastacc, true)\n\n  // Parent (4 bytes, little-endian)\n  metadataView.setUint32(12, account.parent, true)\n\n  parts.push(metadataBytes)\n\n  return concatBytes(parts)\n}\n\n/**\n * Decode service account according to Gray Paper specification\n * \n * Gray Paper merklization.tex equation C(255, s):\n * Decodes the service account structure:\n * - 0 (discriminator, optional for JAM 0.7.0)\n * - sa_codehash (32 bytes)\n * - encode[8]{sa_balance, sa_minaccgas, sa_minmemogas, sa_octets, sa_gratis} (40 bytes)\n * - encode[4]{sa_items, sa_created, sa_lastacc, sa_parent} (16 bytes)\n * \n * @param data - Octet sequence to decode\n * @param major - JAM version major (default: 0)\n * @param minor - JAM version minor (default: 7)\n * @param patch - JAM version patch (default: 2)\n * @returns Decoded ServiceAccountData and remaining data, or null on error\n */\nexport function decodeServiceAccount(\n  data: Uint8Array,\n  major: i32 = 0,\n  minor: i32 = 7,\n  patch: i32 = 2,\n): DecodingResult<ServiceAccountData> | null {\n  let currentData = data\n\n  // Gray Paper: 0 (placeholder discriminator)\n  // Include discriminator for JAM version > 0.7.0 (v0.7.1+)\n  // Fuzzer test vectors (v0.7.0) omit this discriminator byte\n  const expectDiscriminator =\n    major > 0 ||\n    (major === 0 && minor > 7) ||\n    (major === 0 && minor === 7 && patch > 0)\n\n  if (expectDiscriminator) {\n    // For v0.7.1+, expect discriminator byte\n    if (currentData.length > 0 && currentData[0] === 0x00) {\n      const discriminatorResult = decodeNatural(currentData)\n      if (!discriminatorResult) {\n        return null\n      }\n      currentData = currentData.slice(discriminatorResult.consumed)\n    } else {\n      // Discriminator expected but missing - this is an error for v0.7.1+\n      return null\n    }\n  } else {\n    // For v0.7.0 and earlier, discriminator is optional (fuzzer test vectors omit it)\n    // If first byte is 0x00, decode it as natural number. Otherwise, assume discriminator is missing.\n    if (currentData.length > 0 && currentData[0] === 0x00) {\n      const discriminatorResult = decodeNatural(currentData)\n      if (!discriminatorResult) {\n        return null\n      }\n      currentData = currentData.slice(discriminatorResult.consumed)\n    }\n    // If first byte is not 0x00, assume discriminator is missing and start with codehash\n  }\n\n  // Gray Paper: sa_codehash (32-byte hash)\n  if (currentData.length < 32) {\n    return null\n  }\n  const codehash = currentData.slice(0, 32)\n  currentData = currentData.slice(32)\n\n  // Gray Paper: decode[8]{sa_balance, sa_minaccgas, sa_minmemogas, sa_octets, sa_gratis}\n  if (currentData.length < 40) {\n    return null\n  }\n  const accountBytes = currentData.slice(0, 40)\n  const accountView = new DataView(accountBytes.buffer)\n\n  // Decode 8-byte fields (little-endian)\n  const balance = accountView.getUint64(0, true)\n  const minaccgas = accountView.getUint64(8, true)\n  const minmemogas = accountView.getUint64(16, true)\n  const octets = accountView.getUint64(24, true)\n  const gratis = accountView.getUint64(32, true)\n\n  currentData = currentData.slice(40)\n\n  // Gray Paper: decode[4]{sa_items, sa_created, sa_lastacc, sa_parent}\n  if (currentData.length < 16) {\n    return null\n  }\n  const metadataBytes = currentData.slice(0, 16)\n  const metadataView = new DataView(metadataBytes.buffer)\n\n  // Decode 4-byte fields (little-endian)\n  const items = metadataView.getUint32(0, true)\n  const created = metadataView.getUint32(4, true)\n  const lastacc = metadataView.getUint32(8, true)\n  const parent = metadataView.getUint32(12, true)\n\n  currentData = currentData.slice(16)\n\n  const consumed = data.length - currentData.length\n\n  const accountData = new ServiceAccountData(\n    codehash,\n    balance,\n    minaccgas,\n    minmemogas,\n    octets,\n    gratis,\n    items,\n    created,\n    lastacc,\n    parent,\n  )\n\n  return new DecodingResult<ServiceAccountData>(accountData, consumed)\n}\n\n\n// ============================================================================\n// Fixed-Length Integer Encoding (Gray Paper compliant)\n// ============================================================================\n\n/**\n * Encode natural number using fixed-length little-endian encoding\n * \n * Gray Paper: encode[l](x) - Fixed-length encoding in l bytes\n * Formula: x mod 256  encode[l-1](x/256)\n * \n * @param value - Natural number to encode\n * @param length - Fixed length in bytes (1, 2, 4, 8, etc.)\n * @returns Encoded bytes\n */\nexport function encodeFixedLength(value: u64, length: i32): Uint8Array {\n  const result = new Uint8Array(length)\n  \n  // Little-endian encoding\n  for (let i = 0; i < length; i++) {\n    result[i] = u8((value >> (i * 8)) & 0xff)\n  }\n  \n  return result\n}\n\n/**\n * Encode natural number (full implementation)\n * \n * Gray Paper Equation 30-38: Variable-length encoding for natural numbers\n * - x = 0: Single byte [0x00]\n * - x >= 2^56: [0xFF] + 8 bytes little-endian\n * - Otherwise: prefix + variable bytes\n */\nexport function encodeNatural(value: u64): Uint8Array {\n  // Case 1: x = 0\n  if (value === 0) {\n    const result = new Uint8Array(1)\n    result[0] = 0\n    return result\n  }\n  \n  // Case 2: x >= 2^56 (large numbers)\n  if (value >= (1 << 56)) {\n    const result = new Uint8Array(9)\n    result[0] = 0xff\n    for (let i = 0; i < 8; i++) {\n      result[1 + i] = u8((value >> (i * 8)) & 0xff)\n    }\n    return result\n  }\n  \n  // Case 3: Small values (1-127) - direct encoding\n  if (value >= 1 && value <= 127) {\n    const result = new Uint8Array(1)\n    result[0] = u8(value)\n    return result\n  }\n  \n  // Case 4: Variable-length encoding\n  // Find length l where 2^(7l)  x < 2^(7(l+1))\n  let l = 1\n  while (l <= 8 && value >= (1 << (7 * (l + 1)))) {\n    l++\n  }\n  \n  // Calculate prefix: 2^8 - 2^(8-l) + x/2^(8l)\n  const prefixBase = (1 << 8) - (1 << (8 - l))\n  const highBits = value >> (8 * l)\n  const prefix = prefixBase + i32(highBits)\n  \n  // Calculate suffix: x mod 2^(8l)\n  const suffix = value & ((1 << (8 * l)) - 1)\n  \n  // Create result\n  const result = new Uint8Array(1 + l)\n  result[0] = u8(prefix)\n  \n  // Encode suffix in little-endian\n  for (let i = 0; i < l; i++) {\n    result[1 + i] = u8((suffix >> (i * 8)) & 0xff)\n  }\n  \n  return result\n}\n\n// ============================================================================\n// Work Package Encoding (Gray Paper compliant)\n// ============================================================================\n\n/**\n * RefineContext structure\n */\nexport class RefineContext {\n  anchor: Uint8Array // 32-byte hash\n  state_root: Uint8Array // 32-byte hash\n  beefy_root: Uint8Array // 32-byte hash\n  lookup_anchor: Uint8Array // 32-byte hash\n  lookup_anchor_slot: u64 // 4-byte timeslot\n  prerequisites: Uint8Array[] // Array of 32-byte hashes\n  \n  constructor() {\n    this.anchor = new Uint8Array(32)\n    this.state_root = new Uint8Array(32)\n    this.beefy_root = new Uint8Array(32)\n    this.lookup_anchor = new Uint8Array(32)\n    this.lookup_anchor_slot = 0\n    this.prerequisites = []\n  }\n}\n\n/**\n * Import segment structure\n */\nexport class ImportSegment {\n  treeRoot: Uint8Array // 32-byte hash\n  index: u32 // Segment index (0-32767)\n  isRefined: bool // Whether this is a refined hash\n  \n  constructor() {\n    this.treeRoot = new Uint8Array(32)\n    this.index = 0\n    this.isRefined = false\n  }\n}\n\n/**\n * Extrinsic reference structure\n */\nexport class ExtrinsicReference {\n  hash: Uint8Array // 32-byte hash\n  length: u32 // 4-byte length\n  \n  constructor() {\n    this.hash = new Uint8Array(32)\n    this.length = 0\n  }\n}\n\n/**\n * Work item structure\n */\nexport class WorkItem {\n  serviceindex: u32\n  codehash: Uint8Array // 32-byte hash\n  refgaslimit: u64\n  accgaslimit: u64\n  exportcount: u16\n  payload: Uint8Array\n  importsegments: ImportSegment[]\n  extrinsics: ExtrinsicReference[]\n  \n  constructor() {\n    this.serviceindex = 0\n    this.codehash = new Uint8Array(32)\n    this.refgaslimit = 0\n    this.accgaslimit = 0\n    this.exportcount = 0\n    this.payload = new Uint8Array(0)\n    this.importsegments = []\n    this.extrinsics = []\n  }\n}\n\n/**\n * Work package structure\n */\nexport class WorkPackage {\n  authCodeHost: u32\n  authCodeHash: Uint8Array // 32-byte hash\n  context: RefineContext\n  authToken: Uint8Array\n  authConfig: Uint8Array\n  workItems: WorkItem[]\n  \n  constructor() {\n    this.authCodeHost = 0\n    this.authCodeHash = new Uint8Array(32)\n    this.context = new RefineContext()\n    this.authToken = new Uint8Array(0)\n    this.authConfig = new Uint8Array(0)\n    this.workItems = []\n  }\n}\n\n/**\n * Encode refine context according to Gray Paper specification\n * \n * Gray Paper Equation 199-206: encode{WC  workcontext}\n * Fields:\n * 1. WC_anchorhash (32 bytes)\n * 2. WC_anchorpoststate (32 bytes)\n * 3. WC_anchoraccoutlog (32 bytes)\n * 4. WC_lookupanchorhash (32 bytes)\n * 5. encode[4]{WC_lookupanchortime} (4 bytes)\n * 6. var{WC_prerequisites} (variable-length sequence)\n */\nexport function encodeRefineContext(context: RefineContext): Uint8Array {\n  const parts: Uint8Array[] = []\n  \n  // 1. Anchor hash (32 bytes)\n  parts.push(context.anchor)\n  \n  // 2. State root (32 bytes)\n  parts.push(context.state_root)\n  \n  // 3. Beefy root (32 bytes)\n  parts.push(context.beefy_root)\n  \n  // 4. Lookup anchor (32 bytes)\n  parts.push(context.lookup_anchor)\n  \n  // 5. Lookup anchor slot - encode[4] (4 bytes, little-endian)\n  parts.push(encodeFixedLength(context.lookup_anchor_slot, 4))\n  \n  // 6. Prerequisites - var{} encoding (length prefix + hashes)\n  parts.push(encodeNatural(u64(context.prerequisites.length)))\n  \n  // Encode each prerequisite as 32-byte hash\n  for (let i = 0; i < context.prerequisites.length; i++) {\n    parts.push(context.prerequisites[i])\n  }\n  \n  return concatBytes(parts)\n}\n\n/**\n * Encode import reference according to Gray Paper specification\n * \n * Gray Paper Equation 305-311: encodeImportRef\n * Structure:\n * - h: 32-byte hash\n * - encode[2]{index}: 2-byte index with type encoding:\n *   - Regular hash: i (0-32767)\n *   - Refined hash: i + 2^15 (32768-65535)\n */\nexport function encodeImportReference(importRef: ImportSegment): Uint8Array {\n  const parts: Uint8Array[] = []\n  \n  // h: 32-byte hash\n  parts.push(importRef.treeRoot)\n  \n  // encode[2]{index}: 2-byte index with type encoding\n  let encodedIndex = importRef.index\n  if (importRef.isRefined) {\n    encodedIndex = importRef.index + 32768 // Add 2^15 for refined\n  }\n  \n  // Encode as 2-byte little-endian\n  parts.push(encodeFixedLength(u64(encodedIndex), 2))\n  \n  return concatBytes(parts)\n}\n\n/**\n * Encode extrinsic reference according to Gray Paper specification\n * \n * Gray Paper formula: (h, encode[4]{length})\n * Structure:\n * - h: 32-byte hash\n * - encode[4]{length}: 4-byte fixed-length length\n */\nexport function encodeExtrinsicReference(extrinsicRef: ExtrinsicReference): Uint8Array {\n  const parts: Uint8Array[] = []\n  \n  // h: 32-byte hash\n  parts.push(extrinsicRef.hash)\n  \n  // encode[4]{length}: 4-byte fixed-length length\n  parts.push(encodeFixedLength(u64(extrinsicRef.length), 4))\n  \n  return concatBytes(parts)\n}\n\n/**\n * Encode variable sequence (generic implementation)\n * \n * Generic variable-length sequence encoding with length prefix.\n * This is used for arrays/sequences in the Gray Paper.\n * \n * Format: encode(len) || item1 || item2 || .\n * \n * @param sequence - Array of items to encode\n * @returns Encoded sequence with length prefix\n */\nexport function encodeVariableSequence(sequence: Uint8Array[]): Uint8Array {\n  const parts: Uint8Array[] = []\n  \n  // Encode length prefix\n  parts.push(encodeNatural(u64(sequence.length)))\n  \n  // Encode each item\n  for (let i = 0; i < sequence.length; i++) {\n    parts.push(sequence[i])\n  }\n  \n  return concatBytes(parts)\n}\n\n/**\n * Encode work item according to Gray Paper specification\n * \n * Gray Paper Equation 242-264: encode{WI  workitem}\n * Fields:\n * 1. encode[4]{WI_serviceindex} - 4-byte service ID\n * 2. WI_codehash - 32-byte hash\n * 3. encode[8]{WI_refgaslimit} - 8-byte gas limit\n * 4. encode[8]{WI_accgaslimit} - 8-byte gas limit\n * 5. encode[2]{WI_exportcount} - 2-byte export count\n * 6. var{WI_payload} - variable-length payload\n * 7. var{WI_importsegments} - variable-length import segments\n * 8. var{WI_extrinsics} - variable-length extrinsic references\n */\nexport function encodeWorkItem(workItem: WorkItem): Uint8Array {\n  const parts: Uint8Array[] = []\n  \n  // 1. encode[4]{serviceindex} - 4-byte service ID\n  parts.push(encodeFixedLength(u64(workItem.serviceindex), 4))\n  \n  // 2. codehash - 32-byte hash\n  parts.push(workItem.codehash)\n  \n  // 3. encode[8]{refgaslimit} - 8-byte gas limit\n  parts.push(encodeFixedLength(workItem.refgaslimit, 8))\n  \n  // 4. encode[8]{accgaslimit} - 8-byte gas limit\n  parts.push(encodeFixedLength(workItem.accgaslimit, 8))\n  \n  // 5. encode[2]{exportcount} - 2-byte export count\n  parts.push(encodeFixedLength(u64(workItem.exportcount), 2))\n  \n  // 6. var{payload} - variable-length payload (length prefix + data)\n  parts.push(encodeNatural(u64(workItem.payload.length)))\n  parts.push(workItem.payload)\n  \n  // 7. var{importsegments} - variable-length import segments\n  parts.push(encodeNatural(u64(workItem.importsegments.length)))\n  for (let i = 0; i < workItem.importsegments.length; i++) {\n    parts.push(encodeImportReference(workItem.importsegments[i]))\n  }\n  \n  // 8. var{extrinsics} - variable-length extrinsic references\n  parts.push(encodeNatural(u64(workItem.extrinsics.length)))\n  for (let i = 0; i < workItem.extrinsics.length; i++) {\n    parts.push(encodeExtrinsicReference(workItem.extrinsics[i]))\n  }\n  \n  return concatBytes(parts)\n}\n\n/**\n * Encode work item summary according to Gray Paper S(w) function\n * \n * Gray Paper pvm_invocations.tex line 357: S(w)\n * Fields:\n * 1. encode[4]{serviceindex} - 4-byte service ID\n * 2. codehash - 32-byte hash\n * 3. encode[8]{refgaslimit} - 8-byte gas limit\n * 4. encode[8]{accgaslimit} - 8-byte gas limit\n * 5. encode[2]{exportcount} - 2-byte export count\n * 6. encode[2]{len(importsegments)} - 2-byte import count\n * 7. encode[2]{len(extrinsics)} - 2-byte extrinsic count\n * 8. encode[4]{len(payload)} - 4-byte payload length\n * \n * Total size: 4 + 32 + 8 + 8 + 2 + 2 + 2 + 4 = 62 bytes\n */\nexport function encodeWorkItemSummary(workItem: WorkItem): Uint8Array {\n  const parts: Uint8Array[] = []\n  \n  // 1. encode[4]{serviceindex} - 4-byte service ID\n  parts.push(encodeFixedLength(u64(workItem.serviceindex), 4))\n  \n  // 2. codehash - 32-byte hash\n  parts.push(workItem.codehash)\n  \n  // 3. encode[8]{refgaslimit} - 8-byte gas limit\n  parts.push(encodeFixedLength(workItem.refgaslimit, 8))\n  \n  // 4. encode[8]{accgaslimit} - 8-byte gas limit\n  parts.push(encodeFixedLength(workItem.accgaslimit, 8))\n  \n  // 5. encode[2]{exportcount} - 2-byte export count\n  parts.push(encodeFixedLength(u64(workItem.exportcount), 2))\n  \n  // 6. encode[2]{len(importsegments)} - 2-byte import count\n  parts.push(encodeFixedLength(u64(workItem.importsegments.length), 2))\n  \n  // 7. encode[2]{len(extrinsics)} - 2-byte extrinsic count\n  parts.push(encodeFixedLength(u64(workItem.extrinsics.length), 2))\n  \n  // 8. encode[4]{len(payload)} - 4-byte payload length\n  parts.push(encodeFixedLength(u64(workItem.payload.length), 4))\n  \n  return concatBytes(parts)\n}\n\n/**\n * Decode import reference according to Gray Paper specification\n * \n * Gray Paper Equation 305-311: encodeImportRef\n * Structure:\n * - h: 32-byte hash\n * - encode[2]{index}: 2-byte index with type encoding:\n *   - Regular hash: i (0-32767)\n *   - Refined hash: i + 2^15 (32768-65535)\n */\nexport function decodeImportReference(data: Uint8Array): DecodingResult<ImportSegment> | null {\n  if (data.length < 34) {\n    return null\n  }\n  \n  // h: 32-byte hash\n  const treeRoot = data.slice(0, 32)\n  \n  // encode[2]{index}: 2-byte index with type encoding\n  const indexResult = decodeFixedLength(data.slice(32), 2)\n  if (!indexResult) {\n    return null\n  }\n  const encodedIndex = u32(indexResult.value)\n  const isRefined = encodedIndex >= 32768\n  const index = isRefined ? encodedIndex - 32768 : encodedIndex\n  \n  const importSegment = new ImportSegment()\n  importSegment.treeRoot = treeRoot\n  importSegment.index = index\n  importSegment.isRefined = isRefined\n  \n  return new DecodingResult<ImportSegment>(importSegment, 34)\n}\n\n/**\n * Decode extrinsic reference according to Gray Paper specification\n * \n * Gray Paper formula: (h, encode[4]{length})\n * Structure:\n * - h: 32-byte hash\n * - encode[4]{length}: 4-byte fixed-length length\n */\nexport function decodeExtrinsicReference(data: Uint8Array): DecodingResult<ExtrinsicReference> | null {\n  if (data.length < 36) {\n    return null\n  }\n  \n  // h: 32-byte hash\n  const hash = data.slice(0, 32)\n  \n  // encode[4]{length}: 4-byte fixed-length length\n  const lengthResult = decodeFixedLength(data.slice(32), 4)\n  if (!lengthResult) {\n    return null\n  }\n  const length = u32(lengthResult.value)\n  \n  const extrinsicRef = new ExtrinsicReference()\n  extrinsicRef.hash = hash\n  extrinsicRef.length = length\n  \n  return new DecodingResult<ExtrinsicReference>(extrinsicRef, 36)\n}\n\n/**\n * Decode work item according to Gray Paper specification\n * \n * Gray Paper Equation 242-264: encode{WI  workitem}\n * Fields:\n * 1. encode[4]{WI_serviceindex} - 4-byte service ID\n * 2. WI_codehash - 32-byte hash\n * 3. encode[8]{WI_refgaslimit} - 8-byte gas limit\n * 4. encode[8]{WI_accgaslimit} - 8-byte gas limit\n * 5. encode[2]{WI_exportcount} - 2-byte export count\n * 6. var{WI_payload} - variable-length payload\n * 7. var{WI_importsegments} - variable-length import segments\n * 8. var{WI_extrinsics} - variable-length extrinsic references\n */\nexport function decodeWorkItem(data: Uint8Array): DecodingResult<WorkItem> | null {\n  let currentData = data\n  \n  // 1. decode[4]{serviceindex} - 4-byte service ID\n  const serviceIndexResult = decodeFixedLength(currentData, 4)\n  if (!serviceIndexResult) {\n    return null\n  }\n  const serviceIndex = u32(serviceIndexResult.value)\n  currentData = currentData.slice(serviceIndexResult.consumed)\n  \n  // 2. codehash - 32-byte hash\n  if (currentData.length < 32) {\n    return null\n  }\n  const codehash = currentData.slice(0, 32)\n  currentData = currentData.slice(32)\n  \n  // 3. decode[8]{refgaslimit} - 8-byte gas limit\n  const refGasLimitResult = decodeFixedLength(currentData, 8)\n  if (!refGasLimitResult) {\n    return null\n  }\n  const refgaslimit = refGasLimitResult.value\n  currentData = currentData.slice(refGasLimitResult.consumed)\n  \n  // 4. decode[8]{accgaslimit} - 8-byte gas limit\n  const accGasLimitResult = decodeFixedLength(currentData, 8)\n  if (!accGasLimitResult) {\n    return null\n  }\n  const accgaslimit = accGasLimitResult.value\n  currentData = currentData.slice(accGasLimitResult.consumed)\n  \n  // 5. decode[2]{exportcount} - 2-byte export count\n  const exportCountResult = decodeFixedLength(currentData, 2)\n  if (!exportCountResult) {\n    return null\n  }\n  const exportcount = u16(exportCountResult.value)\n  currentData = currentData.slice(exportCountResult.consumed)\n  \n  // 6. var{payload} - variable-length payload (length prefix + data)\n  const payloadLengthResult = decodeNatural(currentData)\n  if (!payloadLengthResult) {\n    return null\n  }\n  const payloadLength = i32(payloadLengthResult.value)\n  currentData = currentData.slice(payloadLengthResult.consumed)\n  if (currentData.length < payloadLength) {\n    return null\n  }\n  const payload = currentData.slice(0, payloadLength)\n  currentData = currentData.slice(payloadLength)\n  \n  // 7. var{importsegments} - variable-length import segments\n  const importSegmentsLengthResult = decodeNatural(currentData)\n  if (!importSegmentsLengthResult) {\n    return null\n  }\n  const importSegmentsLength = i32(importSegmentsLengthResult.value)\n  currentData = currentData.slice(importSegmentsLengthResult.consumed)\n  const importsegments = new Array<ImportSegment>()\n  for (let i = 0; i < importSegmentsLength; i++) {\n    const importSegmentResult = decodeImportReference(currentData)\n    if (!importSegmentResult) {\n      return null\n    }\n    importsegments.push(importSegmentResult.value)\n    currentData = currentData.slice(importSegmentResult.consumed)\n  }\n  \n  // 8. var{extrinsics} - variable-length extrinsic references\n  const extrinsicsLengthResult = decodeNatural(currentData)\n  if (!extrinsicsLengthResult) {\n    return null\n  }\n  const extrinsicsLength = i32(extrinsicsLengthResult.value)\n  currentData = currentData.slice(extrinsicsLengthResult.consumed)\n  const extrinsics = new Array<ExtrinsicReference>()\n  for (let i = 0; i < extrinsicsLength; i++) {\n    const extrinsicResult = decodeExtrinsicReference(currentData)\n    if (!extrinsicResult) {\n      return null\n    }\n    extrinsics.push(extrinsicResult.value)\n    currentData = currentData.slice(extrinsicResult.consumed)\n  }\n  \n  const workItem = new WorkItem()\n  workItem.serviceindex = serviceIndex\n  workItem.codehash = codehash\n  workItem.refgaslimit = refgaslimit\n  workItem.accgaslimit = accgaslimit\n  workItem.exportcount = exportcount\n  workItem.payload = payload\n  workItem.importsegments = importsegments\n  workItem.extrinsics = extrinsics\n  \n  const consumed = data.length - currentData.length\n  return new DecodingResult<WorkItem>(workItem, consumed)\n}\n\n/**\n * Encode work package according to Gray Paper specification\n * \n * Gray Paper Equation 242-264: encode{WP  workpackage}\n * Fields:\n * 1. encode[4]{WP_authcodehost} - 4-byte service ID\n * 2. WP_authcodehash - 32-byte hash\n * 3. WP_context - work context structure\n * 4. var{WP_authtoken} - variable-length auth token\n * 5. var{WP_authconfig} - variable-length auth config\n * 6. var{WP_workitems} - variable-length work items\n */\nexport function encodeWorkPackage(workPackage: WorkPackage): Uint8Array {\n  const parts: Uint8Array[] = []\n  \n  // 1. encode[4]{authcodehost} - 4-byte service ID\n  parts.push(encodeFixedLength(u64(workPackage.authCodeHost), 4))\n  \n  // 2. authcodehash - 32-byte hash\n  parts.push(workPackage.authCodeHash)\n  \n  // 3. context - work context structure\n  parts.push(encodeRefineContext(workPackage.context))\n  \n  // 4. var{authtoken} - variable-length auth token\n  parts.push(encodeNatural(u64(workPackage.authToken.length)))\n  parts.push(workPackage.authToken)\n  \n  // 5. var{authconfig} - variable-length auth config\n  parts.push(encodeNatural(u64(workPackage.authConfig.length)))\n  parts.push(workPackage.authConfig)\n  \n  // 6. var{workitems} - variable-length work items\n  parts.push(encodeNatural(u64(workPackage.workItems.length)))\n  for (let i = 0; i < workPackage.workItems.length; i++) {\n    parts.push(encodeWorkItem(workPackage.workItems[i]))\n  }\n  \n  return concatBytes(parts)\n}\n\n// ============================================================================\n// Fixed-Length Integer Decoding (Gray Paper compliant)\n// ============================================================================\n\n/**\n * Decode natural number from fixed-length little-endian encoding\n * \n * Gray Paper: decode[l](data) - Fixed-length decoding in l bytes\n * Formula: Little-endian decoding\n * \n * @param data - Octet sequence to decode\n * @param length - Fixed length in bytes (1, 2, 4, 8, etc.)\n * @returns Decoded value and remaining data\n */\n/**\n * Decode accumulate arguments according to Gray Paper specification\n *\n * Gray Paper pvm_invocations.tex equation 163: encode{t, s, len(i)}\n * All values use variable-length natural number encoding (decodeNatural):\n * - t (timeslot): decodeNatural (variable)\n * - s (serviceId): decodeNatural (variable)\n * - len(i) (input length): decodeNatural (variable)\n *\n * Note: This differs from fixed-length encodings used elsewhere (e.g. encode[4] in headers).\n * The general encode{} notation uses variable-length encoding.\n *\n * @param args - Encoded accumulate arguments\n * @returns Decoding result with timeslot, serviceId, and inputLength, or null if decoding fails\n */\nexport function decodeAccumulateArgs(\n  args: Uint8Array,\n): DecodingResult<DecodedAccumulateArgs> | null {\n  if (args.length < 1) {\n    return null\n  }\n\n  let offset: i32 = 0\n\n  // 1. Decode timeslot - Gray Paper: encode{t} (variable-length natural number)\n  const timeslotResult = decodeNatural(args.slice(offset))\n  if (!timeslotResult) {\n    return null\n  }\n  const timeslot = timeslotResult.value\n  offset += timeslotResult.consumed\n\n  // 2. Decode service ID - Gray Paper: encode{s} (variable-length natural number)\n  if (offset >= args.length) {\n    return null\n  }\n  const serviceIdResult = decodeNatural(args.slice(offset))\n  if (!serviceIdResult) {\n    return null\n  }\n  const serviceId = serviceIdResult.value\n  offset += serviceIdResult.consumed\n\n  // 3. Decode input length - Gray Paper: encode{len(i)} (variable-length natural number)\n  if (offset >= args.length) {\n    return null\n  }\n  const inputLengthResult = decodeNatural(args.slice(offset))\n  if (!inputLengthResult) {\n    return null\n  }\n  const inputLength = inputLengthResult.value\n  offset += inputLengthResult.consumed\n\n  return new DecodingResult(\n    new DecodedAccumulateArgs(timeslot, serviceId, inputLength),\n    offset,\n  )\n}\n\nexport function decodeFixedLength(data: Uint8Array, length: i32): DecodingResult<u64> | null {\n  if (data.length < length) {\n    return null\n  }\n  \n  let value: u64 = u64(0)\n  \n  // Little-endian decoding\n  for (let i = 0; i < length; i++) {\n    value |= u64(data[i]) << u64(i * 8)\n  }\n  \n  return new DecodingResult<u64>(value, length)\n}\n\n// ============================================================================\n// Variable-Length Decoding (Gray Paper compliant)\n// ============================================================================\n\n/**\n * Decode variable-length term with length discriminator\n * \n * Gray Paper: var{x} = len(x), x\n * Format: encode(len) || data\n * \n * @param data - Octet sequence to decode\n * @returns Decoded data and remaining octet sequence\n */\nexport function decodeVariableLength(data: Uint8Array): DecodingResult<Uint8Array> | null {\n  const lengthResult = decodeNatural(data)\n  if (!lengthResult) {\n    return null\n  }\n  \n  const length = i32(lengthResult.value)\n  const offset = lengthResult.consumed\n  \n  if (data.length < offset + length) {\n    return null\n  }\n  \n  const value = data.slice(offset, offset + length)\n  const remaining = data.slice(offset + length)\n  \n  return new DecodingResult<Uint8Array>(value, offset + length)\n}\n\n// ============================================================================\n// Dictionary Decoding (Gray Paper compliant)\n// ============================================================================\n\n/**\n * Dictionary entry structure\n */\nexport class DictionaryEntry {\n  key: Uint8Array\n  value: Uint8Array\n  \n  constructor(key: Uint8Array, value: Uint8Array) {\n    this.key = key\n    this.value = value\n  }\n}\n\n// ============================================================================\n// Variable Sequence Decoding (Gray Paper compliant)\n// ============================================================================\n\n/**\n * Decode variable-length sequence with custom element decoder\n * \n * Gray Paper: var{sequence} = encode(len) || encode(element0) || encode(element1) || ...\n * \n * @param data - Octet sequence to decode\n * @param elementDecoder - Function to decode individual elements\n * @returns Decoded sequence and remaining data\n */\nexport function decodeVariableSequence<T>(\n  data: Uint8Array,\n  elementDecoder: (data: Uint8Array) => DecodingResult<T> | null,\n): DecodingResult<T[]> | null {\n  // Decode length prefix\n  const lengthResult = decodeNatural(data)\n  if (!lengthResult) {\n    return null\n  }\n  \n  const length = i32(lengthResult.value)\n  let currentData = data.slice(lengthResult.consumed)\n  \n  const result = new Array<T>()\n  \n  // Decode each element\n  for (let i = 0; i < length; i++) {\n    const elementResult = elementDecoder(currentData)\n    if (!elementResult) {\n      return null\n    }\n    result.push(elementResult.value)\n    currentData = currentData.slice(elementResult.consumed)\n  }\n  \n  const consumed = data.length - currentData.length\n  return new DecodingResult<T[]>(result, consumed)\n}\n\n// ============================================================================\n// Service Account Structures (AssemblyScript)\n// ============================================================================\n\n/**\n * RawCshKeyvals entry structure\n * Matches TypeScript's Record<Hex, Hex> - a flat key-value dictionary\n * where keys are state keys and values are state values\n */\nexport class CshEntry {\n  key: Uint8Array   // State key (variable length)\n  value: Uint8Array // State value (variable length)\n  \n  constructor(key: Uint8Array, value: Uint8Array) {\n    this.key = key\n    this.value = value\n  }\n}\n\n/**\n * RawCshKeyvals - Flat key-value store for service account data\n * Matches TypeScript's rawCshKeyvals: Record<Hex, Hex>\n * \n * This flattened structure contains all storage, preimages, and requests\n * in a single dictionary, matching the TypeScript implementation.\n */\nexport class RawCshKeyvals {\n  entries: Array<CshEntry>\n  \n  constructor() {\n    this.entries = new Array<CshEntry>()\n  }\n  \n  set(key: Uint8Array, value: Uint8Array): void {\n    // Find existing entry\n    for (let i = 0; i < this.entries.length; i++) {\n      if (this.compareKeys(this.entries[i].key, key)) {\n        this.entries[i].value = value\n        return\n      }\n    }\n    // Add new entry\n    this.entries.push(new CshEntry(key, value))\n  }\n  \n  get(key: Uint8Array): Uint8Array | null {\n    for (let i = 0; i < this.entries.length; i++) {\n      if (this.compareKeys(this.entries[i].key, key)) {\n        return this.entries[i].value\n      }\n    }\n    return null\n  }\n  \n  has(key: Uint8Array): bool {\n    return this.get(key) !== null\n  }\n  \n  delete(key: Uint8Array): bool {\n    for (let i = 0; i < this.entries.length; i++) {\n      if (this.compareKeys(this.entries[i].key, key)) {\n        this.entries.splice(i, 1)\n        return true\n      }\n    }\n    return false\n  }\n  \n  keys(): Array<Uint8Array> {\n    const result = new Array<Uint8Array>()\n    for (let i = 0; i < this.entries.length; i++) {\n      result.push(this.entries[i].key)\n    }\n    return result\n  }\n  \n  private compareKeys(a: Uint8Array, b: Uint8Array): bool {\n    if (a.length !== b.length) return false\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false\n    }\n    return true\n  }\n}\n\n// ============================================================================\n// RawCshKeyvals Helper Functions\n// These functions help access storage/preimages/requests from the flattened\n// rawCshKeyvals dictionary, matching the TypeScript helper functions.\n// ============================================================================\n\n/**\n * Create a C(s, h) state key from serviceId and blake hash\n * \n * Gray Paper format: C(s, h) = n, a, n, a, n, a, n, a, a, a, ..., a\n * where n = encode[4](serviceId), a = blake(h)[0:27]\n * \n * This creates a 31-byte interleaved key.\n */\nfunction createCshKey(serviceId: u32, combinedData: Uint8Array): Uint8Array {\n  // Compute Blake2b-256 hash of the combined data\n  const blakeHashFull = blake2b256(combinedData)\n  \n  // Take first 27 bytes of Blake hash\n  const blakeHash = blakeHashFull.slice(0, 27)\n  \n  // Encode serviceId as 4 bytes little-endian\n  const serviceBytes = new Uint8Array(4)\n  serviceBytes[0] = u8(serviceId & 0xFF)\n  serviceBytes[1] = u8((serviceId >> 8) & 0xFF)\n  serviceBytes[2] = u8((serviceId >> 16) & 0xFF)\n  serviceBytes[3] = u8((serviceId >> 24) & 0xFF)\n  \n  // Create 31-byte interleaved key\n  const key = new Uint8Array(31)\n  \n  // Interleave: n, a, n, a, n, a, n, a, a, a, ..., a\n  key[0] = serviceBytes[0]  // n\n  key[1] = blakeHash[0]     // a\n  key[2] = serviceBytes[1]  // n\n  key[3] = blakeHash[1]     // a\n  key[4] = serviceBytes[2]  // n\n  key[5] = blakeHash[2]     // a\n  key[6] = serviceBytes[3]  // n\n  key[7] = blakeHash[3]     // a\n  \n  // Remaining 23 bytes: a, a, ..., a\n  for (let i = 4; i < 27; i++) {\n    key[8 + (i - 4)] = blakeHash[i]\n  }\n  \n  return key\n}\n\n/**\n * Create a storage key from service ID and storage key blob\n * Gray Paper: C(s, encode[4]{2^32-1} || k)\n * \n * Special handling: If storageKey is already 27 bytes (Blake hash from state loading),\n * skip hashing and directly interleave with serviceId.\n */\nexport function createStorageKey(serviceId: u32, storageKey: Uint8Array): Uint8Array {\n  // Check if storageKey is already a 27-byte Blake hash (from state loading)\n  // When loading from state, we store h (27-byte Blake hash) directly\n  // When creating new storage (from PVM), we have k (original storage key)\n  if (storageKey.length === 27) {\n    // Storage key is already a Blake hash - use it directly to construct state key\n    // C(s, h) where h is already blake(encode[4]{0xFFFFFFFF} || k)\n    // We just need to interleave serviceId with the 27-byte hash\n    const key = new Uint8Array(31)\n    \n    // Encode serviceId as 4 bytes little-endian\n    const serviceBytes = new Uint8Array(4)\n    serviceBytes[0] = u8(serviceId & 0xFF)\n    serviceBytes[1] = u8((serviceId >> 8) & 0xFF)\n    serviceBytes[2] = u8((serviceId >> 16) & 0xFF)\n    serviceBytes[3] = u8((serviceId >> 24) & 0xFF)\n    \n    // Interleave: n, a, n, a, n, a, n, a, a, a, ..., a\n    key[0] = serviceBytes[0]    // n\n    key[1] = storageKey[0]      // a\n    key[2] = serviceBytes[1]    // n\n    key[3] = storageKey[1]      // a\n    key[4] = serviceBytes[2]    // n\n    key[5] = storageKey[2]      // a\n    key[6] = serviceBytes[3]    // n\n    key[7] = storageKey[3]      // a\n    \n    // Remaining 23 bytes: a, a, ..., a\n    for (let i = 4; i < 27; i++) {\n      key[8 + (i - 4)] = storageKey[i]\n    }\n    \n    return key\n  }\n  \n  // Storage key is the original key `k` - compute blake(encode[4]{0xFFFFFFFF} || k)\n  // Prefix: encode[4]{2^32-1} = 0xFFFFFFFF (little-endian)\n  const prefix = new Uint8Array(4)\n  prefix[0] = 0xFF\n  prefix[1] = 0xFF\n  prefix[2] = 0xFF\n  prefix[3] = 0xFF\n  // Concatenate prefix + storage key\n  const combinedData = concatBytes([prefix, storageKey])\n  // Create proper C(s, h) key\n  return createCshKey(serviceId, combinedData)\n}\n\n/**\n * Create a preimage key from service ID and preimage hash\n * Gray Paper: C(s, encode[4]{2^32-2} || h)\n * \n * Special handling: If preimageHash is already 27 bytes (Blake hash from state loading),\n * skip hashing and directly interleave with serviceId.\n */\nexport function createPreimageKey(serviceId: u32, preimageHash: Uint8Array): Uint8Array {\n  // Check if preimageHash is already a 27-byte Blake hash (from state loading)\n  if (preimageHash.length === 27) {\n    // Preimage hash is already a Blake hash - use it directly to construct state key\n    const key = new Uint8Array(31)\n    \n    // Encode serviceId as 4 bytes little-endian\n    const serviceBytes = new Uint8Array(4)\n    serviceBytes[0] = u8(serviceId & 0xFF)\n    serviceBytes[1] = u8((serviceId >> 8) & 0xFF)\n    serviceBytes[2] = u8((serviceId >> 16) & 0xFF)\n    serviceBytes[3] = u8((serviceId >> 24) & 0xFF)\n    \n    // Interleave: n, a, n, a, n, a, n, a, a, a, ..., a\n    key[0] = serviceBytes[0]      // n\n    key[1] = preimageHash[0]      // a\n    key[2] = serviceBytes[1]      // n\n    key[3] = preimageHash[1]      // a\n    key[4] = serviceBytes[2]      // n\n    key[5] = preimageHash[2]      // a\n    key[6] = serviceBytes[3]      // n\n    key[7] = preimageHash[3]      // a\n    \n    // Remaining 23 bytes: a, a, ..., a\n    for (let i = 4; i < 27; i++) {\n      key[8 + (i - 4)] = preimageHash[i]\n    }\n    \n    return key\n  }\n  \n  // Preimage hash is the full 32-byte hash - compute blake(encode[4]{0xFFFFFFFE} || h)\n  // Prefix: encode[4]{2^32-2} = 0xFEFFFFFF (little-endian)\n  const prefix = new Uint8Array(4)\n  prefix[0] = 0xFE\n  prefix[1] = 0xFF\n  prefix[2] = 0xFF\n  prefix[3] = 0xFF\n  // Concatenate prefix + preimage hash\n  const combinedData = concatBytes([prefix, preimageHash])\n  // Create proper C(s, h) key\n  return createCshKey(serviceId, combinedData)\n}\n\n/**\n * Create a request key from service ID, request hash, and length\n * Gray Paper: C(s, encode[4]{l} || h)\n * \n * Special handling: If requestHash is already 27 bytes (Blake hash from state loading),\n * skip hashing and directly interleave with serviceId.\n */\nexport function createRequestKey(serviceId: u32, requestHash: Uint8Array, length: u64): Uint8Array {\n  // Check if requestHash is already a 27-byte Blake hash (from state loading)\n  if (requestHash.length === 27) {\n    // Request hash is already a Blake hash - use it directly to construct state key\n    const key = new Uint8Array(31)\n    \n    // Encode serviceId as 4 bytes little-endian\n    const serviceBytes = new Uint8Array(4)\n    serviceBytes[0] = u8(serviceId & 0xFF)\n    serviceBytes[1] = u8((serviceId >> 8) & 0xFF)\n    serviceBytes[2] = u8((serviceId >> 16) & 0xFF)\n    serviceBytes[3] = u8((serviceId >> 24) & 0xFF)\n    \n    // Interleave: n, a, n, a, n, a, n, a, a, a, ..., a\n    key[0] = serviceBytes[0]      // n\n    key[1] = requestHash[0]       // a\n    key[2] = serviceBytes[1]      // n\n    key[3] = requestHash[1]       // a\n    key[4] = serviceBytes[2]      // n\n    key[5] = requestHash[2]       // a\n    key[6] = serviceBytes[3]      // n\n    key[7] = requestHash[3]       // a\n    \n    // Remaining 23 bytes: a, a, ..., a\n    for (let i = 4; i < 27; i++) {\n      key[8 + (i - 4)] = requestHash[i]\n    }\n    \n    return key\n  }\n  \n  // Request hash is the full 32-byte hash - compute blake(encode[4]{l} || h)\n  // Prefix: encode[4]{length} (little-endian)\n  const prefix = encodeFixedLength(length, 4)\n  // Concatenate prefix + request hash\n  const combinedData = concatBytes([prefix, requestHash])\n  // Create proper C(s, h) key\n  return createCshKey(serviceId, combinedData)\n}\n\n/**\n * Get storage value from rawCshKeyvals\n */\nexport function getStorageValue(account: CompleteServiceAccount, serviceId: u32, storageKey: Uint8Array): Uint8Array | null {\n  const key = createStorageKey(serviceId, storageKey)\n  return account.rawCshKeyvals.get(key)\n}\n\n/**\n * Set storage value in rawCshKeyvals\n */\nexport function setStorageValue(account: CompleteServiceAccount, serviceId: u32, storageKey: Uint8Array, value: Uint8Array): void {\n  const key = createStorageKey(serviceId, storageKey)\n  account.rawCshKeyvals.set(key, value)\n}\n\n/**\n * Delete storage value from rawCshKeyvals\n */\nexport function deleteStorageValue(account: CompleteServiceAccount, serviceId: u32, storageKey: Uint8Array): bool {\n  const key = createStorageKey(serviceId, storageKey)\n  return account.rawCshKeyvals.delete(key)\n}\n\n/**\n * Get preimage value from rawCshKeyvals\n */\nexport function getPreimageValue(account: CompleteServiceAccount, serviceId: u32, preimageHash: Uint8Array): Uint8Array | null {\n  const key = createPreimageKey(serviceId, preimageHash)\n  return account.rawCshKeyvals.get(key)\n}\n\n/**\n * Set preimage value in rawCshKeyvals\n */\nexport function setPreimageValue(account: CompleteServiceAccount, serviceId: u32, preimageHash: Uint8Array, blob: Uint8Array): void {\n  const key = createPreimageKey(serviceId, preimageHash)\n  account.rawCshKeyvals.set(key, blob)\n}\n\n/**\n * Delete preimage value from rawCshKeyvals\n */\nexport function deletePreimageValue(account: CompleteServiceAccount, serviceId: u32, preimageHash: Uint8Array): bool {\n  const key = createPreimageKey(serviceId, preimageHash)\n  return account.rawCshKeyvals.delete(key)\n}\n\n/**\n * Get request value from rawCshKeyvals\n * Returns the raw encoded value (sequence of timeslots)\n */\nexport function getRequestValue(account: CompleteServiceAccount, serviceId: u32, requestHash: Uint8Array, length: u64): Uint8Array | null {\n  const key = createRequestKey(serviceId, requestHash, length)\n  return account.rawCshKeyvals.get(key)\n}\n\n/**\n * Set request value in rawCshKeyvals\n * Value should be the encoded sequence of timeslots\n */\nexport function setRequestValue(account: CompleteServiceAccount, serviceId: u32, requestHash: Uint8Array, length: u64, value: Uint8Array): void {\n  const key = createRequestKey(serviceId, requestHash, length)\n  account.rawCshKeyvals.set(key, value)\n}\n\n/**\n * Delete request value from rawCshKeyvals\n */\nexport function deleteRequestValue(account: CompleteServiceAccount, serviceId: u32, requestHash: Uint8Array, length: u64): bool {\n  const key = createRequestKey(serviceId, requestHash, length)\n  return account.rawCshKeyvals.delete(key)\n}\n\n/**\n * Encode request timeslots to value format\n * Gray Paper: encode{var{sequence{encode[4]{x} | x  t}}}\n */\nexport function encodeRequestTimeslots(timeslots: u32[]): Uint8Array {\n  return encodeVariableSequenceGeneric<u32>(\n    timeslots,\n    (slot: u32) => encodeFixedLength(u64(slot), 4),\n  )\n}\n\n/**\n * Decode request timeslots from value format\n */\nexport function decodeRequestTimeslots(value: Uint8Array): u32[] | null {\n  const result = decodeVariableSequence<u32>(\n    value,\n    (data: Uint8Array) => {\n      const fixedResult = decodeFixedLength(data, 4)\n      if (!fixedResult) {\n        return null\n      }\n      return new DecodingResult<u32>(u32(fixedResult.value), 4)\n    },\n  )\n  if (!result) {\n    return null\n  }\n  return result.value\n}\n\n/**\n * Storage entry structure\n * @deprecated Use RawCshKeyvals instead\n */\nexport class StorageEntry {\n  key: Uint8Array\n  value: Uint8Array\n  \n  constructor(key: Uint8Array, value: Uint8Array) {\n    this.key = key\n    this.value = value\n  }\n}\n\n/**\n * Preimage entry structure\n */\nexport class PreimageEntry {\n  hash: Uint8Array\n  blob: Uint8Array\n  \n  constructor(hash: Uint8Array, blob: Uint8Array) {\n    this.hash = hash\n    this.blob = blob\n  }\n}\n\n/**\n * Preimage Request Status (sequence of up to 3 timeslots)\n */\nexport class PreimageRequestStatus {\n  timeslots: u32[]\n  \n  constructor() {\n    this.timeslots = new Array<u32>()\n  }\n}\n\n/**\n * Request entry structure\n */\nexport class RequestEntry {\n  hash: Uint8Array\n  length: u64\n  status: PreimageRequestStatus\n  \n  constructor(hash: Uint8Array, length: u64, status: PreimageRequestStatus) {\n    this.hash = hash\n    this.length = length\n    this.status = status\n  }\n}\n\n\n/**\n * Complete Service Account structure (AssemblyScript)\n * \n * Matches TypeScript ServiceAccount interface with rawCshKeyvals\n * for flattened storage/preimages/requests dictionary.\n */\nexport class CompleteServiceAccount {\n  codehash: Uint8Array // 32 bytes\n  balance: u64\n  minaccgas: u64\n  minmemogas: u64\n  octets: u64\n  gratis: u64\n  items: u32\n  created: u32\n  lastacc: u32\n  parent: u32\n  \n  /**\n   * Flattened key-value store for storage, preimages, and requests\n   * Matches TypeScript's rawCshKeyvals: Record<Hex, Hex>\n   */\n  rawCshKeyvals: RawCshKeyvals\n\n  \n  constructor() {\n    this.codehash = new Uint8Array(32)\n    this.balance = u64(0)\n    this.minaccgas = u64(0)\n    this.minmemogas = u64(0)\n    this.octets = u64(0)\n    this.gratis = u64(0)\n    this.items = 0\n    this.created = 0\n    this.lastacc = 0\n    this.parent = 0\n    this.rawCshKeyvals = new RawCshKeyvals()\n  }\n}\n\n\n/**\n * Decode complete ServiceAccount according to Gray Paper accounts.tex equation 12-27\n * \n * NOTE: This implementation matches TypeScript's decodeCompleteServiceAccount\n * which decodes rawCshKeyvals as a SINGLE dictionary (flattened storage/preimages/requests).\n * \n * Gray Paper: serviceaccount  tuple{\n *   sa_storage  dictionary{blob}{blob},\n *   sa_preimages  dictionary{hash}{blob},\n *   sa_requests  dictionary{tuple{hash, bloblength}}{sequence[:3]{timeslot}},\n *   sa_gratis  balance,\n *   sa_codehash  hash,\n *   sa_balance  balance,\n *   sa_minaccgas  gas,\n *   sa_minmemogas  gas,\n *   sa_created  timeslot,\n *   sa_lastacc  timeslot,\n *   sa_parent  serviceid\n * }\n * \n * @param data - Octet sequence to decode\n * @returns Decoded ServiceAccount and remaining data\n */\nexport function decodeCompleteServiceAccount(\n  data: Uint8Array,\n): DecodingResult<CompleteServiceAccount> | null {\n  let currentData = data\n  \n  const account = new CompleteServiceAccount()\n  \n  // rawCshKeyvals: decode{dictionary{blob}{blob}}\n  // This is a single flattened dictionary matching TypeScript's rawCshKeyvals\n  const keyvalVarResult = decodeVariableLength(currentData)\n  if (!keyvalVarResult) {\n    return null\n  }\n  const keyvalPairs = keyvalVarResult.value\n  currentData = currentData.slice(keyvalVarResult.consumed)\n  \n  let keyvalData = keyvalPairs\n  // Decode pairs until we've processed all bytes\n  while (keyvalData.length > 0) {\n    // Decode key: var{blob} = length prefix + blob\n    const keyVarResult = decodeVariableLength(keyvalData)\n    if (!keyVarResult) {\n      break\n    }\n    const keyBytes = keyVarResult.value\n    keyvalData = keyvalData.slice(keyVarResult.consumed)\n    \n    // Decode value: var{blob} = length prefix + blob\n    const valueVarResult = decodeVariableLength(keyvalData)\n    if (!valueVarResult) {\n      break\n    }\n    const valueBytes = valueVarResult.value\n    keyvalData = keyvalData.slice(valueVarResult.consumed)\n    \n    // Store in rawCshKeyvals\n    account.rawCshKeyvals.set(keyBytes, valueBytes)\n  }\n  \n  // sa_octets: decode[8]{octets} (8-byte fixed-length) - read octets from encoding\n  const octetsResult = decodeFixedLength(currentData, 8)\n  if (!octetsResult) {\n    return null\n  }\n  account.octets = octetsResult.value\n  currentData = currentData.slice(octetsResult.consumed)\n  \n  // sa_items: decode[4]{items} (4-byte fixed-length) - read items from encoding\n  const itemsResult = decodeFixedLength(currentData, 4)\n  if (!itemsResult) {\n    return null\n  }\n  account.items = u32(itemsResult.value)\n  currentData = currentData.slice(itemsResult.consumed)\n  \n  // sa_gratis: decode[8]{balance} (8-byte fixed-length)\n  const gratisResult = decodeFixedLength(currentData, 8)\n  if (!gratisResult) {\n    return null\n  }\n  account.gratis = gratisResult.value\n  currentData = currentData.slice(gratisResult.consumed)\n  \n  // sa_codehash: hash (32-byte blob, identity encoding)\n  if (currentData.length < 32) {\n    return null\n  }\n  account.codehash = currentData.slice(0, 32)\n  currentData = currentData.slice(32)\n  \n  // sa_balance: decode[8]{balance} (8-byte fixed-length)\n  const balanceResult = decodeFixedLength(currentData, 8)\n  if (!balanceResult) {\n    return null\n  }\n  account.balance = balanceResult.value\n  currentData = currentData.slice(balanceResult.consumed)\n  \n  // sa_minaccgas: decode[8]{gas} (8-byte fixed-length)\n  const minAccGasResult = decodeFixedLength(currentData, 8)\n  if (!minAccGasResult) {\n    return null\n  }\n  account.minaccgas = minAccGasResult.value\n  currentData = currentData.slice(minAccGasResult.consumed)\n  \n  // sa_minmemogas: decode[8]{gas} (8-byte fixed-length)\n  const minMemoGasResult = decodeFixedLength(currentData, 8)\n  if (!minMemoGasResult) {\n    return null\n  }\n  account.minmemogas = minMemoGasResult.value\n  currentData = currentData.slice(minMemoGasResult.consumed)\n  \n  // sa_created: decode[4]{timeslot} (4-byte fixed-length)\n  const createdResult = decodeFixedLength(currentData, 4)\n  if (!createdResult) {\n    return null\n  }\n  account.created = u32(createdResult.value)\n  currentData = currentData.slice(createdResult.consumed)\n  \n  // sa_lastacc: decode[4]{timeslot} (4-byte fixed-length)\n  const lastAccResult = decodeFixedLength(currentData, 4)\n  if (!lastAccResult) {\n    return null\n  }\n  account.lastacc = u32(lastAccResult.value)\n  currentData = currentData.slice(lastAccResult.consumed)\n  \n  // sa_parent: decode[4]{serviceid} (4-byte fixed-length)\n  const parentResult = decodeFixedLength(currentData, 4)\n  if (!parentResult) {\n    return null\n  }\n  account.parent = u32(parentResult.value)\n  currentData = currentData.slice(parentResult.consumed)\n  \n  // Note: octets and items are already read from the encoding above (lines 2093-2107)\n  // Do NOT recompute them - they should be preserved from the encoding\n  \n  const consumed = data.length - currentData.length\n  return new DecodingResult<CompleteServiceAccount>(account, consumed)\n}\n\n// ============================================================================\n// PartialState Structures (AssemblyScript)\n// ============================================================================\n\n/**\n * Account entry structure\n */\nexport class AccountEntry {\n  serviceId: u32\n  account: CompleteServiceAccount\n  \n  constructor(serviceId: u32, account: CompleteServiceAccount) {\n    this.serviceId = serviceId\n    this.account = account\n  }\n}\n\n/**\n * AlwaysAccer entry structure\n */\nexport class AlwaysAccerEntry {\n  serviceId: u32\n  gas: u64\n  \n  constructor(serviceId: u32, gas: u64) {\n    this.serviceId = serviceId\n    this.gas = gas\n  }\n}\n\n/**\n * PartialState structure (AssemblyScript)\n */\nexport class PartialState {\n  accounts: Array<AccountEntry>\n  stagingset: Uint8Array[]\n  authqueue: Uint8Array[][]\n  manager: u32\n  assigners: u32[]\n  delegator: u32\n  registrar: u32\n  alwaysaccers: Array<AlwaysAccerEntry>\n  \n  constructor() {\n    this.accounts = new Array<AccountEntry>()\n    this.stagingset = new Array<Uint8Array>()\n    this.authqueue = new Array<Array<Uint8Array>>()\n    this.manager = 0\n    this.assigners = new Array<u32>()\n    this.delegator = 0\n    this.registrar = 0\n    this.alwaysaccers = new Array<AlwaysAccerEntry>()\n  }\n}\n\n/**\n * Decode PartialState according to Gray Paper specification\n * \n * Gray Paper accumulation.tex equation 133-144:\n * partialstate  tuple{\n *   ps_accounts: dictionary<serviceid, serviceaccount>,\n *   ps_stagingset: sequence[Cvalcount]{valkey},\n *   ps_authqueue: sequence[Ccorecount]{sequence[C_authqueuesize]{hash}},\n *   ps_manager: serviceid,\n *   ps_assigners: sequence[Ccorecount]{serviceid},\n *   ps_delegator: serviceid,\n *   ps_registrar: serviceid,\n *   ps_alwaysaccers: dictionary<serviceid, gas>\n * }\n * \n * @param data - Octet sequence to decode\n * @param numCores - Number of cores (Ccorecount)\n * @param numValidators - Number of validators (Cvalcount)\n * @param authQueueSize - Authorization queue size (C_authqueuesize)\n * @returns Decoded PartialState and remaining data\n */\nexport function decodePartialState(\n  data: Uint8Array,\n  numCores: i32,\n  numValidators: i32,\n  authQueueSize: i32,\n): DecodingResult<PartialState> | null {\n  let currentData = data\n  \n  const partialState = new PartialState()\n  \n  // ps_accounts: decode{var{sequence{sorted(serviceid, serviceaccount)}}}\n  // For dictionaries with variable-length values (service accounts), we need to decode\n  // each value to know where it ends, since service accounts are self-delimiting\n  // Note: This matches TypeScript's manual decoding approach\n  const accountsVarResult = decodeVariableLength(currentData)\n  if (!accountsVarResult) {\n    return null\n  }\n  const accountsData = accountsVarResult.value\n  currentData = currentData.slice(accountsVarResult.consumed)\n  \n  let accountsRemaining = accountsData\n  while (accountsRemaining.length >= 4) {\n    // Decode service ID (4 bytes)\n    const serviceIdResult = decodeFixedLength(accountsRemaining, 4)\n    if (!serviceIdResult) {\n      break\n    }\n    const serviceId = u32(serviceIdResult.value)\n    accountsRemaining = accountsRemaining.slice(serviceIdResult.consumed)\n    \n    // Decode complete service account (self-delimiting)\n    const accountResult = decodeCompleteServiceAccount(accountsRemaining)\n    if (!accountResult) {\n      break\n    }\n    const account = accountResult.value\n    accountsRemaining = accountsRemaining.slice(accountResult.consumed)\n    \n    partialState.accounts.push(new AccountEntry(serviceId, account))\n  }\n  \n  // ps_stagingset: decode{sequence[Cvalcount]{valkey}} (fixed-length, no var{})\n  // Each valkey is 336 bytes\n  const VALIDATOR_KEY_SIZE = 336\n  const stagingsetSize = numValidators * VALIDATOR_KEY_SIZE\n  if (currentData.length < stagingsetSize) {\n    return null\n  }\n  \n  for (let i = 0; i < numValidators; i++) {\n    const validatorKey = currentData.slice(i * VALIDATOR_KEY_SIZE, (i + 1) * VALIDATOR_KEY_SIZE)\n    partialState.stagingset.push(validatorKey)\n  }\n  currentData = currentData.slice(stagingsetSize)\n  \n  // ps_authqueue: decode{sequence[Ccorecount]{sequence[C_authqueuesize]{hash}}} (fixed-length)\n  // Gray Paper: C_authqueuesize = 80 (constant, not from config)\n  // Each hash is 32 bytes\n  const HASH_SIZE = 32\n  const AUTH_QUEUE_SIZE = 80 // AUTHORIZATION_CONSTANTS.C_AUTHQUEUESIZE\n  const coreQueueSize = AUTH_QUEUE_SIZE * HASH_SIZE\n  \n  for (let coreIdx = 0; coreIdx < numCores; coreIdx++) {\n    if (currentData.length < coreQueueSize) {\n      return null\n    }\n    const coreQueue = new Array<Uint8Array>()\n    for (let authIdx = 0; authIdx < AUTH_QUEUE_SIZE; authIdx++) {\n      const hash = currentData.slice(authIdx * HASH_SIZE, (authIdx + 1) * HASH_SIZE)\n      coreQueue.push(hash)\n    }\n    partialState.authqueue.push(coreQueue)\n    currentData = currentData.slice(coreQueueSize)\n  }\n  \n  // ps_manager: decode[4]{serviceid} (4-byte fixed-length)\n  const managerResult = decodeFixedLength(currentData, 4)\n  if (!managerResult) {\n    return null\n  }\n  partialState.manager = u32(managerResult.value)\n  currentData = currentData.slice(managerResult.consumed)\n  \n  // ps_assigners: decode{sequence[Ccorecount]{encode[4]{serviceid}}} (fixed-length)\n  for (let i = 0; i < numCores; i++) {\n    const assignerResult = decodeFixedLength(currentData, 4)\n    if (!assignerResult) {\n      return null\n    }\n    partialState.assigners.push(u32(assignerResult.value))\n    currentData = currentData.slice(assignerResult.consumed)\n  }\n  \n  // ps_delegator: decode[4]{serviceid} (4-byte fixed-length)\n  const delegatorResult = decodeFixedLength(currentData, 4)\n  if (!delegatorResult) {\n    return null\n  }\n  partialState.delegator = u32(delegatorResult.value)\n  currentData = currentData.slice(delegatorResult.consumed)\n  \n  // ps_registrar: decode[4]{serviceid} (4-byte fixed-length)\n  const registrarResult = decodeFixedLength(currentData, 4)\n  if (!registrarResult) {\n    return null\n  }\n  partialState.registrar = u32(registrarResult.value)\n  currentData = currentData.slice(registrarResult.consumed)\n  \n  // ps_alwaysaccers: decode{var{sequence{sorted(serviceid, gas)}}}\n  // Manually decode dictionary with fixed-length keys and values\n  const alwaysAccersVarResult = decodeVariableLength(currentData)\n  if (!alwaysAccersVarResult) {\n    return null\n  }\n  const alwaysAccersPairs = alwaysAccersVarResult.value\n  currentData = currentData.slice(alwaysAccersVarResult.consumed)\n  \n  let alwaysAccersData = alwaysAccersPairs\n  // Decode pairs until we've processed all bytes\n  while (alwaysAccersData.length >= 8) { // 4 bytes key + 4 bytes value\n    // Decode key: encode[4]{serviceid} (4 bytes fixed)\n    const serviceIdResult = decodeFixedLength(alwaysAccersData, 4)\n    if (!serviceIdResult) {\n      break\n    }\n    const serviceId = u32(serviceIdResult.value)\n    alwaysAccersData = alwaysAccersData.slice(4) // Consume key\n    \n    // Decode value: encode[4]{gas} (4 bytes fixed)\n    const gasResult = decodeFixedLength(alwaysAccersData, 4)\n    if (!gasResult) {\n      break\n    }\n    const gas = u32(gasResult.value)\n    alwaysAccersData = alwaysAccersData.slice(4) // Consume value\n    \n    partialState.alwaysaccers.push(new AlwaysAccerEntry(serviceId, gas))\n  }\n  \n  const consumed = data.length - currentData.length\n  return new DecodingResult<PartialState>(partialState, consumed)\n}\n\n// ============================================================================\n// Optional Decoding (Gray Paper compliant)\n// ============================================================================\n\n/**\n * Decode optional value\n * \n * Gray Paper: maybe{x} = {0 when x = none, 1, x otherwise}\n * \n * @param data - Octet sequence to decode\n * @param decoder - Function to decode the value when present\n * @returns Decoded optional value and remaining octet sequence\n */\nexport function decodeOptional<T>(\n  data: Uint8Array,\n  decoder: (data: Uint8Array) => DecodingResult<T> | null,\n): DecodingResult<T> | null {\n  if (data.length === 0) {\n    return null\n  }\n  \n  const discriminator = data[0]\n  \n  if (discriminator === 0) {\n    // None case - return null (but we need to indicate consumed bytes)\n    // For AssemblyScript, we'll return a special result indicating null\n    // Actually, we can't return null for the value in a generic way in AssemblyScript\n    // So we'll need to handle this differently - return a result with a flag\n    return null // This indicates \"none\" case\n  }\n  \n  if (discriminator === 1) {\n    // Some case - decode the value\n    const result = decoder(data.slice(1))\n    if (!result) {\n      return null\n    }\n    // Adjust consumed to include discriminator\n    return new DecodingResult<T>(result.value, 1 + result.consumed)\n  }\n  \n  return null // Invalid discriminator\n}\n\n// ============================================================================\n// Deferred Transfer Structures and Decoding (Gray Paper compliant)\n// ============================================================================\n\n/**\n * Deferred Transfer structure (AssemblyScript)\n */\nexport class DeferredTransfer {\n  source: u32\n  dest: u32\n  amount: u64\n  memo: Uint8Array\n  gasLimit: u64\n  \n  constructor() {\n    this.source = 0\n    this.dest = 0\n    this.amount = u64(0)\n    this.memo = new Uint8Array(0)\n    this.gasLimit = u64(0)\n  }\n}\n\n/**\n * Decode deferred transfer according to Gray Paper specification\n * \n * Gray Paper Equation 271-277:\n * encode[X]{DX  defxfer}  encode{\n *   encode[4]{DX_source},\n *   encode[4]{DX_dest},\n *   encode[8]{DX_amount},\n *   DX_memo,\n *   encode[8]{DX_gas}\n * }\n * \n * @param data - Octet sequence to decode\n * @returns Decoded deferred transfer and remaining data\n */\nexport function decodeDeferredTransfer(\n  data: Uint8Array,\n): DecodingResult<DeferredTransfer> | null {\n  let currentData = data\n  \n  const transfer = new DeferredTransfer()\n  \n  // Source: decode[4]{DX_source} (4-byte fixed-length)\n  const sourceResult = decodeFixedLength(currentData, 4)\n  if (!sourceResult) {\n    return null\n  }\n  transfer.source = u32(sourceResult.value)\n  currentData = currentData.slice(sourceResult.consumed)\n  \n  // Destination: decode[4]{DX_dest} (4-byte fixed-length)\n  const destResult = decodeFixedLength(currentData, 4)\n  if (!destResult) {\n    return null\n  }\n  transfer.dest = u32(destResult.value)\n  currentData = currentData.slice(destResult.consumed)\n  \n  // Amount: decode[8]{DX_amount} (8-byte fixed-length)\n  const amountResult = decodeFixedLength(currentData, 8)\n  if (!amountResult) {\n    return null\n  }\n  transfer.amount = amountResult.value\n  currentData = currentData.slice(amountResult.consumed)\n  \n  // Memo: DX_memo (fixed 128-byte blob, Cmemosize = 128)\n  // Gray Paper specifies memo is exactly 128 bytes, no length prefix\n  if (currentData.length < 128) {\n    return null\n  }\n  transfer.memo = currentData.slice(0, 128)\n  currentData = currentData.slice(128)\n  \n  // Gas: decode[8]{DX_gas} (8-byte fixed-length)\n  const gasResult = decodeFixedLength(currentData, 8)\n  if (!gasResult) {\n    return null\n  }\n  transfer.gasLimit = gasResult.value\n  currentData = currentData.slice(gasResult.consumed)\n  \n  const consumed = data.length - currentData.length\n  return new DecodingResult<DeferredTransfer>(transfer, consumed)\n}\n\n// ============================================================================\n// Implications Structures and Decoding (Gray Paper compliant)\n// ============================================================================\n\n/**\n * Provision entry structure\n */\nexport class ProvisionEntry {\n  serviceId: u32\n  blob: Uint8Array\n  \n  constructor(serviceId: u32, blob: Uint8Array) {\n    this.serviceId = serviceId\n    this.blob = blob\n  }\n}\n\n/**\n * Implications structure (AssemblyScript)\n */\nexport class Implications {\n  id: u32\n  state: PartialState\n  nextfreeid: u32\n  xfers: Array<DeferredTransfer>\n  yield: Uint8Array | null\n  provisions: Array<ProvisionEntry>\n  \n  constructor() {\n    this.id = 0\n    this.state = new PartialState()\n    this.nextfreeid = 0\n    this.xfers = new Array<DeferredTransfer>()\n    this.yield = null\n    this.provisions = new Array<ProvisionEntry>()\n  }\n}\n\n/**\n * Decode Implications according to Gray Paper specification\n * \n * Gray Paper pvm_invocations.tex equation 126-133:\n * implications  tuple{\n *   im_id: serviceid,\n *   im_state: partialstate,\n *   im_nextfreeid: serviceid,\n *   im_xfers: defxfers,\n *   im_yield: optional<hash>,\n *   im_provisions: protoset<tuple{serviceid, blob}>\n * }\n * \n * @param data - Octet sequence to decode\n * @param numCores - Number of cores (Ccorecount)\n * @param numValidators - Number of validators (Cvalcount)\n * @param authQueueSize - Authorization queue size (C_authqueuesize)\n * @returns Decoded Implications and remaining data\n */\nexport function decodeImplications(\n  data: Uint8Array,\n  numCores: i32,\n  numValidators: i32,\n  authQueueSize: i32,\n): DecodingResult<Implications> | null {\n  let currentData = data\n  \n  const implications = new Implications()\n  \n  // im_id: decode[4]{serviceid} (4-byte fixed-length)\n  const idResult = decodeFixedLength(currentData, 4)\n  if (!idResult) {\n    return null\n  }\n  implications.id = u32(idResult.value)\n  currentData = currentData.slice(idResult.consumed)\n  \n  // im_state: decode{partialstate}\n  const stateResult = decodePartialState(currentData, numCores, numValidators, authQueueSize)\n  if (!stateResult) {\n    return null\n  }\n  implications.state = stateResult.value\n  currentData = currentData.slice(stateResult.consumed)\n  \n  // im_nextfreeid: decode[4]{serviceid} (4-byte fixed-length)\n  const nextFreeIdResult = decodeFixedLength(currentData, 4)\n  if (!nextFreeIdResult) {\n    return null\n  }\n  implications.nextfreeid = u32(nextFreeIdResult.value)\n  currentData = currentData.slice(nextFreeIdResult.consumed)\n  \n  // im_xfers: decode{var{sequence{defxfer}}}\n  const xfersResult = decodeVariableSequence<DeferredTransfer>(currentData, decodeDeferredTransfer)\n  if (!xfersResult) {\n    return null\n  }\n  implications.xfers = xfersResult.value\n  currentData = currentData.slice(xfersResult.consumed)\n  \n  // im_yield: decode{maybe{hash}}\n  // maybe{x} = {0 when x = none, 1, x otherwise}\n  // hash is 32 bytes\n  if (currentData.length === 0) {\n    return null\n  }\n  const yieldDiscriminator = currentData[0]\n  if (yieldDiscriminator === 0) {\n    // None case\n    implications.yield = null\n    currentData = currentData.slice(1)\n  } else if (yieldDiscriminator === 1) {\n    // Some case - decode 32-byte hash\n    if (currentData.length < 33) {\n      return null\n    }\n    implications.yield = currentData.slice(1, 33)\n    currentData = currentData.slice(33)\n  } else {\n    return null // Invalid discriminator\n  }\n  \n  // im_provisions: decode{var{sequence{sorted(serviceid, blob)}}}\n  // Each tuple is: encode[4]{serviceid} || encode{var{blob}}\n  const provisionsResult = decodeVariableSequence<ProvisionEntry>(\n    currentData,\n    (data: Uint8Array) => {\n      // Decode serviceid: encode[4]{serviceid}\n      const serviceIdResult = decodeFixedLength(data, 4)\n      if (!serviceIdResult) {\n        return null\n      }\n      const serviceId = u32(serviceIdResult.value)\n      let remaining = data.slice(serviceIdResult.consumed)\n      \n      // Decode blob: encode{var{blob}} = encode{len(blob)} || blob\n      const blobLengthResult = decodeNatural(remaining)\n      if (!blobLengthResult) {\n        return null\n      }\n      const blobLength = i32(blobLengthResult.value)\n      remaining = remaining.slice(blobLengthResult.consumed)\n      \n      if (remaining.length < blobLength) {\n        return null\n      }\n      \n      const blob = remaining.slice(0, blobLength)\n      remaining = remaining.slice(blobLength)\n      \n      const consumed = data.length - remaining.length\n      return new DecodingResult<ProvisionEntry>(\n        new ProvisionEntry(serviceId, blob),\n        consumed,\n      )\n    },\n  )\n  if (!provisionsResult) {\n    return null\n  }\n  implications.provisions = provisionsResult.value\n  currentData = currentData.slice(provisionsResult.consumed)\n  \n  const consumed = data.length - currentData.length\n  return new DecodingResult<Implications>(implications, consumed)\n}\n\n/**\n * ImplicationsPair structure (AssemblyScript)\n */\nexport class ImplicationsPair {\n  regular: Implications\n  exceptional: Implications\n  \n  constructor(regular: Implications, exceptional: Implications) {\n    this.regular = regular\n    this.exceptional = exceptional\n  }\n}\n\n/**\n * Decode ImplicationsPair according to Gray Paper specification\n * \n * Gray Paper: ImplicationsPair = implications  implications\n * decode{ImplicationsPair} = decode{Implications} || decode{Implications}\n * \n * @param data - Octet sequence to decode\n * @param numCores - Number of cores (Ccorecount)\n * @param numValidators - Number of validators (Cvalcount)\n * @param authQueueSize - Authorization queue size (C_authqueuesize)\n * @returns Decoded ImplicationsPair and remaining data\n */\nexport function decodeImplicationsPair(\n  data: Uint8Array,\n  numCores: i32,\n  numValidators: i32,\n  authQueueSize: i32,\n): DecodingResult<ImplicationsPair> | null {\n  // Decode regular dimension (first element)\n  const regularResult = decodeImplications(data, numCores, numValidators, authQueueSize)\n  if (!regularResult) {\n    return null\n  }\n  const regular = regularResult.value\n  const regularRemaining = data.slice(regularResult.consumed)\n  \n  // Decode exceptional dimension (second element)\n  const exceptionalResult = decodeImplications(\n    regularRemaining,\n    numCores,\n    numValidators,\n    authQueueSize,\n  )\n  if (!exceptionalResult) {\n    return null\n  }\n  const exceptional = exceptionalResult.value\n  const exceptionalRemaining = regularRemaining.slice(exceptionalResult.consumed)\n  \n  const pair = new ImplicationsPair(regular, exceptional)\n  \n  const consumed = data.length - exceptionalRemaining.length\n  return new DecodingResult<ImplicationsPair>(pair, consumed)\n}\n\n// ============================================================================\n// Encoding Functions (Gray Paper compliant)\n// ============================================================================\n\n/**\n * Encode optional value according to Gray Paper specification\n * \n * Gray Paper: maybe{x} = {0 when x = none, 1, x otherwise}\n * \n * @param value - Optional value to encode (null for none, Uint8Array for some)\n * @param encoder - Function to encode the value when present\n * @returns Encoded octet sequence\n */\nexport function encodeOptional(\n  value: Uint8Array | null,\n  encoder: (value: Uint8Array) => Uint8Array,\n): Uint8Array {\n  if (value === null) {\n    // None case: single byte 0\n    const result = new Uint8Array(1)\n    result[0] = 0\n    return result\n  } else {\n    // Some case: discriminator 1 + encoded value\n    const encoded = encoder(value)\n    const result = new Uint8Array(1 + encoded.length)\n    result[0] = 1\n    result.set(encoded, 1)\n    return result\n  }\n}\n\n/**\n * Encode deferred transfer according to Gray Paper specification\n * \n * Gray Paper Equation 271-277:\n * encode[X]{DX  defxfer}  encode{\n *   encode[4]{DX_source},\n *   encode[4]{DX_dest},\n *   encode[8]{DX_amount},\n *   DX_memo,\n *   encode[8]{DX_gas}\n * }\n * \n * @param transfer - Deferred transfer to encode\n * @returns Encoded octet sequence\n */\nexport function encodeDeferredTransfer(transfer: DeferredTransfer): Uint8Array {\n  const parts: Uint8Array[] = []\n  \n  // Source: encode[4]{DX_source} (4-byte fixed-length)\n  parts.push(encodeFixedLength(u64(transfer.source), 4))\n  \n  // Destination: encode[4]{DX_dest} (4-byte fixed-length)\n  parts.push(encodeFixedLength(u64(transfer.dest), 4))\n  \n  // Amount: encode[8]{DX_amount} (8-byte fixed-length)\n  parts.push(encodeFixedLength(transfer.amount, 8))\n  \n  // Memo: DX_memo (fixed 128-byte blob, Cmemosize = 128)\n  // Gray Paper specifies memo is exactly 128 bytes, no length prefix\n  if (transfer.memo.length != 128) {\n    // Pad or truncate to exactly 128 bytes\n    const fixedMemo = new Uint8Array(128)\n    const copyLen = i32(min(u64(transfer.memo.length), u64(128)))\n    for (let i = 0; i < copyLen; i++) {\n      fixedMemo[i] = transfer.memo[i]\n    }\n    parts.push(fixedMemo)\n  } else {\n    parts.push(transfer.memo)\n  }\n  \n  // Gas: encode[8]{DX_gas} (8-byte fixed-length)\n  parts.push(encodeFixedLength(transfer.gasLimit, 8))\n  \n  return concatBytes(parts)\n}\n\n// ============================================================================\n// Accumulate Input Structures and Encoding (Gray Paper compliant)\n// ============================================================================\n\n/**\n * OperandTuple structure for work item results\n * \n * Gray Paper Equation 279-287: encode[U]{OT  operandtuple}\n */\nexport class OperandTuple {\n  packageHash: Uint8Array    // 32-byte hash\n  segmentRoot: Uint8Array    // 32-byte hash\n  authorizer: Uint8Array     // 32-byte public key\n  payloadHash: Uint8Array    // 32-byte hash\n  gasLimit: u64              // 8-byte gas limit\n  result: Uint8Array         // Variable-length result (success blob or empty for error)\n  resultType: u8             // 0 = success, 1-6 = error types\n  authTrace: Uint8Array      // Variable-length authorization trace\n  \n  constructor() {\n    this.packageHash = new Uint8Array(32)\n    this.segmentRoot = new Uint8Array(32)\n    this.authorizer = new Uint8Array(32)\n    this.payloadHash = new Uint8Array(32)\n    this.gasLimit = u64(0)\n    this.result = new Uint8Array(0)\n    this.resultType = 0 // Success by default\n    this.authTrace = new Uint8Array(0)\n  }\n}\n\n/**\n * AccumulateInput structure (discriminated union)\n * \n * Gray Paper Equation 289-292:\n * encode{AI  accinput}  {\n *   encode{0, encode[U]{o}}  when AI  operandtuple\n *   encode{1, encode[X]{o}}  when AI  defxfer\n * }\n */\nexport class AccumulateInput {\n  inputType: u8  // 0 = OperandTuple, 1 = DeferredTransfer\n  operandTuple: OperandTuple | null\n  deferredTransfer: DeferredTransfer | null\n  \n  constructor(inputType: u8) {\n    this.inputType = inputType\n    this.operandTuple = null\n    this.deferredTransfer = null\n  }\n  \n  static fromOperandTuple(ot: OperandTuple): AccumulateInput {\n    const input = new AccumulateInput(0)\n    input.operandTuple = ot\n    return input\n  }\n  \n  static fromDeferredTransfer(dt: DeferredTransfer): AccumulateInput {\n    const input = new AccumulateInput(1)\n    input.deferredTransfer = dt\n    return input\n  }\n}\n\n/**\n * Encode work result according to Gray Paper specification\n * \n * Gray Paper pvm_invocations.tex encodeResult:\n * 0 = success (followed by var{blob})\n * 1 =  (out of gas)\n * 2 = panic\n * 3 = badexports\n * 4 = oversize\n * 5 = BAD\n * 6 = BIG\n */\nexport function encodeWorkResult(resultType: u8, result: Uint8Array): Uint8Array {\n  const parts: Uint8Array[] = []\n  \n  // Discriminator byte\n  const discriminatorByte = new Uint8Array(1)\n  discriminatorByte[0] = resultType\n  parts.push(discriminatorByte)\n  \n  // If success (type 0), append the variable-length result blob\n  if (resultType == 0) {\n    parts.push(encodeNatural(u64(result.length)))\n    parts.push(result)\n  }\n  // For error types 1-6, no additional data\n  \n  return concatBytes(parts)\n}\n\n/**\n * Encode OperandTuple according to Gray Paper specification\n * \n * Gray Paper Equation 279-287:\n * encode[U]{OT  operandtuple}  encode{\n *   OT_packagehash,\n *   OT_segroot,\n *   OT_authorizer,\n *   OT_payloadhash,\n *   OT_gaslimit,\n *   encodeResult{OT_result},\n *   var{OT_authtrace}\n * }\n * \n * Note: OT_gaslimit uses natural encoding (no encode[8]{} wrapper)\n */\nexport function encodeOperandTuple(ot: OperandTuple): Uint8Array {\n  const parts: Uint8Array[] = []\n  \n  // packageHash: 32-byte hash\n  parts.push(ot.packageHash)\n  \n  // segmentRoot: 32-byte hash\n  parts.push(ot.segmentRoot)\n  \n  // authorizer: 32-byte public key\n  parts.push(ot.authorizer)\n  \n  // payloadHash: 32-byte hash\n  parts.push(ot.payloadHash)\n  \n  // gasLimit: natural encoding (Gray Paper uses encode{} not encode[8]{})\n  parts.push(encodeNatural(ot.gasLimit))\n  \n  // encodeResult{result}: discriminator + optional var{blob}\n  parts.push(encodeWorkResult(ot.resultType, ot.result))\n  \n  // var{authTrace}: variable-length with length prefix\n  parts.push(encodeNatural(u64(ot.authTrace.length)))\n  parts.push(ot.authTrace)\n  \n  return concatBytes(parts)\n}\n\n/**\n * Encode AccumulateInput according to Gray Paper specification\n * \n * Gray Paper Equation 289-292:\n * encode{AI  accinput}  {\n *   encode{0, encode[U]{o}}  when AI  operandtuple\n *   encode{1, encode[X]{o}}  when AI  defxfer\n * }\n * \n * For v0.7.0 and earlier, accinput encoding didn't exist - encode as raw type\n * For v0.7.1+, include type discriminator byte\n * \n * @param input - AccumulateInput to encode\n * @param jamVersionMajor - JAM version major (default 0)\n * @param jamVersionMinor - JAM version minor (default 7)\n * @param jamVersionPatch - JAM version patch (default 2)\n */\nexport function encodeAccumulateInput(\n  input: AccumulateInput,\n  jamVersionMajor: u8 = 0,\n  jamVersionMinor: u8 = 7,\n  jamVersionPatch: u8 = 2,\n): Uint8Array {\n  // Check if version is <= 0.7.0 (accinput encoding didn't exist)\n  const isV070OrEarlier = \n    jamVersionMajor < 0 ||\n    (jamVersionMajor == 0 && jamVersionMinor < 7) ||\n    (jamVersionMajor == 0 && jamVersionMinor == 7 && jamVersionPatch <= 0)\n  \n  if (isV070OrEarlier) {\n    // In v0.7.0, accinput didn't exist - encode as raw type without discriminator\n    if (input.inputType == 0 && input.operandTuple != null) {\n      return encodeOperandTuple(input.operandTuple!)\n    } else if (input.inputType == 1 && input.deferredTransfer != null) {\n      return encodeDeferredTransfer(input.deferredTransfer!)\n    }\n    return new Uint8Array(0)\n  }\n  \n  // v0.7.1+ encoding with discriminator\n  const parts: Uint8Array[] = []\n  \n  // Type discriminator\n  const discriminatorByte = new Uint8Array(1)\n  discriminatorByte[0] = input.inputType\n  parts.push(discriminatorByte)\n  \n  if (input.inputType == 0 && input.operandTuple != null) {\n    // OperandTuple encoding\n    parts.push(encodeOperandTuple(input.operandTuple!))\n  } else if (input.inputType == 1 && input.deferredTransfer != null) {\n    // DeferredTransfer encoding\n    parts.push(encodeDeferredTransfer(input.deferredTransfer!))\n  }\n  \n  return concatBytes(parts)\n}\n\n/**\n * Decode work result according to Gray Paper specification\n * \n * Gray Paper pvm_invocations.tex encodeResult:\n * 0 = success (followed by var{blob})\n * 1-6 = error types (no additional data)\n */\nexport function decodeWorkResult(data: Uint8Array): DecodingResult<OperandTuple> | null {\n  if (data.length === 0) {\n    return null\n  }\n  \n  const ot = new OperandTuple()\n  ot.resultType = data[0]\n  \n  if (ot.resultType == 0) {\n    // Success: var{result_blob}\n    const lengthResult = decodeNatural(data.slice(1))\n    if (!lengthResult) {\n      return null\n    }\n    const blobLength = i32(lengthResult.value)\n    const remaining = data.slice(1 + lengthResult.consumed)\n    if (remaining.length < blobLength) {\n      return null\n    }\n    ot.result = remaining.slice(0, blobLength)\n    return new DecodingResult<OperandTuple>(ot, 1 + lengthResult.consumed + blobLength)\n  }\n  \n  // Error types 1-6: no additional data\n  return new DecodingResult<OperandTuple>(ot, 1)\n}\n\n/**\n * Decode OperandTuple according to Gray Paper specification\n * \n * Gray Paper Equation 279-287:\n * encode[U]{OT  operandtuple}  encode{\n *   OT_packagehash,\n *   OT_segroot,\n *   OT_authorizer,\n *   OT_payloadhash,\n *   OT_gaslimit,\n *   encodeResult{OT_result},\n *   var{OT_authtrace}\n * }\n */\nexport function decodeOperandTuple(data: Uint8Array): DecodingResult<OperandTuple> | null {\n  if (data.length < 128) { // Minimum: 32+32+32+32 = 128 bytes for fixed hash fields\n    return null\n  }\n  \n  const ot = new OperandTuple()\n  let offset = 0\n  \n  // packageHash: 32 bytes\n  ot.packageHash = data.slice(offset, offset + 32)\n  offset += 32\n  \n  // segmentRoot: 32 bytes\n  ot.segmentRoot = data.slice(offset, offset + 32)\n  offset += 32\n  \n  // authorizer: 32 bytes\n  ot.authorizer = data.slice(offset, offset + 32)\n  offset += 32\n  \n  // payloadHash: 32 bytes\n  ot.payloadHash = data.slice(offset, offset + 32)\n  offset += 32\n  \n  // gasLimit: natural encoding (Gray Paper uses encode{} not encode[8]{})\n  const gasResult = decodeNatural(data.slice(offset))\n  if (!gasResult) {\n    return null\n  }\n  ot.gasLimit = gasResult.value\n  offset += gasResult.consumed\n  \n  // decodeResult: discriminator + optional var{blob}\n  const resultDisc = data[offset]\n  ot.resultType = resultDisc\n  offset += 1\n  \n  if (resultDisc == 0) {\n    // Success: var{result_blob}\n    const lengthResult = decodeNatural(data.slice(offset))\n    if (!lengthResult) {\n      return null\n    }\n    const blobLength = i32(lengthResult.value)\n    offset += lengthResult.consumed\n    \n    if (offset + blobLength > data.length) {\n      return null\n    }\n    ot.result = data.slice(offset, offset + blobLength)\n    offset += blobLength\n  }\n  // For error types 1-6: no additional data, result stays empty\n  \n  // var{authTrace}: variable-length with length prefix\n  const authTraceLengthResult = decodeNatural(data.slice(offset))\n  if (!authTraceLengthResult) {\n    return null\n  }\n  const authTraceLength = i32(authTraceLengthResult.value)\n  offset += authTraceLengthResult.consumed\n  \n  if (offset + authTraceLength > data.length) {\n    return null\n  }\n  ot.authTrace = data.slice(offset, offset + authTraceLength)\n  offset += authTraceLength\n  \n  return new DecodingResult<OperandTuple>(ot, offset)\n}\n\n/**\n * Decode AccumulateInput according to Gray Paper specification\n * \n * Gray Paper Equation 289-292:\n * encode{AI  accinput}  {\n *   encode{0, encode[U]{o}}  when AI  operandtuple\n *   encode{1, encode[X]{o}}  when AI  defxfer\n * }\n */\nexport function decodeAccumulateInput(data: Uint8Array): DecodingResult<AccumulateInput> | null {\n  if (data.length === 0) {\n    return null\n  }\n  \n  const inputType = data[0]\n  const remaining = data.slice(1)\n  \n  if (inputType == 0) {\n    // OperandTuple\n    const otResult = decodeOperandTuple(remaining)\n    if (!otResult) {\n      return null\n    }\n    const input = AccumulateInput.fromOperandTuple(otResult.value)\n    return new DecodingResult<AccumulateInput>(input, 1 + otResult.consumed)\n  } else if (inputType == 1) {\n    // DeferredTransfer\n    const dtResult = decodeDeferredTransfer(remaining)\n    if (!dtResult) {\n      return null\n    }\n    const input = AccumulateInput.fromDeferredTransfer(dtResult.value)\n    return new DecodingResult<AccumulateInput>(input, 1 + dtResult.consumed)\n  }\n  \n  return null\n}\n\n/**\n * Encode variable-length sequence with custom element encoder\n * \n * Gray Paper: var{sequence} = encode(len) || encode(element0) || encode(element1) || ...\n * \n * @param sequence - Array of elements to encode\n * @param elementEncoder - Function to encode individual elements\n * @returns Encoded sequence with length prefix\n */\nexport function encodeVariableSequenceGeneric<T>(\n  sequence: T[],\n  elementEncoder: (element: T) => Uint8Array,\n): Uint8Array {\n  const parts: Uint8Array[] = []\n  \n  // Encode length prefix\n  parts.push(encodeNatural(u64(sequence.length)))\n  \n  // Encode each element\n  for (let i = 0; i < sequence.length; i++) {\n    parts.push(elementEncoder(sequence[i]))\n  }\n  \n  return concatBytes(parts)\n}\n\n/**\n * Encode complete service account according to Gray Paper specification\n * \n * NOTE: This implementation matches TypeScript's encodeCompleteServiceAccount\n * which encodes rawCshKeyvals as a SINGLE dictionary (flattened storage/preimages/requests).\n * \n * Gray Paper accounts.tex equation 12-27:\n * serviceaccount  tuple{\n *   sa_storage  dictionary{blob}{blob},\n *   sa_preimages  dictionary{hash}{blob},\n *   sa_requests  dictionary{tuple{hash, bloblength}}{sequence[:3]{timeslot}},\n *   sa_gratis  balance,\n *   sa_codehash  hash,\n *   sa_balance  balance,\n *   sa_minaccgas  gas,\n *   sa_minmemogas  gas,\n *   sa_created  timeslot,\n *   sa_lastacc  timeslot,\n *   sa_parent  serviceid\n * }\n * \n * @param account - CompleteServiceAccount to encode\n * @returns Encoded octet sequence\n */\nexport function encodeCompleteServiceAccount(account: CompleteServiceAccount): Uint8Array {\n  const parts: Uint8Array[] = []\n  \n  // rawCshKeyvals: encode{dictionary{blob}{blob}}\n  // Sort entries by key for deterministic encoding (matching TypeScript)\n  const sortedEntries = account.rawCshKeyvals.entries.slice()\n  sortedEntries.sort((a, b) => {\n    // Compare Uint8Array keys byte-by-byte\n    const minLen = a.key.length < b.key.length ? a.key.length : b.key.length\n    for (let i = 0; i < minLen; i++) {\n      if (a.key[i] < b.key[i]) return -1\n      if (a.key[i] > b.key[i]) return 1\n    }\n    if (a.key.length < b.key.length) return -1\n    if (a.key.length > b.key.length) return 1\n    return 0\n  })\n  \n  // Manually encode dictionary: var{sequence{sorted(key, value)}}\n  // Each key and value must be encoded with var{} discriminator (length prefix + blob)\n  const keyvalPairs: Uint8Array[] = []\n  for (let i = 0; i < sortedEntries.length; i++) {\n    const entry = sortedEntries[i]\n    // Key: encode{var{blob}} = encode{len(key)} || key\n    const encodedKey = concatBytes([encodeNatural(u64(entry.key.length)), entry.key])\n    // Value: encode{var{blob}} = encode{len(value)} || value\n    const encodedValue = concatBytes([encodeNatural(u64(entry.value.length)), entry.value])\n    keyvalPairs.push(concatBytes([encodedKey, encodedValue]))\n  }\n  const concatenatedPairs = concatBytes(keyvalPairs)\n  // Wrap with var{} discriminator\n  parts.push(concatBytes([encodeNatural(u64(concatenatedPairs.length)), concatenatedPairs]))\n  \n  // sa_octets: encode[8]{octets} (8-byte fixed-length) - include octets in encoding\n  parts.push(encodeFixedLength(account.octets, 8))\n  \n  // sa_items: encode[4]{items} (4-byte fixed-length) - include items in encoding\n  parts.push(encodeFixedLength(u64(account.items), 4))\n  \n  // sa_gratis: encode[8]{balance} (8-byte fixed-length)\n  parts.push(encodeFixedLength(account.gratis, 8))\n  \n  // sa_codehash: hash (32-byte blob, identity encoding)\n  parts.push(account.codehash)\n  \n  // sa_balance: encode[8]{balance} (8-byte fixed-length)\n  parts.push(encodeFixedLength(account.balance, 8))\n  \n  // sa_minaccgas: encode[8]{gas} (8-byte fixed-length)\n  parts.push(encodeFixedLength(account.minaccgas, 8))\n  \n  // sa_minmemogas: encode[8]{gas} (8-byte fixed-length)\n  parts.push(encodeFixedLength(account.minmemogas, 8))\n  \n  // sa_created: encode[4]{timeslot} (4-byte fixed-length)\n  parts.push(encodeFixedLength(u64(account.created), 4))\n  \n  // sa_lastacc: encode[4]{timeslot} (4-byte fixed-length)\n  parts.push(encodeFixedLength(u64(account.lastacc), 4))\n  \n  // sa_parent: encode[4]{serviceid} (4-byte fixed-length)\n  parts.push(encodeFixedLength(u64(account.parent), 4))\n  \n  return concatBytes(parts)\n}\n\n/**\n * Encode partial state according to Gray Paper specification\n * \n * Gray Paper accumulation.tex equation 133-144:\n * partialstate  tuple{\n *   ps_accounts: dictionary<serviceid, serviceaccount>,\n *   ps_stagingset: sequence[Cvalcount]{valkey},\n *   ps_authqueue: sequence[Ccorecount]{sequence[C_authqueuesize]{hash}},\n *   ps_manager: serviceid,\n *   ps_assigners: sequence[Ccorecount]{serviceid},\n *   ps_delegator: serviceid,\n *   ps_registrar: serviceid,\n *   ps_alwaysaccers: dictionary<serviceid, gas>\n * }\n * \n * @param state - PartialState to encode\n * @param numCores - Number of cores (Ccorecount)\n * @param numValidators - Number of validators (Cvalcount)\n * @param authQueueSize - Authorization queue size (C_authqueuesize)\n * @returns Encoded octet sequence\n */\nexport function encodePartialState(\n  state: PartialState,\n  numCores: i32,\n  numValidators: i32,\n  authQueueSize: i32,\n): Uint8Array {\n  const parts: Uint8Array[] = []\n  \n  // ps_accounts: encode{var{sequence{sorted(serviceid, serviceaccount)}}}\n  // Sort accounts by serviceId for deterministic encoding\n  const sortedAccounts = state.accounts.slice()\n  sortedAccounts.sort((a, b) => {\n    if (a.serviceId < b.serviceId) return -1\n    if (a.serviceId > b.serviceId) return 1\n    return 0\n  })\n  \n  // Manually encode dictionary: var{sequence{sorted(key, value)}}\n  const accountPairs: Uint8Array[] = []\n  for (let i = 0; i < sortedAccounts.length; i++) {\n    const entry = sortedAccounts[i]\n    // Key: encode[4]{serviceid}\n    const key = encodeFixedLength(u64(entry.serviceId), 4)\n    // Value: encode{serviceaccount}\n    const value = encodeCompleteServiceAccount(entry.account)\n    accountPairs.push(concatBytes([key, value]))\n  }\n  const concatenatedAccountPairs = concatBytes(accountPairs)\n  // Wrap with var{} discriminator\n  parts.push(concatBytes([encodeNatural(u64(concatenatedAccountPairs.length)), concatenatedAccountPairs]))\n  \n  // ps_stagingset: encode{sequence[Cvalcount]{valkey}} (fixed-length, no var{})\n  // Each valkey is 336 bytes\n  for (let i = 0; i < numValidators; i++) {\n    if (i < state.stagingset.length) {\n      parts.push(state.stagingset[i])\n    } else {\n      // Pad with zeros if not enough validators\n      parts.push(new Uint8Array(336))\n    }\n  }\n  \n  // ps_authqueue: encode{sequence[Ccorecount]{sequence[C_authqueuesize]{hash}}} (fixed-length)\n  // Gray Paper: C_authqueuesize = 80 (constant, not from config)\n  // Each hash is 32 bytes\n  const HASH_SIZE = 32\n  const AUTH_QUEUE_SIZE = 80 // AUTHORIZATION_CONSTANTS.C_AUTHQUEUESIZE\n  for (let coreIdx = 0; coreIdx < numCores; coreIdx++) {\n    if (coreIdx < state.authqueue.length) {\n      const coreQueue = state.authqueue[coreIdx]\n      for (let authIdx = 0; authIdx < AUTH_QUEUE_SIZE; authIdx++) {\n        if (authIdx < coreQueue.length) {\n          parts.push(coreQueue[authIdx])\n        } else {\n          // Pad with zeros if not enough hashes\n          parts.push(new Uint8Array(HASH_SIZE))\n        }\n      }\n    } else {\n      // Pad entire core queue with zeros\n      for (let authIdx = 0; authIdx < AUTH_QUEUE_SIZE; authIdx++) {\n        parts.push(new Uint8Array(HASH_SIZE))\n      }\n    }\n  }\n  \n  // ps_manager: encode[4]{serviceid} (4-byte fixed-length)\n  parts.push(encodeFixedLength(u64(state.manager), 4))\n  \n  // ps_assigners: encode{sequence[Ccorecount]{encode[4]{serviceid}}} (fixed-length)\n  for (let i = 0; i < numCores; i++) {\n    if (i < state.assigners.length) {\n      parts.push(encodeFixedLength(u64(state.assigners[i]), 4))\n    } else {\n      // Pad with zeros if not enough assigners\n      parts.push(encodeFixedLength(u64(0), 4))\n    }\n  }\n  \n  // ps_delegator: encode[4]{serviceid} (4-byte fixed-length)\n  parts.push(encodeFixedLength(u64(state.delegator), 4))\n  \n  // ps_registrar: encode[4]{serviceid} (4-byte fixed-length)\n  parts.push(encodeFixedLength(u64(state.registrar), 4))\n  \n  // ps_alwaysaccers: encode{var{sequence{sorted(serviceid, gas)}}}\n  // Sort alwaysaccers by serviceId for deterministic encoding\n  const sortedAlwaysAccers = state.alwaysaccers.slice()\n  sortedAlwaysAccers.sort((a, b) => {\n    if (a.serviceId < b.serviceId) return -1\n    if (a.serviceId > b.serviceId) return 1\n    return 0\n  })\n  \n  // Manually encode dictionary: var{sequence{sorted(key, value)}}\n  const alwaysAccerPairs: Uint8Array[] = []\n  for (let i = 0; i < sortedAlwaysAccers.length; i++) {\n    const entry = sortedAlwaysAccers[i]\n    // Key: encode[4]{serviceid}\n    const key = encodeFixedLength(u64(entry.serviceId), 4)\n    // Value: encode[4]{gas} (4-byte fixed-length)\n    const value = encodeFixedLength(entry.gas, 4)\n    alwaysAccerPairs.push(concatBytes([key, value]))\n  }\n  const concatenatedAlwaysAccerPairs = concatBytes(alwaysAccerPairs)\n  // Wrap with var{} discriminator\n  parts.push(concatBytes([encodeNatural(u64(concatenatedAlwaysAccerPairs.length)), concatenatedAlwaysAccerPairs]))\n  \n  return concatBytes(parts)\n}\n\n/**\n * Encode Implications according to Gray Paper specification\n * \n * Gray Paper pvm_invocations.tex equation 126-133:\n * implications  tuple{\n *   im_id: serviceid,\n *   im_state: partialstate,\n *   im_nextfreeid: serviceid,\n *   im_xfers: defxfers,\n *   im_yield: optional<hash>,\n *   im_provisions: protoset<tuple{serviceid, blob}>\n * }\n * \n * @param implications - Implications to encode\n * @param numCores - Number of cores (Ccorecount)\n * @param numValidators - Number of validators (Cvalcount)\n * @param authQueueSize - Authorization queue size (C_authqueuesize)\n * @returns Encoded octet sequence\n */\nexport function encodeImplications(\n  implications: Implications,\n  numCores: i32,\n  numValidators: i32,\n  authQueueSize: i32,\n): Uint8Array {\n  const parts: Uint8Array[] = []\n  \n  // im_id: encode[4]{serviceid} (4-byte fixed-length)\n  parts.push(encodeFixedLength(u64(implications.id), 4))\n  \n  // im_state: encode{partialstate}\n  parts.push(encodePartialState(implications.state, numCores, numValidators, authQueueSize))\n  \n  // im_nextfreeid: encode[4]{serviceid} (4-byte fixed-length)\n  parts.push(encodeFixedLength(u64(implications.nextfreeid), 4))\n  \n  // im_xfers: encode{var{sequence{defxfer}}}\n  parts.push(encodeVariableSequenceGeneric<DeferredTransfer>(\n    implications.xfers,\n    encodeDeferredTransfer,\n  ))\n  \n  // im_yield: encode{maybe{hash}}\n  // maybe{x} = {0 when x = none, 1, x otherwise}\n  // hash is 32 bytes\n  parts.push(encodeOptional(\n    implications.yield,\n    (hash: Uint8Array) => hash, // Identity encoding for hash\n  ))\n  \n  // im_provisions: encode{var{sequence{sorted(serviceid, blob)}}}\n  // Sort provisions by serviceId for deterministic encoding\n  const sortedProvisions = implications.provisions.slice()\n  sortedProvisions.sort((a, b) => {\n    if (a.serviceId < b.serviceId) return -1\n    if (a.serviceId > b.serviceId) return 1\n    return 0\n  })\n  \n  // Each tuple is: encode[4]{serviceid} || encode{var{blob}}\n  parts.push(encodeVariableSequenceGeneric<ProvisionEntry>(\n    sortedProvisions,\n    (entry: ProvisionEntry) => {\n      const provisionParts: Uint8Array[] = []\n      // encode[4]{serviceid}\n      provisionParts.push(encodeFixedLength(u64(entry.serviceId), 4))\n      // encode{var{blob}} = encode{len(blob)} || blob\n      provisionParts.push(encodeNatural(u64(entry.blob.length)))\n      provisionParts.push(entry.blob)\n      return concatBytes(provisionParts)\n    },\n  ))\n  \n  return concatBytes(parts)\n}\n\n/**\n * Encode ImplicationsPair according to Gray Paper specification\n * \n * Gray Paper: ImplicationsPair = implications  implications\n * encode{ImplicationsPair} = encode{Implications} || encode{Implications}\n * \n * @param pair - ImplicationsPair to encode\n * @param numCores - Number of cores (Ccorecount)\n * @param numValidators - Number of validators (Cvalcount)\n * @param authQueueSize - Authorization queue size (C_authqueuesize)\n * @returns Encoded octet sequence\n */\nexport function encodeImplicationsPair(\n  pair: ImplicationsPair,\n  numCores: i32,\n  numValidators: i32,\n  authQueueSize: i32,\n): Uint8Array {\n  // Encode regular dimension (first element)\n  const encodedRegular = encodeImplications(pair.regular, numCores, numValidators, authQueueSize)\n  \n  // Encode exceptional dimension (second element)\n  const encodedExceptional = encodeImplications(pair.exceptional, numCores, numValidators, authQueueSize)\n  \n  // Concatenate: encode{regular} || encode{exceptional}\n  return concatBytes([encodedRegular, encodedExceptional])\n}\n\n/**\n * Create service storage key according to Gray Paper specification.\n *\n * Gray Paper merklization.tex (lines 103-104):\n *  s, sa  accounts, k, v  sa_storage:\n * C(s, encode[4]{2-1}  k)  v\n *\n * Storage keys use the pattern: C(s, encode[4]{0xFFFFFFFF}  storage_key)\n * where s is the service ID and k is the storage key.\n *\n * This function handles two cases:\n * 1. Original storage key `k`: Computes blake(encode[4]{0xFFFFFFFF} || k) and uses first 27 bytes\n * 2. Already-hashed storage key (27 bytes): Uses the hash directly to construct the state key\n *\n * @param serviceId - Service account ID\n * @param storageKey - Storage key (either original blob `k` or 27-byte Blake hash `h`)\n * @returns 31-byte state key for service storage\n */\nexport function createServiceStorageKey(\n  serviceId: u64,\n  storageKey: Uint8Array,\n): Uint8Array {\n  // Check if storageKey is already a 27-byte Blake hash (from state loading)\n  if (storageKey.length === 27) {\n    // Storage key is already a Blake hash - use it directly to construct state key\n    // C(s, h) where h is already blake(encode[4]{0xFFFFFFFF} || k)\n    const key = new Uint8Array(31)\n    const serviceUint8Array = encodeFixedLength(serviceId, 4)\n\n    // Interleave: n, a, n, a, n, a, n, a, a, a, ..., a\n    key[0] = serviceUint8Array[0] // n\n    key[1] = storageKey[0] // a\n    key[2] = serviceUint8Array[1] // n\n    key[3] = storageKey[1] // a\n    key[4] = serviceUint8Array[2] // n\n    key[5] = storageKey[2] // a\n    key[6] = serviceUint8Array[3] // n\n    key[7] = storageKey[3] // a\n    // Remaining bytes: a, a, ..., a (23 bytes)\n    for (let i = 0; i < 23; i++) {\n      key[8 + i] = storageKey[4 + i]\n    }\n\n    return key\n  }\n\n  // Storage key is the original key `k` - compute blake(encode[4]{0xFFFFFFFF} || k)\n  // Create the prefix: encode[4]{2-1} = encode[4]{0xFFFFFFFF}\n  const prefix = encodeFixedLength(0xffffffff, 4)\n\n  // Concatenate prefix with storage key\n  const combinedKey = new Uint8Array(prefix.length + storageKey.length)\n  for (let i = 0; i < prefix.length; i++) {\n    combinedKey[i] = prefix[i]\n  }\n  for (let i = 0; i < storageKey.length; i++) {\n    combinedKey[prefix.length + i] = storageKey[i]\n  }\n\n  // Compute Blake hash and take first 27 bytes\n  const blakeHashFull = blake2b256(combinedKey)\n  const blakeHash = blakeHashFull.slice(0, 27)\n\n  // Construct the state key by interleaving service ID with Blake hash\n  const key = new Uint8Array(31)\n  const serviceUint8Array = encodeFixedLength(serviceId, 4)\n\n  key[0] = serviceUint8Array[0] // n\n  key[1] = blakeHash[0] // a\n  key[2] = serviceUint8Array[1] // n\n  key[3] = blakeHash[1] // a\n  key[4] = serviceUint8Array[2] // n\n  key[5] = blakeHash[2] // a\n  key[6] = serviceUint8Array[3] // n\n  key[7] = blakeHash[3] // a\n  for (let i = 0; i < 23; i++) {\n    key[8 + i] = blakeHash[4 + i] // a...a\n  }\n\n  return key\n}\n\n/**\n * Create service preimage key according to Gray Paper specification.\n *\n * Gray Paper merklization.tex (lines 105-106):\n *  s, sa  accounts, h, p  sa_preimages:\n * C(s, encode[4]{2-2}  h)  p\n *\n * Preimage keys use the pattern: C(s, encode[4]{0xFFFFFFFE}  preimage_hash)\n * where s is the service ID and h is the preimage hash.\n *\n * This function handles two cases:\n * 1. Full preimage hash `h` (32 bytes): Computes blake(encode[4]{0xFFFFFFFE} || h) and uses first 27 bytes\n * 2. Already-hashed key (27 bytes): Uses the hash directly to construct the state key\n *\n * @param serviceId - Service account ID\n * @param preimageHash - Preimage hash (either full 32-byte hash or 27-byte Blake hash)\n * @returns 31-byte state key for service preimage\n */\nexport function createServicePreimageKey(\n  serviceId: u64,\n  preimageHash: Uint8Array,\n): Uint8Array {\n  // Check if preimageHash is already a 27-byte Blake hash (from state loading)\n  if (preimageHash.length === 27) {\n    // Preimage hash is already a Blake hash - use it directly to construct state key\n    const key = new Uint8Array(31)\n    const serviceUint8Array = encodeFixedLength(serviceId, 4)\n\n    // Interleave: n, a, n, a, n, a, n, a, a, a, ..., a\n    key[0] = serviceUint8Array[0] // n\n    key[1] = preimageHash[0] // a\n    key[2] = serviceUint8Array[1] // n\n    key[3] = preimageHash[1] // a\n    key[4] = serviceUint8Array[2] // n\n    key[5] = preimageHash[2] // a\n    key[6] = serviceUint8Array[3] // n\n    key[7] = preimageHash[3] // a\n    for (let i = 0; i < 23; i++) {\n      key[8 + i] = preimageHash[4 + i] // a...a\n    }\n\n    return key\n  }\n\n  // Preimage hash is the full 32-byte hash - compute blake(encode[4]{0xFFFFFFFE} || h)\n  // Create the prefix: encode[4]{2-2} = encode[4]{0xFFFFFFFE}\n  const prefix = encodeFixedLength(0xfffffffe, 4)\n\n  // Concatenate prefix with preimage hash\n  const combinedKey = new Uint8Array(prefix.length + preimageHash.length)\n  for (let i = 0; i < prefix.length; i++) {\n    combinedKey[i] = prefix[i]\n  }\n  for (let i = 0; i < preimageHash.length; i++) {\n    combinedKey[prefix.length + i] = preimageHash[i]\n  }\n\n  // Compute Blake hash and take first 27 bytes\n  const blakeHashFull = blake2b256(combinedKey)\n  const blakeHash = blakeHashFull.slice(0, 27)\n\n  // Construct the state key by interleaving service ID with Blake hash\n  const key = new Uint8Array(31)\n  const serviceUint8Array = encodeFixedLength(serviceId, 4)\n\n  key[0] = serviceUint8Array[0] // n\n  key[1] = blakeHash[0] // a\n  key[2] = serviceUint8Array[1] // n\n  key[3] = blakeHash[1] // a\n  key[4] = serviceUint8Array[2] // n\n  key[5] = blakeHash[2] // a\n  key[6] = serviceUint8Array[3] // n\n  key[7] = blakeHash[3] // a\n  for (let i = 0; i < 23; i++) {\n    key[8 + i] = blakeHash[4 + i] // a...a\n  }\n\n  return key\n}\n\n/**\n * Create service request key according to Gray Paper specification.\n *\n * Gray Paper merklization.tex (lines 107-110):\n *  s, sa  accounts, h, l, t  sa_requests:\n * C(s, encode[4]{l}  h)  encode{var{sequence{encode[4]{x} | x  t}}}\n *\n * Request keys use the pattern: C(s, encode[4]{length}  request_hash)\n * where s is the service ID, l is the blob length, and h is the request hash.\n *\n * This function handles two cases:\n * 1. Full request hash `h` (32 bytes): Computes blake(encode[4]{l} || h) and uses first 27 bytes\n * 2. Already-hashed key (27 bytes): Uses the hash directly to construct the state key\n *\n * @param serviceId - Service account ID\n * @param requestHash - Request hash (either full 32-byte hash or 27-byte Blake hash)\n * @param length - Blob length\n * @returns 31-byte state key for service request\n */\nexport function createServiceRequestKey(\n  serviceId: u64,\n  requestHash: Uint8Array,\n  length: u64,\n): Uint8Array {\n  // Check if requestHash is already a 27-byte Blake hash (from state loading)\n  if (requestHash.length === 27) {\n    // Request hash is already a Blake hash - use it directly to construct state key\n    const key = new Uint8Array(31)\n    const serviceUint8Array = encodeFixedLength(serviceId, 4)\n\n    // Interleave: n, a, n, a, n, a, n, a, a, a, ..., a\n    key[0] = serviceUint8Array[0] // n\n    key[1] = requestHash[0] // a\n    key[2] = serviceUint8Array[1] // n\n    key[3] = requestHash[1] // a\n    key[4] = serviceUint8Array[2] // n\n    key[5] = requestHash[2] // a\n    key[6] = serviceUint8Array[3] // n\n    key[7] = requestHash[3] // a\n    for (let i = 0; i < 23; i++) {\n      key[8 + i] = requestHash[4 + i] // a...a\n    }\n\n    return key\n  }\n\n  // Request hash is the full 32-byte hash - compute blake(encode[4]{l} || h)\n  // Create the prefix: encode[4]{length}\n  const prefix = encodeFixedLength(length, 4)\n\n  // Concatenate prefix with request hash\n  const combinedKey = new Uint8Array(prefix.length + requestHash.length)\n  for (let i = 0; i < prefix.length; i++) {\n    combinedKey[i] = prefix[i]\n  }\n  for (let i = 0; i < requestHash.length; i++) {\n    combinedKey[prefix.length + i] = requestHash[i]\n  }\n\n  // Compute Blake hash and take first 27 bytes\n  const blakeHashFull = blake2b256(combinedKey)\n  const blakeHash = blakeHashFull.slice(0, 27)\n\n  // Construct the state key by interleaving service ID with Blake hash\n  const key = new Uint8Array(31)\n  const serviceUint8Array = encodeFixedLength(serviceId, 4)\n\n  key[0] = serviceUint8Array[0] // n\n  key[1] = blakeHash[0] // a\n  key[2] = serviceUint8Array[1] // n\n  key[3] = blakeHash[1] // a\n  key[4] = serviceUint8Array[2] // n\n  key[5] = blakeHash[2] // a\n  key[6] = serviceUint8Array[3] // n\n  key[7] = blakeHash[3] // a\n  for (let i = 0; i < 23; i++) {\n    key[8 + i] = blakeHash[4 + i] // a...a\n  }\n\n  return key\n}\n","import { strtol, strtod, strtob } from \"./util/string\";\n\ntype auto = i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isBoolean<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isInteger<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isSigned<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFloat<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isVector<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isReference<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isString<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArray<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArrayLike<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFunction<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNullable<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isDefined(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isConstant(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isManaged<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isVoid<T>(): bool;\n\n// @ts-ignore\n@builtin\nexport declare function lengthof<T>(func?: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function clz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ctz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function popcnt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotl<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotr<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function abs<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function max<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function min<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ceil<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function floor<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function copysign<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function nearest<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function reinterpret<T>(value: number): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sqrt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function trunc<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function add<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sub<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function mul<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function div<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function eq<T>(left: T, right: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ne<T>(left: T, right: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rem<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function load<T>(ptr: usize, immOffset?: usize, immAlign?: usize): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function store<T>(ptr: usize, value: auto, immOffset?: usize, immAlign?: usize): void;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sizeof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function alignof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function idof<T>(): u32;\n\n// @ts-ignore\n@builtin\nexport declare function nameof<T>(): string;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unreachable(): auto;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function changetype<T>(value: auto): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function assert<T>(isTrueish: T, message?: string): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unchecked<T>(expr: T): T;\n\nexport namespace inline {\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function always<T>(expr: T): T;\n}\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function call_indirect<T>(index: u32, ...args: auto[]): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function instantiate<T>(...args: auto[]): T;\n\nexport namespace atomic {\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load<T>(ptr: usize, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store<T>(ptr: usize, value: T, immOffset?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function notify(ptr: usize, count: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function fence(): void;\n}\n\n// @ts-ignore: decorator\n@lazy\nexport const enum AtomicWaitResult {\n  OK = 0,\n  NOT_EQUAL = 1,\n  TIMED_OUT = 2\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8(value: auto): i8;\n\nexport namespace i8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i8 = -128;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i8 =  127;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i8 {\n    return <i8>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16(value: auto): i16;\n\nexport namespace i16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i16 = -32768;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i16 =  32767;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i16 {\n    return <i16>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32(value: auto): i32;\n\nexport namespace i32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i32 = -2147483648;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i32 =  2147483647;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i32 {\n    return strtol<i32>(value, radix);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_s(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_u(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_s(left: i32, right: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_u(left: u32, right: u32): u32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f32(value: f32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i32, immOffset?: usize): void;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64(value: auto): i64;\n\nexport namespace i64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i64 = -9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i64 =  9223372036854775807;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i64 {\n    return strtol<i64>(value, radix);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_s(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_u(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: i64, right:i64): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: i64, right:i64): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_s(left: i64, right: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_u(left: u64, right: u64): u64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f64(value: f64): i64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store32(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load32_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store32(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i64, immOffset?: usize): void;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw32 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isize(value: auto): isize;\n\nexport namespace isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? -2147483648\n    : <isize>-9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? 2147483647\n    : <isize>9223372036854775807;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): isize {\n    return <isize>strtol<i64>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u8(value: auto): u8;\n\nexport namespace u8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u8 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u8 = 255;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u8 {\n    return <u8>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u16(value: auto): u16;\n\nexport namespace u16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u16 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u16 = 65535;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u16 {\n    return <u16>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u32(value: auto): u32;\n\nexport namespace u32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u32 = 4294967295;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u32 {\n    return <u32>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u64(value: auto): u64;\n\nexport namespace u64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u64 = 18446744073709551615;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u64 {\n    return <u64>strtol<i64>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function usize(value: auto): usize;\n\nexport namespace usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: usize = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\n    ? 4294967295\n    : <usize>18446744073709551615;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): usize {\n    return <usize>strtol<i64>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function bool(value: auto): bool;\n\nexport namespace bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: bool = false;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: bool = true;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string): bool {\n    return strtob(value);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32(value: auto): f32;\n\nexport namespace f32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f32 = -16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f32 =  16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const POSITIVE_INFINITY: f32 =  Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NEGATIVE_INFINITY: f32 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NaN: f32 = 0.0 / 0.0;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string): f32 {\n    return <f32>strtod(value);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f32, y: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i32(value: i32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: f32, right: f32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: f32, right: f32): i32;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64(value: auto): f64;\n\nexport namespace f64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const POSITIVE_INFINITY: f64 =  Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NEGATIVE_INFINITY: f64 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NaN: f64 = 0.0 / 0.0;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string): f64 {\n    return strtod(value);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f64, y: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i64(value: i64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: f64, right: f64): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: f64, right: f64): i32;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function v128(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace v128 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat<T>(x: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane<T>(x: v128, idx: u8): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane<T>(x: v128, idx: u8, value: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_ext<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_zero<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat<T>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load8_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load16_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div<T>(a: v128, b: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function andnot(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function not(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitselect(v1: v128, v2: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true<T>(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask<T>(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot<T>(a: v128, b: v128): v128; // i16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr<T>(a: v128, b: v128): v128; // u8, u16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_zero<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function demote_zero<T = f64>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function promote_low<T = f32>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function q15mulr_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_swizzle(a: v128, s: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc_zero<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_madd<T>(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_nmadd<T>(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_laneselect<T>(a: v128, b: v128, m: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_min<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_max<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_q15mulr<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_dot<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_dot_add<T>(a: v128, b: v128, c: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8x16(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace i8x16 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(\n    a: v128, b: v128,\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8,\n    l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8\n  ): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_swizzle(a: v128, s: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_laneselect(a: v128, b: v128, m: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\n\nexport namespace i16x8 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function q15mulr_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i8x16_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i8x16_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i8x16_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i8x16_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(\n    a: v128, b: v128,\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8\n  ): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_laneselect(a: v128, b: v128, m: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_q15mulr_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_dot_i8x16_i7x16_s(a: v128, b: v128, c: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\n\nexport namespace i32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_s_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_u_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc_f32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc_f32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc_f64x2_s_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc_f64x2_u_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_laneselect(a: v128, b: v128, m: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_dot_i8x16_i7x16_add_s(a: v128, b: v128, c: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64x2(a: i64, b: i64): v128;\n\nexport namespace i64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_laneselect(a: v128, b: v128, m: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\n\nexport namespace f32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function demote_f64x2_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_madd(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_nmadd(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_max(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64x2(a: f64, b: f64): v128;\n\nexport namespace f64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function promote_low_f32x4(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_madd(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_nmadd(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_max(a: v128, b: v128): v128;\n}\n\n@final\nexport abstract class i31 { // FIXME: usage of 'new' requires a class :(\n\n  // @ts-ignore: decorator\n  @builtin\n  static new(value: i32): i31ref { return changetype<i31ref>(unreachable()); }\n\n  // @ts-ignore: decorator\n  @builtin\n  static get(i31expr: i31ref): i32 { return unreachable(); }\n}\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n// @ts-ignore: decorator\n@external(\"env\", \"abort\")\n@external.js(\"throw Error(`${message} in ${fileName}:${lineNumber}:${columnNumber}`);\")\ndeclare function abort(\n  message?: string | null,\n  fileName?: string | null,\n  lineNumber?: u32,\n  columnNumber?: u32\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"trace\")\n@external.js(\"console.log(message, ...[a0, a1, a2, a3, a4].slice(0, n));\")\ndeclare function trace(\n  message: string,\n  n?: i32,\n  a0?: f64,\n  a1?: f64,\n  a2?: f64,\n  a3?: f64,\n  a4?: f64\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"seed\")\n@external.js(\"return Date.now() * Math.random();\")\ndeclare function seed(): f64;\n\n/* eslint-enable @typescript-eslint/no-unused-vars */\n","import { itoa32, utoa32, itoa64, utoa64, dtoa } from \"./util/number\";\nimport { strtol, strtod } from \"./util/string\";\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const NaN: f64 = 0 / 0; // context-aware\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const Infinity: f64 = 1 / 0; // context-aware\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNaN<T extends number>(value: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFinite<T extends number>(value: T): bool;\n\n@final @unmanaged\nexport abstract class I8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i8 = i8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i8 = i8.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i8 {\n    return <i8>strtol<i32>(value, radix);\n  }\n\n  toString(this: i8, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i16 = i16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i16 = i16.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i16 {\n    return <i16>strtol<i32>(value, radix);\n  }\n\n  toString(this: i16, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i32 = i32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i32 = i32.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i32 {\n    return <i32>strtol<i32>(value, radix);\n  }\n\n  toString(this: i32, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i64 = i64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i64 = i64.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i64 {\n    return strtol<i64>(value, radix);\n  }\n\n  toString(this: i64, radix: i32 = 10): String {\n    return itoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: isize = isize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: isize = isize.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): isize {\n    return <isize>strtol<i64>(value, radix);\n  }\n\n  toString(this: isize, radix: i32 = 10): String {\n    if (sizeof<isize>() == 4) {\n      return itoa32(<i32>this, radix);\n    } else {\n      return itoa64(<i64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class U8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u8 = u8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u8 = u8.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u8 {\n    return <u8>strtol<i32>(value, radix);\n  }\n\n  toString(this: u8, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u16 = u16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u16 = u16.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u16 {\n    return <u16>strtol<i32>(value, radix);\n  }\n\n  toString(this: u16, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u32 = u32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u32 = u32.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u32 {\n    return <u32>strtol<i32>(value, radix);\n  }\n\n  toString(this: u32, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u64 = u64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u64 = u64.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u64 {\n    return <u64>strtol<i64>(value, radix);\n  }\n\n  toString(this: u64, radix: i32 = 10): String {\n    return utoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: usize = usize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: usize = usize.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): usize {\n    return <usize>strtol<i64>(value, radix);\n  }\n\n  toString(this: usize, radix: i32 = 10): String {\n    if (sizeof<usize>() == 4) {\n      return utoa32(<u32>this, radix);\n    } else {\n      return utoa64(<u64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class Bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: bool = bool.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: bool = bool.MAX_VALUE;\n\n  toString(this: bool, radix: i32 = 0): String {\n    return this ? \"true\" : \"false\";\n  }\n}\n\nexport { Bool as Boolean };\n\n@final @unmanaged\nexport abstract class F32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f32 = f32.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f32 = f32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f32 = f32.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f32 = f32.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f32 = f32.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f32 = f32.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f32 = f32.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f32 = f32.NaN;\n\n  static isNaN(value: f32): bool {\n    return isNaN<f32>(value);\n  }\n\n  static isFinite(value: f32): bool {\n    return isFinite<f32>(value);\n  }\n\n  static isSafeInteger(value: f32): bool {\n    return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value;\n  }\n\n  static isInteger(value: f32): bool {\n    return isFinite<f32>(value) && trunc<f32>(value) == value;\n  }\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): f32 {\n    return <f32>strtol<f64>(value, radix);\n  }\n\n  /** @deprecated */\n  static parseFloat(value: string): f32 {\n    return <f32>strtod(value);\n  }\n\n  toString(this: f32, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\n@final @unmanaged\nexport abstract class F64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f64 = f64.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f64 = f64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f64 = f64.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f64 = f64.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f64 = f64.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f64 = f64.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f64 = f64.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f64 = f64.NaN;\n\n  static isNaN(value: f64): bool {\n    return isNaN<f64>(value);\n  }\n\n  static isFinite(value: f64): bool {\n    return isFinite<f64>(value);\n  }\n\n  static isSafeInteger(value: f64): bool {\n    return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value;\n  }\n\n  static isInteger(value: f64): bool {\n    return isFinite<f64>(value) && trunc<f64>(value) == value;\n  }\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): f64 {\n    return strtol<f64>(value, radix);\n  }\n\n  /** @deprecated */\n  static parseFloat(value: string): f64 {\n    return strtod(value);\n  }\n\n  toString(this: f64, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\nexport { F64 as Number };\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { compareImpl, strtol, strtod, isSpace, isAscii, isFinalSigma, toLower8, toUpper8 } from \"./util/string\";\nimport { SPECIALS_UPPER, casemap, bsearch } from \"./util/casemap\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_UNPAIRED_SURROGATE } from \"./util/error\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\n\n@final export abstract class String {\n\n  @lazy static readonly MAX_LENGTH: i32 = <i32>(BLOCK_MAXSIZE >>> alignof<u16>());\n\n  static fromCharCode(unit: i32, surr: i32 = -1): String {\n    let hasSur = surr > 0;\n    let out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    store<u16>(changetype<usize>(out), <u16>unit);\n    if (hasSur) store<u16>(changetype<usize>(out), <u16>surr, 2);\n    return out;\n  }\n\n  static fromCharCodes(units: Array<i32>): String {\n    let length = units.length;\n    let out = changetype<String>(__new(<usize>length << 1, idof<String>()));\n    let ptr = units.dataStart;\n    for (let i = 0; i < length; ++i) {\n      store<u16>(changetype<usize>(out) + (<usize>i << 1), load<i32>(ptr + (<usize>i << 2)));\n    }\n    return out;\n  }\n\n  static fromCodePoint(code: i32): String {\n    let hasSur = <u32>code > 0xFFFF;\n    let out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    if (!hasSur) {\n      store<u16>(changetype<usize>(out), <u16>code);\n    } else {\n      // Checks valid code point range\n      assert(<u32>code <= 0x10FFFF);\n      code -= 0x10000;\n      let hi = (code & 0x03FF) | 0xDC00;\n      let lo = code >>> 10 | 0xD800;\n      store<u32>(changetype<usize>(out), lo | hi << 16);\n    }\n    return out;\n  }\n\n  @builtin static raw(parts: TemplateStringsArray, ...args: unknown[]): string { return unreachable(); }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >> 1;\n  }\n\n  at(pos: i32): String {\n    let len = this.length;\n    pos += select(0, len, pos >= 0);\n    if (<u32>pos >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let out = __new(2, idof<String>());\n    store<u16>(out, load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return changetype<String>(out); // retains\n  }\n\n  @operator(\"[]\") charAt(pos: i32): String {\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\"\");\n    let out = changetype<String>(__new(2, idof<String>()));\n    store<u16>(changetype<usize>(out), load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return out;\n  }\n\n  charCodeAt(pos: i32): i32 {\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\n    return load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n  }\n\n  codePointAt(pos: i32): i32 {\n    let len = this.length;\n    if (<u32>pos >= <u32>len) return -1; // (undefined)\n    let first = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n    if ((first & 0xFC00) != 0xD800 || pos + 1 == len) return first;\n    let second = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1), 2);\n    if ((second & 0xFC00) != 0xDC00) return first;\n    return (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator(\"+\") private static __concat(left: String, right: String): String {\n    return left.concat(right);\n  }\n\n  concat(other: String): String {\n    let thisSize: isize = this.length << 1;\n    let otherSize: isize = other.length << 1;\n    let outSize: usize = thisSize + otherSize;\n    if (outSize == 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(outSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(other), otherSize);\n    return out;\n  }\n\n  endsWith(search: String, end: i32 = String.MAX_LENGTH): bool {\n    end = min(max(end, 0), this.length);\n    let searchLength = <isize>search.length;\n    let searchStart = <isize>end - searchLength;\n    if (searchStart < 0) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  @operator(\"==\") private static __eq(left: String | null, right: String | null): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return true;\n    if (changetype<usize>(left) == 0 || changetype<usize>(right) == 0) return false;\n    let leftLength = changetype<string>(left).length;\n    if (leftLength != changetype<string>(right).length) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(left, 0, right, 0, leftLength);\n  }\n\n  @operator.prefix(\"!\")\n  private static __not(str: String | null): bool {\n    return changetype<usize>(str) == 0 || !changetype<string>(str).length;\n  }\n\n  @operator(\"!=\")\n  private static __ne(left: String | null, right: String | null): bool {\n    return !this.__eq(left, right);\n  }\n\n  @operator(\">\") private static __gt(left: String, right: String): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return false;\n    let leftLength  = left.length;\n    if (!leftLength) return false;\n    let rightLength = right.length;\n    if (!rightLength) return true;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res > 0 : leftLength > rightLength;\n  }\n\n  @operator(\">=\") private static __gte(left: String, right: String): bool {\n    return !this.__lt(left, right);\n  }\n\n  @operator(\"<\") private static __lt(left: String, right: String): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return false;\n    let rightLength = right.length;\n    if (!rightLength) return false;\n    let leftLength  = left.length;\n    if (!leftLength) return true;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res < 0 : leftLength < rightLength;\n  }\n\n  @operator(\"<=\") private static __lte(left: String, right: String): bool {\n    return !this.__gt(left, right);\n  }\n\n  includes(search: String, start: i32 = 0): bool {\n    return this.indexOf(search, start) != -1;\n  }\n\n  indexOf(search: String, start: i32 = 0): i32 {\n    let searchLen = <isize>search.length;\n    if (!searchLen) return 0;\n    let len = <isize>this.length;\n    if (!len) return -1;\n    let searchStart = min(max(<isize>start, 0), len);\n    for (len -= searchLen; searchStart <= len; ++searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  lastIndexOf(search: String, start: i32 = i32.MAX_VALUE): i32 {\n    let searchLen = <isize>search.length;\n    if (!searchLen) return this.length;\n    let len = this.length;\n    if (!len) return -1;\n    let searchStart = min(max(<isize>start, 0), <isize>len - searchLen);\n    for (; searchStart >= 0; --searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  // TODO: implement full locale comparison with locales and Collator options\n  localeCompare(other: String): i32 {\n    if (changetype<usize>(other) == changetype<usize>(this)) return 0;\n    let alen = this.length;\n    let blen = other.length;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(this, 0, other, 0, <usize>min(alen, blen));\n    res = res ? res : alen - blen;\n    // normalize to [-1, 1] range\n    return i32(res > 0) - i32(res < 0);\n  }\n\n  startsWith(search: String, start: i32 = 0): bool {\n    let len = <isize>this.length;\n    let searchStart = min(max(<isize>start, 0), len);\n    let searchLength = <isize>search.length;\n    if (searchLength + searchStart > len) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String { // legacy\n    let intStart: isize = start;\n    let end: isize = length;\n    let len: isize = this.length;\n    if (intStart < 0) intStart = max(len + intStart, 0);\n    let size = min(max(end, 0), len - intStart) << 1;\n    if (size <= 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (intStart << 1), size);\n    return out;\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    let len: isize = this.length;\n    let finalStart = min<isize>(max(start, 0), len);\n    let finalEnd = min<isize>(max(end, 0), len);\n    let fromPos = min<isize>(finalStart, finalEnd) << 1;\n    let toPos = max<isize>(finalStart, finalEnd) << 1;\n    let size = toPos - fromPos;\n    if (!size) return changetype<String>(\"\");\n    if (!fromPos && toPos == len << 1) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + fromPos, size);\n    return out;\n  }\n\n  trim(): String {\n    let len = this.length;\n    let size: usize = len << 1;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    let offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2; size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (!offset && size == len << 1) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  @inline\n  trimLeft(): String {\n    return this.trimStart();\n  }\n\n  @inline\n  trimRight(): String {\n    return this.trimEnd();\n  }\n\n  trimStart(): String {\n    let size = <usize>this.length << 1;\n    let offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2;\n    }\n    if (!offset) return this;\n    size -= offset;\n    if (!size) return changetype<String>(\"\");\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  trimEnd(): String {\n    let originalSize = <usize>this.length << 1;\n    let size = originalSize;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (size == originalSize) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), size);\n    return out;\n  }\n\n  padStart(length: i32, pad: string = \" \"): String {\n    let thisSize = <usize>this.length << 1;\n    let targetSize = <usize>length << 1;\n    let padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    let prependSize = targetSize - thisSize;\n    let out = changetype<String>(__new(targetSize, idof<String>()));\n    if (prependSize > padSize) {\n      let repeatCount = (prependSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = prependSize - restBase;\n      memory.repeat(changetype<usize>(out), changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out), changetype<usize>(pad), prependSize);\n    }\n    memory.copy(changetype<usize>(out) + prependSize, changetype<usize>(this), thisSize);\n    return out;\n  }\n\n  padEnd(length: i32, pad: string = \" \"): String {\n    let thisSize = <usize>this.length << 1;\n    let targetSize = <usize>length << 1;\n    let padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    let appendSize = targetSize - thisSize;\n    let out = changetype<String>(__new(targetSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    if (appendSize > padSize) {\n      let repeatCount = (appendSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = appendSize - restBase;\n      memory.repeat(changetype<usize>(out) + thisSize, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + thisSize + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(pad), appendSize);\n    }\n    return out;\n  }\n\n  repeat(count: i32 = 0): String {\n    let length = this.length;\n\n    // Most browsers can't handle strings 1 << 28 chars or longer\n    if (count < 0 || <u64>length * count > (1 << 28)) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n\n    if (count == 0 || !length) return changetype<String>(\"\");\n    if (count == 1) return this;\n    let out = changetype<String>(__new((length * count) << 1, idof<String>()));\n    memory.repeat(changetype<usize>(out), changetype<usize>(this), <usize>length << 1, count);\n    return out;\n  }\n\n  replace(search: String, replacement: String): String {\n    let len: usize = this.length;\n    let slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    let index: isize = this.indexOf(search);\n    if (~index) {\n      let rlen: usize = replacement.length;\n      len -= slen;\n      let olen = len + rlen;\n      if (olen) {\n        let out = changetype<String>(__new(olen << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this), index << 1);\n        memory.copy(\n          changetype<usize>(out) + (index << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        memory.copy(\n          changetype<usize>(out) + ((index + rlen) << 1),\n          changetype<usize>(this) + ((index + slen) << 1),\n          (len - index) << 1\n        );\n        return out;\n      }\n    }\n    return this;\n  }\n\n  replaceAll(search: String, replacement: String): String {\n    let thisLen: usize = this.length;\n    let searchLen: usize = search.length;\n    if (thisLen <= searchLen) {\n      return thisLen < searchLen\n        ? this\n        : select<String>(replacement, this, search == this);\n    }\n    let replaceLen: usize = replacement.length;\n    if (!searchLen) {\n      if (!replaceLen) return this;\n      // Special case: 'abc'.replaceAll('', '-') -> '-a-b-c-'\n      let out = changetype<String>(__new((thisLen + (thisLen + 1) * replaceLen) << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(replacement), replaceLen << 1);\n      let offset = replaceLen;\n      for (let i: usize = 0; i < thisLen; ++i) {\n        store<u16>(\n          changetype<usize>(out) + (offset++ << 1),\n          load<u16>(changetype<usize>(this) + (i << 1))\n        );\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(replacement),\n          replaceLen << 1\n        );\n        offset += replaceLen;\n      }\n      return out;\n    }\n    let prev: isize = 0, next: isize = 0;\n    if (searchLen == replaceLen) {\n      // Fast path when search and replacement have same length\n      let outSize = thisLen << 1;\n      let out = changetype<String>(__new(outSize, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this), outSize);\n      while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n        memory.copy(changetype<usize>(out) + (next << 1), changetype<usize>(replacement), replaceLen << 1);\n        prev = next + searchLen;\n      }\n      return out;\n    }\n    let out: String | null = null, offset: usize = 0, outSize = thisLen;\n    while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n      if (!out) out = changetype<String>(__new(thisLen << 1, idof<String>()));\n      let chunk = next - prev;\n      if (offset + chunk + replaceLen > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(this) + (prev << 1),\n        chunk << 1\n      );\n      offset += chunk;\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(replacement),\n        replaceLen << 1\n      );\n      offset += replaceLen;\n      prev = next + searchLen;\n    }\n    if (out) {\n      let rest = thisLen - prev;\n      if (offset + rest > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      if (rest) {\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(this) + (prev << 1),\n          rest << 1\n        );\n      }\n      rest += offset;\n      if (outSize > rest) {\n        out = changetype<String>(__renew(changetype<usize>(out), rest << 1));\n      }\n      return out;\n    }\n    return this;\n  }\n\n  slice(start: i32, end: i32 = i32.MAX_VALUE): String {\n    let len = this.length;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end,   len);\n    len   = end - start;\n    if (len <= 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(len << 1, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n    return out;\n  }\n\n  split(separator: String | null = null, limit: i32 = i32.MAX_VALUE): String[] {\n    if (!limit) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    if (changetype<usize>(separator) == 0) return [ this ];\n    let length: isize = this.length;\n    let sepLen = changetype<string>(separator).length;\n    if (limit < 0) limit = i32.MAX_VALUE;\n    if (!sepLen) {\n      if (!length) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n      // split by chars\n      length = min<isize>(length, <isize>limit);\n      let result = changetype<String[]>(__newArray(<i32>length, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      let resultStart = result.dataStart as usize;\n      for (let i: isize = 0; i < length; ++i) {\n        let charStr = changetype<String>(__new(2, idof<String>()));\n        store<u16>(changetype<usize>(charStr), load<u16>(changetype<usize>(this) + (<usize>i << 1)));\n        store<usize>(resultStart + (<usize>i << alignof<usize>()), changetype<usize>(charStr)); // result[i] = charStr\n        __link(changetype<usize>(result), changetype<usize>(charStr), true);\n      }\n      return result;\n    } else if (!length) {\n      let result = changetype<String[]>(__newArray(1, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      store<usize>(result.dataStart as usize, changetype<usize>(\"\")); // static \"\"\n      return result;\n    }\n    let result = changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    let end = 0, start = 0, i = 0;\n    while (~(end = this.indexOf(changetype<string>(separator), start))) {\n      let len = end - start;\n      if (len > 0) {\n        let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n        result.push(out);\n      } else {\n        result.push(changetype<String>(\"\"));\n      }\n      if (++i == limit) return result;\n      start = end + sepLen;\n    }\n    if (!start) { // also means: loop above didn't do anything\n      result.push(this);\n      return result;\n    }\n    let len = length - start;\n    if (len > 0) {\n      let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n      result.push(out);\n    } else {\n      result.push(changetype<String>(\"\")); // static \"\"\n    }\n    return result;\n  }\n\n  toLowerCase(): String {\n    let len = <usize>this.length;\n    if (!len) return this;\n    let codes = changetype<String>(__new(len * 2 * 2, idof<String>()));\n    let j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toLower8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // check special casing for lower table. It has one ently so instead lookup we just inline this.\n        if (c == 0x0130) {\n          // 0x0130 -> [0x0069, 0x0307]\n          store<u32>(changetype<usize>(codes) + (j << 1), (0x0307 << 16) | 0x0069);\n          ++j;\n        } else if (c == 0x03A3) { // ''\n          //  maps to  but except at the end of a word where it maps to \n          let sigma = 0x03C3; // \n          if (len > 1 && isFinalSigma(changetype<usize>(this), i, len)) {\n            sigma = 0x03C2; // \n          }\n          store<u16>(changetype<usize>(codes) + (j << 1), sigma);\n        } else if (c - 0x24B6 <= 0x24CF - 0x24B6) {\n          // Range 0x24B6 <= c <= 0x24CF not covered by casemap and require special early handling\n          store<u16>(changetype<usize>(codes) + (j << 1), c + 26);\n        } else {\n          let code = casemap(c, 0) & 0x1FFFFF;\n          if (code < 0x10000) {\n            store<u16>(changetype<usize>(codes) + (j << 1), code);\n          } else {\n            // store as surrogare pair\n            code -= 0x10000;\n            let lo = (code >>> 10) | 0xD800;\n            let hi = (code & 0x03FF) | 0xDC00;\n            store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n            ++j;\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toUpperCase(): String {\n    let len = <usize>this.length;\n    if (!len) return this;\n    let codes = changetype<String>(__new(len * 3 * 2, idof<String>()));\n    let specialsPtr = changetype<usize>(SPECIALS_UPPER);\n    let specialsLen = SPECIALS_UPPER.length;\n    let j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toUpper8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // Range 0x24D0 <= c <= 0x24E9 not covered by casemap and require special early handling\n        if (c - 0x24D0 <= 0x24E9 - 0x24D0) {\n          // monkey patch\n          store<u16>(changetype<usize>(codes) + (j << 1), c - 26);\n        } else {\n          let index: usize = -1;\n          // Fast range check. See first and last rows in specialsUpper table\n          if (c - 0x00DF <= 0xFB17 - 0x00DF) {\n            index = <usize>bsearch(c, specialsPtr, specialsLen);\n          }\n          if (~index) {\n            // load next 3 code points from row with `index` offset for specialsUpper table\n            let ab = load<u32>(specialsPtr + (index << 1), 2);\n            let cc = load<u16>(specialsPtr + (index << 1), 6);\n            store<u32>(changetype<usize>(codes) + (j << 1), ab, 0);\n            store<u16>(changetype<usize>(codes) + (j << 1), cc, 4);\n            j += 1 + usize(cc != 0);\n          } else {\n            let code = casemap(c, 1) & 0x1FFFFF;\n            if (code < 0x10000) {\n              store<u16>(changetype<usize>(codes) + (j << 1), code);\n            } else {\n              // store as surrogare pair\n              code -= 0x10000;\n              let lo = (code >>> 10) | 0xD800;\n              let hi = (code & 0x03FF) | 0xDC00;\n              store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n              ++j;\n            }\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toString(): String {\n    return this;\n  }\n}\n\n// @ts-ignore: nolib\nexport type string = String;\n\nexport function parseInt(str: string, radix: i32 = 0): f64 {\n  return strtol<f64>(str, radix);\n}\n\nexport function parseFloat(str: string): f64 {\n  return strtod(str);\n}\n\n// Encoding helpers\nexport namespace String {\n\n  export namespace UTF8 {\n\n    export const enum ErrorMode {\n      WTF8,\n      REPLACE,\n      ERROR\n    }\n\n    export function byteLength(str: string, nullTerminated: bool = false): i32 {\n      let strOff = changetype<usize>(str);\n      let strEnd = strOff + <usize>changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n      let bufLen = i32(nullTerminated);\n      while (strOff < strEnd) {\n        let c1 = <u32>load<u16>(strOff);\n        if (c1 < 128) {\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) break;\n          bufLen += 1;\n        } else if (c1 < 2048) {\n          bufLen += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\n            if ((<u32>load<u16>(strOff, 2) & 0xFC00) == 0xDC00) {\n              bufLen += 4; strOff += 4;\n              continue;\n            }\n          }\n          bufLen += 3;\n        }\n        strOff += 2;\n      }\n      return bufLen;\n    }\n\n    export function encode(str: string, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): ArrayBuffer {\n      let buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str, nullTerminated), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf), nullTerminated, errorMode);\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): usize {\n      let strEnd = str + (<usize>len << 1);\n      let bufOff = buf;\n      while (str < strEnd) {\n        let c1 = <u32>load<u16>(str);\n        if (c1 < 128) {\n          store<u8>(bufOff, c1);\n          bufOff++;\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) return bufOff - buf;\n        } else if (c1 < 2048) {\n          let b0 = c1 >> 6 | 192;\n          let b1 = c1 & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          bufOff += 2;\n        } else {\n          // D800: 11011 0 0000000000 Lead\n          // DBFF: 11011 0 1111111111\n          // DC00: 11011 1 0000000000 Trail\n          // DFFF: 11011 1 1111111111\n          // F800: 11111 0 0000000000 Mask\n          // FC00: 11111 1 0000000000\n          if ((c1 & 0xF800) == 0xD800) {\n            if (c1 < 0xDC00 && str + 2 < strEnd) {\n              let c2 = <u32>load<u16>(str, 2);\n              if ((c2 & 0xFC00) == 0xDC00) {\n                c1 = 0x10000 + ((c1 & 0x03FF) << 10) | (c2 & 0x03FF);\n                let b0 = c1 >> 18 | 240;\n                let b1 = c1 >> 12 & 63 | 128;\n                let b2 = c1 >> 6  & 63 | 128;\n                let b3 = c1       & 63 | 128;\n                store<u32>(bufOff, b3 << 24 | b2 << 16 | b1 << 8 | b0);\n                bufOff += 4; str += 4;\n                continue;\n              }\n            }\n            if (errorMode != ErrorMode.WTF8) { // unlikely\n              if (errorMode == ErrorMode.ERROR) throw new Error(E_UNPAIRED_SURROGATE);\n              c1 = 0xFFFD;\n            }\n          }\n          let b0 = c1 >> 12 | 224;\n          let b1 = c1 >> 6  & 63 | 128;\n          let b2 = c1       & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          store<u8>(bufOff, b2, 2);\n          bufOff += 3;\n        }\n        str += 2;\n      }\n      if (nullTerminated) {\n        store<u8>(bufOff++, 0);\n      }\n      return bufOff - buf;\n    }\n\n    export function decode(buf: ArrayBuffer, nullTerminated: bool = false): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength, nullTerminated);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize, nullTerminated: bool = false): String {\n      let bufOff = buf;\n      let bufEnd = buf + len;\n      assert(bufEnd >= bufOff); // guard wraparound\n      let str = changetype<String>(__new(len << 1, idof<String>())); // max is one u16 char per u8 byte\n      let strOff = changetype<usize>(str);\n      while (bufOff < bufEnd) {\n        let u0 = <u32>load<u8>(bufOff); ++bufOff;\n        if (!(u0 & 128)) {\n          // @ts-ignore: cast\n          if (nullTerminated & !u0) break;\n          store<u16>(strOff, u0);\n        } else {\n          if (bufEnd == bufOff) break;\n          let u1 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n          if ((u0 & 224) == 192) {\n            store<u16>(strOff, (u0 & 31) << 6 | u1);\n          } else {\n            if (bufEnd == bufOff) break;\n            let u2 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n            if ((u0 & 240) == 224) {\n              u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n            } else {\n              if (bufEnd == bufOff) break;\n              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | <u32>load<u8>(bufOff) & 63;\n              ++bufOff;\n            }\n            if (u0 < 0x10000) {\n              store<u16>(strOff, u0);\n            } else {\n              u0 -= 0x10000;\n              let lo = u0 >> 10 | 0xD800;\n              let hi = (u0 & 0x03FF) | 0xDC00;\n              store<u32>(strOff, lo | (hi << 16));\n              strOff += 2;\n            }\n          }\n        }\n        strOff += 2;\n      }\n      return changetype<String>(__renew(changetype<usize>(str), strOff - changetype<usize>(str)));\n    }\n  }\n\n  export namespace UTF16 {\n\n    export function byteLength(str: string): i32 {\n      return changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n    }\n\n    export function encode(str: string): ArrayBuffer {\n      let buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf));\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize): usize {\n      let size = <usize>len << 1;\n      memory.copy(buf, changetype<usize>(str), size);\n      return size;\n    }\n\n    export function decode(buf: ArrayBuffer): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize): String {\n      let str = changetype<String>(__new(len &= ~1, idof<String>()));\n      memory.copy(changetype<usize>(str), buf, len);\n      return str;\n    }\n  }\n}\n\nexport class TemplateStringsArray extends Array<string> {\n  readonly raw: string[];\n}\n","/**\n * Alignment helper functions (AssemblyScript)\n * Gray Paper reference: equation 766\n */\n\nimport { MEMORY_CONFIG, ZONE_SIZE } from './config'\n\n/**\n * Align to page boundary\n * Gray Paper: rnp(x  )  Cpvmpagesize * ceil(x / Cpvmpagesize)\n */\nexport function alignToPage(size: u32): u32 {\n  return u32(Math.ceil(f64(size) / f64(MEMORY_CONFIG.PAGE_SIZE))) * MEMORY_CONFIG.PAGE_SIZE\n}\n\n/**\n * Align to zone boundary  \n * Gray Paper: rnq(x  )  Cpvminitzonesize * ceil(x / Cpvminitzonesize)\n */\nexport function alignToZone(size: u32): u32 {\n  return u32(Math.ceil(f64(size) / f64(ZONE_SIZE))) * ZONE_SIZE\n}\n","import { Math as JSMath } from \"./bindings/dom\";\nexport { JSMath };\n\nimport {\n  pow_lut, exp_lut, exp2_lut, log_lut, log2_lut,\n  powf_lut, expf_lut, exp2f_lut, logf_lut, log2f_lut\n} from \"./util/math\";\n\nimport {\n  abs as builtin_abs,\n  ceil as builtin_ceil,\n  clz as builtin_clz,\n  copysign as builtin_copysign,\n  floor as builtin_floor,\n  max as builtin_max,\n  min as builtin_min,\n  sqrt as builtin_sqrt,\n  trunc as builtin_trunc\n} from \"./builtins\";\n\n// SUN COPYRIGHT NOTICE\n//\n// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\n// Developed at SunPro, a Sun Microsystems, Inc. business.\n// Permission to use, copy, modify, and distribute this software\n// is freely granted, provided that this notice is preserved.\n//\n// Applies to all functions marked with a comment referring here.\n\n/** @internal */\n// @ts-ignore: decorator\n@lazy let rempio2_y0: f64, rempio2_y1: f64, res128_hi: u64;\n\n/** @internal */\n// @ts-ignore: decorator\n@lazy @inline const PIO2_TABLE = memory.data<u64>([\n  0x00000000A2F9836E, 0x4E441529FC2757D1, 0xF534DDC0DB629599, 0x3C439041FE5163AB,\n  0xDEBBC561B7246E3A, 0x424DD2E006492EEA, 0x09D1921CFE1DEB1C, 0xB129A73EE88235F5,\n  0x2EBB4484E99C7026, 0xB45F7E413991D639, 0x835339F49C845F8B, 0xBDF9283B1FF897FF,\n  0xDE05980FEF2F118B, 0x5A0A6D1F6D367ECF, 0x27CB09B74F463F66, 0x9E5FEA2D7527BAC7,\n  0xEBE5F17B3D0739F7, 0x8A5292EA6BFB5FB1, 0x1F8D5D0856033046, 0xFC7B6BABF0CFBC20,\n  0x9AF4361DA9E39161, 0x5EE61B086599855F, 0x14A068408DFFD880, 0x4D73273106061557\n]);\n\n/** @internal */\nfunction R(z: f64): f64 { // Rational approximation of (asin(x)-x)/x^3\n  const                   // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f64>(0x3FC5555555555555), //  1.66666666666666657415e-01\n    pS1 = reinterpret<f64>(0xBFD4D61203EB6F7D), // -3.25565818622400915405e-01\n    pS2 = reinterpret<f64>(0x3FC9C1550E884455), //  2.01212532134862925881e-01\n    pS3 = reinterpret<f64>(0xBFA48228B5688F3B), // -4.00555345006794114027e-02\n    pS4 = reinterpret<f64>(0x3F49EFE07501B288), //  7.91534994289814532176e-04\n    pS5 = reinterpret<f64>(0x3F023DE10DFDF709), //  3.47933107596021167570e-05\n    qS1 = reinterpret<f64>(0xC0033A271C8A2D4B), // -2.40339491173441421878e+00\n    qS2 = reinterpret<f64>(0x40002AE59C598AC8), //  2.02094576023350569471e+00\n    qS3 = reinterpret<f64>(0xBFE6066C1B8D0159), // -6.88283971605453293030e-01\n    qS4 = reinterpret<f64>(0x3FB3B8C5B12E9282); //  7.70381505559019352791e-02\n\n  let p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));\n  let q = 1.0 + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));\n  return p / q;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction expo2(x: f64, sign: f64): f64 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                       // see: musl/src/math/__expo2.c\n    k    = <u32>2043,\n    kln2 = reinterpret<f64>(0x40962066151ADD8B); // 0x1.62066151add8bp+10\n  let scale = reinterpret<f64>(<u64>((<u32>0x3FF + k / 2) << 20) << 32);\n  // in directed rounding correct sign before rounding or overflow is important\n  return NativeMath.exp(x - kln2) * (sign * scale) * scale;\n}\n\n/** @internal */\n/* Helper function to eventually get bits of /2 * |x|\n *\n * y = /4 * (frac << clz(frac) >> 11)\n * return clz(frac)\n *\n * Right shift 11 bits to make upper half fit in `double`\n */\n// @ts-ignore: decorator\n@inline\nfunction pio2_right(q0: u64, q1: u64): u64 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\n  // Bits of /4\n  const p0: u64 = 0xC4C6628B80DC1CD1;\n  const p1: u64 = 0xC90FDAA22168C234;\n\n  const Ox1p_64 = reinterpret<f64>(0x3BF0000000000000); // 0x1p-64\n  const Ox1p_75 = reinterpret<f64>(0x3B40000000000000); // 0x1p-75\n\n  let shift = clz(q1);\n\n  q1 = q1 << shift | q0 >> (64 - shift);\n  q0 <<= shift;\n\n  let lo = umuldi(p1, q1);\n  let hi = res128_hi;\n\n  let ahi = hi >> 11;\n  let alo = lo >> 11 | hi << 53;\n  let blo = <u64>(Ox1p_75 * <f64>p0 * <f64>q1 + Ox1p_75 * <f64>p1 * <f64>q0);\n\n  rempio2_y0 = <f64>(ahi + u64(lo < blo));\n  rempio2_y1 = Ox1p_64 * <f64>(alo + blo);\n\n  return shift;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction umuldi(u: u64, v: u64): u64 {\n  let u1: u64 , v1: u64, w0: u64, w1: u64, t: u64;\n\n  u1 = u & 0xFFFFFFFF;\n  v1 = v & 0xFFFFFFFF;\n\n  u >>= 32;\n  v >>= 32;\n\n  t  = u1 * v1;\n  w0 = t & 0xFFFFFFFF;\n  t  = u * v1 + (t >> 32);\n  w1 = t >> 32;\n  t  = u1 * v + (t & 0xFFFFFFFF);\n\n  res128_hi = u * v + w1 + (t >> 32);\n  return (t << 32) + w0;\n}\n\n/** @internal */\nfunction pio2_large_quot(x: f64, u: i64): i32 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\n  let magnitude = u & 0x7FFFFFFFFFFFFFFF;\n  let offset = (magnitude >> 52) - 1045;\n  let shift  = offset & 63;\n  let tblPtr = PIO2_TABLE + (<i32>(offset >> 6) << 3);\n  let s0: u64, s1: u64, s2: u64;\n\n  let b0 = load<u64>(tblPtr, 0 << 3);\n  let b1 = load<u64>(tblPtr, 1 << 3);\n  let b2 = load<u64>(tblPtr, 2 << 3);\n\n  // Get 192 bits of 0x1p-31 /  with `offset` bits skipped\n  if (shift) {\n    let rshift = 64 - shift;\n    let b3 = load<u64>(tblPtr, 3 << 3);\n    s0 = b1 >> rshift | b0 << shift;\n    s1 = b2 >> rshift | b1 << shift;\n    s2 = b3 >> rshift | b2 << shift;\n  } else {\n    s0 = b0;\n    s1 = b1;\n    s2 = b2;\n  }\n\n  let significand = (u & 0x000FFFFFFFFFFFFF) | 0x0010000000000000;\n\n  // First 128 bits of fractional part of x/(2)\n  let blo = umuldi(s1, significand);\n  let bhi = res128_hi;\n\n  let ahi = s0 * significand;\n  let clo = (s2 >> 32) * (significand >> 32);\n  let plo = blo + clo;\n  let phi = ahi + bhi + u64(plo < clo);\n\n  // r: u128 = p << 2\n  let rlo = plo << 2;\n  let rhi = phi << 2 | plo >> 62;\n\n  // s: i128 = r >> 127\n  let slo = <i64>rhi >> 63;\n  let shi = slo >> 1;\n  let q   = (<i64>phi >> 62) - slo;\n\n  let shifter = 0x3CB0000000000000 - (pio2_right(rlo ^ slo, rhi ^ shi) << 52);\n  let signbit = (u ^ rhi) & 0x8000000000000000;\n  let coeff   = reinterpret<f64>(shifter | signbit);\n\n  rempio2_y0 *= coeff;\n  rempio2_y1 *= coeff;\n\n  return <i32>q;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction rempio2(x: f64, u: u64, sign: i32): i32 {\n  const\n    pio2_1  = reinterpret<f64>(0x3FF921FB54400000), // 1.57079632673412561417e+00\n    pio2_1t = reinterpret<f64>(0x3DD0B4611A626331), // 6.07710050650619224932e-11\n    pio2_2  = reinterpret<f64>(0x3DD0B4611A600000), // 6.07710050630396597660e-11\n    pio2_2t = reinterpret<f64>(0x3BA3198A2E037073), // 2.02226624879595063154e-21\n    pio2_3  = reinterpret<f64>(0x3BA3198A2E000000), // 2.02226624871116645580e-21\n    pio2_3t = reinterpret<f64>(0x397B839A252049C1), // 8.47842766036889956997e-32\n    invpio2 = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\n\n  let ix = <u32>(u >> 32) & 0x7FFFFFFF;\n\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (ix < 0x4002D97C) { // |x| < 3pi/4, special case with n=+-1\n      let q = 1, z: f64, y0: f64, y1: f64;\n      if (!sign) {\n        z = x - pio2_1;\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\n          y0 = z - pio2_1t;\n          y1 = (z - y0) - pio2_1t;\n        } else { // near pi/2, use 33+33+53 bit pi\n          z -= pio2_2;\n          y0 = z - pio2_2t;\n          y1 = (z - y0) - pio2_2t;\n        }\n      } else { // negative x\n        z = x + pio2_1;\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\n          y0 = z + pio2_1t;\n          y1 = (z - y0) + pio2_1t;\n        } else { // near pi/2, use 33+33+53 bit pi\n          z += pio2_2;\n          y0 = z + pio2_2t;\n          y1 = (z - y0) + pio2_2t;\n        }\n        q = -1;\n      }\n      rempio2_y0 = y0;\n      rempio2_y1 = y1;\n      return q;\n    }\n  }\n\n  if (ix < 0x413921FB) { // |x| ~< 2^20*pi/2 (1647099)\n    // Use precise Cody Waite scheme\n    let q  = nearest(x * invpio2);\n    let r  = x - q * pio2_1;\n    let w  = q * pio2_1t; // 1st round good to 85 bit\n    let j  = ix >> 20;\n    let y0 = r - w;\n    let hi = <u32>(reinterpret<u64>(y0) >> 32);\n    let i  = j - ((hi >> 20) & 0x7FF);\n\n    if (i > 16) { // 2nd iteration needed, good to 118\n      let t = r;\n      w  = q * pio2_2;\n      r  = t - w;\n      w  = q * pio2_2t - ((t - r) - w);\n      y0 = r - w;\n      hi = <u32>(reinterpret<u64>(y0) >> 32);\n      i = j - ((hi >> 20) & 0x7FF);\n      if (i > 49) { // 3rd iteration need, 151 bits acc\n        let t = r;\n        w  = q * pio2_3;\n        r  = t - w;\n        w  = q * pio2_3t - ((t - r) - w);\n        y0 = r - w;\n      }\n    }\n    let y1 = (r - y0) - w;\n    rempio2_y0 = y0;\n    rempio2_y1 = y1;\n    return <i32>q;\n  }\n  let q = pio2_large_quot(x, u);\n  return select(-q, q, sign);\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction sin_kern(x: f64, y: f64, iy: i32): f64 { // see: musl/tree/src/math/__sin.c\n  const\n    S1 = reinterpret<f64>(0xBFC5555555555549), // -1.66666666666666324348e-01\n    S2 = reinterpret<f64>(0x3F8111111110F8A6), //  8.33333333332248946124e-03\n    S3 = reinterpret<f64>(0xBF2A01A019C161D5), // -1.98412698298579493134e-04\n    S4 = reinterpret<f64>(0x3EC71DE357B1FE7D), //  2.75573137070700676789e-06\n    S5 = reinterpret<f64>(0xBE5AE5E68A2B9CEB), // -2.50507602534068634195e-08\n    S6 = reinterpret<f64>(0x3DE5D93A5ACFD57C); //  1.58969099521155010221e-10\n\n  let z = x * x;\n  let w = z * z;\n  let r = S2 + z * (S3 + z * S4) + z * w * (S5 + z * S6);\n  let v = z * x;\n  if (!iy) {\n    return x + v * (S1 + z * r);\n  } else {\n    return x - ((z * (0.5 * y - v * r) - y) - v * S1);\n  }\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction cos_kern(x: f64, y: f64): f64 { // see: musl/tree/src/math/__cos.c\n  const\n    C1 = reinterpret<f64>(0x3FA555555555554C), //  4.16666666666666019037e-02\n    C2 = reinterpret<f64>(0xBF56C16C16C15177), // -1.38888888888741095749e-03\n    C3 = reinterpret<f64>(0x3EFA01A019CB1590), //  2.48015872894767294178e-05\n    C4 = reinterpret<f64>(0xBE927E4F809C52AD), // -2.75573143513906633035e-07\n    C5 = reinterpret<f64>(0x3E21EE9EBDB4B1C4), //  2.08757232129817482790e-09\n    C6 = reinterpret<f64>(0xBDA8FAE9BE8838D4); // -1.13596475577881948265e-11\n\n  let z = x * x;\n  let w = z * z;\n  let r = z * (C1 + z * (C2 + z * C3)) + w * w * (C4 + z * (C5 + z * C6));\n  let hz = 0.5 * z;\n  w = 1.0 - hz;\n  return w + (((1.0 - w) - hz) + (z * r - x * y));\n}\n\n/** @internal */\nfunction tan_kern(x: f64, y: f64, iy: i32): f64 { // see: src/lib/msun/src/k_tan.c\n  const\n    T0  = reinterpret<f64>(0x3FD5555555555563), //  3.33333333333334091986e-01\n    T1  = reinterpret<f64>(0x3FC111111110FE7A), //  1.33333333333201242699e-01\n    T2  = reinterpret<f64>(0x3FABA1BA1BB341FE), //  5.39682539762260521377e-02\n    T3  = reinterpret<f64>(0x3F9664F48406D637), //  2.18694882948595424599e-02\n    T4  = reinterpret<f64>(0x3F8226E3E96E8493), //  8.86323982359930005737e-03\n    T5  = reinterpret<f64>(0x3F6D6D22C9560328), //  3.59207910759131235356e-03\n    T6  = reinterpret<f64>(0x3F57DBC8FEE08315), //  1.45620945432529025516e-03\n    T7  = reinterpret<f64>(0x3F4344D8F2F26501), //  5.88041240820264096874e-04\n    T8  = reinterpret<f64>(0x3F3026F71A8D1068), //  2.46463134818469906812e-04\n    T9  = reinterpret<f64>(0x3F147E88A03792A6), //  7.81794442939557092300e-05\n    T10 = reinterpret<f64>(0x3F12B80F32F0A7E9), //  7.14072491382608190305e-05\n    T11 = reinterpret<f64>(0xBEF375CBDB605373), // -1.85586374855275456654e-05\n    T12 = reinterpret<f64>(0x3EFB2A7074BF7AD4); //  2.59073051863633712884e-05\n\n  const\n    one    = reinterpret<f64>(0x3FF0000000000000), // 1.00000000000000000000e+00\n    pio4   = reinterpret<f64>(0x3FE921FB54442D18), // 7.85398163397448278999e-01\n    pio4lo = reinterpret<f64>(0x3C81A62633145C07); // 3.06161699786838301793e-17\n\n  let z: f64, r: f64, v: f64, w: f64, s: f64;\n  let hx = <i32>(reinterpret<u64>(x) >> 32); // high word of x\n  let ix = hx & 0x7FFFFFFF; // high word of |x|\n  let big = ix >= 0x3FE59428;\n  if (big) { // |x| >= 0.6744\n    if (hx < 0) { x = -x, y = -y; }\n    z = pio4 - x;\n    w = pio4lo - y;\n    x = z + w;\n    y = 0.0;\n  }\n  z = x * x;\n  w = z * z;\n  r = T1 + w * (T3 + w * (T5 + w * (T7 + w * (T9 + w * T11))));\n  v = z * (T2 + w * (T4 + w * (T6 + w * (T8 + w * (T10 + w * T12)))));\n  s = z * x;\n  r = y + z * (s * (r + v) + y);\n  r += T0 * s;\n  w = x + r;\n  if (big) {\n    v = iy;\n    return (1 - ((hx >> 30) & 2)) * (v - 2.0 * (x - (w * w / (w + v) - r)));\n  }\n  if (iy == 1) return w;\n  let a: f64, t: f64;\n  z = w;\n  z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF00000000);\n  v = r - (z - x);  // z + v = r + x\n  t = a = -one / w; // a = -1.0 / w\n  t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\n  s = one + t * z;\n  return t + a * (s + t * v);\n}\n\n/** @internal */\nfunction dtoi32(x: f64): i32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    const inv32 = 1.0 / 4294967296;\n    return <i32><i64>(x - 4294967296 * floor(x * inv32));\n  } else {\n    let result = 0;\n    let u = reinterpret<u64>(x);\n    let e = (u >> 52) & 0x7FF;\n    if (e <= 1023 + 30) {\n      result = <i32>x;\n    } else if (e <= 1023 + 30 + 53) {\n      let v = (u & ((<u64>1 << 52) - 1)) | (<u64>1 << 52);\n      v = v << e - 1023 - 52 + 32;\n      result = <i32>(v >> 32);\n      result = select<i32>(-result, result, <i64>u < 0);\n    }\n    return result;\n  }\n}\n\n// @ts-ignore: decorator\n@lazy let random_seeded = false;\n\n// @ts-ignore: decorator\n@lazy let random_state0_64: u64, random_state1_64: u64;\n\n// @ts-ignore: decorator\n@lazy let random_state0_32: u32, random_state1_32: u32;\n\nfunction murmurHash3(h: u64): u64 { // Force all bits of a hash block to avalanche\n  h ^= h >> 33;                     // see: https://github.com/aappleby/smhasher\n  h *= 0xFF51AFD7ED558CCD;\n  h ^= h >> 33;\n  h *= 0xC4CEB9FE1A85EC53;\n  h ^= h >> 33;\n  return h;\n}\n\nfunction splitMix32(h: u32): u32 {\n  h += 0x6D2B79F5;\n  h  = (h ^ (h >> 15)) * (h | 1);\n  h ^= h + (h ^ (h >> 7)) * (h | 61);\n  return h ^ (h >> 14);\n}\n\nexport namespace NativeMath {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const E       = reinterpret<f64>(0x4005BF0A8B145769); // 2.7182818284590452354\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN2     = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.69314718055994530942\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN10    = reinterpret<f64>(0x40026BB1BBB55516); // 2.30258509299404568402\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG2E   = reinterpret<f64>(0x3FF71547652B82FE); // 1.4426950408889634074\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG10E  = reinterpret<f64>(0x3FDBCB7B1526E50E); // 0.43429448190325182765\n\n  // @ts-ignore: decorator\n  @lazy\n  export const PI      = reinterpret<f64>(0x400921FB54442D18); // 3.14159265358979323846\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT1_2 = reinterpret<f64>(0x3FE6A09E667F3BCD); // 0.70710678118654752440\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT2   = reinterpret<f64>(0x3FF6A09E667F3BCD); // 1.41421356237309504880\n\n  // @ts-ignore: decorator\n  @lazy\n  export let sincos_sin: f64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export let sincos_cos: f64 = 0;\n\n  // @ts-ignore: decorator\n  @inline export function abs(x: f64): f64 {\n    return builtin_abs<f64>(x);\n  }\n\n  export function acos(x: f64): f64 { // see: musl/src/math/acos.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    let hx = <u32>(reinterpret<u64>(x) >> 32);\n    let ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) {\n        if (<i32>hx < 0) return 2 * pio2_hi + Ox1p_120f;\n        return 0;\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix <= 0x3C600000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * R(x * x)));\n    }\n    let s: f64, w: f64, z: f64;\n    if (<i32>hx < 0) {\n      // z = (1.0 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f64>(z);\n      w = R(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1.0 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f64>(z);\n    let df = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n    let c = (z - df * df) / (s + df);\n    w = R(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f64): f64 { // see: musl/src/math/acosh.c\n    const s = reinterpret<f64>(0x3FE62E42FEFA39EF);\n    let u = reinterpret<u64>(x);\n    // Prevent propagation for all input values less than 1.0.\n    // Note musl lib didn't fix this yet.\n    if (<i64>u < 0x3FF0000000000000) return (x - x) / 0.0;\n    let e = u >> 52 & 0x7FF;\n    if (e < 0x3FF + 1) return log1p(x - 1 + builtin_sqrt<f64>((x - 1) * (x - 1) + 2 * (x - 1)));\n    if (e < 0x3FF + 26) return log(2 * x - 1 / (x + builtin_sqrt<f64>(x * x - 1)));\n    return log(x) + s;\n  }\n\n  export function asin(x: f64): f64 { // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    let hx = <u32>(reinterpret<u64>(x) >> 32);\n    let ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) return x * pio2_hi + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix < 0x3E500000 && ix >= 0x00100000) return x;\n      return x + x * R(x * x);\n    }\n    // let z = (1.0 - builtin_abs<f64>(x)) * 0.5;\n    let z = 0.5 - builtin_abs<f64>(x) * 0.5;\n    let s = builtin_sqrt<f64>(z);\n    let r = R(z);\n    if (ix >= 0x3FEF3333) x = pio2_hi - (2 * (s + s * r) - pio2_lo);\n    else {\n      let f = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n      let c = (z - f * f) / (s + f);\n      x = 0.5 * pio2_hi - (2 * s * r - (pio2_lo - 2 * c) - (0.5 * pio2_hi - 2 * f));\n    }\n    return select(-x, x, <i32>hx < 0);\n  }\n\n  export function asinh(x: f64): f64 { // see: musl/src/math/asinh.c\n    const c = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.693147180559945309417232121458176568\n    let u = reinterpret<u64>(x);\n    let e = u >> 52 & 0x7FF;\n    let y = reinterpret<f64>(u & 0x7FFFFFFFFFFFFFFF);\n    if (e >= 0x3FF + 26) y = log(y) + c;\n    else if (e >= 0x3FF + 1)  y =   log(2 * y + 1 / (builtin_sqrt<f64>(y * y + 1) + y));\n    else if (e >= 0x3FF - 26) y = log1p(y + y * y / (builtin_sqrt<f64>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f64): f64 { // see musl/src/math/atan.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f64>(0x3FDDAC670561BB4F), //  4.63647609000806093515e-01\n      atanhi1   = reinterpret<f64>(0x3FE921FB54442D18), //  7.85398163397448278999e-01\n      atanhi2   = reinterpret<f64>(0x3FEF730BD281F69B), //  9.82793723247329054082e-01\n      atanhi3   = reinterpret<f64>(0x3FF921FB54442D18), //  1.57079632679489655800e+00\n      atanlo0   = reinterpret<f64>(0x3C7A2B7F222F65E2), //  2.26987774529616870924e-17\n      atanlo1   = reinterpret<f64>(0x3C81A62633145C07), //  3.06161699786838301793e-17\n      atanlo2   = reinterpret<f64>(0x3C7007887AF0CBBD), //  1.39033110312309984516e-17\n      atanlo3   = reinterpret<f64>(0x3C91A62633145C07), //  6.12323399573676603587e-17\n      aT0       = reinterpret<f64>(0x3FD555555555550D), //  3.33333333333329318027e-01\n      aT1       = reinterpret<f64>(0xBFC999999998EBC4), // -1.99999999998764832476e-01\n      aT2       = reinterpret<f64>(0x3FC24924920083FF), //  1.42857142725034663711e-01\n      aT3       = reinterpret<f64>(0xBFBC71C6FE231671), // -1.11111104054623557880e-01,\n      aT4       = reinterpret<f64>(0x3FB745CDC54C206E), //  9.09088713343650656196e-02\n      aT5       = reinterpret<f64>(0xBFB3B0F2AF749A6D), // -7.69187620504482999495e-02\n      aT6       = reinterpret<f64>(0x3FB10D66A0D03D51), //  6.66107313738753120669e-02\n      aT7       = reinterpret<f64>(0xBFADDE2D52DEFD9A), // -5.83357013379057348645e-02\n      aT8       = reinterpret<f64>(0x3FA97B4B24760DEB), //  4.97687799461593236017e-02\n      aT9       = reinterpret<f64>(0xBFA2B4442C6A6C2F), // -3.65315727442169155270e-02\n      aT10      = reinterpret<f64>(0x3F90AD3AE322DA11), //  1.62858201153657823623e-02\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    let ix = <u32>(reinterpret<u64>(x) >> 32);\n    let sx = x;\n    ix &= 0x7FFFFFFF;\n    let z: f64;\n    if (ix >= 0x44100000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign<f64>(z, sx);\n    }\n    let id: i32;\n    if (ix < 0x3FDC0000) {\n      if (ix < 0x3E400000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f64>(x);\n      if (ix < 0x3FF30000) {\n        if (ix < 0x3FE60000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x40038000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    let w = z * z;\n    let s1 = z * (aT0 + w * (aT2 + w * (aT4 + w * (aT6 + w * (aT8 + w * aT10)))));\n    let s2 = w * (aT1 + w * (aT3 + w * (aT5 + w * (aT7 + w * aT9))));\n    let s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign<f64>(z, sx);\n  }\n\n  export function atanh(x: f64): f64 { // see: musl/src/math/atanh.c\n    let u = reinterpret<u64>(x);\n    let e = u >> 52 & 0x7FF;\n    let y = builtin_abs(x);\n    if (e < 0x3FF - 1) {\n      if (e >= 0x3FF - 32) y = 0.5 * log1p(2 * y + 2 * y * y / (1 - y));\n    } else {\n      y = 0.5 * log1p(2 * (y / (1 - y)));\n    }\n    return builtin_copysign<f64>(y, x);\n  }\n\n  export function atan2(y: f64, x: f64): f64 { // see: musl/src/math/atan2.c and SUN COPYRIGHT NOTICE above\n    const pi_lo = reinterpret<f64>(0x3CA1A62633145C07); // 1.2246467991473531772E-16\n    if (isNaN(x) || isNaN(y)) return x + y;\n    let u = reinterpret<u64>(x);\n    let ix = <u32>(u >> 32);\n    let lx = <u32>u;\n    u = reinterpret<u64>(y);\n    let iy = <u32>(u >> 32);\n    let ly = <u32>u;\n    if ((ix - 0x3FF00000 | lx) == 0) return atan(y);\n    let m = ((iy >> 31) & 1) | ((ix >> 30) & 2);\n    ix = ix & 0x7FFFFFFF;\n    iy = iy & 0x7FFFFFFF;\n    if ((iy | ly) == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  PI;\n        case 3: return -PI;\n      }\n    }\n    if ((ix | lx) == 0) return m & 1 ? -PI / 2 : PI / 2;\n    if (ix == 0x7FF00000) {\n      if (iy == 0x7FF00000) {\n        let t = m & 2 ? 3 * PI / 4 : PI / 4;\n        return m & 1 ? -t : t;\n      } else {\n        let t = m & 2 ? PI : 0;\n        return m & 1 ? -t : t;\n      }\n    }\n    let z: f64;\n    if (ix + (64 << 20) < iy || iy == 0x7FF00000) return m & 1 ? -PI / 2 : PI / 2;\n    if ((m & 2) && iy + (64 << 20) < ix) z = 0;\n    else z = atan(builtin_abs<f64>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return PI - (z - pi_lo);\n      case 3: return (z - pi_lo) - PI;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f64): f64 { // see: musl/src/math/cbrt.c and SUN COPYRIGHT NOTICE above\n    const\n      B1     = <u32>715094163,\n      B2     = <u32>696219795,\n      P0     = reinterpret<f64>(0x3FFE03E60F61E692), //  1.87595182427177009643\n      P1     = reinterpret<f64>(0xBFFE28E092F02420), // -1.88497979543377169875\n      P2     = reinterpret<f64>(0x3FF9F1604A49D6C2), //  1.621429720105354466140\n      P3     = reinterpret<f64>(0xBFE844CBBEE751D9), // -0.758397934778766047437\n      P4     = reinterpret<f64>(0x3FC2B000D4E4EDD7), //  0.145996192886612446982\n      Ox1p54 = reinterpret<f64>(0x4350000000000000); //  0x1p54\n\n    let u = reinterpret<u64>(x);\n    let hx = <u32>(u >> 32) & 0x7FFFFFFF;\n    if (hx >= 0x7FF00000) return x + x;\n    if (hx < 0x00100000) {\n      u = reinterpret<u64>(x * Ox1p54);\n      hx = <u32>(u >> 32) & 0x7FFFFFFF;\n      if (hx == 0) return x;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 1 << 63;\n    u |= <u64>hx << 32;\n    let t = reinterpret<f64>(u);\n    let r = (t * t) * (t / x);\n    t = t * ((P0 + r * (P1 + r * P2)) + ((r * r) * r) * (P3 + r * P4));\n    t = reinterpret<f64>((reinterpret<u64>(t) + 0x80000000) & 0xFFFFFFFFC0000000);\n    let s = t * t;\n    r = x / s;\n    r = (r - t) / (2 * t + r);\n    t = t + t * r;\n    return t;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function ceil(x: f64): f64 {\n    return builtin_ceil<f64>(x);\n  }\n\n  export function clz32(x: f64): f64 {\n    if (!isFinite(x)) return 32;\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    return builtin_clz(dtoi32(x));\n  }\n\n  export function cos(x: f64): f64 { // see: musl/src/math/cos.c\n    let u  = reinterpret<u64>(x);\n    let ux = u32(u >> 32);\n    let sign = ux >> 31;\n\n    ux &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ux <= 0x3FE921FB) {\n      if (ux < 0x3E46A09E) {  // |x| < 2**-27 * sqrt(2)\n        return 1.0;\n      }\n      return cos_kern(x, 0);\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7FF00000) return x - x;\n\n    // argument reduction needed\n    let n  = rempio2(x, u, sign);\n    let y0 = rempio2_y0;\n    let y1 = rempio2_y1;\n\n    x = n & 1 ? sin_kern(y0, y1, 1) : cos_kern(y0, y1);\n    return (n + 1) & 2 ? -x : x;\n  }\n\n  export function cosh(x: f64): f64 { // see: musl/src/math/cosh.c\n    let u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    x = reinterpret<f64>(u);\n    let w = <u32>(u >> 32);\n    let t: f64;\n    if (w < 0x3FE62E42) {\n      if (w < 0x3FF00000 - (26 << 20)) return 1;\n      t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (w < 0x40862E42) {\n      t = exp(x);\n      return 0.5 * (t + 1 / t);\n    }\n    t = expo2(x, 1);\n    return t;\n  }\n\n  export function exp(x: f64): f64 { // see: musl/src/math/exp.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return exp_lut(x);\n    } else {\n      const\n        ln2hi     = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n        ln2lo     = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n        invln2    = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n        P1        = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n        P2        = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n        P3        = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n        P4        = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n        P5        = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n        overflow  = reinterpret<f64>(0x40862E42FEFA39EF), //  709.782712893383973096\n        underflow = reinterpret<f64>(0xC0874910D52D3051), // -745.13321910194110842\n        Ox1p1023  = reinterpret<f64>(0x7FE0000000000000); //  0x1p1023\n\n      let hx = u32(reinterpret<u64>(x) >> 32);\n      let sign = hx >> 31;\n      hx &= 0x7FFFFFFF;\n      if (hx >= 0x4086232B) {\n        if (isNaN(x)) return x;\n        if (x > overflow)  return x * Ox1p1023;\n        if (x < underflow) return 0;\n      }\n      let hi: f64, lo: f64 = 0;\n      let k = 0;\n      if (hx > 0x3FD62E42) {\n        if (hx >= 0x3FF0A2B2) {\n          k = i32(invln2 * x + builtin_copysign<f64>(0.5, x));\n        } else {\n          k = 1 - (sign << 1);\n        }\n        hi = x - k * ln2hi;\n        lo = k * ln2lo;\n        x = hi - lo;\n      } else if (hx > 0x3E300000) {\n        hi = x;\n      } else return 1.0 + x;\n      let xs = x * x;\n      // let c = x - xp2 * (P1 + xp2 * (P2 + xp2 * (P3 + xp2 * (P4 + xp2 * P5))));\n      let xq = xs * xs;\n      let c = x - (xs * P1 + xq * ((P2 + xs * P3) + xq * (P4 + xs * P5)));\n      let y = 1.0 + (x * c / (2 - c) - lo + hi);\n      return k == 0 ? y : scalbn(y, k);\n    }\n  }\n\n  export function exp2(x: f64): f64 {\n    return exp2_lut(x);\n  }\n\n  export function expm1(x: f64): f64 { // see: musl/src/math/expm1.c and SUN COPYRIGHT NOTICE above\n    const\n      o_threshold = reinterpret<f64>(0x40862E42FEFA39EF), //  7.09782712893383973096e+02\n      ln2_hi      = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n      ln2_lo      = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n      invln2      = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n      Q1          = reinterpret<f64>(0xBFA11111111110F4), // -3.33333333333331316428e-02\n      Q2          = reinterpret<f64>(0x3F5A01A019FE5585), //  1.58730158725481460165e-03\n      Q3          = reinterpret<f64>(0xBF14CE199EAADBB7), // -7.93650757867487942473e-05\n      Q4          = reinterpret<f64>(0x3ED0CFCA86E65239), //  4.00821782732936239552e-06\n      Q5          = reinterpret<f64>(0xBE8AFDB76E09C32D), // -2.01099218183624371326e-07\n      Ox1p1023    = reinterpret<f64>(0x7FE0000000000000); //  0x1p1023\n\n    let u = reinterpret<u64>(x);\n    let hx = u32(u >> 32) & 0x7FFFFFFF;\n    let sign = u32(u >> 63);\n    let k = 0;\n    if (hx >= 0x4043687A) {\n      if (isNaN(x)) return x;\n      if (sign) return -1;\n      if (x > o_threshold) return x * Ox1p1023;\n    }\n    let c = 0.0, t: f64;\n    if (hx > 0x3FD62E42) {\n      k = select<i32>(\n        1 - (sign << 1),\n        i32(invln2 * x + builtin_copysign<f64>(0.5, x)),\n        hx < 0x3FF0A2B2\n      );\n      t = <f64>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x3C900000) return x;\n    let hfx = 0.5 * x;\n    let hxs = x * hfx;\n    // let r1 = 1.0 + hxs * (Q1 + hxs * (Q2 + hxs * (Q3 + hxs * (Q4 + hxs * Q5))));\n    let hxq = hxs * hxs;\n    let r1 = (1.0 + hxs * Q1) + hxq * ((Q2 + hxs * Q3) + hxq * (Q4 + hxs * Q5));\n    t = 3.0 - r1 * hfx;\n    let e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x3FF + k) << 52;\n    let twopk = reinterpret<f64>(u);\n    let y: f64;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 1024) y = y * 2.0 * Ox1p1023;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x3FF - k) << 52;\n    y = reinterpret<f64>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function floor(x: f64): f64 {\n    return builtin_floor<f64>(x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function fround(x: f64): f64 {\n    return <f32>x;\n  }\n\n  export function hypot(x: f64, y: f64): f64 { // see: musl/src/math/hypot.c\n    const\n      SPLIT    = reinterpret<f64>(0x41A0000000000000) + 1, // 0x1p27 + 1\n      Ox1p700  = reinterpret<f64>(0x6BB0000000000000),\n      Ox1p_700 = reinterpret<f64>(0x1430000000000000);\n\n    let ux = reinterpret<u64>(x);\n    let uy = reinterpret<u64>(y);\n    ux &= 0x7FFFFFFFFFFFFFFF;\n    uy &= 0x7FFFFFFFFFFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    let ex = i32(ux >> 52);\n    let ey = i32(uy >> 52);\n    y = reinterpret<f64>(uy);\n    if (ey == 0x7FF) return y;\n    x = reinterpret<f64>(ux);\n    if (ex == 0x7FF || uy == 0) return x;\n    if (ex - ey > 64) return x + y;\n    let z = 1.0;\n    if (ex > 0x3FF + 510) {\n      z  = Ox1p700;\n      x *= Ox1p_700;\n      y *= Ox1p_700;\n    } else if (ey < 0x3FF - 450) {\n      z  = Ox1p_700;\n      x *= Ox1p700;\n      y *= Ox1p700;\n    }\n    let c = x * SPLIT;\n    let h = x - c + c;\n    let l = x - h;\n    let hx = x * x;\n    let lx = h * h - hx + (2 * h + l) * l;\n    c = y * SPLIT;\n    h = y - c + c;\n    l = y - h;\n    let hy = y * y;\n    let ly = h * h - hy + (2 * h + l) * l;\n    return z * builtin_sqrt(ly + lx + hy + hx);\n  }\n\n  export function imul(x: f64, y: f64): f64 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    return dtoi32(x) * dtoi32(y);\n  }\n\n  export function log(x: f64): f64 { // see: musl/src/math/log.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log_lut(x);\n    } else {\n      const\n        ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n        ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n        Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n        Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n        Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n        Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n        Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n        Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n        Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n        Ox1p54 = reinterpret<f64>(0x4350000000000000); // 0x1p54\n\n      let u = reinterpret<u64>(x);\n      let hx = u32(u >> 32);\n      let k = 0;\n      let sign = hx >> 31;\n      if (sign || hx < 0x00100000) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (sign) return (x - x) / 0.0;\n        k -= 54;\n        x *= Ox1p54;\n        u = reinterpret<u64>(x);\n        hx = u32(u >> 32);\n      } else if (hx >= 0x7FF00000) {\n        return x;\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\n        return 0;\n      }\n      hx += 0x3FF00000 - 0x3FE6A09E;\n      k += (<i32>hx >> 20) - 0x3FF;\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n      x = reinterpret<f64>(u);\n      let f = x - 1.0;\n      let hfsq = 0.5 * f * f;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n      let r = t2 + t1;\n      let dk = <f64>k;\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n    }\n  }\n\n  export function log10(x: f64): f64 { // see: musl/src/math/log10.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f64>(0x3FDBCB7B15200000), // 4.34294481878168880939e-01\n      ivln10lo  = reinterpret<f64>(0x3DBB9438CA9AADD5), // 2.50829467116452752298e-11\n      log10_2hi = reinterpret<f64>(0x3FD34413509F6000), // 3.01029995663611771306e-01\n      log10_2lo = reinterpret<f64>(0x3D59FEF311F12B36), // 3.69423907715893078616e-13\n      Lg1       = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2       = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3       = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4       = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5       = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6       = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7       = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n      Ox1p54    = reinterpret<f64>(0x4350000000000000); // 0x1p54\n\n    let u = reinterpret<u64>(x);\n    let hx = u32(u >> 32);\n    let k = 0;\n    let sign = hx >> 31;\n    if (sign || hx < 0x00100000) {\n      if (u << 1 == 0) return -1 / (x * x);\n      if (sign) return (x - x) / 0.0;\n      k -= 54;\n      x *= Ox1p54;\n      u = reinterpret<u64>(x);\n      hx = u32(u >> 32);\n    } else if (hx >= 0x7FF00000) {\n      return x;\n    } else if (hx == 0x3FF00000 && u << 32 == 0) {\n      return 0;\n    }\n    hx += 0x3FF00000 - 0x3FE6A09E;\n    k += i32(hx >> 20) - 0x3FF;\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n    x = reinterpret<f64>(u);\n    let f = x - 1.0;\n    let hfsq = 0.5 * f * f;\n    let s = f / (2.0 + f);\n    let z = s * s;\n    let w = z * z;\n    let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    let r = t2 + t1;\n    let hi = f - hfsq;\n    u = reinterpret<u64>(hi);\n    u &= 0xFFFFFFFF00000000;\n    hi = reinterpret<f64>(u);\n    let lo = f - hi - hfsq + s * (hfsq + r);\n    let val_hi = hi * ivln10hi;\n    let dk = <f64>k;\n    let y = dk * log10_2hi;\n    let val_lo = dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi;\n    w = y + val_hi;\n    val_lo += (y - w) + val_hi;\n    return val_lo + w;\n  }\n\n  export function log1p(x: f64): f64 { // see: musl/src/math/log1p.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n      ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n      Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244); // 1.479819860511658591e-01\n\n    let u = reinterpret<u64>(x);\n    let hx = u32(u >> 32);\n    let k = 1;\n    let c = 0.0, f = 0.0;\n    if (hx < 0x3FDA827A || bool(hx >> 31)) {\n      if (hx >= 0xBFF00000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (hx << 1 < 0x3CA00000 << 1) return x;\n      if (hx <= 0xBFD2BEC4) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (hx >= 0x7FF00000) return x;\n    if (k) {\n      u = reinterpret<u64>(1 + x);\n      let hu = u32(u >> 32);\n      hu += 0x3FF00000 - 0x3FE6A09E;\n      k = i32(hu >> 20) - 0x3FF;\n      if (k < 54) {\n        let uf = reinterpret<f64>(u);\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      hu = (hu & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hu << 32 | (u & 0xFFFFFFFF);\n      f = reinterpret<f64>(u) - 1;\n    }\n    let hfsq = 0.5 * f * f;\n    let s = f / (2.0 + f);\n    let z = s * s;\n    let w = z * z;\n    let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    let r = t2 + t1;\n    let dk = <f64>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f64): f64 { // see: musl/src/math/log2.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log2_lut(x);\n    } else {\n      const\n        ivln2hi = reinterpret<f64>(0x3FF7154765200000), // 1.44269504072144627571e+00\n        ivln2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 1.67517131648865118353e-10\n        Lg1     = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n        Lg2     = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n        Lg3     = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n        Lg4     = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n        Lg5     = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n        Lg6     = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n        Lg7     = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n        Ox1p54  = reinterpret<f64>(0x4350000000000000); // 1p54\n\n      let u = reinterpret<u64>(x);\n      let hx = u32(u >> 32);\n      let k = 0;\n      let sign = hx >> 31;\n      if (sign || hx < 0x00100000) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (sign) return (x - x) / 0.0;\n        k -= 54;\n        x *= Ox1p54;\n        u = reinterpret<u64>(x);\n        hx = u32(u >> 32);\n      } else if (hx >= 0x7FF00000) {\n        return x;\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\n        return 0;\n      }\n      hx += 0x3FF00000 - 0x3FE6A09E;\n      k += i32(hx >> 20) - 0x3FF;\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n      x = reinterpret<f64>(u);\n      let f = x - 1.0;\n      let hfsq = 0.5 * f * f;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n      let r = t2 + t1;\n      let hi = f - hfsq;\n      u = reinterpret<u64>(hi);\n      u &= 0xFFFFFFFF00000000;\n      hi = reinterpret<f64>(u);\n      let lo = f - hi - hfsq + s * (hfsq + r);\n      let val_hi = hi * ivln2hi;\n      let val_lo = (lo + hi) * ivln2lo + lo * ivln2hi;\n      let y = <f64>k;\n      w = y + val_hi;\n      val_lo += (y - w) + val_hi;\n      val_hi = w;\n      return val_lo + val_hi;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function max(value1: f64, value2: f64): f64 {\n    return builtin_max<f64>(value1, value2);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function min(value1: f64, value2: f64): f64 {\n    return builtin_min<f64>(value1, value2);\n  }\n\n  export function pow(x: f64, y: f64): f64 { // see: musl/src/math/pow.c and SUN COPYRIGHT NOTICE above\n    // TODO: remove this fast pathes after introduced own mid-end IR with \"stdlib call simplify\" transforms\n    if (builtin_abs<f64>(y) <= 2) {\n      if (y == 2.0) return x * x;\n      if (y == 0.5) {\n        return select<f64>(\n          builtin_abs<f64>(builtin_sqrt<f64>(x)),\n          Infinity,\n          x != -Infinity\n        );\n      }\n      if (y == -1.0) return 1 / x;\n      if (y == 1.0) return x;\n      if (y == 0.0) return 1.0;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      return pow_lut(x, y);\n    } else {\n      const\n        dp_h1   = reinterpret<f64>(0x3FE2B80340000000), //  5.84962487220764160156e-01\n        dp_l1   = reinterpret<f64>(0x3E4CFDEB43CFD006), //  1.35003920212974897128e-08\n        two53   = reinterpret<f64>(0x4340000000000000), //  9007199254740992.0\n        huge    = reinterpret<f64>(0x7E37E43C8800759C), //  1e+300\n        tiny    = reinterpret<f64>(0x01A56E1FC2F8F359), //  1e-300\n        L1      = reinterpret<f64>(0x3FE3333333333303), //  5.99999999999994648725e-01\n        L2      = reinterpret<f64>(0x3FDB6DB6DB6FABFF), //  4.28571428578550184252e-01\n        L3      = reinterpret<f64>(0x3FD55555518F264D), //  3.33333329818377432918e-01\n        L4      = reinterpret<f64>(0x3FD17460A91D4101), //  2.72728123808534006489e-01\n        L5      = reinterpret<f64>(0x3FCD864A93C9DB65), //  2.30660745775561754067e-01\n        L6      = reinterpret<f64>(0x3FCA7E284A454EEF), //  2.06975017800338417784e-01\n        P1      = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n        P2      = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n        P3      = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n        P4      = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n        P5      = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n        lg2     = reinterpret<f64>(0x3FE62E42FEFA39EF), //  6.93147180559945286227e-01\n        lg2_h   = reinterpret<f64>(0x3FE62E4300000000), //  6.93147182464599609375e-01\n        lg2_l   = reinterpret<f64>(0xBE205C610CA86C39), // -1.90465429995776804525e-09\n        ovt     = reinterpret<f64>(0x3C971547652B82FE), //  8.0085662595372944372e-017\n        cp      = reinterpret<f64>(0x3FEEC709DC3A03FD), //  9.61796693925975554329e-01\n        cp_h    = reinterpret<f64>(0x3FEEC709E0000000), //  9.61796700954437255859e-01\n        cp_l    = reinterpret<f64>(0xBE3E2FE0145B01F5), // -7.02846165095275826516e-09\n        ivln2   = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n        ivln2_h = reinterpret<f64>(0x3FF7154760000000), //  1.44269502162933349609e+00\n        ivln2_l = reinterpret<f64>(0x3E54AE0BF85DDF44), //  1.92596299112661746887e-08\n        inv3    = reinterpret<f64>(0x3FD5555555555555); //  0.3333333333333333333333\n\n      let u_ = reinterpret<u64>(x);\n      let hx = i32(u_ >> 32);\n      let lx = <u32>u_;\n      u_ = reinterpret<u64>(y);\n      let hy = i32(u_ >> 32);\n      let ly = <u32>u_;\n      let ix = hx & 0x7FFFFFFF;\n      let iy = hy & 0x7FFFFFFF;\n      if ((iy | ly) == 0) return 1.0; // x**0 = 1, even if x is NaN\n      // if (hx == 0x3FF00000 && lx == 0) return 1.0; // C: 1**y = 1, even if y is NaN, JS: NaN\n      if ( // NaN if either arg is NaN\n        ix > 0x7FF00000 || (ix == 0x7FF00000 && lx != 0) ||\n        iy > 0x7FF00000 || (iy == 0x7FF00000 && ly != 0)\n      ) return x + y;\n      let yisint = 0, k: i32;\n      if (hx < 0) {\n        if (iy >= 0x43400000) yisint = 2;\n        else if (iy >= 0x3FF00000) {\n          k = (iy >> 20) - 0x3FF;\n          let offset = select<u32>(52, 20, k > 20) - k;\n          let Ly = select<u32>(ly, iy, k > 20);\n          let jj = Ly >> offset;\n          if ((jj << offset) == Ly) yisint = 2 - (jj & 1);\n        }\n      }\n      if (ly == 0) {\n        if (iy == 0x7FF00000) { // y is +-inf\n          if (((ix - 0x3FF00000) | lx) == 0) return NaN; // C: (-1)**+-inf is 1, JS: NaN\n          else if (ix >= 0x3FF00000) return hy >= 0 ? y : 0.0; // (|x|>1)**+-inf = inf,0\n          else return hy >= 0 ? 0.0 : -y; // (|x|<1)**+-inf = 0,inf\n        }\n        if (iy == 0x3FF00000) {\n          if (hy >= 0) return x;\n          return 1 / x;\n        }\n        if (hy == 0x40000000) return x * x;\n        if (hy == 0x3FE00000) {\n          if (hx >= 0) return builtin_sqrt(x);\n        }\n      }\n      let ax = builtin_abs<f64>(x), z: f64;\n      if (lx == 0) {\n        if (ix == 0 || ix == 0x7FF00000 || ix == 0x3FF00000) {\n          z = ax;\n          if (hy < 0) z = 1.0 / z;\n          if (hx < 0) {\n            if (((ix - 0x3FF00000) | yisint) == 0) {\n              let d = z - z;\n              z = d / d;\n            } else if (yisint == 1) z = -z;\n          }\n          return z;\n        }\n      }\n      let s = 1.0;\n      if (hx < 0) {\n        if (yisint == 0) {\n          let d = x - x;\n          return d / d;\n        }\n        if (yisint == 1) s = -1.0;\n      }\n      let t1: f64, t2: f64, p_h: f64, p_l: f64, r: f64, t: f64, u: f64, v: f64, w: f64;\n      let j: i32, n: i32;\n      if (iy > 0x41E00000) {\n        if (iy > 0x43F00000) {\n          if (ix <= 0x3FEFFFFF) return hy < 0 ? huge * huge : tiny * tiny;\n          if (ix >= 0x3FF00000) return hy > 0 ? huge * huge : tiny * tiny;\n        }\n        if (ix < 0x3FEFFFFF) return hy < 0 ? s * huge * huge : s * tiny * tiny;\n        if (ix > 0x3FF00000) return hy > 0 ? s * huge * huge : s * tiny * tiny;\n        t = ax - 1.0;\n        w = (t * t) * (0.5 - t * (inv3 - t * 0.25));\n        u = ivln2_h * t;\n        v = t * ivln2_l - w * ivln2;\n        t1 = u + v;\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n        t2 = v - (t1 - u);\n      } else {\n        let ss: f64, s2: f64, s_h: f64, s_l: f64, t_h: f64, t_l: f64;\n        n = 0;\n        if (ix < 0x00100000) {\n          ax *= two53;\n          n -= 53;\n          ix = <u32>(reinterpret<u64>(ax) >> 32);\n        }\n        n += (ix >> 20) - 0x3FF;\n        j = ix & 0x000FFFFF;\n        ix = j | 0x3FF00000;\n        if (j <= 0x3988E) k = 0;\n        else if (j < 0xBB67A) k = 1;\n        else {\n          k = 0;\n          n += 1;\n          ix -= 0x00100000;\n        }\n        ax = reinterpret<f64>(reinterpret<u64>(ax) & 0xFFFFFFFF | (<u64>ix << 32));\n        let bp = select<f64>(1.5, 1.0, k); // k ? 1.5 : 1.0\n        u = ax - bp;\n        v = 1.0 / (ax + bp);\n        ss = u * v;\n        s_h = ss;\n        s_h = reinterpret<f64>(reinterpret<u64>(s_h) & 0xFFFFFFFF00000000);\n        t_h = reinterpret<f64>(u64(((ix >> 1) | 0x20000000) + 0x00080000 + (k << 18)) << 32);\n        t_l = ax - (t_h - bp);\n        s_l = v * ((u - s_h * t_h) - s_h * t_l);\n        s2 = ss * ss;\n        r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));\n        r += s_l * (s_h + ss);\n        s2 = s_h * s_h;\n        t_h = 3.0 + s2 + r;\n        t_h = reinterpret<f64>(reinterpret<u64>(t_h) & 0xFFFFFFFF00000000);\n        t_l = r - ((t_h - 3.0) - s2);\n        u = s_h * t_h;\n        v = s_l * t_h + t_l * ss;\n        p_h = u + v;\n        p_h = reinterpret<f64>(reinterpret<u64>(p_h) & 0xFFFFFFFF00000000);\n        p_l = v - (p_h - u);\n        let z_h = cp_h * p_h;\n        let dp_l = select<f64>(dp_l1, 0.0, k);\n        let z_l = cp_l * p_h + p_l * cp + dp_l;\n        t = <f64>n;\n        let dp_h = select<f64>(dp_h1, 0.0, k);\n        t1 = ((z_h + z_l) + dp_h) + t;\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n        t2 = z_l - (((t1 - t) - dp_h) - z_h);\n      }\n      let y1 = y;\n      y1 = reinterpret<f64>(reinterpret<u64>(y1) & 0xFFFFFFFF00000000);\n      p_l = (y - y1) * t1 + y * t2;\n      p_h = y1 * t1;\n      z = p_l + p_h;\n      u_ = reinterpret<u64>(z);\n      j = u32(u_ >> 32);\n      let i = <i32>u_;\n      if (j >= 0x40900000) {\n        if (((j - 0x40900000) | i) != 0) return s * huge * huge;\n        if (p_l + ovt > z - p_h) return s * huge * huge;\n      } else if ((j & 0x7FFFFFFF) >= 0x4090CC00) {\n        if (((j - 0xC090CC00) | i) != 0) return s * tiny * tiny;\n        if (p_l <= z - p_h) return s * tiny * tiny;\n      }\n      i = j & 0x7FFFFFFF;\n      k = (i >> 20) - 0x3FF;\n      n = 0;\n      if (i > 0x3FE00000) {\n        n = j + (0x00100000 >> (k + 1));\n        k = ((n & 0x7FFFFFFF) >> 20) - 0x3FF;\n        t = 0.0;\n        t = reinterpret<f64>(u64(n & ~(0x000FFFFF >> k)) << 32);\n        n = ((n & 0x000FFFFF) | 0x00100000) >> (20 - k);\n        if (j < 0) n = -n;\n        p_h -= t;\n      }\n      t = p_l + p_h;\n      t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\n      u = t * lg2_h;\n      v = (p_l - (t - p_h)) * lg2 + t * lg2_l;\n      z = u + v;\n      w = v - (z - u);\n      t = z * z;\n      t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\n      r = (z * t1) / (t1 - 2.0) - (w + z * w);\n      z = 1.0 - (r - z);\n      j = u32(reinterpret<u64>(z) >> 32);\n      j += n << 20;\n      if ((j >> 20) <= 0) z = scalbn(z, n);\n      else z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF | (<u64>j << 32));\n      return s * z;\n    }\n  }\n\n  export function seedRandom(value: i64): void {\n    // Instead zero seed use golden ratio:\n    // phi = (1 + sqrt(5)) / 2\n    // trunc(2^64 / phi) = 0x9e3779b97f4a7c15\n    if (value == 0) value = 0x9e3779b97f4a7c15;\n    random_state0_64 = murmurHash3(value);\n    random_state1_64 = murmurHash3(~random_state0_64);\n    random_state0_32 = splitMix32(<u32>value);\n    random_state1_32 = splitMix32(random_state0_32);\n    random_seeded = true;\n  }\n\n  export function random(): f64 { // see: v8/src/base/utils/random-number-generator.cc\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\n    let s1 = random_state0_64;\n    let s0 = random_state1_64;\n    random_state0_64 = s0;\n    s1 ^= s1 << 23;\n    s1 ^= s1 >> 17;\n    s1 ^= s0;\n    s1 ^= s0 >> 26;\n    random_state1_64 = s1;\n    let r = (s0 >> 12) | 0x3FF0000000000000;\n    return reinterpret<f64>(r) - 1;\n  }\n\n  export function round(x: f64): f64 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_ceil<f64>(x) - f64(builtin_ceil<f64>(x) - 0.5 > x);\n    } else {\n      let roundUp = builtin_ceil<f64>(x);\n      return select<f64>(roundUp, roundUp - 1.0, roundUp - 0.5 <= x);\n    }\n  }\n\n  export function sign(x: f64): f64 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return select<f64>(builtin_copysign<f64>(1, x), x, builtin_abs(x) > 0);\n    } else {\n      return select<f64>(1, select<f64>(-1, x, x < 0), x > 0);\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function signbit(x: f64): bool {\n    return bool(reinterpret<u64>(x) >>> 63);\n  }\n\n  export function sin(x: f64): f64 { // see: musl/src/math/sin.c\n    let u  = reinterpret<u64>(x);\n    let ux = u32(u >> 32);\n    let sign = ux >> 31;\n\n    ux &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ux <= 0x3FE921FB) {\n      if (ux < 0x3E500000) { // |x| < 2**-26\n        return x;\n      }\n      return sin_kern(x, 0.0, 0);\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7FF00000) return x - x;\n\n    // argument reduction needed\n    let n  = rempio2(x, u, sign);\n    let y0 = rempio2_y0;\n    let y1 = rempio2_y1;\n\n    x = n & 1 ? cos_kern(y0, y1) : sin_kern(y0, y1, 1);\n    return n & 2 ? -x : x;\n  }\n\n  export function sinh(x: f64): f64 { // see: musl/src/math/sinh.c\n    let u = reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF;\n    let a = reinterpret<f64>(u);\n    let w = u32(u >> 32);\n    let h = builtin_copysign(0.5, x);\n    if (w < 0x40862E42) {\n      let t = expm1(a);\n      if (w < 0x3FF00000) {\n        if (w < 0x3FF00000 - (26 << 20)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    return expo2(a, 2 * h);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sqrt(x: f64): f64 {\n    return builtin_sqrt<f64>(x);\n  }\n\n  export function tan(x: f64): f64 { // see: musl/src/math/tan.c\n    let u = reinterpret<u64>(x);\n    let ux = u32(u >> 32);\n    let sign = ux >>> 31;\n\n    ux &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ux <= 0x3FE921FB) {\n      if (ux < 0x3E400000) { // |x| < 2**-27\n        return x;\n      }\n      return tan_kern(x, 0.0, 1);\n    }\n\n    // tan(Inf or NaN) is NaN\n    if (ux >= 0x7FF00000) return x - x;\n\n    let n = rempio2(x, u, sign);\n    return tan_kern(rempio2_y0, rempio2_y1, 1 - ((n & 1) << 1));\n  }\n\n  export function tanh(x: f64): f64 { // see: musl/src/math/tanh.c\n    let u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    let y = reinterpret<f64>(u);\n    let w = u32(u >> 32);\n    let t: f64;\n    if (w > 0x3FE193EA) {\n      if (w > 0x40340000) {\n        t = 1 - 0 / y;\n      } else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (w > 0x3FD058AE) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (w >= 0x00100000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f64>(t, x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function trunc(x: f64): f64 {\n    return builtin_trunc<f64>(x);\n  }\n\n  export function scalbn(x: f64, n: i32): f64 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbn.c\n    const\n      Ox1p53    = reinterpret<f64>(0x4340000000000000),\n      Ox1p1023  = reinterpret<f64>(0x7FE0000000000000),\n      Ox1p_1022 = reinterpret<f64>(0x0010000000000000);\n\n    let y = x;\n    if (n > 1023) {\n      y *= Ox1p1023;\n      n -= 1023;\n      if (n > 1023) {\n        y *= Ox1p1023;\n        n = builtin_min<i32>(n - 1023, 1023);\n      }\n    } else if (n < -1022) {\n      // make sure final n < -53 to avoid double\n      // rounding in the subnormal range\n      y *= Ox1p_1022 * Ox1p53;\n      n += 1022 - 53;\n      if (n < -1022) {\n        y *= Ox1p_1022 * Ox1p53;\n        n = builtin_max<i32>(n + 1022 - 53, -1022);\n      }\n    }\n    return y * reinterpret<f64>(<u64>(0x3FF + n) << 52);\n  }\n\n  export function mod(x: f64, y: f64): f64 { // see: musl/src/math/fmod.c\n    if (builtin_abs<f64>(y) == 1.0) {\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\n      // TODO: move this rule to compiler's optimization pass.\n      // It could be apply for any x % C_pot, where \"C_pot\" is pow of two const.\n      return builtin_copysign<f64>(x - builtin_trunc<f64>(x), x);\n    }\n    let ux = reinterpret<u64>(x);\n    let uy = reinterpret<u64>(y);\n    let ex = i64(ux >> 52 & 0x7FF);\n    let ey = i64(uy >> 52 & 0x7FF);\n    let sx = ux >> 63;\n    let uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0x7FF || isNaN<f64>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    let ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      return x * f64(ux1 != uy1);\n    }\n    if (!ex) {\n      ex -= builtin_clz<i64>(ux << 12);\n      ux <<= 1 - ex;\n    } else {\n      ux &= u64(-1) >> 12;\n      ux |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= 1 - ey;\n    } else {\n      uy &= u64(-1) >> 12;\n      uy |= 1 << 52;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 52); ux <<= 1) --ex;\n    let shift = builtin_clz<i64>(ux << 11);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 52;\n      ux |= ex << 52;\n    } else {\n      ux >>= -ex + 1;\n    }\n    return reinterpret<f64>(ux | (sx << 63));\n  }\n\n  export function rem(x: f64, y: f64): f64 { // see: musl/src/math/remquo.c\n    let ux = reinterpret<u64>(x);\n    let uy = reinterpret<u64>(y);\n    let ex = i64(ux >> 52 & 0x7FF);\n    let ey = i64(uy >> 52 & 0x7FF);\n    if (uy << 1 == 0 || ex == 0x7FF || isNaN(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    if (ux << 1 == 0) return x;\n    let uxi = ux;\n    if (!ex) {\n      ex -= builtin_clz<i64>(uxi << 12);\n      uxi <<= 1 - ex;\n    } else {\n      uxi &= u64(-1) >> 12;\n      uxi |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= 1 - ey;\n    } else {\n      uy &= u64(-1) >> 12;\n      uy |= 1 << 52;\n    }\n    let q: u32 = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -60;\n      else {\n        let shift = builtin_clz<i64>(uxi << 11);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n    // end:\n    if (ex > 0) {\n      uxi -= 1 << 52;\n      uxi |= ex << 52;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f64>(uxi);\n    y = builtin_abs<f64>(y);\n    let x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (x2 > y || (x2 == y && <bool>(q & 1))))) {\n      x -= y;\n      // ++q;\n    }\n    return <i64>ux < 0 ? -x : x;\n  }\n\n  export function sincos(x: f64): void { // see: musl/tree/src/math/sincos.c\n    let u = reinterpret<u64>(x);\n    let ux = u32(u >> 32);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3FE921FB) {  // |x| ~<= /4\n      if (ux < 0x3E46A09E) { // if |x| < 2**-27 * sqrt(2)\n        sincos_sin = x;\n        sincos_cos = 1;\n        return;\n      }\n      sincos_sin = sin_kern(x, 0, 0);\n      sincos_cos = cos_kern(x, 0);\n      return;\n    }\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) {\n      let xx = x - x;\n      sincos_sin = xx;\n      sincos_cos = xx;\n      return;\n    }\n    // general argument reduction needed\n    let n = rempio2(x, u, sign);\n    let y0 = rempio2_y0;\n    let y1 = rempio2_y1;\n    let s = sin_kern(y0, y1, 1);\n    let c = cos_kern(y0, y1);\n    let sin = s, cos = c;\n    if (n & 1) {\n      sin =  c;\n      cos = -s;\n    }\n    if (n & 2) {\n      sin = -sin;\n      cos = -cos;\n    }\n    sincos_sin = sin;\n    sincos_cos = cos;\n  }\n}\n\n// @ts-ignore: decorator\n@lazy let rempio2f_y: f64;\n\n// @ts-ignore: decorator\n@lazy @inline const PIO2F_TABLE = memory.data<u64>([\n  0xA2F9836E4E441529,\n  0xFC2757D1F534DDC0,\n  0xDB6295993C439041,\n  0xFE5163ABDEBBC561\n]);\n\nfunction Rf(z: f32): f32 { // Rational approximation of (asin(x)-x)/x^3\n  const                    // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f32>(0x3E2AAA75), //  1.6666586697e-01f\n    pS1 = reinterpret<f32>(0xBD2F13BA), // -4.2743422091e-02f\n    pS2 = reinterpret<f32>(0xBC0DD36B), // -8.6563630030e-03f\n    qS1 = reinterpret<f32>(0xBF34E5AE); // -7.0662963390e-01f\n\n  let p = z * (pS0 + z * (pS1 + z * pS2));\n  let q: f32 = 1 + z * qS1;\n  return p / q;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction expo2f(x: f32, sign: f32): f32 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                                // see: musl/src/math/__expo2f.c\n    k    = <u32>235,\n    kln2 = reinterpret<f32>(0x4322E3BC); // 0x1.45c778p+7f\n  let scale = reinterpret<f32>(u32(0x7F + (k >> 1)) << 23);\n  // in directed rounding correct sign before rounding or overflow is important\n  return NativeMathf.exp(x - kln2) * (sign * scale) * scale;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pio2f_large_quot(x: f32, u: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const coeff = reinterpret<f64>(0x3BF921FB54442D18); //  * 0x1p-65 = 8.51530395021638647334e-20\n\n  let offset = (u >> 23) - 152;\n  let shift  = u64(offset & 63);\n  let tblPtr = PIO2F_TABLE + (offset >> 6 << 3);\n\n  let b0 = load<u64>(tblPtr, 0 << 3);\n  let b1 = load<u64>(tblPtr, 1 << 3);\n  let lo: u64;\n\n  if (shift > 32) {\n    let b2 = load<u64>(tblPtr, 2 << 3);\n    lo  = b2 >> (96 - shift);\n    lo |= b1 << (shift - 32);\n  } else {\n    lo = b1 >> (32 - shift);\n  }\n\n  let hi = (b1 >> (64 - shift)) | (b0 << shift);\n  let mantissa: u64 = (u & 0x007FFFFF) | 0x00800000;\n  let product = mantissa * hi + (mantissa * lo >> 32);\n  let r: i64 = product << 2;\n  let q = i32((product >> 62) + (r >>> 63));\n  rempio2f_y = copysign<f64>(coeff, x) * <f64>r;\n  return q;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction rempio2f(x: f32, u: u32, sign: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const\n    pi2hi = reinterpret<f64>(0x3FF921FB50000000), // 1.57079631090164184570\n    pi2lo = reinterpret<f64>(0x3E5110B4611A6263), // 1.58932547735281966916e-8\n    _2_pi = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\n\n  if (u < 0x4DC90FDB) { //  * 0x1p28\n    let q = nearest(x * _2_pi);\n    rempio2f_y = x - q * pi2hi - q * pi2lo;\n    return <i32>q;\n  }\n\n  let q = pio2f_large_quot(x, u);\n  return select(-q, q, sign);\n}\n\n// |sin(x)/x - s(x)| < 2**-37.5 (~[-4.89e-12, 4.824e-12]).\n// @ts-ignore: decorator\n@inline\nfunction sin_kernf(x: f64): f32 { // see: musl/tree/src/math/__sindf.c\n  const\n    S1 = reinterpret<f64>(0xBFC5555554CBAC77), // -0x15555554cbac77.0p-55\n    S2 = reinterpret<f64>(0x3F811110896EFBB2), //  0x111110896efbb2.0p-59\n    S3 = reinterpret<f64>(0xBF2A00F9E2CAE774), // -0x1a00f9e2cae774.0p-65\n    S4 = reinterpret<f64>(0x3EC6CD878C3B46A7); //  0x16cd878c3b46a7.0p-71\n\n  let z = x * x;\n  let w = z * z;\n  let r = S3 + z * S4;\n  let s = z * x;\n  return f32((x + s * (S1 + z * S2)) + s * w * r);\n}\n\n// |cos(x) - c(x)| < 2**-34.1 (~[-5.37e-11, 5.295e-11]).\n// @ts-ignore: decorator\n@inline\nfunction cos_kernf(x: f64): f32 { // see: musl/tree/src/math/__cosdf.c\n  const\n    C0 = reinterpret<f64>(0xBFDFFFFFFD0C5E81), // -0x1ffffffd0c5e81.0p-54\n    C1 = reinterpret<f64>(0x3FA55553E1053A42), //  0x155553e1053a42.0p-57\n    C2 = reinterpret<f64>(0xBF56C087E80F1E27), // -0x16c087e80f1e27.0p-62\n    C3 = reinterpret<f64>(0x3EF99342E0EE5069); //  0x199342e0ee5069.0p-68\n\n  let z = x * x;\n  let w = z * z;\n  let r = C2 + z * C3;\n  return f32(((1 + z * C0) + w * C1) + (w * z) * r);\n}\n\n// |tan(x)/x - t(x)| < 2**-25.5 (~[-2e-08, 2e-08]).\n// @ts-ignore: decorator\n@inline\nfunction tan_kernf(x: f64, odd: i32): f32 { // see: musl/tree/src/math/__tandf.c\n  const\n    T0 = reinterpret<f64>(0x3FD5554D3418C99F), // 0x15554d3418c99f.0p-54\n    T1 = reinterpret<f64>(0x3FC112FD38999F72), // 0x1112fd38999f72.0p-55\n    T2 = reinterpret<f64>(0x3FAB54C91D865AFE), // 0x1b54c91d865afe.0p-57\n    T3 = reinterpret<f64>(0x3F991DF3908C33CE), // 0x191df3908c33ce.0p-58\n    T4 = reinterpret<f64>(0x3F685DADFCECF44E), // 0x185dadfcecf44e.0p-61\n    T5 = reinterpret<f64>(0x3F8362B9BF971BCD); // 0x1362b9bf971bcd.0p-59\n\n  let z = x * x;\n  let r = T4 + z * T5;\n  let t = T2 + z * T3;\n  let w = z * z;\n  let s = z * x;\n  let u = T0 + z * T1;\n\n  r = (x + s * u) + (s * w) * (t + w * r);\n  return f32(odd ? -1 / r : r);\n}\n\n// See: jdh8/metallic/src/math/float/log2f.c and jdh8/metallic/src/math/float/kernel/atanh.h\n// @ts-ignore: decorator\n@inline\nfunction log2f(x: f64): f64 {\n  const\n    log2e = reinterpret<f64>(0x3FF71547652B82FE), // 1.44269504088896340736\n    c0 = reinterpret<f64>(0x3FD555554FD9CAEF),    // 0.33333332822728226129\n    c1 = reinterpret<f64>(0x3FC999A7A8AF4132),    // 0.20000167595436263505\n    c2 = reinterpret<f64>(0x3FC2438D79437030),    // 0.14268654271188685375\n    c3 = reinterpret<f64>(0x3FBE2F663B001C97);    // 0.11791075649681414150\n\n  let i = reinterpret<i64>(x);\n  let exponent = (i - 0x3FE6A09E667F3BCD) >> 52;\n  x = reinterpret<f64>(i - (exponent << 52));\n  x = (x - 1) / (x + 1);\n  let xx = x * x;\n  let y = x + x * xx * (c0 + c1 * xx + (c2 + c3 * xx) * (xx * xx));\n  return (2 * log2e) * y + <f64>exponent;\n}\n\n// See: jdh8/metallic/src/math/float/exp2f.h and jdh8/metallic/blob/master/src/math/float/kernel/exp2f.h\n// @ts-ignore: decorator\n@inline\nfunction exp2f(x: f64): f64 {\n  const\n    c0 = reinterpret<f64>(0x3FE62E4302FCC24A), // 6.931471880289532425e-1\n    c1 = reinterpret<f64>(0x3FCEBFBE07D97B91), // 2.402265108421173406e-1\n    c2 = reinterpret<f64>(0x3FAC6AF6CCFC1A65), // 5.550357105498874537e-2\n    c3 = reinterpret<f64>(0x3F83B29E3CE9AEF6), // 9.618030771171497658e-3\n    c4 = reinterpret<f64>(0x3F55F0896145A89F), // 1.339086685300950937e-3\n    c5 = reinterpret<f64>(0x3F2446C81E384864); // 1.546973499989028719e-4\n\n  if (x < -1022) return 0;\n  if (x >= 1024) return Infinity;\n\n  let n = nearest(x);\n  x -= n;\n  let xx = x * x;\n  let y = 1 + x * (c0 + c1 * x + (c2 + c3 * x) * xx + (c4 + c5 * x) * (xx * xx));\n  return reinterpret<f64>(reinterpret<i64>(y) + (<i64>n << 52));\n}\n\nexport namespace NativeMathf {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const E       = <f32>NativeMath.E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN2     = <f32>NativeMath.LN2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN10    = <f32>NativeMath.LN10;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG2E   = <f32>NativeMath.LOG2E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG10E  = <f32>NativeMath.LOG10E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const PI      = <f32>NativeMath.PI;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT1_2 = <f32>NativeMath.SQRT1_2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT2   = <f32>NativeMath.SQRT2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export let sincos_sin: f32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export let sincos_cos: f32 = 0;\n\n  // @ts-ignore: decorator\n  @inline\n  export function abs(x: f32): f32 {\n    return builtin_abs<f32>(x);\n  }\n\n  export function acos(x: f32): f32 { // see: musl/src/math/acosf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f32>(0x3FC90FDA), // 1.5707962513e+00f\n      pio2_lo   = reinterpret<f32>(0x33A22168), // 7.5497894159e-08f\n      Ox1p_120f = reinterpret<f32>(0x03800000); // 0x1p-120f\n\n    let hx = reinterpret<u32>(x);\n    let ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3F800000) {\n      if (ix == 0x3F800000) {\n        return select<f32>(2 * pio2_hi + Ox1p_120f, 0, <i32>hx < 0);\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3F000000) {\n      if (ix <= 0x32800000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * Rf(x * x)));\n    }\n    let z: f32, w: f32, s: f32;\n    if (<i32>hx < 0) {\n      // z = (1 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f32>(z);\n      w = Rf(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f32>(z);\n    hx = reinterpret<u32>(s);\n    let df = reinterpret<f32>(hx & 0xFFFFF000);\n    let c = (z - df * df) / (s + df);\n    w = Rf(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f32): f32 { // see: musl/src/math/acoshf.c\n    const s = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    let u = reinterpret<u32>(x);\n    let a = u & 0x7FFFFFFF;\n    if (a < 0x3F800000 + (1 << 23)) { // |x| < 2, invalid if x < 1\n      let xm1 = x - 1;\n      return log1p(xm1 + builtin_sqrt(xm1 * (xm1 + 2)));\n    }\n    if (u < 0x3F800000 + (12 << 23)) { // 2 <= x < 0x1p12\n      return log(2 * x - 1 / (x + builtin_sqrt<f32>(x * x - 1)));\n    }\n    // x >= 0x1p12 or x <= -2 or NaN\n    return log(x) + s;\n  }\n\n  export function asin(x: f32): f32 { // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2      = reinterpret<f32>(0x3FC90FDB), // 1.570796326794896558e+00f\n      Ox1p_120f = reinterpret<f32>(0x03800000); // 0x1p-120f\n\n    let sx = x;\n    let hx = reinterpret<u32>(x) & 0x7FFFFFFF;\n    if (hx >= 0x3F800000) {\n      if (hx == 0x3F800000) return x * pio2 + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (hx < 0x3F000000) {\n      if (hx < 0x39800000 && hx >= 0x00800000) return x;\n      return x + x * Rf(x * x);\n    }\n    // let z: f32 = (1 - builtin_abs<f32>(x)) * 0.5;\n    let z: f32 = 0.5 - builtin_abs<f32>(x) * 0.5;\n    let s = builtin_sqrt<f64>(z); // sic\n    x = f32(pio2 - 2 * (s + s * Rf(z)));\n    return builtin_copysign(x, sx);\n  }\n\n  export function asinh(x: f32): f32 { // see: musl/src/math/asinhf.c\n    const c = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    let u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    let y = reinterpret<f32>(u);\n    if (u >= 0x3F800000 + (12 << 23)) y = log(y) + c;\n    else if (u >= 0x3F800000 + (1 << 23))  y =   log(2 * y + 1 / (builtin_sqrt<f32>(y * y + 1) + y));\n    else if (u >= 0x3F800000 - (12 << 23)) y = log1p(y + y * y / (builtin_sqrt<f32>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f32): f32 { // see: musl/src/math/atanf.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f32>(0x3EED6338), //  4.6364760399e-01f\n      atanhi1   = reinterpret<f32>(0x3F490FDA), //  7.8539812565e-01f\n      atanhi2   = reinterpret<f32>(0x3F7B985E), //  9.8279368877e-01f\n      atanhi3   = reinterpret<f32>(0x3FC90FDA), //  1.5707962513e+00f\n      atanlo0   = reinterpret<f32>(0x31AC3769), //  5.0121582440e-09f\n      atanlo1   = reinterpret<f32>(0x33222168), //  3.7748947079e-08f\n      atanlo2   = reinterpret<f32>(0x33140FB4), //  3.4473217170e-08f\n      atanlo3   = reinterpret<f32>(0x33A22168), //  7.5497894159e-08f\n      aT0       = reinterpret<f32>(0x3EAAAAA9), //  3.3333328366e-01f\n      aT1       = reinterpret<f32>(0xBE4CCA98), // -1.9999158382e-01f\n      aT2       = reinterpret<f32>(0x3E11F50D), //  1.4253635705e-01f\n      aT3       = reinterpret<f32>(0xBDDA1247), // -1.0648017377e-01f\n      aT4       = reinterpret<f32>(0x3D7CAC25), //  6.1687607318e-02f\n      Ox1p_120f = reinterpret<f32>(0x03800000); //  0x1p-120f\n\n    let ix = reinterpret<u32>(x);\n    let sx = x;\n    ix &= 0x7FFFFFFF;\n    let z: f32;\n    if (ix >= 0x4C800000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign(z, sx);\n    }\n    let id: i32;\n    if (ix < 0x3EE00000) {\n      if (ix < 0x39800000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f32>(x);\n      if (ix < 0x3F980000) {\n        if (ix < 0x3F300000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x401C0000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    let w = z * z;\n    let s1 = z * (aT0 + w * (aT2 + w * aT4));\n    let s2 = w * (aT1 + w * aT3);\n    let s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign(z, sx);\n  }\n\n  export function atanh(x: f32): f32 { // see: musl/src/math/atanhf.c\n    let u = reinterpret<u32>(x);\n    let y = builtin_abs(x);\n    if (u < 0x3F800000 - (1 << 23)) {\n      if (u >= 0x3F800000 - (32 << 23)) y = 0.5 * log1p(2 * y * (1.0 + y / (1 - y)));\n    } else y = 0.5 * log1p(2 * (y / (1 - y)));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan2(y: f32, x: f32): f32 { // see: musl/src/math/atan2f.c and SUN COPYRIGHT NOTICE above\n    const\n      pi    = reinterpret<f32>(0x40490FDB), //  3.1415927410e+00f\n      pi_lo = reinterpret<f32>(0xB3BBBD2E); // -8.7422776573e-08f\n\n    if (isNaN(x) || isNaN(y)) return x + y;\n    let ix = reinterpret<u32>(x);\n    let iy = reinterpret<u32>(y);\n    if (ix == 0x3F800000) return atan(y);\n    let m = u32(((iy >> 31) & 1) | ((ix >> 30) & 2));\n    ix &= 0x7FFFFFFF;\n    iy &= 0x7FFFFFFF;\n    if (iy == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  pi;\n        case 3: return -pi;\n      }\n    }\n    if (ix == 0) return m & 1 ? -pi / 2 : pi / 2;\n    if (ix == 0x7F800000) {\n      if (iy == 0x7F800000) {\n        let t: f32 = m & 2 ? 3 * pi / 4 : pi / 4;\n        return m & 1 ? -t : t;\n      } else {\n        let t: f32 = m & 2 ? pi : 0.0;\n        return m & 1 ? -t : t;\n      }\n    }\n    if (ix + (26 << 23) < iy || iy == 0x7F800000) return m & 1 ? -pi / 2 : pi / 2;\n    let z: f32;\n    if ((m & 2) && iy + (26 << 23) < ix) z = 0.0;\n    else z = atan(builtin_abs<f32>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return pi - (z - pi_lo);\n      case 3: return (z - pi_lo) - pi;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f32): f32 { // see: musl/src/math/cbrtf.c and SUN COPYRIGHT NOTICE above\n    const\n      B1      = <u32>709958130,\n      B2      = <u32>642849266,\n      Ox1p24f = reinterpret<f32>(0x4B800000);\n\n    let u = reinterpret<u32>(x);\n    let hx = u & 0x7FFFFFFF;\n    if (hx >= 0x7F800000) return x + x;\n    if (hx < 0x00800000) {\n      if (hx == 0) return x;\n      u = reinterpret<u32>(x * Ox1p24f);\n      hx = u & 0x7FFFFFFF;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 0x80000000;\n    u |= hx;\n    let t = <f64>reinterpret<f32>(u);\n    let r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    return <f32>t;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function ceil(x: f32): f32 {\n    return builtin_ceil<f32>(x);\n  }\n\n  export function clz32(x: f32): f32 {\n    if (!isFinite(x)) return 32;\n    return <f32>builtin_clz(dtoi32(x));\n  }\n\n  export function cos(x: f32): f32 { // see: musl/src/math/cosf.c\n    const\n      c1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // M_PI_2 * 1\n      c2pio2 = reinterpret<f64>(0x400921FB54442D18), // M_PI_2 * 2\n      c3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // M_PI_2 * 3\n      c4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    let ux = reinterpret<u32>(x);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3F490FDA) {  // |x| ~<= /4\n      if (ux < 0x39800000) { // |x| < 2**-12\n        // raise inexact if x != 0\n        return 1;\n      }\n      return cos_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ux <= 0x407B53D1) {  // |x| ~<= 5/4\n        if (ux > 0x4016CBE3) { // |x|  ~> 3/4\n          return -cos_kernf(sign ? x + c2pio2 : x - c2pio2);\n        } else {\n          return sign ? sin_kernf(x + c1pio2) : sin_kernf(c1pio2 - x);\n        }\n      }\n      if (ux <= 0x40E231D5) {  // |x| ~<= 9/4\n        if (ux > 0x40AFEDDF) { // |x|  ~> 7/4\n          return cos_kernf(sign ? x + c4pio2 : x - c4pio2);\n        } else {\n          return sign ? sin_kernf(-x - c3pio2) : sin_kernf(x - c3pio2);\n        }\n      }\n    }\n\n    // cos(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) return x - x;\n\n    // general argument reduction needed\n    let n = rempio2f(x, ux, sign);\n    let y = rempio2f_y;\n\n    let t = n & 1 ? sin_kernf(y) : cos_kernf(y);\n    return (n + 1) & 2 ? -t : t;\n  }\n\n  export function cosh(x: f32): f32 { // see: musl/src/math/coshf.c\n    let u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    x = reinterpret<f32>(u);\n    if (u < 0x3F317217) {\n      if (u < 0x3F800000 - (12 << 23)) return 1;\n      let t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (u < 0x42B17217) {\n      let t = exp(x);\n      // return 0.5 * (t + 1 / t);\n      return 0.5 * t + 0.5 / t;\n    }\n    return expo2f(x, 1);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function floor(x: f32): f32 {\n    return builtin_floor<f32>(x);\n  }\n\n  export function exp(x: f32): f32 { // see: musl/src/math/expf.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return expf_lut(x);\n    } else {\n      const\n        ln2hi    = reinterpret<f32>(0x3F317200), //  6.9314575195e-1f\n        ln2lo    = reinterpret<f32>(0x35BFBE8E), //  1.4286067653e-6f\n        invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+0f\n        P1       = reinterpret<f32>(0x3E2AAA8F), //  1.6666625440e-1f\n        P2       = reinterpret<f32>(0xBB355215), // -2.7667332906e-3f\n        Ox1p127f = reinterpret<f32>(0x7F000000); //  0x1p+127f\n\n      let hx = reinterpret<u32>(x);\n      let sign = hx >> 31;\n      hx &= 0x7FFFFFFF;\n      if (hx >= 0x42AEAC50) {\n        if (hx > 0x7F800000) return x; // NaN\n        if (hx >= 0x42B17218) {\n          if (!sign) return x * Ox1p127f;\n          else if (hx >= 0x42CFF1B5) return 0;\n        }\n      }\n      let hi: f32, lo: f32;\n      let k: i32;\n      if (hx > 0x3EB17218) {\n        if (hx > 0x3F851592) {\n          k = i32(invln2 * x + builtin_copysign<f32>(0.5, x));\n        } else {\n          k = 1 - (sign << 1);\n        }\n        hi = x - <f32>k * ln2hi;\n        lo = <f32>k * ln2lo;\n        x = hi - lo;\n      } else if (hx > 0x39000000) {\n        k = 0;\n        hi = x;\n        lo = 0;\n      } else {\n        return 1 + x;\n      }\n      let xx = x * x;\n      let c = x - xx * (P1 + xx * P2);\n      let y: f32 = 1 + (x * c / (2 - c) - lo + hi);\n      return k == 0 ? y : scalbn(y, k);\n    }\n  }\n\n  export function exp2(x: f32): f32 {\n    return exp2f_lut(x);\n  }\n\n  export function expm1(x: f32): f32 { // see: musl/src/math/expm1f.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi   = reinterpret<f32>(0x3F317180), //  6.9313812256e-01f\n      ln2_lo   = reinterpret<f32>(0x3717F7D1), //  9.0580006145e-06f\n      invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+00f\n      Q1       = reinterpret<f32>(0xBD088868), // -3.3333212137e-02f\n      Q2       = reinterpret<f32>(0x3ACF3010), //  1.5807170421e-03f\n      Ox1p127f = reinterpret<f32>(0x7F000000); //  0x1p+127f\n\n    let u = reinterpret<u32>(x);\n    let hx = u & 0x7FFFFFFF;\n    let sign = u >> 31;\n    if (hx >= 0x4195B844) {\n      if (hx > 0x7F800000) return x;\n      if (sign) return -1;\n      if (hx > 0x42B17217) { // x > log(FLT_MAX)\n        x *= Ox1p127f;\n        return x;\n      }\n    }\n    let c: f32 = 0.0, t: f32, k: i32;\n    if (hx > 0x3EB17218) {\n      k = select<i32>(\n        1 - (sign << 1),\n        i32(invln2 * x + builtin_copysign<f32>(0.5, x)),\n        hx < 0x3F851592\n      );\n      t = <f32>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x33000000) {\n      return x;\n    } else k = 0;\n    let hfx: f32 = 0.5 * x;\n    let hxs: f32 = x * hfx;\n    let r1: f32 = 1.0 + hxs * (Q1 + hxs * Q2);\n    t  = 3.0 - r1 * hfx;\n    let e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e  = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x7F + k) << 23;\n    let twopk = reinterpret<f32>(u);\n    let y: f32;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 128) y = y * 2.0 * Ox1p127f;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x7F - k) << 23;\n    y = reinterpret<f32>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function fround(x: f32): f32 {\n    return x;\n  }\n\n  export function hypot(x: f32, y: f32): f32 { // see: musl/src/math/hypotf.c\n    const\n      Ox1p90f  = reinterpret<f32>(0x6C800000),\n      Ox1p_90f = reinterpret<f32>(0x12800000);\n\n    let ux = reinterpret<u32>(x);\n    let uy = reinterpret<u32>(y);\n    ux &= 0x7FFFFFFF;\n    uy &= 0x7FFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    x = reinterpret<f32>(ux);\n    y = reinterpret<f32>(uy);\n    if (uy == 0xFF << 23) return y;\n    if (ux >= 0xFF << 23 || uy == 0 || ux - uy >= 25 << 23) return x + y;\n    let z: f32 = 1;\n    if (ux >= (0x7F + 60) << 23) {\n      z  = Ox1p90f;\n      x *= Ox1p_90f;\n      y *= Ox1p_90f;\n    } else if (uy < (0x7F - 60) << 23) {\n      z  = Ox1p_90f;\n      x *= Ox1p90f;\n      y *= Ox1p90f;\n    }\n    return z * builtin_sqrt<f32>(f32(<f64>x * x + <f64>y * y));\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function imul(x: f32, y: f32): f32 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    return <f32>(dtoi32(x) * dtoi32(y));\n  }\n\n  export function log(x: f32): f32 { // see: musl/src/math/logf.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return logf_lut(x);\n    } else {\n      const\n        ln2_hi  = reinterpret<f32>(0x3F317180), // 6.9313812256e-01f\n        ln2_lo  = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06f\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f\n        Lg2     = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f\n        Lg3     = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f\n        Lg4     = reinterpret<f32>(0x3E789E26), // 0xf89e26.0p-26f\n        Ox1p25f = reinterpret<f32>(0x4C000000);\n\n      let u = reinterpret<u32>(x);\n      let k = 0;\n      let sign = u >> 31;\n      if (sign || u < 0x00800000) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (sign) return (x - x) / 0;\n        k -= 25;\n        x *= Ox1p25f;\n        u = reinterpret<u32>(x);\n      } else if (u >= 0x7F800000) {\n        return x;\n      } else if (u == 0x3F800000) {\n        return 0;\n      }\n      u += 0x3F800000 - 0x3F3504F3;\n      k += i32(u >> 23) - 0x7F;\n      u = (u & 0x007FFFFF) + 0x3F3504F3;\n      x = reinterpret<f32>(u);\n      let f = x - 1.0;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * Lg4);\n      let t2 = z * (Lg1 + w * Lg3);\n      let r = t2 + t1;\n      let hfsq = <f32>0.5 * f * f;\n      let dk = <f32>k;\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n    }\n  }\n\n  export function log10(x: f32): f32 { // see: musl/src/math/log10f.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f32>(0x3EDE6000), //  4.3432617188e-01f\n      ivln10lo  = reinterpret<f32>(0xB804EAD9), // -3.1689971365e-05f\n      log10_2hi = reinterpret<f32>(0x3E9A2080), //  3.0102920532e-01f\n      log10_2lo = reinterpret<f32>(0x355427DB), //  7.9034151668e-07f\n      Lg1       = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2       = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n      Lg3       = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n      Lg4       = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n      Ox1p25f   = reinterpret<f32>(0x4C000000); //  0x1p25f\n\n    let ux = reinterpret<u32>(x);\n    let k = 0;\n    let sign = ux >> 31;\n    if (sign || ux < 0x00800000) {\n      if (ux << 1 == 0) return -1 / (x * x);\n      if (sign) return (x - x) / 0.0;\n      k -= 25;\n      x *= Ox1p25f;\n      ux = reinterpret<u32>(x);\n    } else if (ux >= 0x7F800000) {\n      return x;\n    } else if (ux == 0x3F800000) {\n      return 0;\n    }\n    ux += 0x3F800000 - 0x3F3504F3;\n    k += i32(ux >> 23) - 0x7F;\n    ux = (ux & 0x007FFFFF) + 0x3F3504F3;\n    x = reinterpret<f32>(ux);\n    let f = x - 1.0;\n    let s = f / (2.0 + f);\n    let z = s * s;\n    let w = z * z;\n    let t1 = w * (Lg2 + w * Lg4);\n    let t2 = z * (Lg1 + w * Lg3);\n    let r = t2 + t1;\n    let hfsq: f32 = 0.5 * f * f;\n    let hi = f - hfsq;\n    ux = reinterpret<u32>(hi);\n    ux &= 0xFFFFF000;\n    hi = reinterpret<f32>(ux);\n    let lo = f - hi - hfsq + s * (hfsq + r);\n    let dk = <f32>k;\n    return dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi + hi * ivln10hi + dk * log10_2hi;\n  }\n\n  export function log1p(x: f32): f32 { // see: musl/src/math/log1pf.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f32>(0x3F317180), // 6.9313812256e-01\n      ln2_lo = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06\n      Lg1    = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2    = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f, 0.40000972152f\n      Lg3    = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f, 0.28498786688f\n      Lg4    = reinterpret<f32>(0x3E789E26); // 0xf89e26.0p-26f, 0.24279078841f\n\n    let ix = reinterpret<u32>(x);\n    let c: f32 = 0;\n    let f: f32 = 0;\n    let k = 1;\n    if (ix < 0x3ED413D0 || bool(ix >> 31)) {\n      if (ix >= 0xBF800000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (ix << 1 < 0x33800000 << 1) return x;\n      if (ix <= 0xBE95F619) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (ix >= 0x7F800000) return x;\n    if (k) {\n      let uf: f32 = 1 + x;\n      let iu = reinterpret<u32>(uf);\n      iu += 0x3F800000 - 0x3F3504F3;\n      k = i32(iu >> 23) - 0x7F;\n      if (k < 25) {\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      iu = (iu & 0x007FFFFF) + 0x3F3504F3;\n      f = reinterpret<f32>(iu) - 1;\n    }\n    let s = f / (2.0 + f);\n    let z = s * s;\n    let w = z * z;\n    let t1 = w * (Lg2 + w * Lg4);\n    let t2 = z * (Lg1 + w * Lg3);\n    let r = t2 + t1;\n    let hfsq: f32 = 0.5 * f * f;\n    let dk = <f32>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f32): f32 { // see: musl/src/math/log2f.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log2f_lut(x);\n    } else {\n      const\n        ivln2hi = reinterpret<f32>(0x3FB8B000), //  1.4428710938e+00f\n        ivln2lo = reinterpret<f32>(0xB9389AD4), // -1.7605285393e-04\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n        Lg2     = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n        Lg3     = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n        Lg4     = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n        Ox1p25f = reinterpret<f32>(0x4C000000); //  0x1p25f\n\n      let ux = reinterpret<u32>(x);\n      let k = 0;\n      let sign = ux >> 31;\n      if (sign || ux < 0x00800000) {\n        if (ux << 1 == 0) return -1 / (x * x);\n        if (sign) return (x - x) / 0.0;\n        k -= 25;\n        x *= Ox1p25f;\n        ux = reinterpret<u32>(x);\n      } else if (ux >= 0x7F800000) {\n        return x;\n      } else if (ux == 0x3F800000) {\n        return 0;\n      }\n      ux += 0x3F800000 - 0x3F3504F3;\n      k += i32(ux >> 23) - 0x7F;\n      ux = (ux & 0x007FFFFF) + 0x3F3504F3;\n      x = reinterpret<f32>(ux);\n      let f = x - 1.0;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * Lg4);\n      let t2 = z * (Lg1 + w * Lg3);\n      let r = t2 + t1;\n      let hfsq: f32 = 0.5 * f * f;\n      let hi = f - hfsq;\n      let u = reinterpret<u32>(hi);\n      u &= 0xFFFFF000;\n      hi = reinterpret<f32>(u);\n      let lo: f32 = f - hi - hfsq + s * (hfsq + r);\n      let dk = <f32>k;\n      return (lo + hi) * ivln2lo + lo * ivln2hi + hi * ivln2hi + dk;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function max(value1: f32, value2: f32): f32 {\n    return builtin_max<f32>(value1, value2);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function min(value1: f32, value2: f32): f32 {\n    return builtin_min<f32>(value1, value2);\n  }\n\n  export function pow(x: f32, y: f32): f32 {\n    // TODO: remove this fast pathes after introduced own mid-end IR with \"stdlib call simplify\" transforms\n    if (builtin_abs<f32>(y) <= 2) {\n      if (y == 2.0) return x * x;\n      if (y == 0.5) {\n        return select<f32>(\n          builtin_abs<f32>(builtin_sqrt<f32>(x)),\n          Infinity,\n          x != -Infinity\n        );\n      }\n      if (y == -1.0) return 1 / x;\n      if (y == 1.0) return x;\n      if (y == 0.0) return 1.0;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      // see: musl/src/math/powf.c\n      return powf_lut(x, y);\n    } else {\n      // based on:  jdh8/metallic/src/math/float/powf.c\n      if (y == 0) return 1;\n      // @ts-ignore: cast\n      if (isNaN(x) | isNaN(y)) {\n        return NaN;\n      }\n      let sign: u32 = 0;\n      let uy = reinterpret<u32>(y);\n      let ux = reinterpret<u32>(x);\n      let sx = ux >> 31;\n      ux &= 0x7FFFFFFF;\n      if (sx && nearest(y) == y) {\n        x = -x;\n        sx = 0;\n        sign = u32(nearest(y * 0.5) != y * 0.5) << 31;\n      }\n      let m: u32;\n      if (ux == 0x3F800000) { // x == 1\n        m = sx | u32((uy & 0x7FFFFFFF) == 0x7F800000) ? 0x7FC00000 : 0x3F800000;\n      } else if (ux == 0) {\n        m = <i32>uy < 0 ? 0x7F800000 : 0;\n      } else if (ux == 0x7F800000) {\n        m = <i32>uy < 0 ? 0 : 0x7F800000;\n      } else if (sx) {\n        m = 0x7FC00000;\n      } else {\n        m = reinterpret<u32>(<f32>exp2f(<f64>y * log2f(x)));\n      }\n      return reinterpret<f32>(m | sign);\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function seedRandom(value: i64): void {\n    NativeMath.seedRandom(value);\n  }\n\n  // Using xoroshiro64starstar from http://xoshiro.di.unimi.it/xoroshiro64starstar.c\n  export function random(): f32 {\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\n\n    let s0 = random_state0_32;\n    let s1 = random_state1_32;\n    let r  = rotl<u32>(s0 * 0x9E3779BB, 5) * 5;\n\n    s1 ^= s0;\n    random_state0_32 = rotl<u32>(s0, 26) ^ s1 ^ (s1 << 9);\n    random_state1_32 = rotl<u32>(s1, 13);\n\n    return reinterpret<f32>((r >> 9) | (127 << 23)) - 1.0;\n  }\n\n  export function round(x: f32): f32 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_ceil<f32>(x) - f32(builtin_ceil<f32>(x) - 0.5 > x);\n    } else {\n      let roundUp = builtin_ceil<f32>(x);\n      return select<f32>(roundUp, roundUp - 1.0, roundUp - 0.5 <= x);\n    }\n  }\n\n  export function sign(x: f32): f32 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return select<f32>(builtin_copysign<f32>(1, x), x, builtin_abs(x) > 0);\n    } else {\n      return select<f32>(1, select<f32>(-1, x, x < 0), x > 0);\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function signbit(x: f32): bool {\n    return <bool>(reinterpret<u32>(x) >>> 31);\n  }\n\n  export function sin(x: f32): f32 { // see: musl/src/math/sinf.c\n    const\n      s1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // M_PI_2 * 1\n      s2pio2 = reinterpret<f64>(0x400921FB54442D18), // M_PI_2 * 2\n      s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // M_PI_2 * 3\n      s4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    let ux = reinterpret<u32>(x);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3F490FDA) {  // |x| ~<= /4\n      if (ux < 0x39800000) { // |x| < 2**-12\n        return x;\n      }\n      return sin_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ux <= 0x407B53D1) {   // |x| ~<= 5/4\n        if (ux <= 0x4016CBE3) { // |x| ~<= 3/4\n          return sign ? -cos_kernf(x + s1pio2) : cos_kernf(x - s1pio2);\n        }\n        return sin_kernf(-(sign ? x + s2pio2 : x - s2pio2));\n      }\n\n      if (ux <= 0x40E231D5) {   // |x| ~<= 9/4\n        if (ux <= 0x40AFEDDF) { // |x| ~<= 7/4\n          return sign ? cos_kernf(x + s3pio2) : -cos_kernf(x - s3pio2);\n        }\n        return sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n      }\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) return x - x;\n\n    let n = rempio2f(x, ux, sign);\n    let y = rempio2f_y;\n\n    let t = n & 1 ? cos_kernf(y) : sin_kernf(y);\n    return n & 2 ? -t : t;\n  }\n\n  export function sinh(x: f32): f32 { // see: musl/src/math/sinhf.c\n    let u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    let a = reinterpret<f32>(u);\n    let h = builtin_copysign<f32>(0.5, x);\n    if (u < 0x42B17217) {\n      let t = expm1(a);\n      if (u < 0x3F800000) {\n        if (u < 0x3F800000 - (12 << 23)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    return expo2f(a, 2 * h);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sqrt(x: f32): f32 {\n    return builtin_sqrt<f32>(x);\n  }\n\n  export function tan(x: f32): f32 { // see: musl/src/math/tanf.c\n    const\n      t1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // 1 * M_PI_2\n      t2pio2 = reinterpret<f64>(0x400921FB54442D18), // 2 * M_PI_2\n      t3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // 3 * M_PI_2\n      t4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    let ux = reinterpret<u32>(x);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3F490FDA) {  // |x| ~<= /4\n      if (ux < 0x39800000) { // |x| < 2**-12\n        return x;\n      }\n      return tan_kernf(x, 0);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ux <= 0x407B53D1) {   // |x| ~<= 5/4\n        if (ux <= 0x4016CBE3) { // |x| ~<= 3/4\n          return tan_kernf((sign ? x + t1pio2 : x - t1pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t2pio2 : x - t2pio2), 0);\n        }\n      }\n      if (ux <= 0x40E231D5) {   // |x| ~<= 9/4\n        if (ux <= 0x40AFEDDF) { // |x| ~<= 7/4\n          return tan_kernf((sign ? x + t3pio2 : x - t3pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t4pio2 : x - t4pio2), 0);\n        }\n      }\n    }\n\n    // tan(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) return x - x;\n\n    // argument reduction\n    let n = rempio2f(x, ux, sign);\n    let y = rempio2f_y;\n    return tan_kernf(y, n & 1);\n  }\n\n  export function tanh(x: f32): f32 { // see: musl/src/math/tanhf.c\n    let u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    let y = reinterpret<f32>(u);\n    let t: f32;\n    if (u > 0x3F0C9F54) {\n      if (u > 0x41200000) t = 1 + 0 / y;\n      else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (u > 0x3E82C578) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (u >= 0x00800000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f32>(t, x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function trunc(x: f32): f32 {\n    return builtin_trunc<f32>(x);\n  }\n\n  export function scalbn(x: f32, n: i32): f32 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbnf.c\n    const\n      Ox1p24f   = reinterpret<f32>(0x4B800000),\n      Ox1p127f  = reinterpret<f32>(0x7F000000),\n      Ox1p_126f = reinterpret<f32>(0x00800000);\n\n    let y = x;\n    if (n > 127) {\n      y *= Ox1p127f;\n      n -= 127;\n      if (n > 127) {\n        y *= Ox1p127f;\n        n = builtin_min<i32>(n - 127, 127);\n      }\n    } else if (n < -126) {\n      y *= Ox1p_126f * Ox1p24f;\n      n += 126 - 24;\n      if (n < -126) {\n        y *= Ox1p_126f * Ox1p24f;\n        n = builtin_max<i32>(n + 126 - 24, -126);\n      }\n    }\n    return y * reinterpret<f32>(<u32>(0x7F + n) << 23);\n  }\n\n  export function mod(x: f32, y: f32): f32 { // see: musl/src/math/fmodf.c\n    if (builtin_abs<f32>(y) == 1.0) {\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\n      // TODO: move this rule to compiler's optimization pass.\n      // It could be apply for any x % C_pot, where \"C_pot\" is pow of two const.\n      return builtin_copysign<f32>(x - builtin_trunc<f32>(x), x);\n    }\n    let ux = reinterpret<u32>(x);\n    let uy = reinterpret<u32>(y);\n    let ex = i32(ux >> 23 & 0xFF);\n    let ey = i32(uy >> 23 & 0xFF);\n    let sm = ux & 0x80000000;\n    let uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0xFF || isNaN<f32>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    let ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      return x * f32(ux1 != uy1);\n    }\n    if (!ex) {\n      ex -= builtin_clz<u32>(ux << 9);\n      ux <<= 1 - ex;\n    } else {\n      ux &= <u32>-1 >> 9;\n      ux |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= 1 - ey;\n    } else {\n      uy &= u32(-1) >> 9;\n      uy |= 1 << 23;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 23); ux <<= 1) --ex;\n    let shift = <i32>builtin_clz<u32>(ux << 8);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 23;\n      ux |= <u32>ex << 23;\n    } else {\n      ux >>= -ex + 1;\n    }\n    return reinterpret<f32>(ux | sm);\n  }\n\n  export function rem(x: f32, y: f32): f32 { // see: musl/src/math/remquof.c\n    let ux = reinterpret<u32>(x);\n    let uy = reinterpret<u32>(y);\n    let ex = i32(ux >> 23 & 0xFF);\n    let ey = i32(uy >> 23 & 0xFF);\n    let uxi = ux;\n    if (uy << 1 == 0 || ex == 0xFF || isNaN(y)) return (x * y) / (x * y);\n    if (ux << 1 == 0) return x;\n    if (!ex) {\n      ex -= builtin_clz<u32>(uxi << 9);\n      uxi <<= 1 - ex;\n    } else {\n      uxi &= u32(-1) >> 9;\n      uxi |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= 1 - ey;\n    } else {\n      uy &= u32(-1) >> 9;\n      uy |= 1 << 23;\n    }\n    let q = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -30;\n      else {\n        let shift = builtin_clz<i32>(uxi << 8);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n    // end:\n    if (ex > 0) {\n      uxi -= 1 << 23;\n      uxi |= <u32>ex << 23;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f32>(uxi);\n    y = builtin_abs<f32>(y);\n    let x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (<f32>x2 > y || (<f32>x2 == y && bool(q & 1))))) {\n      x -= y;\n      // q++;\n    }\n    return <i32>ux < 0 ? -x : x;\n  }\n\n  export function sincos(x: f32): void { // see: musl/tree/src/math/sincosf.c\n    const\n      s1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // 1 * M_PI_2\n      s2pio2 = reinterpret<f64>(0x400921FB54442D18), // 2 * M_PI_2\n      s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // 3 * M_PI_2\n      s4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    let ux = reinterpret<u32>(x);\n    let sign = ux >> 31;\n    ux &= 0x7FFFFFFF;\n\n    if (ux <= 0x3F490FDA) {  // |x| ~<= /4\n      if (ux < 0x39800000) { // |x| < 2**-12\n        sincos_sin = x;\n        sincos_cos = 1;\n        return;\n      }\n      sincos_sin = sin_kernf(x);\n      sincos_cos = cos_kernf(x);\n      return;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ux <= 0x407B53D1) {   // |x| ~<= 5/4\n        if (ux <= 0x4016CBE3) { // |x| ~<= 3/4\n          if (sign) {\n            sincos_sin = -cos_kernf(x + s1pio2);\n            sincos_cos =  sin_kernf(x + s1pio2);\n          } else {\n            sincos_sin = cos_kernf(s1pio2 - x);\n            sincos_cos = sin_kernf(s1pio2 - x);\n          }\n          return;\n        }\n        // -sin(x + c) is not correct if x+c could be 0: -0 vs +0\n        sincos_sin = -sin_kernf(sign ? x + s2pio2 : x - s2pio2);\n        sincos_cos = -cos_kernf(sign ? x + s2pio2 : x - s2pio2);\n        return;\n      }\n      if (ux <= 0x40E231D5) {   // |x| ~<= 9/4\n        if (ux <= 0x40AFEDDF) { // |x| ~<= 7/4\n          if (sign) {\n            sincos_sin =  cos_kernf(x + s3pio2);\n            sincos_cos = -sin_kernf(x + s3pio2);\n          } else {\n            sincos_sin = -cos_kernf(x - s3pio2);\n            sincos_cos =  sin_kernf(x - s3pio2);\n          }\n          return;\n        }\n        sincos_sin = sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n        sincos_cos = cos_kernf(sign ? x + s4pio2 : x - s4pio2);\n        return;\n      }\n    }\n    // sin(Inf or NaN) is NaN\n    if (ux >= 0x7F800000) {\n      let xx = x - x;\n      sincos_sin = xx;\n      sincos_cos = xx;\n      return;\n    }\n    // general argument reduction needed\n    let n = rempio2f(x, ux, sign);\n    let y = rempio2f_y;\n    let s = sin_kernf(y);\n    let c = cos_kernf(y);\n    let sin = s, cos = c;\n    if (n & 1) {\n      sin =  c;\n      cos = -s;\n    }\n    if (n & 2) {\n      sin = -sin;\n      cos = -cos;\n    }\n    sincos_sin = sin;\n    sincos_cos = cos;\n  }\n}\n\nexport function ipow32(x: i32, e: i32): i32 {\n  let out = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (x == 2) {\n      return select<i32>(1 << e, 0, <u32>e < 32);\n    }\n    if (e <= 0) {\n      if (x == -1) return select<i32>(-1, 1, e & 1);\n      return i32(e == 0) | i32(x == 1);\n    }\n    else if (e == 1) return x;\n    else if (e == 2) return x * x;\n    else if (e < 32) {\n      let log = 32 - clz(e);\n      // 32 = 2 ^ 5, so need only five cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 5: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n  while (e) {\n    if (e & 1) out *= x;\n    e >>>= 1;\n    x *= x;\n  }\n  return out;\n}\n\nexport function ipow64(x: i64, e: i64): i64 {\n  let out: i64 = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (x == 2) {\n      return select<i64>(1 << e, 0, <u64>e < 64);\n    }\n    if (e <= 0) {\n      if (x == -1) return select<i64>(-1, 1, e & 1);\n      return i64(e == 0) | i64(x == 1);\n    }\n    else if (e == 1) return x;\n    else if (e == 2) return x * x;\n    else if (e < 64) {\n      let log = 64 - <i32>clz(e);\n      // 64 = 2 ^ 6, so need only six cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 6: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 5: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n  while (e) {\n    if (e & 1) out *= x;\n    e >>>= 1;\n    x *= x;\n  }\n  return out;\n}\n\n/*\nTODO:\nIn compile time if only exponent is constant we could replace ipow32/ipow64 by shortest addition chains\nwhich usually faster than exponentiation by squaring\n\nfor ipow32 and e < 32:\n\nlet b: i32, c: i32, d: i32, h: i32, k: i32, g: i32;\nswitch (e) {\n  case  1: return x;\n  case  2: return x * x;\n  case  3: return x * x * x;\n  case  4: return (b = x * x) * b;\n  case  5: return (b = x * x) * b * x;\n  case  6: return (b = x * x) * b * b;\n  case  7: return (b = x * x) * b * b * x;\n  case  8: return (d = (b = x * x) * b) * d;\n  case  9: return (c = x * x * x) * c * c;\n  case 10: return (d = (b = x * x) * b) * d * b;\n  case 11: return (d = (b = x * x) * b) * d * b * x;\n  case 12: return (d = (b = x * x) * b) * d * d;\n  case 13: return (d = (b = x * x) * b) * d * d * x;\n  case 14: return (d = (b = x * x) * b) * d * d * b;\n  case 15: return (k = (b = x * x) * b * x) * k * k;\n  case 16: return (h = (d = (b = x * x) * b) * d) * h;\n  case 17: return (h = (d = (b = x * x) * b) * d) * h * x;\n  case 18: return (h = (d = (b = x * x) * b) * d * x) * h;\n  case 19: return (h = (d = (b = x * x) * b) * d * x) * h * x;\n  case 20: return (h = (k = (b = x * x) * b * x) * k) * h;\n  case 21: return (h = (k = (b = x * x) * b * x) * k) * h * x;\n  case 22: return (g = (h = (k = (b = x * x) * b * x) * k) * x) * g;\n  case 23: return (h = (d = (c = (b = x * x) * x) * b) * d) * h * c;\n  case 24: return (h = (d = (c = x * x * x) * c) * d) * h;\n  case 25: return (h = (d = (c = x * x * x) * c) * d) * h * x;\n  case 26: return (g = (h = (d = (c = x * x * x) * c) * d) * x) * g;\n  case 27: return (h = (d = (c = x * x * x) * c) * d) * h * c;\n  case 28: return (h = (d = (c = x * x * x) * c * x) * d) * h;\n  case 29: return (h = (d = (c = x * x * x) * c * x) * d) * h * x;\n  case 30: return (h = (d = (c = x * x * x) * c) * d * c) * h;\n  case 31: return (h = (d = (c = x * x * x) * c) * d * c) * h * x;\n}\n\nfor ipow64: TODO\nswitch (e) {\n  case 32:\n  ...\n  case 63:\n}\n*/\n","export function REVERSE<T>(ptr: usize, len: usize): void {\n  if (len > 1) {\n    let\n      i: usize = 0,\n      tail: usize,\n      hlen: usize = len >> 1;\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (sizeof<T>() == 1) {\n        // TODO: Decide later: Does we need this fast path cases?\n        //\n        // if (len == 4) {\n        //   store<u32>(ptr, bswap(load<u32>(ptr)));\n        //   return;\n        // }\n        // if (len == 8) {\n        //   store<u64>(ptr, bswap(load<u64>(ptr)));\n        //   return;\n        // }\n        tail = len - 8;\n        while (i + 7 < hlen) {\n          let front = ptr + i;\n          let back  = ptr + tail - i;\n          let temp  = bswap(load<u64>(front));\n          store<u64>(front, bswap(load<u64>(back)));\n          store<u64>(back, temp);\n          i += 8;\n        }\n      }\n\n      if (sizeof<T>() == 2) {\n        tail = len - 2;\n        while (i + 1 < hlen) {\n          let front = ptr + (i << 1);\n          let back  = ptr + (tail - i << 1);\n          let temp  = rotr(load<u32>(back), 16);\n          store<u32>(back, rotr(load<u32>(front), 16));\n          store<u32>(front, temp);\n          i += 2;\n        }\n      }\n    }\n\n    tail = len - 1;\n    while (i < hlen) {\n      let front = ptr + (i << alignof<T>());\n      let back  = ptr + (tail - i << alignof<T>());\n      let temp  = load<T>(front);\n      store<T>(front, load<T>(back));\n      store<T>(back, temp);\n      i++;\n    }\n  }\n}\n\nexport function FILL<T>(\n  ptr: usize,\n  len: usize,\n  value: T,\n  start: isize,\n  end: isize\n): void {\n  start = start < 0 ? max(len + start, 0) : min(start, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n\n  if (sizeof<T>() == 1) {\n    if (start < end) {\n      memory.fill(\n        ptr + <usize>start,\n        u8(value),\n        <usize>(end - start)\n      );\n    }\n  } else {\n    if (ASC_SHRINK_LEVEL <= 1) {\n      if (isInteger<T>()) {\n        // @ts-ignore\n        if (value == <T>0 | value == <T>-1) {\n          if (start < end) {\n            memory.fill(\n              ptr + (<usize>start << alignof<T>()),\n              u8(value),\n              <usize>(end - start) << alignof<T>()\n            );\n          }\n          return;\n        }\n      } else if (isFloat<T>()) {\n        // for floating non-negative zeros we can use fast memory.fill\n        if ((sizeof<T>() == 4 && reinterpret<u32>(f32(value)) == 0) ||\n            (sizeof<T>() == 8 && reinterpret<u64>(f64(value)) == 0)) {\n          if (start < end) {\n            memory.fill(\n              ptr + (<usize>start << alignof<T>()),\n              0,\n              <usize>(end - start) << alignof<T>()\n            );\n          }\n          return;\n        }\n      }\n    }\n    for (; start < end; ++start) {\n      store<T>(ptr + (<usize>start << alignof<T>()), value);\n    }\n  }\n}\n","import { BLOCK_MAXSIZE } from \"./rt/common\";\nimport { ArrayBuffer } from \"./arraybuffer\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH } from \"./util/error\";\n\n// TODO: there is probably a smarter way to check byteOffset for accesses larger than 1 byte\n\nexport class DataView {\n\n  readonly buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  readonly byteLength: i32;\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\n  }\n\n  constructor(\n    buffer: ArrayBuffer,\n    byteOffset: i32 = 0,\n    byteLength: i32 = buffer.byteLength\n  ) {\n    if (\n      i32(<u32>byteLength > <u32>BLOCK_MAXSIZE) |\n      i32(<u32>byteOffset + byteLength > <u32>buffer.byteLength)\n    ) throw new RangeError(E_INVALIDLENGTH);\n    this.buffer = buffer; // links\n    let dataStart = changetype<usize>(buffer) + <usize>byteOffset;\n    this.dataStart = dataStart;\n    this.byteLength = byteLength;\n  }\n\n  getFloat32(byteOffset: i32, littleEndian: bool = false): f32 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    return littleEndian\n      ? load<f32>(this.dataStart + <usize>byteOffset)\n      : reinterpret<f32>(bswap<u32>(load<u32>(this.dataStart + <usize>byteOffset)));\n  }\n\n  getFloat64(byteOffset: i32, littleEndian: bool = false): f64 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    return littleEndian\n      ? load<f64>(this.dataStart + <usize>byteOffset)\n      : reinterpret<f64>(bswap<u64>(load<u64>(this.dataStart + <usize>byteOffset)));\n  }\n\n  getInt8(byteOffset: i32): i8 {\n    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>byteOffset);\n  }\n\n  getInt16(byteOffset: i32, littleEndian: bool = false): i16 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    let result: i16 = load<i16>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<u16>(result);\n  }\n\n  getInt32(byteOffset: i32, littleEndian: bool = false): i32 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    let result: i32 = load<i32>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<u32>(result);\n  }\n\n  getUint8(byteOffset: i32): u8 {\n    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>byteOffset);\n  }\n\n  getUint16(byteOffset: i32, littleEndian: bool = false): u16 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    let result: u16 = load<u16>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<u16>(result);\n  }\n\n  getUint32(byteOffset: i32, littleEndian: bool = false): u32 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    let result: u32 = load<u32>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<u32>(result);\n  }\n\n  setFloat32(byteOffset: i32, value: f32, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    if (littleEndian) store<f32>(this.dataStart + <usize>byteOffset, value);\n    else store<u32>(this.dataStart + <usize>byteOffset, bswap<u32>(reinterpret<u32>(value)));\n  }\n\n  setFloat64(byteOffset: i32, value: f64, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    if (littleEndian) store<f64>(this.dataStart + <usize>byteOffset, value);\n    else store<u64>(this.dataStart + <usize>byteOffset, bswap<u64>(reinterpret<u64>(value)));\n  }\n\n  setInt8(byteOffset: i32, value: i8): void {\n    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i8>(this.dataStart + <usize>byteOffset, value);\n  }\n\n  setInt16(byteOffset: i32, value: i16, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i16>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u16>(value));\n  }\n\n  setInt32(byteOffset: i32, value: i32, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i32>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u32>(value));\n  }\n\n  setUint8(byteOffset: i32, value: u8): void {\n    if (<u32>byteOffset >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>byteOffset, value);\n  }\n\n  setUint16(byteOffset: i32, value: u16, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 2 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u16>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u16>(value));\n  }\n\n  setUint32(byteOffset: i32, value: u32, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 4 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u32>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u32>(value));\n  }\n\n  // Non-standard additions that make sense in WebAssembly, but won't work in JS:\n\n  getInt64(byteOffset: i32, littleEndian: bool = false): i64 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    let result: i64 = load<i64>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<u64>(result);\n  }\n\n  getUint64(byteOffset: i32, littleEndian: bool = false): u64 {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    let result = load<u64>(this.dataStart + <usize>byteOffset);\n    return littleEndian ? result : bswap<u64>(result);\n  }\n\n  setInt64(byteOffset: i32, value: i64, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i64>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u64>(value));\n  }\n\n  setUint64(byteOffset: i32, value: u64, littleEndian: bool = false): void {\n    if (\n      (byteOffset >>> 31) | i32(byteOffset + 8 > this.byteLength)\n    ) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u64>(this.dataStart + <usize>byteOffset, littleEndian ? value : bswap<u64>(value));\n  }\n\n  toString(): string {\n    return \"[object DataView]\";\n  }\n}\n","export function bswap<T extends number>(value: T): T {\n  if (isInteger<T>()) {\n    if (sizeof<T>() == 1) {\n      return value;\n    }\n    if (sizeof<T>() == 2) {\n      return <T>(<u16>value << 8 | (<u16>value >> 8));\n    }\n    if (sizeof<T>() == 4) {\n      return <T>(\n        rotl(<u32>value & 0xFF00FF00, 8) |\n        rotr(<u32>value & 0x00FF00FF, 8)\n      );\n    }\n    if (sizeof<T>() == 8) {\n      let a = (<u64>value >> 8) & 0x00FF00FF00FF00FF;\n      let b = (<u64>value & 0x00FF00FF00FF00FF) << 8;\n      let v = a | b;\n\n      a = (v >>> 16) & 0x0000FFFF0000FFFF;\n      b = (v & 0x0000FFFF0000FFFF) << 16;\n\n      return <T>rotr(a | b, 32);\n    }\n  }\n  ERROR(\"Unsupported generic type\");\n}\n","import {\n  console as binding\n} from \"./bindings/dom\";\n\nexport namespace console {\n\n  export function assert<T>(condition: T, message: string = \"\"): void {\n    binding.assert(!!condition, message);\n  }\n\n  export function log(message: string = \"\"): void {\n    binding.log(message);\n  }\n\n  export function debug(message: string = \"\"): void {\n    binding.debug(message);\n  }\n\n  export function info(message: string = \"\"): void {\n    binding.info(message);\n  }\n\n  export function warn(message: string = \"\"): void {\n    binding.warn(message);\n  }\n\n  export function error(message: string = \"\"): void {\n    binding.error(message);\n  }\n\n  export function time(label: string = \"default\"): void {\n    binding.time(label);\n  }\n\n  export function timeLog(label: string = \"default\"): void {\n    binding.timeLog(label);\n  }\n\n  export function timeEnd(label: string = \"default\"): void {\n    binding.timeEnd(label);\n  }\n}\n","type auto = i32;\n\n@final export abstract class Function<T> {\n  private _index: u32;\n  private _env: usize;\n\n  // @ts-ignore: this on getter\n  get index(this: T): u32 {\n    return load<u32>(changetype<usize>(this), offsetof<Function<T>>(\"_index\"));\n  }\n\n  // @ts-ignore: this on getter\n  get name(this: T): string {\n    return \"\";\n  }\n\n  // @ts-ignore: this on getter\n  get length(this: T): i32 {\n    // @ts-ignore: T is function\n    return lengthof<T>();\n  }\n\n  // @ts-ignore: T is function\n  @builtin call(thisArg: thisof<T> | null, ...args: auto[]): returnof<T> {\n    return unreachable();\n  }\n\n  toString(this: T): string {\n    return \"function() { [native code] }\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    // Env is either `null` (nop) or compiler-generated\n    __visit(this._env, cookie);\n  }\n}\n"]}