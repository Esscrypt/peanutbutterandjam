import type { webcrypto as NodeWebCrypto } from 'node:crypto'
import type {
  QUICClient,
  QUICServer,
  QUICSocket,
  QUICStream,
} from '@infisical/quic'
import * as nobleEd25519 from '@noble/ed25519'
import * as peculiarWebcrypto from '@peculiar/webcrypto'
import type { X509Certificate } from '@peculiar/x509'
import * as x509 from '@peculiar/x509'
import { encodeBase64Url } from 'u8a-utils'

type BufferSource = ArrayBuffer | ArrayBufferView

/**
 * WebCrypto polyfill from @peculiar/webcrypto
 * This behaves differently with respect to Ed25519 keys
 * See: https://github.com/PeculiarVentures/webcrypto/issues/55
 */
const webcrypto = new peculiarWebcrypto.Crypto()

// Use Web Crypto API's JsonWebKey type (what @peculiar/webcrypto actually returns)
// This matches the Web Crypto standard that @peculiar/webcrypto implements
type JsonWebKey = NodeWebCrypto.JsonWebKey

// Type assertion: @peculiar/webcrypto.Crypto is compatible with @peculiar/x509's expected type
// The x509 library expects a Web Crypto API compatible Crypto interface
x509.cryptoProvider.set(webcrypto as unknown as globalThis.Crypto)

async function sleep(ms: number): Promise<void> {
  return await new Promise<void>((r) => setTimeout(r, ms))
}

async function randomBytes(data: ArrayBuffer) {
  webcrypto.getRandomValues(new Uint8Array(data))
}

/**
 * Generates Ed25519 keypair
 * This uses `@peculiar/webcrypto` API
 */
async function generateKeyPairEd25519(): Promise<{
  publicKey: JsonWebKey
  privateKey: JsonWebKey
}> {
  const keyPair = await webcrypto.subtle.generateKey(
    {
      name: 'EdDSA',
      namedCurve: 'Ed25519',
    },
    true,
    ['sign', 'verify'],
  )
  return {
    publicKey: await webcrypto.subtle.exportKey('jwk', keyPair.publicKey),
    privateKey: await webcrypto.subtle.exportKey('jwk', keyPair.privateKey),
  }
}

/**
 * Imports an Ed25519 keypair from raw private and public key bytes
 * @param privateKeyBytes - Raw private key bytes as Uint8Array
 * @param publicKeyBytes - Raw public key bytes as Uint8Array (optional, will be derived if not provided)
 * @returns Promise resolving to an object containing the imported CryptoKey objects
 */
function importEd25519KeyPair(
  privateKeyBytes: Uint8Array,
  publicKeyBytes: Uint8Array,
): {
  privateKey: JsonWebKey
  publicKey: JsonWebKey
} {
  const publicKeyJwk: JsonWebKey = {
    kty: 'OKP',
    crv: 'Ed25519',
    alg: 'EdDSA',
    x: encodeBase64Url(publicKeyBytes),
  }

  const privateKeyJwk: JsonWebKey = {
    ...publicKeyJwk,
    d: encodeBase64Url(privateKeyBytes),
  }

  return { privateKey: privateKeyJwk, publicKey: publicKeyJwk } as const
}

async function publicKeyFromPrivateKey(
  privateKey: JsonWebKey,
): Promise<JsonWebKey> {
  switch (privateKey.kty) {
    case 'OKP': {
      // For Ed25519 keys generated by @peculiar/webcrypto,
      // we cannot just take the `privateKey.x` as the public key
      // The property does not exist on the JWK, so we have to
      // calculate it using @noble/ed25519
      const publicKey = await nobleEd25519.getPublicKey(
        new Uint8Array(Buffer.from(privateKey.d!, 'base64url')),
      )
      return {
        kty: privateKey.kty,
        crv: privateKey.crv,
        key_ops: ['verify'],
        ext: true,
        x: Buffer.from(publicKey).toString('base64url'),
      }
    }
    default:
      throw new Error(`Unsupported key type ${privateKey.kty}`)
  }
}

/**
 * Imports public key.
 * This uses `@peculiar/webcrypto` API for Ed25519 keys.
 */
async function importPublicKey(
  publicKey: JsonWebKey,
): Promise<peculiarWebcrypto.CryptoKey> {
  let algorithm
  switch (publicKey.kty) {
    case 'EC':
      switch (publicKey.crv) {
        case 'P-256':
          algorithm = {
            name: 'ECDSA',
            namedCurve: 'P-256',
          }
          break
        case 'P-384':
          algorithm = {
            name: 'ECDSA',
            namedCurve: 'P-384',
          }
          break
        case 'P-521':
          algorithm = {
            name: 'ECDSA',
            namedCurve: 'P-521',
          }
          break
        default:
          throw new Error(`Unsupported curve ${publicKey.crv}`)
      }
      break
    case 'OKP':
      algorithm = {
        name: 'EdDSA',
        namedCurve: 'Ed25519',
      }
      break
    default:
      throw new Error(`Unsupported key type ${publicKey.kty}`)
  }
  return await webcrypto.subtle.importKey('jwk', publicKey, algorithm, true, [
    'verify',
  ])
}

/**
 * Imports private key.
 * This uses `@peculiar/webcrypto` API for Ed25519 keys.
 */
async function importPrivateKey(
  privateKey: JsonWebKey,
): Promise<peculiarWebcrypto.CryptoKey> {
  let algorithm
  switch (privateKey.kty) {
    case 'OKP':
      algorithm = {
        name: 'EdDSA',
        namedCurve: 'Ed25519',
      }
      break
    default:
      throw new Error(`Unsupported key type ${privateKey.kty}`)
  }
  return await webcrypto.subtle.importKey('jwk', privateKey, algorithm, true, [
    'sign',
  ])
}

async function keyPairEd25519ToPEM(keyPair: {
  publicKey: JsonWebKey
  privateKey: JsonWebKey
}): Promise<{
  publicKey: string
  privateKey: string
}> {
  const publicKey = await importPublicKey(keyPair.publicKey)
  const privatekey = await importPrivateKey(keyPair.privateKey)
  const publicKeySPKI = await webcrypto.subtle.exportKey('spki', publicKey)
  const publicKeySPKIBuffer = Buffer.from(publicKeySPKI)
  const publicKeyPEMBody = `${publicKeySPKIBuffer
    .toString('base64')
    .replace(/(.{64})/g, '$1\n')
    .trimEnd()}\n`
  const publicKeyPEM = `-----BEGIN PUBLIC KEY-----\n${publicKeyPEMBody}\n-----END PUBLIC KEY-----\n`
  const privateKeyPKCS8 = await webcrypto.subtle.exportKey('pkcs8', privatekey)
  const privateKeyPKCS8Buffer = Buffer.from(privateKeyPKCS8)
  const privateKeyPEMBody = `${privateKeyPKCS8Buffer
    .toString('base64')
    .replace(/(.{64})/g, '$1\n')
    .trimEnd()}\n`
  const privateKeyPEM = `-----BEGIN PRIVATE KEY-----\n${privateKeyPEMBody}-----END PRIVATE KEY-----\n`
  return {
    publicKey: publicKeyPEM,
    privateKey: privateKeyPEM,
  }
}

const extendedKeyUsageFlags = {
  serverAuth: '1.3.6.1.5.5.7.3.1',
  clientAuth: '1.3.6.1.5.5.7.3.2',
  codeSigning: '1.3.6.1.5.5.7.3.3',
  emailProtection: '1.3.6.1.5.5.7.3.4',
  timeStamping: '1.3.6.1.5.5.7.3.8',
  ocspSigning: '1.3.6.1.5.5.7.3.9',
}

/**
 * Generate x509 certificate.
 * Duration is in seconds.
 * X509 certificates currently use `UTCTime` format for `notBefore` and `notAfter`.
 * This means:
 *   - Only second resolution.
 *   - Minimum date for validity is 1970-01-01T00:00:00Z (inclusive).
 *   - Maximum date for valdity is 2049-12-31T23:59:59Z (inclusive).
 */
async function generateCertificate({
  certId,
  subjectKeyPair,
  issuerPrivateKey,
  duration,
  subjectAttrsExtra = [],
  issuerAttrsExtra = [],
  dnsAltNames = [],
  now = new Date(),
}: {
  certId: string
  subjectKeyPair: {
    publicKey: JsonWebKey
    privateKey: JsonWebKey
  }
  issuerPrivateKey: JsonWebKey
  duration: number
  subjectAttrsExtra?: { [key: string]: string[] }[]
  issuerAttrsExtra?: { [key: string]: string[] }[]
  dnsAltNames?: string[]
  now?: Date
}): Promise<X509Certificate> {
  const subjectPublicCryptoKey = await importPublicKey(subjectKeyPair.publicKey)
  const subjectPrivateCryptoKey = await importPrivateKey(
    subjectKeyPair.privateKey,
  )
  const issuerPrivateCryptoKey = await importPrivateKey(issuerPrivateKey)

  if (duration < 0) {
    throw new RangeError('`duration` must be positive')
  }
  // X509 `UTCTime` format only has resolution of seconds
  // this truncates to second resolution
  const notBeforeDate = new Date(now.getTime() - (now.getTime() % 1000))
  const notAfterDate = new Date(now.getTime() - (now.getTime() % 1000))
  // If the duration is 0, then only the `now` is valid
  notAfterDate.setSeconds(notAfterDate.getSeconds() + duration)
  if (notBeforeDate < new Date(0)) {
    throw new RangeError(
      '`notBeforeDate` cannot be before 1970-01-01T00:00:00Z',
    )
  }
  if (notAfterDate > new Date(new Date('2050').getTime() - 1)) {
    throw new RangeError('`notAfterDate` cannot be after 2049-12-31T23:59:59Z')
  }
  //   const subjectNodeId = await webcrypto.subtle.digest(
  //     'SHA-256',
  //     await webcrypto.subtle.exportKey('spki', subjectPublicCryptoKey),
  //   )
  //   const issuerPublicKey = await publicKeyFromPrivateKey(issuerPrivateKey)
  //   const issuerPublicCryptoKey = await importPublicKey(issuerPublicKey)
  //   const issuerNodeId = await webcrypto.subtle.digest(
  //     'SHA-256',
  //     await webcrypto.subtle.exportKey('spki', issuerPublicCryptoKey),
  //   )
  const serialNumber = certId
  //   const subjectNodeIdEncoded = Buffer.from(subjectNodeId).toString('hex')
  //   const _issuerNodeIdEncoded = Buffer.from(issuerNodeId).toString('hex')
  // The entire subject attributes and issuer attributes
  // is constructed via `x509.Name` class
  // By default this supports on a limited set of names:
  // CN, L, ST, O, OU, C, DC, E, G, I, SN, T
  // If custom names are desired, this needs to change to constructing
  // `new x509.Name('FOO=BAR', { FOO: '1.2.3.4' })` manually
  // And each custom attribute requires a registered OID
  // Because the OID is what is encoded into ASN.1
  const subjectAttrs = [
    {
      CN: ['JAM Client Ed25519 Cert'],
    },
    // Filter out conflicting CN attributes
    ...subjectAttrsExtra.filter((attr) => !('CN' in attr)),
  ]
  const issuerAttrs = [
    {
      CN: ['JAM Client Ed25519 Cert'],
    },
    // Filter out conflicting CN attributes
    ...issuerAttrsExtra.filter((attr) => !('CN' in attr)),
  ]
  const signingAlgorithm = issuerPrivateCryptoKey.algorithm
  if (signingAlgorithm.name === 'ECDSA') {
    // In ECDSA, the signature should match the curve strength
    switch (signingAlgorithm.namedCurve) {
      case 'P-256':
        signingAlgorithm.hash = 'SHA-256'
        break
      case 'P-384':
        signingAlgorithm.hash = 'SHA-384'
        break
      case 'P-521':
        signingAlgorithm.hash = 'SHA-512'
        break
      default:
        throw new TypeError(
          `Issuer private key has an unsupported curve: ${signingAlgorithm.namedCurve}`,
        )
    }
  }
  const certConfig = {
    serialNumber,
    notBefore: notBeforeDate,
    notAfter: notAfterDate,
    subject: subjectAttrs,
    issuer: issuerAttrs,
    signingAlgorithm,
    publicKey: subjectPublicCryptoKey,
    signingKey: subjectPrivateCryptoKey,
    extensions: [
      new x509.BasicConstraintsExtension(true, undefined, true), // ca: true, pathLength: undefined, critical: true
      new x509.KeyUsagesExtension(
        x509.KeyUsageFlags.keyCertSign |
          x509.KeyUsageFlags.cRLSign |
          x509.KeyUsageFlags.digitalSignature |
          x509.KeyUsageFlags.nonRepudiation |
          x509.KeyUsageFlags.keyAgreement |
          x509.KeyUsageFlags.keyEncipherment |
          x509.KeyUsageFlags.dataEncipherment,
      ),
      new x509.ExtendedKeyUsageExtension([
        extendedKeyUsageFlags.serverAuth,
        extendedKeyUsageFlags.clientAuth,
        extendedKeyUsageFlags.codeSigning,
        extendedKeyUsageFlags.emailProtection,
        extendedKeyUsageFlags.timeStamping,
        extendedKeyUsageFlags.ocspSigning,
      ]),
      new x509.SubjectAlternativeNameExtension([
        // Commented out hardcoded DNS names for testing - uncomment if needed
        // {
        //   type: 'dns',
        //   value: subjectNodeIdEncoded,
        // },
        // {
        //   type: 'dns',
        //   value: 'localhost',
        // },
        // // Quiche doesn't support IP SANs,
        // // instead we hack these in as DNS SANs for testing purposes
        // {
        //   type: 'dns',
        //   value: '127.0.0.1',
        // },
        // // Quiche doesn't support IP SANs,
        // // instead we hack these in as DNS SANs for testing purposes
        // {
        //   type: 'dns',
        //   value: '::1',
        // },
        // {
        //   type: 'ip',
        //   value: '127.0.0.1',
        // },
        // {
        //   type: 'ip',
        //   value: '::1',
        // },
        // Add custom DNS alt names
        ...dnsAltNames.map((dnsName) => ({
          type: 'dns' as const,
          value: dnsName,
        })),
      ]),
      await x509.SubjectKeyIdentifierExtension.create(subjectPublicCryptoKey),
      await x509.AuthorityKeyIdentifierExtension.create(subjectPublicCryptoKey),
    ] as x509.Extension[],
  }
  certConfig.signingKey = issuerPrivateCryptoKey
  return await x509.X509CertificateGenerator.create(certConfig)
}

function certToPEM(cert: X509Certificate): string {
  return `${cert.toString('pem')}\n`
}

/**
 * Generate 256-bit HMAC key using webcrypto.
 * Web Crypto prefers using the `CryptoKey` type.
 * But to be fully generic, we use the `ArrayBuffer` type.
 * In production, prefer to use libsodium as it would be faster.
 */
async function generateKeyHMAC(): Promise<ArrayBuffer> {
  const cryptoKey = await webcrypto.subtle.generateKey(
    {
      name: 'HMAC',
      hash: 'SHA-256',
    },
    true,
    ['sign', 'verify'],
  )
  const key = await webcrypto.subtle.exportKey('raw', cryptoKey)
  return key
}

/**
 * Signs using the 256-bit HMAC key
 * Web Crypto has to use the `CryptoKey` type.
 * But to be fully generic, we use the `ArrayBuffer` type.
 * In production, prefer to use libsodium as it would be faster.
 */
async function signHMAC(key: ArrayBuffer, data: ArrayBuffer) {
  const cryptoKey = await webcrypto.subtle.importKey(
    'raw',
    key,
    {
      name: 'HMAC',
      hash: 'SHA-256',
    },
    true,
    ['sign', 'verify'],
  )
  return webcrypto.subtle.sign('HMAC', cryptoKey, data)
}

/**
 * Verifies using 256-bit HMAC key
 * Web Crypto prefers using the `CryptoKey` type.
 * But to be fully generic, we use the `ArrayBuffer` type.
 * In production, prefer to use libsodium as it would be faster.
 */
async function verifyHMAC(
  key: ArrayBuffer,
  data: ArrayBuffer,
  sig: ArrayBuffer,
) {
  const cryptoKey = await webcrypto.subtle.importKey(
    'raw',
    key,
    {
      name: 'HMAC',
      hash: 'SHA-256',
    },
    true,
    ['sign', 'verify'],
  )
  return webcrypto.subtle.verify('HMAC', cryptoKey, sig, data)
}

/**
 * Zero-copy wraps ArrayBuffer-like objects into Buffer
 * This supports ArrayBuffer, TypedArrays and the NodeJS Buffer
 */
function bufferWrap(
  array: BufferSource,
  offset?: number,
  length?: number,
): Buffer {
  if (Buffer.isBuffer(array)) {
    return array
  } else if (ArrayBuffer.isView(array)) {
    return Buffer.from(
      array.buffer,
      offset ?? array.byteOffset,
      length ?? array.byteLength,
    )
  } else {
    return Buffer.from(array, offset, length)
  }
}

/**
 * Creates two socket handling functions.
 * `extractSocket` is used to extract a socket out of a client or server.
 * `stopSockets` is used to stop all sockets that were extracted.
 *
 * This is used as a failsafe cleanup for active sockets.
 * Failing to clean up sockets in a test will cause CI jobs to hang for 1 hour.
 */
function socketCleanupFactory() {
  const sockets = new Set<QUICSocket>()
  return {
    extractSocket: (thing: QUICClient | QUICServer) => {
      // @ts-ignore: kidnap protected property
      sockets.add(thing.socket)
    },
    stopSockets: async () => {
      const stopProms: Promise<void>[] = []
      for (const socket of sockets) {
        stopProms.push(socket.stop({ force: true }))
      }
      await Promise.all(stopProms)
    },
    sockets,
  }
}

type Messages = Uint8Array[]

type StreamData = {
  messages: Messages
  startDelay: number
  endDelay: number
  delays: number[]
}

/**
 * This is used to have a stream run concurrently in the background.
 * Will resolve once stream has completed.
 * This will send the data provided with delays provided.
 * Will consume stream with provided delays between reads.
 */
const handleStreamProm = async (stream: QUICStream, streamData: StreamData) => {
  const messages = streamData.messages
  const delays = streamData.delays
  const writeProm = (async () => {
    // Write data
    let count = 0
    const writer = stream.writable.getWriter()
    for (const message of messages) {
      await writer.write(message)
      await sleep(delays[count % delays.length])
      count += 1
    }
    await sleep(streamData.endDelay)
    await writer.close()
  })()
  const readProm = (async () => {
    // Consume readable
    let count = 0
    for await (const _ of stream.readable) {
      // Do nothing with delay,
      await sleep(delays[count % delays.length])
      count += 1
    }
  })()
  try {
    await Promise.all([writeProm, readProm])
  } finally {
    await stream.destroy().catch(() => {})
    // @ts-ignore: kidnap logger
    const streamLogger = stream.logger
    streamLogger.info(
      `stream result ${JSON.stringify(
        await Promise.allSettled([readProm, writeProm]),
      )}`,
    )
  }
}

type KeyTypes = 'RSA' | 'ECDSA' | 'Ed25519'
type TLSConfigs = {
  leafKeyPair: { publicKey: JsonWebKey; privateKey: JsonWebKey }
  leafKeyPairPEM: { publicKey: string; privateKey: string }
  leafCert: X509Certificate
  leafCertPEM: string
  caKeyPair: { publicKey: JsonWebKey; privateKey: JsonWebKey }
  caKeyPairPEM: { publicKey: string; privateKey: string }
  caCert: X509Certificate
  caCertPEM: string
}

async function generateTLSConfig(type: KeyTypes): Promise<TLSConfigs> {
  // Initialize with default values to avoid "used before assigned" errors
  const leafKeyPair = await generateKeyPairEd25519()
  const leafKeyPairPEM = await keyPairEd25519ToPEM(leafKeyPair)
  const caKeyPair = await generateKeyPairEd25519()
  const caKeyPairPEM = await keyPairEd25519ToPEM(caKeyPair)

  // Only Ed25519 is implemented currently
  if (type !== 'Ed25519') {
    throw new Error(`Key type ${type} not implemented`)
  }
  const caCert = await generateCertificate({
    certId: '0',
    issuerPrivateKey: caKeyPair.privateKey,
    subjectKeyPair: caKeyPair,
    duration: 60 * 60 * 24 * 365 * 10,
  })
  const leafCert = await generateCertificate({
    certId: '1',
    issuerPrivateKey: caKeyPair.privateKey,
    subjectKeyPair: leafKeyPair,
    duration: 60 * 60 * 24 * 365 * 10,
  })
  return {
    leafKeyPair,
    leafKeyPairPEM,
    leafCert,
    leafCertPEM: certToPEM(leafCert),
    caKeyPair,
    caKeyPairPEM,
    caCert,
    caCertPEM: certToPEM(caCert),
  }
}

export {
  sleep,
  randomBytes,
  generateKeyPairEd25519,
  importEd25519KeyPair,
  publicKeyFromPrivateKey,
  importPublicKey,
  importPrivateKey,
  keyPairEd25519ToPEM,
  generateCertificate,
  certToPEM,
  generateKeyHMAC,
  signHMAC,
  verifyHMAC,
  bufferWrap,
  socketCleanupFactory,
  handleStreamProm,
  generateTLSConfig,
}

export type { Messages, StreamData, KeyTypes, TLSConfigs }
