#!/usr/bin/env bun
/**
 * Compare PVM Trace Files
 *
 * Compares trace files generated by our PVM executor with reference traces
 * from the reference submodule and analyzes differences.
 *
 * Usage: bun scripts/compare-traces.ts [block_number] [executor_type]
 *
 * Examples:
 *   bun scripts/compare-traces.ts 4              # Compare block 4 (auto-detect executor)
 *   bun scripts/compare-traces.ts 4 typescript   # Compare typescript trace for block 4
 *   bun scripts/compare-traces.ts 4 wasm         # Compare wasm trace for block 4
 */

import { existsSync, readdirSync, readFileSync } from 'node:fs'
import { basename, join } from 'node:path'

// ANSI color codes for terminal output
const colors = {
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  reset: '\x1b[0m',
  bold: '\x1b[1m',
  dim: '\x1b[2m',
}

interface TraceLine {
  lineNumber: number
  raw: string
  type: 'instruction' | 'host_function' | 'comment' | 'empty'
  instruction?: string
  step?: number
  pc?: number
  gas?: number
  registers?: string[]
  hostFunction?: {
    name: string
    id: number
    gasUsed: number
    gasRemaining: number
    serviceId: number
  }
}

function parseTraceLine(line: string, lineNumber: number): TraceLine {
  const trimmed = line.trim()

  // Empty line
  if (!trimmed) {
    return { lineNumber, raw: line, type: 'empty' }
  }

  // Comment or metadata line (starts with #)
  if (trimmed.startsWith('#') || trimmed.startsWith('ld:')) {
    return { lineNumber, raw: line, type: 'comment' }
  }

  // Host function call: "Calling host function: NAME ID [gas used: X, gas remaining: Y] [service: Z]"
  const hostFnMatch = trimmed.match(
    /Calling host function: (\w+) (\d+) \[gas used: (\d+), gas remaining: (\d+)\] \[service: (\d+)\]/,
  )
  if (hostFnMatch) {
    return {
      lineNumber,
      raw: line,
      type: 'host_function',
      hostFunction: {
        name: hostFnMatch[1],
        id: Number.parseInt(hostFnMatch[2], 10),
        gasUsed: Number.parseInt(hostFnMatch[3], 10),
        gasRemaining: Number.parseInt(hostFnMatch[4], 10),
        serviceId: Number.parseInt(hostFnMatch[5], 10),
      },
    }
  }

  // Instruction line: "INSTRUCTION STEP PC Gas: GAS Registers:[r0, r1, ...]"
  const instrMatch = trimmed.match(
    /^(\w+) (\d+) (\d+) Gas: (\d+) Registers:\[([^\]]+)\]/,
  )
  if (instrMatch) {
    const registers = instrMatch[5].split(',').map((r) => r.trim())
    return {
      lineNumber,
      raw: line,
      type: 'instruction',
      instruction: instrMatch[1],
      step: Number.parseInt(instrMatch[2], 10),
      pc: Number.parseInt(instrMatch[3], 10),
      gas: Number.parseInt(instrMatch[4], 10),
      registers,
    }
  }

  // Unknown format - treat as comment
  return { lineNumber, raw: line, type: 'comment' }
}

function parseTraceFile(filepath: string): TraceLine[] {
  const content = readFileSync(filepath, 'utf-8')
  const lines = content.split('\n')
  return lines.map((line, idx) => parseTraceLine(line, idx + 1))
}

function findDifferences(
  ourLines: TraceLine[],
  refLines: TraceLine[],
): {
  firstDiff: {
    ourLine: TraceLine | null
    refLine: TraceLine | null
    stepNumber: number
  } | null
  totalOurInstructions: number
  totalRefInstructions: number
  matchingInstructions: number
  differences: Array<{
    step: number
    type:
      | 'instruction'
      | 'pc'
      | 'gas'
      | 'registers'
      | 'missing_our'
      | 'missing_ref'
    ourValue?: string
    refValue?: string
    details?: string
  }>
} {
  // Filter to only instruction and host function lines
  const ourInstructions = ourLines.filter(
    (l) => l.type === 'instruction' || l.type === 'host_function',
  )
  const refInstructions = refLines.filter(
    (l) => l.type === 'instruction' || l.type === 'host_function',
  )

  const differences: Array<{
    step: number
    type:
      | 'instruction'
      | 'pc'
      | 'gas'
      | 'registers'
      | 'missing_our'
      | 'missing_ref'
    ourValue?: string
    refValue?: string
    details?: string
  }> = []

  let matchingInstructions = 0
  let firstDiff: {
    ourLine: TraceLine | null
    refLine: TraceLine | null
    stepNumber: number
  } | null = null

  const maxSteps = Math.max(ourInstructions.length, refInstructions.length)

  for (let i = 0; i < maxSteps; i++) {
    const ourLine = ourInstructions[i]
    const refLine = refInstructions[i]

    if (!ourLine && refLine) {
      differences.push({
        step: refLine.step || i + 1,
        type: 'missing_our',
        refValue: refLine.raw,
      })
      if (!firstDiff) {
        firstDiff = {
          ourLine: null,
          refLine,
          stepNumber: refLine.step || i + 1,
        }
      }
      continue
    }

    if (ourLine && !refLine) {
      differences.push({
        step: ourLine.step || i + 1,
        type: 'missing_ref',
        ourValue: ourLine.raw,
      })
      if (!firstDiff) {
        firstDiff = {
          ourLine,
          refLine: null,
          stepNumber: ourLine.step || i + 1,
        }
      }
      continue
    }

    if (!ourLine || !refLine) continue

    // Compare instruction lines
    if (ourLine.type === 'instruction' && refLine.type === 'instruction') {
      let hasDiff = false

      // Check instruction name
      if (ourLine.instruction !== refLine.instruction) {
        differences.push({
          step: ourLine.step || i + 1,
          type: 'instruction',
          ourValue: ourLine.instruction,
          refValue: refLine.instruction,
          details: `Instruction mismatch at step ${ourLine.step}`,
        })
        hasDiff = true
      }

      // Check PC
      if (ourLine.pc !== refLine.pc) {
        differences.push({
          step: ourLine.step || i + 1,
          type: 'pc',
          ourValue: String(ourLine.pc),
          refValue: String(refLine.pc),
          details: `PC mismatch: ours=${ourLine.pc}, ref=${refLine.pc}`,
        })
        hasDiff = true
      }

      // Check gas
      if (ourLine.gas !== refLine.gas) {
        differences.push({
          step: ourLine.step || i + 1,
          type: 'gas',
          ourValue: String(ourLine.gas),
          refValue: String(refLine.gas),
          details: `Gas diff: ${ourLine.gas! - refLine.gas!} (ours=${ourLine.gas}, ref=${refLine.gas})`,
        })
        hasDiff = true
      }

      // Check registers
      if (ourLine.registers && refLine.registers) {
        const regDiffs: string[] = []
        for (
          let r = 0;
          r < Math.max(ourLine.registers.length, refLine.registers.length);
          r++
        ) {
          const ourReg = ourLine.registers[r] || '0'
          const refReg = refLine.registers[r] || '0'
          if (ourReg !== refReg) {
            regDiffs.push(`r${r}: ${ourReg} vs ${refReg}`)
          }
        }
        if (regDiffs.length > 0) {
          differences.push({
            step: ourLine.step || i + 1,
            type: 'registers',
            ourValue: ourLine.registers.join(', '),
            refValue: refLine.registers.join(', '),
            details: `Register diffs: ${regDiffs.join('; ')}`,
          })
          hasDiff = true
        }
      }

      if (!hasDiff) {
        matchingInstructions++
      } else if (!firstDiff) {
        firstDiff = { ourLine, refLine, stepNumber: ourLine.step || i + 1 }
      }
    }

    // Compare host function calls
    if (ourLine.type === 'host_function' && refLine.type === 'host_function') {
      if (
        ourLine.hostFunction?.name !== refLine.hostFunction?.name ||
        ourLine.hostFunction?.id !== refLine.hostFunction?.id
      ) {
        differences.push({
          step: i + 1,
          type: 'instruction',
          ourValue: `${ourLine.hostFunction?.name} ${ourLine.hostFunction?.id}`,
          refValue: `${refLine.hostFunction?.name} ${refLine.hostFunction?.id}`,
          details: 'Host function mismatch',
        })
        if (!firstDiff) {
          firstDiff = { ourLine, refLine, stepNumber: i + 1 }
        }
      } else if (
        ourLine.hostFunction?.gasUsed !== refLine.hostFunction?.gasUsed
      ) {
        differences.push({
          step: i + 1,
          type: 'gas',
          ourValue: String(ourLine.hostFunction?.gasUsed),
          refValue: String(refLine.hostFunction?.gasUsed),
          details: `Host function gas used: ours=${ourLine.hostFunction?.gasUsed}, ref=${refLine.hostFunction?.gasUsed}`,
        })
        if (!firstDiff) {
          firstDiff = { ourLine, refLine, stepNumber: i + 1 }
        }
      } else {
        matchingInstructions++
      }
    }
  }

  return {
    firstDiff,
    totalOurInstructions: ourInstructions.length,
    totalRefInstructions: refInstructions.length,
    matchingInstructions,
    differences,
  }
}

function analyzeRootCause(
  differences: ReturnType<typeof findDifferences>['differences'],
  firstDiff: ReturnType<typeof findDifferences>['firstDiff'],
): string[] {
  const analyses: string[] = []

  if (!firstDiff) {
    analyses.push('‚úÖ No differences found - traces match perfectly!')
    return analyses
  }

  // Analyze the first difference
  analyses.push(`${colors.bold}üîç Root Cause Analysis${colors.reset}`)
  analyses.push('')

  // Check if it's an initial state difference
  if (firstDiff.stepNumber === 1) {
    const ourRegs = firstDiff.ourLine?.registers
    const refRegs = firstDiff.refLine?.registers

    if (ourRegs && refRegs) {
      const regDiffs: string[] = []
      for (let r = 0; r < 13; r++) {
        if (ourRegs[r] !== refRegs[r]) {
          regDiffs.push(`r${r}`)
        }
      }
      if (regDiffs.length > 0) {
        analyses.push(
          `${colors.yellow}‚ö†Ô∏è  Initial register state mismatch in: ${regDiffs.join(', ')}${colors.reset}`,
        )
        analyses.push(
          '   This suggests different input data (arguments, timeslot, service_id)',
        )
        analyses.push('   or different memory initialization.')
      }
    }

    if (firstDiff.ourLine?.gas !== firstDiff.refLine?.gas) {
      analyses.push(`${colors.yellow}‚ö†Ô∏è  Initial gas mismatch${colors.reset}`)
      analyses.push(`   Our gas: ${firstDiff.ourLine?.gas}`)
      analyses.push(`   Ref gas: ${firstDiff.refLine?.gas}`)
      analyses.push('   This suggests different gas limit configuration.')
    }
  }

  // Check for PC divergence
  const pcDiffs = differences.filter((d) => d.type === 'pc')
  if (pcDiffs.length > 0) {
    analyses.push(
      `${colors.cyan}üìç PC Divergence detected at step ${pcDiffs[0].step}${colors.reset}`,
    )
    analyses.push(`   Our PC: ${pcDiffs[0].ourValue}`)
    analyses.push(`   Ref PC: ${pcDiffs[0].refValue}`)
    analyses.push('   Possible causes:')
    analyses.push('   - Different branch target calculation')
    analyses.push('   - Different jump table values')
    analyses.push('   - Different bitmask (basic block validation)')
  }

  // Check for instruction divergence
  const instrDiffs = differences.filter((d) => d.type === 'instruction')
  if (instrDiffs.length > 0) {
    analyses.push(
      `${colors.magenta}üîÄ Instruction mismatch at step ${instrDiffs[0].step}${colors.reset}`,
    )
    analyses.push(`   Our instruction: ${instrDiffs[0].ourValue}`)
    analyses.push(`   Ref instruction: ${instrDiffs[0].refValue}`)
    analyses.push('   This likely follows from a PC divergence.')
  }

  // Check for gas consumption differences
  const gasDiffs = differences.filter((d) => d.type === 'gas')
  if (gasDiffs.length > 0 && pcDiffs.length === 0 && instrDiffs.length === 0) {
    analyses.push(
      `${colors.yellow}‚õΩ Gas consumption difference at step ${gasDiffs[0].step}${colors.reset}`,
    )
    analyses.push(`   Our gas: ${gasDiffs[0].ourValue}`)
    analyses.push(`   Ref gas: ${gasDiffs[0].refValue}`)
    analyses.push('   Possible causes:')
    analyses.push('   - Different host function gas costs')
    analyses.push('   - Different gas metering implementation')
  }

  // Check for register differences
  const regDiffs = differences.filter((d) => d.type === 'registers')
  if (regDiffs.length > 0 && pcDiffs.length === 0) {
    analyses.push(
      `${colors.blue}üìä Register value difference at step ${regDiffs[0].step}${colors.reset}`,
    )
    analyses.push(`   ${regDiffs[0].details}`)
    analyses.push('   Possible causes:')
    analyses.push('   - Different arithmetic/logic implementation')
    analyses.push('   - Different memory contents')
    analyses.push('   - Different host function return values')
  }

  // Length difference
  if (
    differences.some(
      (d) => d.type === 'missing_our' || d.type === 'missing_ref',
    )
  ) {
    const missingOurs = differences.filter((d) => d.type === 'missing_our')
    const missingRefs = differences.filter((d) => d.type === 'missing_ref')

    if (missingOurs.length > 0) {
      analyses.push(
        `${colors.red}‚ùå Our trace is shorter by ${missingOurs.length} steps${colors.reset}`,
      )
      analyses.push('   Possible causes:')
      analyses.push('   - Early termination (PANIC, OOG, HALT)')
      analyses.push('   - Step limit reached (TypeScript executor)')
    }

    if (missingRefs.length > 0) {
      analyses.push(
        `${colors.green}‚ûï Our trace is longer by ${missingRefs.length} steps${colors.reset}`,
      )
      analyses.push('   Possible causes:')
      analyses.push('   - Different termination condition')
      analyses.push('   - Reference trace truncated')
    }
  }

  return analyses
}

function printComparison(
  blockNumber: number,
  ourPath: string,
  refPath: string,
  ourLines: TraceLine[],
  refLines: TraceLine[],
  result: ReturnType<typeof findDifferences>,
) {
  console.log(
    `${colors.bold}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${colors.reset}`,
  )
  console.log(
    `${colors.bold}üìä Trace Comparison for Block ${blockNumber}${colors.reset}`,
  )
  console.log(
    `${colors.bold}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${colors.reset}`,
  )
  console.log()
  console.log(`${colors.cyan}Our trace:${colors.reset} ${ourPath}`)
  console.log(`${colors.cyan}Reference:${colors.reset} ${refPath}`)
  console.log()

  // Summary
  console.log(`${colors.bold}üìà Summary${colors.reset}`)
  console.log(`   Our instructions:       ${result.totalOurInstructions}`)
  console.log(`   Reference instructions: ${result.totalRefInstructions}`)
  console.log(`   Matching:               ${result.matchingInstructions}`)
  console.log(`   Differences:            ${result.differences.length}`)
  console.log()

  // Match percentage
  const matchPercent =
    result.totalRefInstructions > 0
      ? (
          (result.matchingInstructions / result.totalRefInstructions) *
          100
        ).toFixed(2)
      : '0'
  const matchColor =
    Number.parseFloat(matchPercent) >= 99
      ? colors.green
      : Number.parseFloat(matchPercent) >= 90
        ? colors.yellow
        : colors.red
  console.log(`   ${matchColor}Match rate: ${matchPercent}%${colors.reset}`)
  console.log()

  // First difference
  if (result.firstDiff) {
    console.log(
      `${colors.bold}üî¥ First Difference at Step ${result.firstDiff.stepNumber}${colors.reset}`,
    )
    console.log()
    if (result.firstDiff.ourLine) {
      console.log(
        `${colors.red}   Our:${colors.reset} ${result.firstDiff.ourLine.raw.trim()}`,
      )
    } else {
      console.log(`${colors.red}   Our:${colors.reset} (missing)`)
    }
    if (result.firstDiff.refLine) {
      console.log(
        `${colors.green}   Ref:${colors.reset} ${result.firstDiff.refLine.raw.trim()}`,
      )
    } else {
      console.log(`${colors.green}   Ref:${colors.reset} (missing)`)
    }
    console.log()
  }

  // Show first N differences
  const maxDiffsToShow = 10
  if (result.differences.length > 0) {
    console.log(
      `${colors.bold}üìã First ${Math.min(maxDiffsToShow, result.differences.length)} Differences${colors.reset}`,
    )
    console.log()

    for (
      let i = 0;
      i < Math.min(maxDiffsToShow, result.differences.length);
      i++
    ) {
      const diff = result.differences[i]
      const typeIcon = {
        instruction: 'üîÄ',
        pc: 'üìç',
        gas: '‚õΩ',
        registers: 'üìä',
        missing_our: '‚ùå',
        missing_ref: '‚ûï',
      }[diff.type]

      console.log(`   ${typeIcon} Step ${diff.step}: ${diff.type}`)
      if (diff.ourValue)
        console.log(`      ${colors.red}Our:${colors.reset} ${diff.ourValue}`)
      if (diff.refValue)
        console.log(`      ${colors.green}Ref:${colors.reset} ${diff.refValue}`)
      if (diff.details)
        console.log(`      ${colors.dim}${diff.details}${colors.reset}`)
      console.log()
    }

    if (result.differences.length > maxDiffsToShow) {
      console.log(
        `   ${colors.dim}... and ${result.differences.length - maxDiffsToShow} more differences${colors.reset}`,
      )
      console.log()
    }
  }

  // Root cause analysis
  const analyses = analyzeRootCause(result.differences, result.firstDiff)
  for (const analysis of analyses) {
    console.log(analysis)
  }
  console.log()
}

function findTraceFiles(
  blockNumber: number,
  executorType?: string,
): {
  ourPath: string | null
  refPath: string | null
} {
  const workspaceRoot = join(__dirname, '..')

  // Reference path (reference)
  const refPath = join(
    workspaceRoot,
    'submodules/reference/jam-test-vectors/0.7.1/preimages_light',
    `${String(blockNumber).padStart(8, '0')}.log`,
  )

  // Our trace paths to check
  const tracesDirs = [
    join(workspaceRoot, 'pvm-traces'),
    join(workspaceRoot, 'infra/node/pvm-traces'),
  ]

  let ourPath: string | null = null

  // If executor type specified, look for that specific file
  if (executorType) {
    const filename = `${executorType}-${blockNumber}.log`
    for (const dir of tracesDirs) {
      const fullPath = join(dir, filename)
      if (existsSync(fullPath)) {
        ourPath = fullPath
        break
      }
    }
  } else {
    // Auto-detect: prefer typescript, then wasm, then reference format
    const patterns = [
      `typescript-${blockNumber}.log`,
      `wasm-${blockNumber}.log`,
      `${String(blockNumber).padStart(8, '0')}.log`,
    ]

    for (const pattern of patterns) {
      for (const dir of tracesDirs) {
        const fullPath = join(dir, pattern)
        if (existsSync(fullPath)) {
          ourPath = fullPath
          break
        }
      }
      if (ourPath) break
    }
  }

  return {
    ourPath,
    refPath: existsSync(refPath) ? refPath : null,
  }
}

function main() {
  const args = process.argv.slice(2)

  if (args.length === 0) {
    // List available blocks
    console.log(`${colors.bold}PVM Trace Comparison Tool${colors.reset}`)
    console.log()
    console.log(
      'Usage: bun scripts/compare-traces.ts [block_number] [executor_type]',
    )
    console.log()
    console.log('Examples:')
    console.log(
      '  bun scripts/compare-traces.ts 4              # Compare block 4',
    )
    console.log(
      '  bun scripts/compare-traces.ts 4 typescript   # Compare typescript trace',
    )
    console.log(
      '  bun scripts/compare-traces.ts 4 wasm         # Compare wasm trace',
    )
    console.log()

    // Show available traces
    const workspaceRoot = join(__dirname, '..')
    const tracesDirs = [
      { path: join(workspaceRoot, 'pvm-traces'), name: 'pvm-traces/' },
      {
        path: join(workspaceRoot, 'infra/node/pvm-traces'),
        name: 'infra/node/pvm-traces/',
      },
    ]

    console.log(`${colors.bold}Available traces:${colors.reset}`)
    for (const { path: dir, name } of tracesDirs) {
      if (existsSync(dir)) {
        const files = readdirSync(dir).filter((f) => f.endsWith('.log'))
        if (files.length > 0) {
          console.log(`  ${colors.cyan}${name}${colors.reset}`)
          for (const file of files.slice(0, 10)) {
            console.log(`    - ${file}`)
          }
          if (files.length > 10) {
            console.log(`    ... and ${files.length - 10} more`)
          }
        }
      }
    }

    return
  }

  const blockNumber = Number.parseInt(args[0], 10)
  const executorType = args[1]

  if (isNaN(blockNumber)) {
    console.error(
      `${colors.red}Error: Invalid block number: ${args[0]}${colors.reset}`,
    )
    process.exit(1)
  }

  const { ourPath, refPath } = findTraceFiles(blockNumber, executorType)

  if (!ourPath) {
    console.error(
      `${colors.red}Error: No trace file found for block ${blockNumber}${colors.reset}`,
    )
    console.error('Run the test first to generate traces.')
    process.exit(1)
  }

  if (!refPath) {
    console.error(
      `${colors.red}Error: Reference trace not found for block ${blockNumber}${colors.reset}`,
    )
    console.error(
      'Expected at: submodules/reference/jam-test-vectors/0.7.1/preimages_light/',
    )
    process.exit(1)
  }

  // Parse and compare
  const ourLines = parseTraceFile(ourPath)
  const refLines = parseTraceFile(refPath)

  const result = findDifferences(ourLines, refLines)

  printComparison(blockNumber, ourPath, refPath, ourLines, refLines, result)
}

main()
