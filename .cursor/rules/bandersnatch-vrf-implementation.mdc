# Bandersnatch VRF Implementation Guide

## Overview
This guide outlines the implementation requirements for the Bandersnatch VRF (Verifiable Random Function) package, which provides cryptographic primitives for the JAM protocol's Safrole consensus mechanism.

## Package Structure
```
packages/bandersnatch-vrf/
├── src/
│   ├── types.ts              # All types, interfaces, and enums
│   ├── config.ts             # Configuration constants and parameters
│   ├── curve.ts              # Bandersnatch curve operations
│   ├── prover/
│   │   ├── types.ts          # Prover-specific types
│   │   ├── config.ts         # Prover configuration
│   │   ├── ietf.ts           # IETF VRF Prover implementation
│   │   ├── pedersen.ts       # Pedersen VRF Prover implementation
│   │   ├── ring.ts           # Ring VRF Prover implementation
│   │   └── index.ts          # Prover exports
│   ├── verifier/
│   │   ├── types.ts          # Verifier-specific types
│   │   ├── config.ts         # Verifier configuration
│   │   ├── ietf.ts           # IETF VRF Verifier implementation
│   │   ├── pedersen.ts       # Pedersen VRF Verifier implementation
│   │   ├── ring.ts           # Ring VRF Verifier implementation
│   │   └── index.ts          # Verifier exports
│   └── index.ts              # Main package exports
```

## Implementation Requirements

### 1. VRF Schemes
Implement the following VRF schemes as specified in RFC-9381 and the Bandersnatch VRF specification:

#### IETF VRF (RFC-9381)
- **prove(secretKey, input, auxData?) -> VRFProofWithOutput**
- **verify(publicKey, input, output, proof, auxData?) -> boolean**

#### Pedersen VRF
- **prove(secretKey, input, auxData?) -> VRFProofWithOutput**
- **verify(publicKey, input, output, proof, auxData?) -> boolean**

#### Ring VRF
- **prove(secretKey, input, auxData?) -> VRFProofWithOutput**
- **verify(publicKey, input, output, proof, auxData?) -> boolean**

### 2. Bandersnatch Curve Operations
Implement core curve operations in `curve.ts`:
- Point addition and doubling
- Scalar multiplication
- Hash-to-curve function (H1)
- Point hashing function (H2)
- Point serialization/deserialization

### 3. Configuration Management
- Store all constants in `config.ts`
- Use `BANDERSNATCH_PARAMS` for curve parameters
- Define scheme-specific configurations in respective `config.ts` files

### 4. Type Safety
- All types must be defined in `types.ts` files
- Use strict TypeScript with proper interfaces
- Export types from respective `index.ts` files

### 5. Testing Requirements
- Unit tests for each VRF scheme
- Curve operation tests
- Integration tests with Safrole
- Performance benchmarks

## File Organization Rules

### One Implementation Class Per File
- **Rule**: Each implementation file must contain exactly one class
- **Rationale**: Improves maintainability, readability, and testability
- **Structure**: 
  - `ietf.ts` → `IETFVRFProver` or `IETFVRFVerifier`
  - `pedersen.ts` → `PedersenVRFProver` or `PedersenVRFVerifier`
  - `ring.ts` → `RingVRFProver` or `RingVRFVerifier`

### Separate Sub-packages for Multiple Implementations
- **Rule**: If a single file would contain multiple implementation classes, create separate sub-packages
- **Example**: 
  ```
  prover/
  ├── ietf/
  │   ├── types.ts
  │   ├── config.ts
  │   ├── implementation.ts
  │   └── index.ts
  ├── pedersen/
  │   ├── types.ts
  │   ├── config.ts
  │   ├── implementation.ts
  │   └── index.ts
  └── ring/
      ├── types.ts
      ├── config.ts
      ├── implementation.ts
      └── index.ts
  ```

### Import/Export Structure
- Each implementation file exports its single class
- Index files consolidate exports from multiple implementation files
- Types and configs are imported from shared files

## Reference Implementations
- **Rust Reference**: `submodules/ark-vrf/` - Elliptic Curve VRFs implementation
- **Specification**: `submodules/bandersnatch-vrf-spec/` - Official Bandersnatch VRF specification

## Security Considerations
- All cryptographic operations must be constant-time
- Proper key validation and curve point validation
- Secure random number generation for nonces
- Protection against timing attacks

## Performance Targets
- VRF proof generation: < 10ms
- VRF proof verification: < 5ms
- Curve operations: < 1ms per operation

## Integration with Safrole
The Bandersnatch VRF package is used by the Safrole consensus protocol for:
- Ticket generation and validation
- Anonymous leader selection
- Secure randomness in block production

## Development Guidelines
1. Follow the established directory structure
2. Implement types first, then configuration, then implementation
3. Write comprehensive tests for all functionality
4. Use the logger from `@pbnjam/core` for all logging
5. Ensure all exports are properly documented
6. Maintain compatibility with RFC-9381 specifications
7. **One implementation class per file**
8. **Create sub-packages for multiple implementations**
