# Logging Standards

## Overview

This project uses a centralized logging system from `@pbnj/core` instead of direct console methods. All logging must go through the standardized logger to ensure consistent formatting, log levels, and output handling.

## Core Requirements

### 1. Logger Import and Usage

**Always use the logger from `@pbnj/core`:**
```typescript
import { logger } from '@pbnj/core'
```

**Never use console methods directly:**
```typescript
// ❌ WRONG - Don't use console methods
console.log('Some message')
console.error('Error message')
console.warn('Warning message')
console.info('Info message')

// ✅ CORRECT - Use logger methods
logger.info('Some message')
logger.error('Error message')
logger.warn('Warning message')
logger.debug('Debug message')
```

### 2. Logger Initialization

**Always initialize the logger in main entrypoints:**

#### CLI Entrypoint (`packages/cli/src/index.ts`)
```typescript
import { logger } from '@pbnj/core'

// Initialize logger at the very beginning
logger.init()

// Rest of CLI code...
```

#### RPC Server Entrypoint (`apis/rpc-server/src/index.ts`)
```typescript
import { logger } from '@pbnj/core'

// Initialize logger before any other operations
logger.init()

// Rest of server code...
```

#### Any Other Main Entrypoint
```typescript
import { logger } from '@pbnj/core'

// Initialize logger first
logger.init()

// Then proceed with application logic
```

### 3. Log Levels

**Use appropriate log levels:**

```typescript
// ✅ Debug information for development
logger.debug('Processing request', { requestId, method })

// ✅ General information
logger.info('Server started', { port, environment })

// ✅ Warnings that don't stop execution
logger.warn('Deprecated feature used', { feature, alternative })

// ✅ Errors that affect functionality
logger.error('Database connection failed', { error, retryCount })

// ✅ Critical errors that may cause shutdown
logger.fatal('Unrecoverable error', { error, context })
```

### 4. Structured Logging

**Always use structured logging with context:**

```typescript
// ❌ WRONG - Simple string logging
logger.info('User logged in')

// ✅ CORRECT - Structured logging with context
logger.info('User logged in', {
  userId: user.id,
  method: 'oauth',
  timestamp: new Date().toISOString()
})

// ✅ CORRECT - Error logging with context
logger.error('Failed to process transaction', {
  transactionId: tx.id,
  error: error.message,
  stack: error.stack,
  userId: user.id
})
```

### 5. Error Handling

**Always log errors with proper context:**

```typescript
try {
  // Some operation
} catch (error) {
  logger.error('Operation failed', {
    operation: 'processData',
    error: error.message,
    stack: error.stack,
    context: { userId, dataId }
  })
  throw error // Re-throw if needed
}
```

## Implementation Guidelines

### 1. Module-Level Logging

**In any module that needs logging:**

```typescript
import { logger } from '@pbnj/core'

export class SomeService {
  async processData(data: unknown) {
    logger.debug('Processing data', { dataType: typeof data })
    
    try {
      const result = await this.transform(data)
      logger.info('Data processed successfully', { 
        inputSize: data.length,
        outputSize: result.length 
      })
      return result
    } catch (error) {
      logger.error('Data processing failed', {
        error: error.message,
        dataType: typeof data
      })
      throw error
    }
  }
}
```

### 2. CLI Command Logging

**In CLI commands:**

```typescript
import { logger } from '@pbnj/core'

export class TestSafroleCommand implements ICommand<TestSafroleOptions> {
  async execute(options: TestSafroleOptions): Promise<void> {
    logger.info('Starting Safrole test', { 
      vectors: options.vectors,
      vector: options.vector 
    })
    
    try {
      // Test logic
      logger.info('Safrole test completed successfully')
    } catch (error) {
      logger.error('Safrole test failed', { error: error.message })
      throw error
    }
  }
}
```

### 3. Server Request Logging

**In RPC server handlers:**

```typescript
import { logger } from '@pbnj/core'

app.post('/api/process', async (req, res) => {
  const requestId = generateId()
  
  logger.info('Processing API request', {
    requestId,
    method: req.method,
    path: req.path,
    userId: req.user?.id
  })
  
  try {
    const result = await processRequest(req.body)
    logger.info('API request completed', { requestId, status: 'success' })
    res.json(result)
  } catch (error) {
    logger.error('API request failed', {
      requestId,
      error: error.message,
      status: 'error'
    })
    res.status(500).json({ error: 'Internal server error' })
  }
})
```

## Configuration

### Environment Variables

**Set logging configuration via environment variables:**

```bash
# Log level (debug, info, warn, error, fatal)
LOG_LEVEL=info

# Log format (json, text)
LOG_FORMAT=json

# Log destination (stdout, stderr, file)
LOG_DESTINATION=stdout

# Development mode (enables text format by default)
NODE_ENV=development
```

### Logger Configuration

The logger configuration is handled internally by the `@pbnj/core` package based on environment variables. The logger.init() call initializes the logger with the appropriate settings.

## Migration Guide

### Converting from console.log

**Before:**
```typescript
console.log('User logged in:', userId)
console.error('Database error:', error)
console.warn('Deprecated method called')
```

**After:**
```typescript
import { logger } from '@pbnj/core'

logger.info('User logged in', { userId })
logger.error('Database error', { error: error.message })
logger.warn('Deprecated method called')
```

### Adding Logger to New Files

1. **Import the logger:**
   ```typescript
   import { logger } from '@pbnj/core'
   ```

2. **Replace console calls:**
   ```typescript
   // Replace console.log with logger.info
   // Replace console.error with logger.error
   // Replace console.warn with logger.warn
   ```

3. **Add structured context:**
   ```typescript
   // Add relevant context data to log calls
   logger.info('Operation completed', { 
     operation: 'processData',
     duration: elapsedTime,
     result: 'success'
   })
   ```

## Enforcement

### Pre-commit Hooks

The project includes pre-commit hooks that will:
- Check for console.log usage and flag violations
- Ensure logger.init is called in main entrypoints
- Validate log level usage

### Code Review Checklist

Before merging code, ensure:
- [ ] No console.log, console.error, etc. usage
- [ ] All logging uses `@pbnj/core` logger
- [ ] Logger is initialized in main entrypoints
- [ ] Log messages include appropriate context
- [ ] Log levels are appropriate for the message
- [ ] Error logging includes error details and context

### Linting Rules

The project's linting configuration will:
- Flag console method usage as errors
- Require logger import in files with logging
- Enforce structured logging patterns

## Benefits

### 1. Consistency
- Uniform log format across all components
- Standardized log levels and message structure
- Consistent timestamp and metadata handling

### 2. Observability
- Structured logs enable better log aggregation
- JSON format allows for easy parsing and analysis
- Context-rich logs improve debugging capabilities

### 3. Performance
- Centralized log level control
- Efficient log formatting and output
- Configurable log destinations

### 4. Maintainability
- Single logging interface to maintain
- Easy to add new log destinations or formats
- Consistent error handling patterns

## Remember

- **Always import logger from `@pbnj/core`**
- **Never use console methods directly**
- **Initialize logger in main entrypoints with logger.init()**
- **Use structured logging with context**
- **Choose appropriate log levels**
- **Include error details when logging errors**

This ensures consistent, observable, and maintainable logging across the entire JAM protocol implementation.
description:
globs:
alwaysApply: false
---
