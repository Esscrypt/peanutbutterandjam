/**
 * Fuzzer State Trie Comparison Test
 *
 * Compares the state trie generated by generateStateTrie() with the keyvals
 * provided by the fuzzer Initialize message to identify differences that cause
 * state root mismatches.
 */

import { describe, it, expect } from 'bun:test'
import * as path from 'node:path'
import { readFileSync } from 'node:fs'
import { decodeFuzzMessage } from '../../../packages/codec/src/fuzz'
import { FuzzMessageType } from '@pbnj/types'
import { ConfigService } from '../services/config-service'
import { StateService } from '../services/state-service'
import { ValidatorSetManager } from '../services/validator-set'
import { EntropyService } from '../services/entropy'
import { TicketService } from '../services/ticket-service'
import { AuthQueueService } from '../services/auth-queue-service'
import { AuthPoolService } from '../services/auth-pool-service'
import { DisputesService } from '../services/disputes-service'
import { ReadyService } from '../services/ready-service'
import { AccumulationService } from '../services/accumulation-service'
import { WorkReportService } from '../services/work-report-service'
import { PrivilegesService } from '../services/privileges-service'
import { ServiceAccountService } from '../services/service-account-service'
import { RecentHistoryService } from '../services/recent-history-service'
import { NodeGenesisManager } from '../services/genesis-manager'
import { SealKeyService } from '../services/seal-key'
import { ClockService } from '../services/clock-service'
import { EventBusService } from '@pbnj/core'
import { StatisticsService } from '../services/statistics-service'
import { bytesToHex } from '@pbnj/core'
import { safeResult } from '@pbnj/types'

// Test vectors directory (relative to workspace root)
// __dirname is infra/node/__tests__, so we go up 3 levels to get to workspace root
const WORKSPACE_ROOT = path.join(__dirname, '../../../')

describe('Fuzzer State Trie Comparison', () => {
  it('should compare generateStateTrie with fuzzer keyvals and identify differences', () => {
    const configService = new ConfigService('tiny')

    // Load PeerInfo message to get JAM version
    const peerInfoJsonPath = path.join(
      WORKSPACE_ROOT,
      'submodules/jam-conformance/fuzz-proto/examples/v1/no_forks/00000000_fuzzer_peer_info.json',
    )
    let jamVersion: { major: number; minor: number; patch: number } = { major: 0, minor: 7, patch: 0 }
    try {
      const peerInfoJson = JSON.parse(readFileSync(peerInfoJsonPath, 'utf-8'))
      if (peerInfoJson.jam_version) {
        jamVersion = peerInfoJson.jam_version
        console.log(`üìã JAM version from PeerInfo: ${jamVersion.major}.${jamVersion.minor}.${jamVersion.patch}`)
      }
    } catch (error) {
      console.warn(`‚ö†Ô∏è  Failed to load PeerInfo, using default JAM version: ${error instanceof Error ? error.message : String(error)}`)
    }

    // Load Initialize message
    const initializeBinPath = path.join(
      WORKSPACE_ROOT,
      'submodules/jam-conformance/fuzz-proto/examples/v1/no_forks/00000001_fuzzer_initialize.bin',
    )

    let initializeBin: Uint8Array
    try {
      initializeBin = new Uint8Array(readFileSync(initializeBinPath))
    } catch (error) {
      throw new Error(
        `Failed to read Initialize binary: ${error instanceof Error ? error.message : String(error)}`,
      )
    }

    // Decode Initialize message
    // The binary file includes the 4-byte length prefix, so we need to skip it
    // or the message starts directly after it
    let messageData: Uint8Array
    if (initializeBin.length >= 4) {
      // Check if first 4 bytes are a length prefix (little-endian)
      const lengthPrefix = new DataView(initializeBin.buffer, initializeBin.byteOffset, 4).getUint32(0, true)
      if (lengthPrefix === initializeBin.length - 4) {
        // It's a length prefix, skip it
        messageData = initializeBin.subarray(4)
      } else {
        // No length prefix, use entire buffer
        messageData = initializeBin
      }
    } else {
      messageData = initializeBin
    }

    const decodedMessage = decodeFuzzMessage(messageData, configService)

    if (decodedMessage.type !== FuzzMessageType.Initialize) {
      throw new Error(`Expected Initialize message, got ${decodedMessage.type}`)
    }

    const init = decodedMessage.payload as any

    console.log(`\nüìã Initialize message loaded:`)
    console.log(`  Keyvals count: ${init.keyvals.length}`)

    // Initialize services (minimal setup for state service)
    const eventBusService = new EventBusService()
    const clockService = new ClockService({
      eventBusService,
      configService,
    })
    const entropyService = new EntropyService(eventBusService)
    const validatorSetManager = new ValidatorSetManager({
      configService,
      entropyService,
      eventBusService,
    })
    const ticketService = new TicketService({
      configService,
      validatorSetManager,
      eventBusService,
    })
    const authQueueService = new AuthQueueService({
      configService,
      eventBusService,
    })
    const authPoolService = new AuthPoolService({
      configService,
      eventBusService,
    })
    const disputesService = new DisputesService({
      configService,
      eventBusService,
    })
    const readyService = new ReadyService({
      configService,
    })
    const accumulationService = new AccumulationService({
      configService,
      eventBusService,
    })
    const workReportService = new WorkReportService({
      configService,
      eventBus: eventBusService,
    })
    const privilegesService = new PrivilegesService({
      configService,
      eventBusService,
    })
    const serviceAccountsService = new ServiceAccountService({
      configService,
      eventBusService,
    })
    const recentHistoryService = new RecentHistoryService({
      eventBusService,
    })
    const statisticsService = new StatisticsService({
      configService,
      eventBusService,
    })

    // Create a mock genesis manager that returns empty state
    const genesisManager = {
      getState: () => {
        return safeResult({ keyvals: [] })
      },
      getGenesisHeaderHash: () => {
        return safeResult('0x0000000000000000000000000000000000000000000000000000000000000000')
      },
    } as any

    const sealKeyService = new SealKeyService({
      configService,
      validatorSetManager,
      eventBusService,
    })

    const stateService = new StateService({
      validatorSetManager,
      entropyService,
      ticketService,
      authQueueService,
      authPoolService,
      disputesService,
      readyService,
      accumulationService,
      workReportService,
      privilegesService,
      serviceAccountsService,
      recentHistoryService,
      configService,
      genesisManagerService: genesisManager,
      sealKeyService,
      clockService,
      statisticsService,
    })

    // Set state from keyvals with JAM version from PeerInfo
    // Note: Some keyvals may fail to decode (e.g., Chapter 12 with incomplete data)
    // setState now handles errors gracefully and continues processing
    const [setStateError] = stateService.setState(init.keyvals, jamVersion)
    if (setStateError) {
      console.log(`‚ö†Ô∏è  Warning: Some keyvals may have failed to decode: ${setStateError.message}`)
    }

    console.log(`‚úÖ State set from ${init.keyvals.length} keyvals (some may have been skipped due to decoding errors)`)

    // Generate state trie
    const [trieError, generatedTrie] = stateService.generateStateTrie()
    if (trieError) {
      throw new Error(`Failed to generate state trie: ${trieError.message}`)
    }

    console.log(`\nüìä State Trie Comparison:`)
    console.log(`  Fuzzer keyvals: ${init.keyvals.length} keys`)
    console.log(`  Generated trie: ${Object.keys(generatedTrie).length} keys`)

    // Convert fuzzer keyvals to a map for comparison
    const fuzzerKeyvalsMap = new Map<string, string>()
    for (const kv of init.keyvals) {
      fuzzerKeyvalsMap.set(kv.key, kv.value)
    }

    // Find keys in fuzzer but not in generated trie
    const missingInGenerated: string[] = []
    for (const [key, value] of fuzzerKeyvalsMap.entries()) {
      if (!(key in generatedTrie)) {
        missingInGenerated.push(key)
      }
    }

    // Find keys in generated trie but not in fuzzer
    const extraInGenerated: string[] = []
    for (const key of Object.keys(generatedTrie)) {
      if (!fuzzerKeyvalsMap.has(key)) {
        extraInGenerated.push(key)
      }
    }

    // Find keys with different values
    const differentValues: Array<{ key: string; fuzzerValue: string; generatedValue: string }> = []
    for (const [key, fuzzerValue] of fuzzerKeyvalsMap.entries()) {
      if (key in generatedTrie) {
        const generatedValue = generatedTrie[key]
        if (fuzzerValue !== generatedValue) {
          differentValues.push({ key, fuzzerValue, generatedValue })
        }
      }
    }

    // Report findings
    console.log(`\nüîç Comparison Results:`)
    console.log(`  Keys in fuzzer but missing in generated: ${missingInGenerated.length}`)
    if (missingInGenerated.length > 0) {
      console.log(`    Missing keys:`)
      for (const key of missingInGenerated.slice(0, 10)) {
        const value = fuzzerKeyvalsMap.get(key)!
        console.log(`      ${key}: ${value.substring(0, 40)}...`)
      }
      if (missingInGenerated.length > 10) {
        console.log(`      ... and ${missingInGenerated.length - 10} more`)
      }
    }

    console.log(`\n  Keys in generated but not in fuzzer: ${extraInGenerated.length}`)
    if (extraInGenerated.length > 0) {
      console.log(`    Extra keys:`)
      for (const key of extraInGenerated.slice(0, 10)) {
        const value = generatedTrie[key]
        console.log(`      ${key}: ${value.substring(0, 40)}...`)
      }
      if (extraInGenerated.length > 10) {
        console.log(`      ... and ${extraInGenerated.length - 10} more`)
      }
    }

    console.log(`\n  Keys with different values: ${differentValues.length}`)
    if (differentValues.length > 0) {
      console.log(`    Different values:`)
      for (const { key, fuzzerValue, generatedValue } of differentValues.slice(0, 10)) {
        console.log(`      ${key}:`)
        console.log(`        Fuzzer:    ${fuzzerValue.substring(0, 60)}...`)
        console.log(`        Generated: ${generatedValue.substring(0, 60)}...`)
        console.log(`        Fuzzer length: ${fuzzerValue.length} chars, Generated length: ${generatedValue.length} chars`)
      }
      if (differentValues.length > 10) {
        console.log(`      ... and ${differentValues.length - 10} more`)
      }
    }

    // Calculate state roots for comparison
    console.log(`\nüå≥ State Root Comparison:`)
    
    // Method 1: Direct from keyvals
    const { merklizeState, bytesToHex: bytesToHexCore } = require('@pbnj/core')
    const keyvalsDict: Record<string, string> = {}
    for (const kv of init.keyvals) {
      keyvalsDict[kv.key] = kv.value
    }
    const [merkleError, merkleRoot] = merklizeState(keyvalsDict)
    if (merkleError) {
      throw new Error(`Failed to compute Merkle root: ${merkleError.message}`)
    }
    const keyvalsRoot = bytesToHexCore(merkleRoot)
    console.log(`  From keyvals directly: ${keyvalsRoot}`)

    // Method 2: From generated state trie
    const [generatedMerkleError, generatedMerkleRoot] = merklizeState(generatedTrie)
    if (generatedMerkleError) {
      throw new Error(`Failed to compute Merkle root from generated trie: ${generatedMerkleError.message}`)
    }
    const generatedRoot = bytesToHexCore(generatedMerkleRoot)
    console.log(`  From generated trie:   ${generatedRoot}`)

    // Method 3: From stateService.getStateRoot()
    const [stateRootError, stateServiceRoot] = stateService.getStateRoot()
    if (stateRootError) {
      throw new Error(`Failed to get state root: ${stateRootError.message}`)
    }
    console.log(`  From stateService:     ${stateServiceRoot}`)

    const expectedRoot = '0x80748e40b5f83342b844a54aed5fd65861b982288e35ce1e7503fc45645d45b6'
    console.log(`  Expected:              ${expectedRoot}`)

    console.log(`\n‚úÖ Comparison complete`)
    console.log(`  Keyvals root matches expected: ${keyvalsRoot === expectedRoot ? '‚úÖ' : '‚ùå'}`)
    console.log(`  Generated trie root matches expected: ${generatedRoot === expectedRoot ? '‚úÖ' : '‚ùå'}`)
    console.log(`  StateService root matches expected: ${stateServiceRoot === expectedRoot ? '‚úÖ' : '‚ùå'}`)

    // Assertions for debugging
    expect(missingInGenerated.length).toBe(0)
    expect(extraInGenerated.length).toBe(0)
    expect(differentValues.length).toBe(0)
    expect(keyvalsRoot).toBe(expectedRoot)
  })
})

